{"version":3,"file":"static/chunks/228.fa4791efe005acbc.js","mappings":"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","sources":["webpack://_N_E/./node_modules/@noble/curves/esm/abstract/curve.js","webpack://_N_E/./node_modules/@noble/curves/esm/abstract/modular.js","webpack://_N_E/./node_modules/@noble/curves/esm/abstract/utils.js","webpack://_N_E/./node_modules/@noble/hashes/esm/sha512.js","webpack://_N_E/<anon>"],"sourcesContent":["/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { nLength, validateField } from './modular.js';\nimport { bitLen, validateObject } from './utils.js';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n        throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\nfunction calcWOpts(W, bits) {\n    validateW(W, bits);\n    const windows = Math.ceil(bits / W) + 1; // +1, because\n    const windowSize = 2 ** (W - 1); // -1 because we skip zero\n    return { windows, windowSize };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points))\n        throw new Error('array expected');\n    points.forEach((p, i) => {\n        if (!(p instanceof c))\n            throw new Error('invalid point at index ' + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars))\n        throw new Error('array of scalars expected');\n    scalars.forEach((s, i) => {\n        if (!field.isValid(s))\n            throw new Error('invalid scalar at index ' + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap(); // This allows use make points immutable (nothing changes inside)\nfunction getW(P) {\n    return pointWindowSizes.get(P) || 1;\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / ùëä) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nexport function wNAF(c, bits) {\n    return {\n        constTimeNegate,\n        hasPrecomputes(elm) {\n            return getW(elm) !== 1;\n        },\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n, p = c.ZERO) {\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:\n         * - ùëä is the window size\n         * - ùëõ is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @param elm Point instance\n         * @param W window size\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = calcWOpts(W, bits);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        /**\n         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @param acc accumulator point to add result of multiplication\n         * @returns point\n         */\n        wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                if (n === _0n)\n                    break; // No need to go over empty scalar\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                if (wbits === 0)\n                    continue;\n                let curr = precomputes[offset + Math.abs(wbits) - 1]; // -1 because we skip zero\n                if (wbits < 0)\n                    curr = curr.negate();\n                // NOTE: by re-using acc, we can save a lot of additions in case of MSM\n                acc = acc.add(curr);\n            }\n            return acc;\n        },\n        getPrecomputes(W, P, transform) {\n            // Calculate precomputes on a first run, reuse them after\n            let comp = pointPrecomputes.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1)\n                    pointPrecomputes.set(P, transform(comp));\n            }\n            return comp;\n        },\n        wNAFCached(P, n, transform) {\n            const W = getW(P);\n            return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n        },\n        wNAFCachedUnsafe(P, n, transform, prev) {\n            const W = getW(P);\n            if (W === 1)\n                return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n            return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n        },\n        // We calculate precomputes for elliptic curve point multiplication\n        // using windowed method. This specifies window size and\n        // stores precomputed values. Usually only base point would be precomputed.\n        setWindowSize(P, W) {\n            validateW(W, bits);\n            pointWindowSizes.set(P, W);\n            pointPrecomputes.delete(P);\n        },\n    };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster with precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */\nexport function pippenger(c, fieldN, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    if (points.length !== scalars.length)\n        throw new Error('arrays of points and scalars must have equal length');\n    const zero = c.ZERO;\n    const wbits = bitLen(BigInt(points.length));\n    const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1; // in bits\n    const MASK = (1 << windowSize) - 1;\n    const buckets = new Array(MASK + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for (let i = lastBits; i >= 0; i -= windowSize) {\n        buckets.fill(zero);\n        for (let j = 0; j < scalars.length; j++) {\n            const scalar = scalars[j];\n            const wbits = Number((scalar >> BigInt(i)) & BigInt(MASK));\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0)\n            for (let j = 0; j < windowSize; j++)\n                sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nexport function precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar √ó 256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255 √ó 32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16 √ó 255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */\n    validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = BigInt((1 << windowSize) - 1);\n    const tables = points.map((p) => {\n        const res = [];\n        for (let i = 0, acc = p; i < tableSize; i++) {\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars) => {\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length)\n            throw new Error('array of scalars must be smaller than array of points');\n        let res = zero;\n        for (let i = 0; i < chunks; i++) {\n            // No need to double if accumulator is still zero.\n            if (res !== zero)\n                for (let j = 0; j < windowSize; j++)\n                    res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for (let j = 0; j < scalars.length; j++) {\n                const n = scalars[j];\n                const curr = Number((n >> shiftBy) & MASK);\n                if (!curr)\n                    continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\nexport function validateBasic(curve) {\n    validateField(curve.Fp);\n    validateObject(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...nLength(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map","/**\n * Utils for modular division and finite fields.\n * A finite field over 11 is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { bitMask, bytesToNumberBE, bytesToNumberLE, ensureBytes, numberToBytesBE, numberToBytesLE, validateObject, } from './utils.js';\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _8n = /* @__PURE__ */ BigInt(8);\n// prettier-ignore\nconst _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);\n// Calculates a modulo b\nexport function mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @todo use field version && remove\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nexport function pow(num, power, modulo) {\n    if (power < _0n)\n        throw new Error('invalid exponent, negatives unsupported');\n    if (modulo <= _0n)\n        throw new Error('invalid modulus');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nexport function pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nexport function invert(number, modulo) {\n    if (number === _0n)\n        throw new Error('invert: expected non-zero number');\n    if (modulo <= _0n)\n        throw new Error('invert: expected positive modulus, got ' + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ‚â° 1    if a is a square (mod p)\n    // (a | p) ‚â° -1   if a is not a square (mod p)\n    // (a | p) ‚â° 0    if a ‚â° 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p) ‚â° -1 and set c ‚â° zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++) {\n        // Crash instead of infinity loop, we cannot reasonable count until P.\n        if (Z > 1000)\n            throw new Error('Cannot find square root: likely non-prime P');\n    }\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ‚â° -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\n/**\n * Square root for a finite field. It will try to check if optimizations are applicable and fall back to 4:\n *\n * 1. P ‚â° 3 (mod 4)\n * 2. P ‚â° 5 (mod 8)\n * 3. P ‚â° 9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nexport function FpSqrt(P) {\n    // P ‚â° 3 (mod 4)\n    // ‚àön = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q ‚â° 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P ‚â° 9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nexport function validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return validateObject(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('invalid exponent, negatives unsupported');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nexport function FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nexport function FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n/**\n * Legendre symbol.\n * * (a | p) ‚â° 1    if a is a square (mod p), quadratic residue\n * * (a | p) ‚â° -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) ‚â° 0    if a ‚â° 0 (mod p)\n */\nexport function FpLegendre(order) {\n    const legendreConst = (order - _1n) / _2n; // Integer arithmetic\n    return (f, x) => f.pow(x, legendreConst);\n}\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare(f) {\n    const legendre = FpLegendre(f.ORDER);\n    return (x) => {\n        const p = legendre(f, x);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nexport function nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n    let sqrtP; // cached sqrtP\n    const f = Object.freeze({\n        ORDER,\n        isLE,\n        BITS,\n        BYTES,\n        MASK: bitMask(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error('invalid field element: expected bigint, got ' + typeof num);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt ||\n            ((n) => {\n                if (!sqrtP)\n                    sqrtP = FpSqrt(ORDER);\n                return sqrtP(f, n);\n            }),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n            return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nexport function FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nexport function FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */\nexport function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = ensureBytes('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error('hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen);\n    const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n    const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map","/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nexport function isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\nexport function abytes(item) {\n    if (!isBytes(item))\n        throw new Error('Uint8Array expected');\n}\nexport function abool(title, value) {\n    if (typeof value !== 'boolean')\n        throw new Error(title + ' boolean expected, got ' + value);\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexport function numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? '0' + hex : hex;\n}\nexport function hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nexport function numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n        }\n    }\n    else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(title + ' must be hex string or Uint8Array');\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Is positive bigint\nconst isPosBig = (n) => typeof n === 'bigint' && _0n <= n;\nexport function inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max))\n        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nexport function bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nexport function validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error('invalid validator function');\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n/**\n * throws not implemented error\n */\nexport const notImplemented = () => {\n    throw new Error('not implemented');\n};\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args) => {\n        const val = map.get(arg);\n        if (val !== undefined)\n            return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n}\n//# sourceMappingURL=utils.js.map","/**\n * SHA2-512 a.k.a. sha512 and sha384. It is slower than sha256 in js because u64 operations are slow.\n *\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [the paper on truncated SHA512/256](https://eprint.iacr.org/2010/548.pdf).\n * @module\n */\nimport { HashMD } from './_md.js';\nimport u64 from './_u64.js';\nimport { wrapConstructor } from './utils.js';\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nexport class SHA512 extends HashMD {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nexport class SHA512_224 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nexport class SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nexport class SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\n/** SHA2-512 hash function. */\nexport const sha512 = /* @__PURE__ */ wrapConstructor(() => new SHA512());\n/** SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks. */\nexport const sha512_224 = /* @__PURE__ */ wrapConstructor(() => new SHA512_224());\n/** SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks. */\nexport const sha512_256 = /* @__PURE__ */ wrapConstructor(() => new SHA512_256());\n/** SHA2-384 hash function. */\nexport const sha384 = /* @__PURE__ */ wrapConstructor(() => new SHA384());\n//# sourceMappingURL=sha512.js.map"],"names":["_0n","BigInt","_1n","constTimeNegate","condition","item","neg","negate","validateW","W","bits","Number","isSafeInteger","calcWOpts","windows","Math","ceil","windowSize","pointPrecomputes","WeakMap","pointWindowSizes","getW","P","get","wNAF","c","hasPrecomputes","elm","unsafeLadder","n","p","ZERO","d","add","double","precomputeWindow","points","base","window","push","i","precomputes","f","BASE","mask","maxNumber","shiftBy","offset","wbits","offset2","abs","cond1","cond2","wNAFUnsafe","acc","curr","getPrecomputes","transform","comp","set","wNAFCached","wNAFCachedUnsafe","prev","setWindowSize","delete","pippenger","fieldN","scalars","validateMSMPoints","Array","isArray","forEach","validateMSMScalars","field","s","isValid","length","zero","_utils_js__WEBPACK_IMPORTED_MODULE_0__","Dd","MASK","buckets","fill","lastBits","floor","BITS","sum","j","scalar","resI","sumI","validateBasic","curve","_modular_js__WEBPACK_IMPORTED_MODULE_1__","OP","Fp","FF","h","Gx","Gy","nBitLength","nByteLength","Object","freeze","kK","ORDER","_2n","_3n","_4n","_5n","_8n","mod","a","b","result","pow2","x","power","modulo","res","invert","number","y","u","v","q","r","m","gcd","isNegativeLE","num","FIELD_FIELDS","validateField","opts","reduce","map","val","BYTES","nLength","_nBitLength","undefined","toString","Field","bitLen","isLE","redef","sqrtP","dQ","ONE","create","is0","isOdd","eql","lhs","rhs","sqr","sub","mul","pow","FpPow","div","sqrN","addN","subN","mulN","inv","sqrt","FpSqrt","p1div4","root","c1","n2","nv","tonelliShanks","Q","S","Z","legendreC","Q1div2","g","t2","ge","invertBatch","FpInvertBatch","nums","tmp","lastMultiplied","inverted","reduceRight","lst","cmov","toBytes","S5","tL","fromBytes","bytes","ty","bytesToNumberBE","getFieldBytesLength","fieldOrder","bitLength","getMinHashLength","mapHashToField","key","len","fieldLen","minLen","reduced","isBytes","Uint8Array","ArrayBuffer","isView","constructor","name","abytes","abool","title","value","hexes","from","_","padStart","bytesToHex","hex","numberToHexUnpadded","hexToNumber","asciis","_0","_9","A","F","asciiToBase16","ch","hexToBytes","hl","al","array","ai","hi","n1","charCodeAt","char","bytesToNumberLE","reverse","numberToBytesBE","numberToBytesLE","ensureBytes","expectedLength","e","concatBytes","arrays","pad","isPosBig","inRange","min","max","aInRange","bitMask","u8n","data","u8fr","arr","createHmacDrbg","hashLen","qByteLen","hmacFn","k","reset","reseed","seed","gen","out","sl","slice","pred","validatorFns","bigint","function","boolean","string","stringOrUint8Array","object","hash","outputLen","validateObject","validators","optValidators","checkField","fieldName","type","isOptional","checkVal","String","entries","memoized","fn","arg","args","computed","SHA512_Kh","SHA512_Kl","_u64_js__WEBPACK_IMPORTED_MODULE_0__","ZP","split","SHA512_W_H","Uint32Array","SHA512_W_L","SHA512","_md_js__WEBPACK_IMPORTED_MODULE_1__","VR","Ah","Al","Bh","Bl","Ch","Cl","Dh","Dl","Eh","El","Fh","Fl","Gh","Gl","Hh","Hl","process","view","getUint32","W15h","W15l","s0h","rotrSH","shrSH","s0l","rotrSL","shrSL","W2h","W2l","s1h","rotrBH","s1l","rotrBL","SUMl","add4L","SUMh","add4H","sigma1h","sigma1l","CHIh","CHIl","T1ll","add5L","T1h","add5H","T1l","sigma0h","sigma0l","MAJh","MAJl","l","All","add3L","add3H","roundClean","destroy","buffer","sha512","_utils_js__WEBPACK_IMPORTED_MODULE_2__","hE"],"sourceRoot":""}