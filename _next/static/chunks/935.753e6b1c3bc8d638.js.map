{"version":3,"file":"static/chunks/935.753e6b1c3bc8d638.js","mappings":"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","sources":["webpack://_N_E/./node_modules/@bitcoinerlab/secp256k1/dist/index.js","webpack://_N_E/./node_modules/@noble/curves/_shortw_utils.js","webpack://_N_E/./node_modules/@noble/curves/abstract/curve.js","webpack://_N_E/./node_modules/@noble/curves/abstract/hash-to-curve.js","webpack://_N_E/./node_modules/@noble/curves/abstract/modular.js","webpack://_N_E/./node_modules/@noble/curves/abstract/utils.js","webpack://_N_E/./node_modules/@noble/curves/abstract/weierstrass.js","webpack://_N_E/./node_modules/@noble/curves/secp256k1.js","webpack://_N_E/./node_modules/@noble/hashes/_assert.js","webpack://_N_E/./node_modules/@noble/hashes/_md.js","webpack://_N_E/./node_modules/@noble/hashes/crypto.js","webpack://_N_E/./node_modules/@noble/hashes/hmac.js","webpack://_N_E/./node_modules/@noble/hashes/ripemd160.js","webpack://_N_E/./node_modules/@noble/hashes/sha1.js","webpack://_N_E/./node_modules/@noble/hashes/sha256.js","webpack://_N_E/./node_modules/@noble/hashes/utils.js","webpack://_N_E/./node_modules/@unisat/wallet-utils/es/utils.js","webpack://_N_E/./node_modules/@unisat/wallet-utils/es/index.js","webpack://_N_E/./node_modules/base-x/src/index.js","webpack://_N_E/./node_modules/bech32/dist/index.js","webpack://_N_E/./node_modules/bip174/src/lib/combiner/index.js","webpack://_N_E/./node_modules/bip174/src/lib/converter/global/globalXpub.js","webpack://_N_E/./node_modules/bip174/src/lib/converter/global/unsignedTx.js","webpack://_N_E/./node_modules/bip174/src/lib/converter/index.js","webpack://_N_E/./node_modules/bip174/src/lib/converter/input/finalScriptSig.js","webpack://_N_E/./node_modules/bip174/src/lib/converter/input/finalScriptWitness.js","webpack://_N_E/./node_modules/bip174/src/lib/converter/input/nonWitnessUtxo.js","webpack://_N_E/./node_modules/bip174/src/lib/converter/input/partialSig.js","webpack://_N_E/./node_modules/bip174/src/lib/converter/input/porCommitment.js","webpack://_N_E/./node_modules/bip174/src/lib/converter/input/sighashType.js","webpack://_N_E/./node_modules/bip174/src/lib/converter/input/tapKeySig.js","webpack://_N_E/./node_modules/bip174/src/lib/converter/input/tapLeafScript.js","webpack://_N_E/./node_modules/bip174/src/lib/converter/input/tapMerkleRoot.js","webpack://_N_E/./node_modules/bip174/src/lib/converter/input/tapScriptSig.js","webpack://_N_E/./node_modules/bip174/src/lib/converter/input/witnessUtxo.js","webpack://_N_E/./node_modules/bip174/src/lib/converter/output/tapTree.js","webpack://_N_E/./node_modules/bip174/src/lib/converter/shared/bip32Derivation.js","webpack://_N_E/./node_modules/bip174/src/lib/converter/shared/checkPubkey.js","webpack://_N_E/./node_modules/bip174/src/lib/converter/shared/redeemScript.js","webpack://_N_E/./node_modules/bip174/src/lib/converter/shared/tapBip32Derivation.js","webpack://_N_E/./node_modules/bip174/src/lib/converter/shared/tapInternalKey.js","webpack://_N_E/./node_modules/bip174/src/lib/converter/shared/witnessScript.js","webpack://_N_E/./node_modules/bip174/src/lib/converter/tools.js","webpack://_N_E/./node_modules/bip174/src/lib/converter/varint.js","webpack://_N_E/./node_modules/bip174/src/lib/parser/fromBuffer.js","webpack://_N_E/./node_modules/bip174/src/lib/parser/index.js","webpack://_N_E/./node_modules/bip174/src/lib/parser/toBuffer.js","webpack://_N_E/./node_modules/bip174/src/lib/psbt.js","webpack://_N_E/./node_modules/bip174/src/lib/typeFields.js","webpack://_N_E/./node_modules/bip174/src/lib/utils.js","webpack://_N_E/./node_modules/bip322-js/dist/BIP322.js","webpack://_N_E/./node_modules/bip322-js/dist/Signer.js","webpack://_N_E/./node_modules/bip322-js/dist/Verifier.js","webpack://_N_E/./node_modules/bip322-js/dist/bitcoinjs/DecodeScriptSignature.js","webpack://_N_E/./node_modules/bip322-js/dist/bitcoinjs/index.js","webpack://_N_E/./node_modules/bip322-js/dist/helpers/Address.js","webpack://_N_E/./node_modules/bip322-js/dist/helpers/BIP137.js","webpack://_N_E/./node_modules/bip322-js/dist/helpers/Key.js","webpack://_N_E/./node_modules/bip322-js/dist/helpers/VarInt.js","webpack://_N_E/./node_modules/bip322-js/dist/helpers/VarStr.js","webpack://_N_E/./node_modules/bip322-js/dist/helpers/Witness.js","webpack://_N_E/./node_modules/bip322-js/dist/helpers/index.js","webpack://_N_E/./node_modules/bip322-js/dist/index.js","webpack://_N_E/./node_modules/bip322-js/node_modules/secp256k1/elliptic.js","webpack://_N_E/./node_modules/bip322-js/node_modules/secp256k1/lib/elliptic.js","webpack://_N_E/./node_modules/bip322-js/node_modules/secp256k1/lib/index.js","webpack://_N_E/./node_modules/bitcoinjs-lib/node_modules/bs58check/base.js","webpack://_N_E/./node_modules/bitcoinjs-lib/node_modules/bs58check/index.js","webpack://_N_E/./node_modules/bitcoinjs-lib/src/address.js","webpack://_N_E/./node_modules/bitcoinjs-lib/src/bip66.js","webpack://_N_E/./node_modules/bitcoinjs-lib/src/block.js","webpack://_N_E/./node_modules/bitcoinjs-lib/src/bufferutils.js","webpack://_N_E/./node_modules/bitcoinjs-lib/src/crypto.js","webpack://_N_E/./node_modules/bitcoinjs-lib/src/ecc_lib.js","webpack://_N_E/./node_modules/bitcoinjs-lib/src/index.js","webpack://_N_E/./node_modules/bitcoinjs-lib/src/merkle.js","webpack://_N_E/./node_modules/bitcoinjs-lib/src/networks.js","webpack://_N_E/./node_modules/bitcoinjs-lib/src/ops.js","webpack://_N_E/./node_modules/bitcoinjs-lib/src/payments/bip341.js","webpack://_N_E/./node_modules/bitcoinjs-lib/src/payments/embed.js","webpack://_N_E/./node_modules/bitcoinjs-lib/src/payments/index.js","webpack://_N_E/./node_modules/bitcoinjs-lib/src/payments/lazy.js","webpack://_N_E/./node_modules/bitcoinjs-lib/src/payments/p2ms.js","webpack://_N_E/./node_modules/bitcoinjs-lib/src/payments/p2pk.js","webpack://_N_E/./node_modules/bitcoinjs-lib/src/payments/p2pkh.js","webpack://_N_E/./node_modules/bitcoinjs-lib/src/payments/p2sh.js","webpack://_N_E/./node_modules/bitcoinjs-lib/src/payments/p2tr.js","webpack://_N_E/./node_modules/bitcoinjs-lib/src/payments/p2wpkh.js","webpack://_N_E/./node_modules/bitcoinjs-lib/src/payments/p2wsh.js","webpack://_N_E/./node_modules/bitcoinjs-lib/src/psbt.js","webpack://_N_E/./node_modules/bitcoinjs-lib/src/psbt/bip371.js","webpack://_N_E/./node_modules/bitcoinjs-lib/src/psbt/psbtutils.js","webpack://_N_E/./node_modules/bitcoinjs-lib/src/push_data.js","webpack://_N_E/./node_modules/bitcoinjs-lib/src/script.js","webpack://_N_E/./node_modules/bitcoinjs-lib/src/script_number.js","webpack://_N_E/./node_modules/bitcoinjs-lib/src/script_signature.js","webpack://_N_E/./node_modules/bitcoinjs-lib/src/transaction.js","webpack://_N_E/./node_modules/bitcoinjs-lib/src/types.js","webpack://_N_E/./node_modules/bitcoinjs-message/index.js","webpack://_N_E/./node_modules/bitcoinjs-message/node_modules/bech32/index.js","webpack://_N_E/./node_modules/bitcore-lib/index.js","webpack://_N_E/./node_modules/bitcore-lib/lib/address.js","webpack://_N_E/./node_modules/bitcore-lib/lib/block/block.js","webpack://_N_E/./node_modules/bitcore-lib/lib/block/blockheader.js","webpack://_N_E/./node_modules/bitcore-lib/lib/block/index.js","webpack://_N_E/./node_modules/bitcore-lib/lib/block/merkleblock.js","webpack://_N_E/./node_modules/bitcore-lib/lib/crypto/bn.js","webpack://_N_E/./node_modules/bitcore-lib/lib/crypto/ecdsa.js","webpack://_N_E/./node_modules/bitcore-lib/lib/crypto/hash.js","webpack://_N_E/./node_modules/bitcore-lib/lib/crypto/point.js","webpack://_N_E/./node_modules/bitcore-lib/lib/crypto/random.js","webpack://_N_E/./node_modules/bitcore-lib/lib/crypto/schnorr.js","webpack://_N_E/./node_modules/bitcore-lib/lib/crypto/signature.js","webpack://_N_E/./node_modules/bitcore-lib/lib/crypto/taggedhash.js","webpack://_N_E/./node_modules/bitcore-lib/lib/encoding/base58.js","webpack://_N_E/./node_modules/bitcore-lib/lib/encoding/base58check.js","webpack://_N_E/./node_modules/bitcore-lib/lib/encoding/bech32.js","webpack://_N_E/./node_modules/bitcore-lib/lib/encoding/bufferreader.js","webpack://_N_E/./node_modules/bitcore-lib/lib/encoding/bufferwriter.js","webpack://_N_E/./node_modules/bitcore-lib/lib/encoding/varint.js","webpack://_N_E/./node_modules/bitcore-lib/lib/errors/index.js","webpack://_N_E/./node_modules/bitcore-lib/lib/errors/spec.js","webpack://_N_E/./node_modules/bitcore-lib/lib/hdprivatekey.js","webpack://_N_E/./node_modules/bitcore-lib/lib/hdpublickey.js","webpack://_N_E/./node_modules/bitcore-lib/lib/message.js","webpack://_N_E/./node_modules/bitcore-lib/lib/networks.js","webpack://_N_E/./node_modules/bitcore-lib/lib/opcode.js","webpack://_N_E/./node_modules/bitcore-lib/lib/privatekey.js","webpack://_N_E/./node_modules/bitcore-lib/lib/publickey.js","webpack://_N_E/./node_modules/bitcore-lib/lib/script/index.js","webpack://_N_E/./node_modules/bitcore-lib/lib/script/interpreter.js","webpack://_N_E/./node_modules/bitcore-lib/lib/script/script.js","webpack://_N_E/./node_modules/bitcore-lib/lib/transaction/index.js","webpack://_N_E/./node_modules/bitcore-lib/lib/transaction/input/index.js","webpack://_N_E/./node_modules/bitcore-lib/lib/transaction/input/input.js","webpack://_N_E/./node_modules/bitcore-lib/lib/transaction/input/multisig.js","webpack://_N_E/./node_modules/bitcore-lib/lib/transaction/input/multisigscripthash.js","webpack://_N_E/./node_modules/bitcore-lib/lib/transaction/input/publickey.js","webpack://_N_E/./node_modules/bitcore-lib/lib/transaction/input/publickeyhash.js","webpack://_N_E/./node_modules/bitcore-lib/lib/transaction/input/taproot.js","webpack://_N_E/./node_modules/bitcore-lib/lib/transaction/output.js","webpack://_N_E/./node_modules/bitcore-lib/lib/transaction/sighash.js","webpack://_N_E/./node_modules/bitcore-lib/lib/transaction/sighashschnorr.js","webpack://_N_E/./node_modules/bitcore-lib/lib/transaction/sighashwitness.js","webpack://_N_E/./node_modules/bitcore-lib/lib/transaction/signature.js","webpack://_N_E/./node_modules/bitcore-lib/lib/transaction/transaction.js","webpack://_N_E/./node_modules/bitcore-lib/lib/transaction/unspentoutput.js","webpack://_N_E/./node_modules/bitcore-lib/lib/unit.js","webpack://_N_E/./node_modules/bitcore-lib/lib/uri.js","webpack://_N_E/./node_modules/bitcore-lib/lib/util/buffer.js","webpack://_N_E/./node_modules/bitcore-lib/lib/util/js.js","webpack://_N_E/./node_modules/bitcore-lib/lib/util/preconditions.js","webpack://_N_E/./node_modules/bitcore-lib/node_modules/bn.js/lib/bn.js","webpack://_N_E/./node_modules/bitcore-lib/node_modules/bs58/index.js","webpack://_N_E/./node_modules/bitcore-lib/node_modules/inherits/inherits_browser.js","webpack://_N_E/./node_modules/bs58/index.js","webpack://_N_E/./node_modules/bs58/node_modules/base-x/src/index.js","webpack://_N_E/./node_modules/bs58check/base.js","webpack://_N_E/./node_modules/bs58check/index.js","webpack://_N_E/./node_modules/bs58check/node_modules/bs58/index.js","webpack://_N_E/./node_modules/buffer-compare/index.js","webpack://_N_E/./node_modules/buffer-equals/index.js","webpack://_N_E/./node_modules/ecpair/src/ecpair.js","webpack://_N_E/./node_modules/ecpair/src/index.js","webpack://_N_E/./node_modules/ecpair/src/networks.js","webpack://_N_E/./node_modules/ecpair/src/testecc.js","webpack://_N_E/./node_modules/ecpair/src/types.js","webpack://_N_E/./node_modules/fast-sha256/sha256.js","webpack://_N_E/./node_modules/next/dist/compiled/native-url/index.js","webpack://_N_E/./node_modules/next/dist/compiled/querystring-es3/index.js","webpack://_N_E/./node_modules/typeforce/errors.js","webpack://_N_E/./node_modules/typeforce/extra.js","webpack://_N_E/./node_modules/typeforce/index.js","webpack://_N_E/./node_modules/typeforce/native.js","webpack://_N_E/./node_modules/varuint-bitcoin/index.js","webpack://_N_E/./node_modules/wif/index.js","webpack://_N_E/./node_modules/tiny-secp256k1/lib/index.js","webpack://_N_E/./node_modules/tiny-secp256k1/lib/rand.browser.js","webpack://_N_E/./node_modules/tiny-secp256k1/lib/validate.js","webpack://_N_E/./node_modules/tiny-secp256k1/lib/validate_error.js","webpack://_N_E/./node_modules/tiny-secp256k1/lib/wasm_loader.browser.js","webpack://_N_E/./node_modules/uint8array-tools/src/mjs/browser.js","webpack://_N_E/<anon>"],"sourcesContent":["'use strict';\n\nvar secp256k1 = require('@noble/curves/secp256k1');\nvar mod = require('@noble/curves/abstract/modular');\nvar utils = require('@noble/curves/abstract/utils');\n\nfunction _interopNamespaceDefault(e) {\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n.default = e;\n  return Object.freeze(n);\n}\n\nvar mod__namespace = /*#__PURE__*/_interopNamespaceDefault(mod);\nvar utils__namespace = /*#__PURE__*/_interopNamespaceDefault(utils);\n\n/*\n * Copyright (c) 2023 Jose-Luis Landabaso\n * Distributed under the MIT software license.\n *\n * This file includes code from the following sources:\n *  * Paul Miller's @noble/secp256k1 (specifically, the privateAdd,\n *    privateNegate, pointAddScalar, and pointMultiply functions).\n *  * Some pieces from tiny-secp256k1\n *    (https://github.com/bitcoinjs/tiny-secp256k1)\n *  * It also uses code from BitGo's BitGoJS library\n *    (https://github.com/BitGo/BitGoJS)\n *\n * This package's tests are based on modified versions of tests from\n * tiny-secp256k1 (https://github.com/bitcoinjs/tiny-secp256k1/tests).\n */\n\nconst Point = secp256k1.secp256k1.ProjectivePoint;\n\nconst THROW_BAD_PRIVATE = \"Expected Private\";\nconst THROW_BAD_POINT = \"Expected Point\";\nconst THROW_BAD_TWEAK = \"Expected Tweak\";\nconst THROW_BAD_HASH = \"Expected Hash\";\nconst THROW_BAD_SIGNATURE = \"Expected Signature\";\nconst THROW_BAD_EXTRA_DATA = \"Expected Extra Data (32 bytes)\";\nconst THROW_BAD_SCALAR = \"Expected Scalar\";\nconst THROW_BAD_RECOVERY_ID = \"Bad Recovery Id\";\n\nconst HASH_SIZE = 32;\nconst TWEAK_SIZE = 32;\nconst BN32_N = new Uint8Array([\n  255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n  254, 186, 174, 220, 230, 175, 72, 160, 59, 191, 210, 94, 140, 208, 54, 65, 65,\n]);\nconst EXTRA_DATA_SIZE = 32;\nconst BN32_ZERO = new Uint8Array(32);\nconst BN32_P_MINUS_N = new Uint8Array([\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 69, 81, 35, 25, 80, 183, 95,\n  196, 64, 45, 161, 114, 47, 201, 186, 238,\n]);\nconst _1n = BigInt(1);\n\nfunction isUint8Array(value) {\n  return value instanceof Uint8Array;\n}\n\nfunction cmpBN32(data1, data2) {\n  for (let i = 0; i < 32; ++i) {\n    if (data1[i] !== data2[i]) {\n      return data1[i] < data2[i] ? -1 : 1;\n    }\n  }\n  return 0;\n}\n\nfunction isZero(x) {\n  return cmpBN32(x, BN32_ZERO) === 0;\n}\n\nfunction isTweak(tweak) {\n  if (\n    !(tweak instanceof Uint8Array) ||\n    tweak.length !== TWEAK_SIZE ||\n    cmpBN32(tweak, BN32_N) >= 0\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction isSignature(signature) {\n  return (\n    signature instanceof Uint8Array &&\n    signature.length === 64 &&\n    cmpBN32(signature.subarray(0, 32), BN32_N) < 0 &&\n    cmpBN32(signature.subarray(32, 64), BN32_N) < 0\n  );\n}\n\nfunction isSigrLessThanPMinusN(signature) {\n  return (\n    isUint8Array(signature) &&\n    signature.length === 64 &&\n    cmpBN32(signature.subarray(0, 32), BN32_P_MINUS_N) < 0\n  );\n}\n\nfunction isSignatureNonzeroRS(signature) {\n  return !(\n    isZero(signature.subarray(0, 32)) || isZero(signature.subarray(32, 64))\n  );\n}\n\nfunction isHash(h) {\n  return h instanceof Uint8Array && h.length === HASH_SIZE;\n}\n\nfunction isExtraData(e) {\n  return (\n    e === undefined || (e instanceof Uint8Array && e.length === EXTRA_DATA_SIZE)\n  );\n}\n\nfunction normalizeScalar(scalar) {\n  let num;\n  if (typeof scalar === \"bigint\") {\n    num = scalar;\n  } else if (\n    typeof scalar === \"number\" &&\n    Number.isSafeInteger(scalar) &&\n    scalar >= 0\n  ) {\n    num = BigInt(scalar);\n  } else if (typeof scalar === \"string\") {\n    if (scalar.length !== 64)\n      throw new Error(\"Expected 32 bytes of private scalar\");\n    num = utils__namespace.hexToNumber(scalar);\n  } else if (scalar instanceof Uint8Array) {\n    if (scalar.length !== 32)\n      throw new Error(\"Expected 32 bytes of private scalar\");\n    num = utils__namespace.bytesToNumberBE(scalar);\n  } else {\n    throw new TypeError(\"Expected valid private scalar\");\n  }\n  if (num < 0) throw new Error(\"Expected private scalar >= 0\");\n  return num;\n}\n\nfunction normalizePrivateKey(privateKey) {\n  return secp256k1.secp256k1.utils.normPrivateKeyToScalar(privateKey);\n}\n\nfunction _privateAdd(privateKey, tweak) {\n  const p = normalizePrivateKey(privateKey);\n  const t = normalizeScalar(tweak);\n  const add = utils__namespace.numberToBytesBE(mod__namespace.mod(p + t, secp256k1.secp256k1.CURVE.n), 32);\n  return secp256k1.secp256k1.utils.isValidPrivateKey(add) ? add : null;\n}\n\nfunction _privateSub(privateKey, tweak) {\n  const p = normalizePrivateKey(privateKey);\n  const t = normalizeScalar(tweak);\n  const sub = utils__namespace.numberToBytesBE(mod__namespace.mod(p - t, secp256k1.secp256k1.CURVE.n), 32);\n  return secp256k1.secp256k1.utils.isValidPrivateKey(sub) ? sub : null;\n}\n\nfunction _privateNegate(privateKey) {\n  const p = normalizePrivateKey(privateKey);\n  const not = utils__namespace.numberToBytesBE(secp256k1.secp256k1.CURVE.n - p, 32);\n  return secp256k1.secp256k1.utils.isValidPrivateKey(not) ? not : null;\n}\n\nfunction _pointAddScalar(p, tweak, isCompressed) {\n  const P = fromHex(p);\n  const t = normalizeScalar(tweak);\n  // multiplyAndAddUnsafe(P, scalar, 1) = P + scalar*G\n  const Q = Point.BASE.multiplyAndAddUnsafe(P, t, _1n);\n  if (!Q) throw new Error(\"Tweaked point at infinity\");\n  return Q.toRawBytes(isCompressed);\n}\n\nfunction _pointMultiply(p, tweak, isCompressed) {\n  const P = fromHex(p);\n  const h = typeof tweak === \"string\" ? tweak : utils__namespace.bytesToHex(tweak);\n  const t = utils__namespace.hexToNumber(h);\n  return P.multiply(t).toRawBytes(isCompressed);\n}\n\nfunction assumeCompression(compressed, p) {\n  if (compressed === undefined) {\n    return p !== undefined ? isPointCompressed(p) : true;\n  }\n  return !!compressed;\n}\n\nfunction throwToNull(fn) {\n  try {\n    return fn();\n  } catch (e) {\n    return null;\n  }\n}\n\nfunction fromXOnly(bytes) {\n  return secp256k1.schnorr.utils.lift_x(utils__namespace.bytesToNumberBE(bytes));\n}\n\nfunction fromHex(bytes) {\n  return bytes.length === 32 ? fromXOnly(bytes) : Point.fromHex(bytes);\n}\n\nfunction _isPoint(p, xOnly) {\n  if ((p.length === 32) !== xOnly) return false;\n  try {\n    if (xOnly) return !!fromXOnly(p);\n    else return !!Point.fromHex(p);\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction isPoint(p) {\n  return _isPoint(p, false);\n}\n\nfunction isPointCompressed(p) {\n  const PUBLIC_KEY_COMPRESSED_SIZE = 33;\n  return _isPoint(p, false) && p.length === PUBLIC_KEY_COMPRESSED_SIZE;\n}\n\nfunction isPrivate(d) {\n  return secp256k1.secp256k1.utils.isValidPrivateKey(d);\n}\n\nfunction isXOnlyPoint(p) {\n  return _isPoint(p, true);\n}\n\nfunction xOnlyPointAddTweak(p, tweak) {\n  if (!isXOnlyPoint(p)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  if (!isTweak(tweak)) {\n    throw new Error(THROW_BAD_TWEAK);\n  }\n  return throwToNull(() => {\n    const P = _pointAddScalar(p, tweak, true);\n    const parity = P[0] % 2 === 1 ? 1 : 0;\n    return { parity, xOnlyPubkey: P.slice(1) };\n  });\n}\n\nfunction xOnlyPointFromPoint(p) {\n  if (!isPoint(p)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  return p.slice(1, 33);\n}\n\nfunction pointFromScalar(sk, compressed) {\n  if (!isPrivate(sk)) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  return throwToNull(() =>\n    secp256k1.secp256k1.getPublicKey(sk, assumeCompression(compressed)),\n  );\n}\n\nfunction xOnlyPointFromScalar(d) {\n  if (!isPrivate(d)) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  return xOnlyPointFromPoint(pointFromScalar(d));\n}\n\nfunction pointCompress(p, compressed) {\n  if (!isPoint(p)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  return fromHex(p).toRawBytes(assumeCompression(compressed, p));\n}\n\nfunction pointMultiply(a, tweak, compressed) {\n  if (!isPoint(a)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  if (!isTweak(tweak)) {\n    throw new Error(THROW_BAD_TWEAK);\n  }\n  return throwToNull(() =>\n    _pointMultiply(a, tweak, assumeCompression(compressed, a)),\n  );\n}\n\nfunction pointAdd(a, b, compressed) {\n  if (!isPoint(a) || !isPoint(b)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  return throwToNull(() => {\n    const A = fromHex(a);\n    const B = fromHex(b);\n    if (A.equals(B.negate())) {\n      return null;\n    } else {\n      return A.add(B).toRawBytes(assumeCompression(compressed, a));\n    }\n  });\n}\n\nfunction pointAddScalar(p, tweak, compressed) {\n  if (!isPoint(p)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  if (!isTweak(tweak)) {\n    throw new Error(THROW_BAD_TWEAK);\n  }\n  return throwToNull(() =>\n    _pointAddScalar(p, tweak, assumeCompression(compressed, p)),\n  );\n}\n\nfunction privateAdd(d, tweak) {\n  if (!isPrivate(d)) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  if (!isTweak(tweak)) {\n    throw new Error(THROW_BAD_TWEAK);\n  }\n  return throwToNull(() => _privateAdd(d, tweak));\n}\n\nfunction privateSub(d, tweak) {\n  if (!isPrivate(d)) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  if (!isTweak(tweak)) {\n    throw new Error(THROW_BAD_TWEAK);\n  }\n  return throwToNull(() => _privateSub(d, tweak));\n}\n\nfunction privateNegate(d) {\n  if (!isPrivate(d)) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  return _privateNegate(d);\n}\n\nfunction sign(h, d, e) {\n  if (!isPrivate(d)) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  if (!isHash(h)) {\n    throw new Error(THROW_BAD_SCALAR);\n  }\n  if (!isExtraData(e)) {\n    throw new Error(THROW_BAD_EXTRA_DATA);\n  }\n  return secp256k1.secp256k1.sign(h, d, { extraEntropy: e }).toCompactRawBytes();\n}\n\nfunction signRecoverable(h, d, e) {\n  if (!isPrivate(d)) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  if (!isHash(h)) {\n    throw new Error(THROW_BAD_SCALAR);\n  }\n  if (!isExtraData(e)) {\n    throw new Error(THROW_BAD_EXTRA_DATA);\n  }\n  const sig = secp256k1.secp256k1.sign(h, d, { extraEntropy: e });\n  return {\n    signature: sig.toCompactRawBytes(),\n    recoveryId: sig.recovery,\n  };\n}\n\nfunction signSchnorr(h, d, e) {\n  if (!isPrivate(d)) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  if (!isHash(h)) {\n    throw new Error(THROW_BAD_SCALAR);\n  }\n  if (!isExtraData(e)) {\n    throw new Error(THROW_BAD_EXTRA_DATA);\n  }\n  return secp256k1.schnorr.sign(h, d, e);\n}\n\nfunction recover(h, signature, recoveryId, compressed) {\n  if (!isHash(h)) {\n    throw new Error(THROW_BAD_HASH);\n  }\n\n  if (!isSignature(signature) || !isSignatureNonzeroRS(signature)) {\n    throw new Error(THROW_BAD_SIGNATURE);\n  }\n\n  if (recoveryId & 2) {\n    if (!isSigrLessThanPMinusN(signature))\n      throw new Error(THROW_BAD_RECOVERY_ID);\n  }\n  if (!isXOnlyPoint(signature.subarray(0, 32))) {\n    throw new Error(THROW_BAD_SIGNATURE);\n  }\n\n  const s =\n    secp256k1.secp256k1.Signature.fromCompact(signature).addRecoveryBit(recoveryId);\n  const Q = s.recoverPublicKey(h);\n  if (!Q) throw new Error(THROW_BAD_SIGNATURE);\n  return Q.toRawBytes(assumeCompression(compressed));\n}\n\nfunction verify(h, Q, signature, strict) {\n  if (!isPoint(Q)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  if (!isSignature(signature)) {\n    throw new Error(THROW_BAD_SIGNATURE);\n  }\n  if (!isHash(h)) {\n    throw new Error(THROW_BAD_SCALAR);\n  }\n  return secp256k1.secp256k1.verify(signature, h, Q, { lowS: strict });\n}\n\nfunction verifySchnorr(h, Q, signature) {\n  if (!isXOnlyPoint(Q)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  if (!isSignature(signature)) {\n    throw new Error(THROW_BAD_SIGNATURE);\n  }\n  if (!isHash(h)) {\n    throw new Error(THROW_BAD_SCALAR);\n  }\n  return secp256k1.schnorr.verify(signature, h, Q);\n}\n\nexports.isPoint = isPoint;\nexports.isPointCompressed = isPointCompressed;\nexports.isPrivate = isPrivate;\nexports.isXOnlyPoint = isXOnlyPoint;\nexports.pointAdd = pointAdd;\nexports.pointAddScalar = pointAddScalar;\nexports.pointCompress = pointCompress;\nexports.pointFromScalar = pointFromScalar;\nexports.pointMultiply = pointMultiply;\nexports.privateAdd = privateAdd;\nexports.privateNegate = privateNegate;\nexports.privateSub = privateSub;\nexports.recover = recover;\nexports.sign = sign;\nexports.signRecoverable = signRecoverable;\nexports.signSchnorr = signSchnorr;\nexports.verify = verify;\nexports.verifySchnorr = verifySchnorr;\nexports.xOnlyPointAddTweak = xOnlyPointAddTweak;\nexports.xOnlyPointFromPoint = xOnlyPointFromPoint;\nexports.xOnlyPointFromScalar = xOnlyPointFromScalar;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getHash = getHash;\nexports.createCurve = createCurve;\n/**\n * Utilities for short weierstrass curves, combined with noble-hashes.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst hmac_1 = require(\"@noble/hashes/hmac\");\nconst utils_1 = require(\"@noble/hashes/utils\");\nconst weierstrass_js_1 = require(\"./abstract/weierstrass.js\");\n/** connects noble-curves to noble-hashes */\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),\n        randomBytes: utils_1.randomBytes,\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash) });\n    return { ...create(defHash), create };\n}\n//# sourceMappingURL=_shortw_utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.wNAF = wNAF;\nexports.pippenger = pippenger;\nexports.precomputeMSMUnsafe = precomputeMSMUnsafe;\nexports.validateBasic = validateBasic;\n/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst modular_js_1 = require(\"./modular.js\");\nconst utils_js_1 = require(\"./utils.js\");\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n        throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\nfunction calcWOpts(W, bits) {\n    validateW(W, bits);\n    const windows = Math.ceil(bits / W) + 1; // +1, because\n    const windowSize = 2 ** (W - 1); // -1 because we skip zero\n    return { windows, windowSize };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points))\n        throw new Error('array expected');\n    points.forEach((p, i) => {\n        if (!(p instanceof c))\n            throw new Error('invalid point at index ' + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars))\n        throw new Error('array of scalars expected');\n    scalars.forEach((s, i) => {\n        if (!field.isValid(s))\n            throw new Error('invalid scalar at index ' + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap(); // This allows use make points immutable (nothing changes inside)\nfunction getW(P) {\n    return pointWindowSizes.get(P) || 1;\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nfunction wNAF(c, bits) {\n    return {\n        constTimeNegate,\n        hasPrecomputes(elm) {\n            return getW(elm) !== 1;\n        },\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n, p = c.ZERO) {\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n         * - 𝑊 is the window size\n         * - 𝑛 is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @param elm Point instance\n         * @param W window size\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = calcWOpts(W, bits);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        /**\n         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @param acc accumulator point to add result of multiplication\n         * @returns point\n         */\n        wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                if (n === _0n)\n                    break; // No need to go over empty scalar\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                if (wbits === 0)\n                    continue;\n                let curr = precomputes[offset + Math.abs(wbits) - 1]; // -1 because we skip zero\n                if (wbits < 0)\n                    curr = curr.negate();\n                // NOTE: by re-using acc, we can save a lot of additions in case of MSM\n                acc = acc.add(curr);\n            }\n            return acc;\n        },\n        getPrecomputes(W, P, transform) {\n            // Calculate precomputes on a first run, reuse them after\n            let comp = pointPrecomputes.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1)\n                    pointPrecomputes.set(P, transform(comp));\n            }\n            return comp;\n        },\n        wNAFCached(P, n, transform) {\n            const W = getW(P);\n            return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n        },\n        wNAFCachedUnsafe(P, n, transform, prev) {\n            const W = getW(P);\n            if (W === 1)\n                return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n            return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n        },\n        // We calculate precomputes for elliptic curve point multiplication\n        // using windowed method. This specifies window size and\n        // stores precomputed values. Usually only base point would be precomputed.\n        setWindowSize(P, W) {\n            validateW(W, bits);\n            pointWindowSizes.set(P, W);\n            pointPrecomputes.delete(P);\n        },\n    };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster with precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */\nfunction pippenger(c, fieldN, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    if (points.length !== scalars.length)\n        throw new Error('arrays of points and scalars must have equal length');\n    const zero = c.ZERO;\n    const wbits = (0, utils_js_1.bitLen)(BigInt(points.length));\n    const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1; // in bits\n    const MASK = (1 << windowSize) - 1;\n    const buckets = new Array(MASK + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for (let i = lastBits; i >= 0; i -= windowSize) {\n        buckets.fill(zero);\n        for (let j = 0; j < scalars.length; j++) {\n            const scalar = scalars[j];\n            const wbits = Number((scalar >> BigInt(i)) & BigInt(MASK));\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0)\n            for (let j = 0; j < windowSize; j++)\n                sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nfunction precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar × 256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255 × 32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16 × 255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */\n    validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = BigInt((1 << windowSize) - 1);\n    const tables = points.map((p) => {\n        const res = [];\n        for (let i = 0, acc = p; i < tableSize; i++) {\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars) => {\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length)\n            throw new Error('array of scalars must be smaller than array of points');\n        let res = zero;\n        for (let i = 0; i < chunks; i++) {\n            // No need to double if accumulator is still zero.\n            if (res !== zero)\n                for (let j = 0; j < windowSize; j++)\n                    res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for (let j = 0; j < scalars.length; j++) {\n                const n = scalars[j];\n                const curr = Number((n >> shiftBy) & MASK);\n                if (!curr)\n                    continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\nfunction validateBasic(curve) {\n    (0, modular_js_1.validateField)(curve.Fp);\n    (0, utils_js_1.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.expand_message_xmd = expand_message_xmd;\nexports.expand_message_xof = expand_message_xof;\nexports.hash_to_field = hash_to_field;\nexports.isogenyMap = isogenyMap;\nexports.createHasher = createHasher;\nconst modular_js_1 = require(\"./modular.js\");\nconst utils_js_1 = require(\"./utils.js\");\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = utils_js_1.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    anum(value);\n    anum(length);\n    if (value < 0 || value >= 1 << (8 * length))\n        throw new Error('invalid I2OSP input: ' + value);\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n/**\n * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\n * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).\n */\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0, utils_js_1.abytes)(msg);\n    (0, utils_js_1.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (lenInBytes > 65535 || ell > 255)\n        throw new Error('expand_message_xmd: invalid lenInBytes');\n    const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0, utils_js_1.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n/**\n * Produces a uniformly random byte string using an extendable-output function (XOF) H.\n * 1. The collision resistance of H MUST be at least k bits.\n * 2. H MUST be an XOF that has been proved indifferentiable from\n *    a random oracle under a reasonable cryptographic assumption.\n * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).\n */\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0, utils_js_1.abytes)(msg);\n    (0, utils_js_1.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    (0, utils_js_1.validateObject)(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    (0, utils_js_1.abytes)(msg);\n    anum(count);\n    const DST = typeof _DST === 'string' ? (0, utils_js_1.utf8ToBytes)(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0, modular_js_1.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return { x: x, y: y };\n    };\n}\n/** Creates hash-to-curve methods from EC Point and mapToCurve function. */\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Same as encodeToCurve, but without hash\n        mapToCurve(scalars) {\n            if (!Array.isArray(scalars))\n                throw new Error('mapToCurve: expected array of bigints');\n            for (const i of scalars)\n                if (typeof i !== 'bigint')\n                    throw new Error('mapToCurve: expected array of bigints');\n            const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isNegativeLE = void 0;\nexports.mod = mod;\nexports.pow = pow;\nexports.pow2 = pow2;\nexports.invert = invert;\nexports.tonelliShanks = tonelliShanks;\nexports.FpSqrt = FpSqrt;\nexports.validateField = validateField;\nexports.FpPow = FpPow;\nexports.FpInvertBatch = FpInvertBatch;\nexports.FpDiv = FpDiv;\nexports.FpLegendre = FpLegendre;\nexports.FpIsSquare = FpIsSquare;\nexports.nLength = nLength;\nexports.Field = Field;\nexports.FpSqrtOdd = FpSqrtOdd;\nexports.FpSqrtEven = FpSqrtEven;\nexports.hashToPrivateScalar = hashToPrivateScalar;\nexports.getFieldBytesLength = getFieldBytesLength;\nexports.getMinHashLength = getMinHashLength;\nexports.mapHashToField = mapHashToField;\n/**\n * Utils for modular division and finite fields.\n * A finite field over 11 is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst utils_js_1 = require(\"./utils.js\");\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _8n = /* @__PURE__ */ BigInt(8);\n// prettier-ignore\nconst _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @todo use field version && remove\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nfunction pow(num, power, modulo) {\n    if (power < _0n)\n        throw new Error('invalid exponent, negatives unsupported');\n    if (modulo <= _0n)\n        throw new Error('invalid modulus');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nfunction invert(number, modulo) {\n    if (number === _0n)\n        throw new Error('invert: expected non-zero number');\n    if (modulo <= _0n)\n        throw new Error('invert: expected positive modulus, got ' + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ≡ 1    if a is a square (mod p)\n    // (a | p) ≡ -1   if a is not a square (mod p)\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++) {\n        // Crash instead of infinity loop, we cannot reasonable count until P.\n        if (Z > 1000)\n            throw new Error('Cannot find square root: likely non-prime P');\n    }\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\n/**\n * Square root for a finite field. It will try to check if optimizations are applicable and fall back to 4:\n *\n * 1. P ≡ 3 (mod 4)\n * 2. P ≡ 5 (mod 8)\n * 3. P ≡ 9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nfunction FpSqrt(P) {\n    // P ≡ 3 (mod 4)\n    // √n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P ≡ 9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\nexports.isNegativeLE = isNegativeLE;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0, utils_js_1.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('invalid exponent, negatives unsupported');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n/**\n * Legendre symbol.\n * * (a | p) ≡ 1    if a is a square (mod p), quadratic residue\n * * (a | p) ≡ -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) ≡ 0    if a ≡ 0 (mod p)\n */\nfunction FpLegendre(order) {\n    const legendreConst = (order - _1n) / _2n; // Integer arithmetic\n    return (f, x) => f.pow(x, legendreConst);\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendre = FpLegendre(f.ORDER);\n    return (x) => {\n        const p = legendre(f, x);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n    let sqrtP; // cached sqrtP\n    const f = Object.freeze({\n        ORDER,\n        isLE,\n        BITS,\n        BYTES,\n        MASK: (0, utils_js_1.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error('invalid field element: expected bigint, got ' + typeof num);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt ||\n            ((n) => {\n                if (!sqrtP)\n                    sqrtP = FpSqrt(ORDER);\n                return sqrtP(f, n);\n            }),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n            return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0, utils_js_1.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error('hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen);\n    const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n    const num = isLE ? (0, utils_js_1.bytesToNumberLE)(key) : (0, utils_js_1.bytesToNumberBE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map","\"use strict\";\n/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.notImplemented = exports.bitMask = void 0;\nexports.isBytes = isBytes;\nexports.abytes = abytes;\nexports.abool = abool;\nexports.bytesToHex = bytesToHex;\nexports.numberToHexUnpadded = numberToHexUnpadded;\nexports.hexToNumber = hexToNumber;\nexports.hexToBytes = hexToBytes;\nexports.bytesToNumberBE = bytesToNumberBE;\nexports.bytesToNumberLE = bytesToNumberLE;\nexports.numberToBytesBE = numberToBytesBE;\nexports.numberToBytesLE = numberToBytesLE;\nexports.numberToVarBytesBE = numberToVarBytesBE;\nexports.ensureBytes = ensureBytes;\nexports.concatBytes = concatBytes;\nexports.equalBytes = equalBytes;\nexports.utf8ToBytes = utf8ToBytes;\nexports.inRange = inRange;\nexports.aInRange = aInRange;\nexports.bitLen = bitLen;\nexports.bitGet = bitGet;\nexports.bitSet = bitSet;\nexports.createHmacDrbg = createHmacDrbg;\nexports.validateObject = validateObject;\nexports.memoized = memoized;\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\nfunction abytes(item) {\n    if (!isBytes(item))\n        throw new Error('Uint8Array expected');\n}\nfunction abool(title, value) {\n    if (typeof value !== 'boolean')\n        throw new Error(title + ' boolean expected, got ' + value);\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? '0' + hex : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n        }\n    }\n    else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(title + ' must be hex string or Uint8Array');\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Is positive bigint\nconst isPosBig = (n) => typeof n === 'bigint' && _0n <= n;\nfunction inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nfunction aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max))\n        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nfunction bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\nexports.bitMask = bitMask;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error('invalid validator function');\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n/**\n * throws not implemented error\n */\nconst notImplemented = () => {\n    throw new Error('not implemented');\n};\nexports.notImplemented = notImplemented;\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nfunction memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args) => {\n        const val = map.get(arg);\n        if (val !== undefined)\n            return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n}\n//# sourceMappingURL=utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DER = exports.DERErr = void 0;\nexports.weierstrassPoints = weierstrassPoints;\nexports.weierstrass = weierstrass;\nexports.SWUFpSqrtRatio = SWUFpSqrtRatio;\nexports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;\n/**\n * Short Weierstrass curve methods. The formula is: y² = x³ + ax + b.\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst curve_js_1 = require(\"./curve.js\");\nconst modular_js_1 = require(\"./modular.js\");\nconst ut = require(\"./utils.js\");\nconst utils_js_1 = require(\"./utils.js\");\nfunction validateSigVerOpts(opts) {\n    if (opts.lowS !== undefined)\n        (0, utils_js_1.abool)('lowS', opts.lowS);\n    if (opts.prehash !== undefined)\n        (0, utils_js_1.abool)('prehash', opts.prehash);\n}\nfunction validatePointOpts(curve) {\n    const opts = (0, curve_js_1.validateBasic)(curve);\n    ut.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('invalid endomorphism, can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('invalid endomorphism, expected beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;\nclass DERErr extends Error {\n    constructor(m = '') {\n        super(m);\n    }\n}\nexports.DERErr = DERErr;\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nexports.DER = {\n    // asn.1 DER encoding utils\n    Err: DERErr,\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n        encode: (tag, data) => {\n            const { Err: E } = exports.DER;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length & 1)\n                throw new E('tlv.encode: unpadded data');\n            const dataLen = data.length / 2;\n            const len = ut.numberToHexUnpadded(dataLen);\n            if ((len.length / 2) & 128)\n                throw new E('tlv.encode: long form length too big');\n            // length of length with long form flag\n            const lenLen = dataLen > 127 ? ut.numberToHexUnpadded((len.length / 2) | 128) : '';\n            const t = ut.numberToHexUnpadded(tag);\n            return t + lenLen + len + data;\n        },\n        // v - value, l - left bytes (unparsed)\n        decode(tag, data) {\n            const { Err: E } = exports.DER;\n            let pos = 0;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length < 2 || data[pos++] !== tag)\n                throw new E('tlv.decode: wrong tlv');\n            const first = data[pos++];\n            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n            let length = 0;\n            if (!isLong)\n                length = first;\n            else {\n                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n                const lenLen = first & 127;\n                if (!lenLen)\n                    throw new E('tlv.decode(long): indefinite length not supported');\n                if (lenLen > 4)\n                    throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n                const lengthBytes = data.subarray(pos, pos + lenLen);\n                if (lengthBytes.length !== lenLen)\n                    throw new E('tlv.decode: length bytes not complete');\n                if (lengthBytes[0] === 0)\n                    throw new E('tlv.decode(long): zero leftmost byte');\n                for (const b of lengthBytes)\n                    length = (length << 8) | b;\n                pos += lenLen;\n                if (length < 128)\n                    throw new E('tlv.decode(long): not minimal encoding');\n            }\n            const v = data.subarray(pos, pos + length);\n            if (v.length !== length)\n                throw new E('tlv.decode: wrong value length');\n            return { v, l: data.subarray(pos + length) };\n        },\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n        encode(num) {\n            const { Err: E } = exports.DER;\n            if (num < _0n)\n                throw new E('integer: negative integers are not allowed');\n            let hex = ut.numberToHexUnpadded(num);\n            // Pad with zero byte if negative flag is present\n            if (Number.parseInt(hex[0], 16) & 0b1000)\n                hex = '00' + hex;\n            if (hex.length & 1)\n                throw new E('unexpected DER parsing assertion: unpadded hex');\n            return hex;\n        },\n        decode(data) {\n            const { Err: E } = exports.DER;\n            if (data[0] & 128)\n                throw new E('invalid signature integer: negative');\n            if (data[0] === 0x00 && !(data[1] & 128))\n                throw new E('invalid signature integer: unnecessary leading zero');\n            return b2n(data);\n        },\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E, _int: int, _tlv: tlv } = exports.DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        ut.abytes(data);\n        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n        if (seqLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n        if (sLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        return { r: int.decode(rBytes), s: int.decode(sBytes) };\n    },\n    hexFromSig(sig) {\n        const { _tlv: tlv, _int: int } = exports.DER;\n        const rs = tlv.encode(0x02, int.encode(sig.r));\n        const ss = tlv.encode(0x02, int.encode(sig.s));\n        const seq = rs + ss;\n        return tlv.encode(0x30, seq);\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const Fn = (0, modular_js_1.Field)(CURVE.n, CURVE.nBitLength);\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y² = x³ + ax + b: Short weierstrass curve formula\n     * @returns y²\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return ut.inRange(num, _1n, CURVE.n);\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (ut.isBytes(key))\n                key = ut.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('invalid private key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error('invalid private key, expected hex or ' + nByteLength + ' bytes, got ' + typeof key);\n        }\n        if (wrapPrivateKey)\n            num = (0, modular_js_1.mod)(num, N); // disabled by default, enabled for BLS\n        ut.aInRange('private key', num, _1n, N); // num in range [1..N-1]\n        return num;\n    }\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (x, y, z) ∋ (x=x/z, y=y/z)\n    const toAffineMemo = (0, utils_js_1.memoized)((p, iz) => {\n        const { px: x, py: y, pz: z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(z, Fp.ONE))\n            return { x, y };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null)\n            iz = is0 ? Fp.ONE : Fp.inv(z);\n        const ax = Fp.mul(x, iz);\n        const ay = Fp.mul(y, iz);\n        const zz = Fp.mul(z, iz);\n        if (is0)\n            return { x: Fp.ZERO, y: Fp.ZERO };\n        if (!Fp.eql(zz, Fp.ONE))\n            throw new Error('invZ was invalid');\n        return { x: ax, y: ay };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = (0, utils_js_1.memoized)((p) => {\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is invalid representation of ZERO.\n            if (CURVE.allowInfinityPoint && !Fp.is0(p.py))\n                return;\n            throw new Error('bad point: ZERO');\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x, y } = p.toAffine();\n        // Check if x, y are valid field elements\n        if (!Fp.isValid(x) || !Fp.isValid(y))\n            throw new Error('bad point: x or y not FE');\n        const left = Fp.sqr(y); // y²\n        const right = weierstrassEquation(x); // x³ + ax + b\n        if (!Fp.eql(left, right))\n            throw new Error('bad point: equation left != right');\n        if (!p.isTorsionFree())\n            throw new Error('bad point: not in prime-order subgroup');\n        return true;\n    });\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n            Object.freeze(this);\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // Multiscalar Multiplication\n        static msm(points, scalars) {\n            return (0, curve_js_1.pippenger)(Point, Fn, points, scalars);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            wnaf.setWindowSize(this, windowSize);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, n, Point.normalizeZ);\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(sc) {\n            const { endo, n: N } = CURVE;\n            ut.aInRange('scalar', sc, _0n, N);\n            const I = Point.ZERO;\n            if (sc === _0n)\n                return I;\n            if (this.is0() || sc === _1n)\n                return this;\n            // Case a: no endomorphism. Case b: has precomputes.\n            if (!endo || wnaf.hasPrecomputes(this))\n                return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);\n            // Case c: endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            const { endo, n: N } = CURVE;\n            ut.aInRange('scalar', scalar, _1n, N);\n            let point, fake; // Fake point is used to const-time mult\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ∋ (x=x/z, y=y/z)\n        toAffine(iz) {\n            return toAffineMemo(this, iz);\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            (0, utils_js_1.abool)('isCompressed', isCompressed);\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            (0, utils_js_1.abool)('isCompressed', isCompressed);\n            return ut.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0, curve_js_1.validateBasic)(curve);\n    ut.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\n/**\n * Creates short weierstrass curve and ECDSA signature methods for it.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, b, p, n, Gx, Gy\n * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })\n */\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function modN(a) {\n        return (0, modular_js_1.mod)(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return (0, modular_js_1.invert)(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = ut.concatBytes;\n            (0, utils_js_1.abool)('isCompressed', isCompressed);\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = ut.bytesToNumberBE(tail);\n                if (!ut.inRange(x, _1n, Fp.ORDER))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n                }\n                catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n                    throw new Error('Point is not on curve' + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                const cl = compressedLen;\n                const ul = uncompressedLen;\n                throw new Error('invalid Point, expected length of ' + cl + ', or uncompressed ' + ul + ', got ' + len);\n            }\n        },\n    });\n    const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0, utils_js_1.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            ut.aInRange('r', this.r, _1n, CURVE_ORDER); // r in [1..N]\n            ut.aInRange('s', this.s, _1n, CURVE_ORDER); // s in [1..N]\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0, utils_js_1.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return ut.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return exports.DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return ut.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = (0, modular_js_1.getMinHashLength)(CURVE.n);\n            return (0, modular_js_1.mapHashToField)(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = ut.isBytes(item);\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // Our custom check \"just in case\"\n            if (bytes.length > 8192)\n                throw new Error('input is too large');\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = ut.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        ut.aInRange('num < 2^' + CURVE.nBitLength, num, _0n, ORDER_MASK);\n        // works with order, can have different size than numToField!\n        return ut.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,\n    // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);\n        validateSigVerOpts(opts);\n        if (prehash)\n            msgHash = (0, utils_js_1.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0, utils_js_1.ensureBytes)('extraEntropy', e)); // check for being bytes\n        }\n        const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G × k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1⋅G - U2⋅P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);\n        publicKey = (0, utils_js_1.ensureBytes)('publicKey', publicKey);\n        const { lowS, prehash, format } = opts;\n        // Verify opts, deduce signature format\n        validateSigVerOpts(opts);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        if (format !== undefined && format !== 'compact' && format !== 'der')\n            throw new Error('format must be compact or der');\n        const isHex = typeof sg === 'string' || ut.isBytes(sg);\n        const isObj = !isHex &&\n            !format &&\n            typeof sg === 'object' &&\n            sg !== null &&\n            typeof sg.r === 'bigint' &&\n            typeof sg.s === 'bigint';\n        if (!isHex && !isObj)\n            throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');\n        let _sig = undefined;\n        let P;\n        try {\n            if (isObj)\n                _sig = new Signature(sg.r, sg.s);\n            if (isHex) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    if (format !== 'compact')\n                        _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof exports.DER.Err))\n                        throw derError;\n                }\n                if (!_sig && format !== 'der')\n                    _sig = Signature.fromCompact(sg);\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            return false;\n        }\n        if (!_sig)\n            return false;\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    (0, modular_js_1.validateField)(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;\n/**\n * NIST secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\n *\n * Seems to be rigid (not backdoored)\n * [as per discussion](https://bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975).\n *\n * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n * [See explanation](https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066).\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst sha256_1 = require(\"@noble/hashes/sha256\");\nconst utils_1 = require(\"@noble/hashes/utils\");\nconst _shortw_utils_js_1 = require(\"./_shortw_utils.js\");\nconst hash_to_curve_js_1 = require(\"./abstract/hash-to-curve.js\");\nconst modular_js_1 = require(\"./abstract/modular.js\");\nconst utils_js_1 = require(\"./abstract/utils.js\");\nconst weierstrass_js_1 = require(\"./abstract/weierstrass.js\");\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = ((0, modular_js_1.pow2)(b3, _3n, P) * b3) % P;\n    const b9 = ((0, modular_js_1.pow2)(b6, _3n, P) * b3) % P;\n    const b11 = ((0, modular_js_1.pow2)(b9, _2n, P) * b2) % P;\n    const b22 = ((0, modular_js_1.pow2)(b11, _11n, P) * b11) % P;\n    const b44 = ((0, modular_js_1.pow2)(b22, _22n, P) * b22) % P;\n    const b88 = ((0, modular_js_1.pow2)(b44, _44n, P) * b44) % P;\n    const b176 = ((0, modular_js_1.pow2)(b88, _88n, P) * b88) % P;\n    const b220 = ((0, modular_js_1.pow2)(b176, _44n, P) * b44) % P;\n    const b223 = ((0, modular_js_1.pow2)(b220, _3n, P) * b3) % P;\n    const t1 = ((0, modular_js_1.pow2)(b223, _23n, P) * b22) % P;\n    const t2 = ((0, modular_js_1.pow2)(t1, _6n, P) * b2) % P;\n    const root = (0, modular_js_1.pow2)(t2, _2n, P);\n    if (!Fpk1.eql(Fpk1.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fpk1 = (0, modular_js_1.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\n/**\n * secp256k1 short weierstrass curve and ECDSA signatures over it.\n *\n * @example\n * import { secp256k1 } from '@noble/curves/secp256k1';\n *\n * const priv = secp256k1.utils.randomPrivateKey();\n * const pub = secp256k1.getPublicKey(priv);\n * const msg = new Uint8Array(32).fill(1); // message hash (not message) in ecdsa\n * const sig = secp256k1.sign(msg, priv); // `{prehash: true}` option is available\n * const isValid = secp256k1.verify(sig, msg, pub) === true;\n */\nexports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({\n    a: BigInt(0), // equation params: a, b\n    b: BigInt(7),\n    Fp: Fpk1, // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n\n    n: secp256k1N, // Curve order, total count of valid points in the field\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1), // Cofactor\n    lowS: true, // Allow only low-S signatures by default in sign() and verify()\n    endo: {\n        // Endomorphism, see above\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, sha256_1.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => (0, utils_js_1.numberToBytesBE)(n, 32);\nconst modP = (x) => (0, modular_js_1.mod)(x, secp256k1P);\nconst modN = (x) => (0, modular_js_1.mod)(x, secp256k1N);\nconst Point = exports.secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    (0, utils_js_1.aInRange)('x', x, _1n, secp256k1P); // Fail if x ≥ p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\nconst num = utils_js_1.bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN(num(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {\n    const m = (0, utils_js_1.ensureBytes)('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0, utils_js_1.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN(num(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = (0, utils_js_1.ensureBytes)('signature', signature, 64);\n    const m = (0, utils_js_1.ensureBytes)('message', message);\n    const pub = (0, utils_js_1.ensureBytes)('publicKey', publicKey, 32);\n    try {\n        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\n        if (!(0, utils_js_1.inRange)(r, _1n, secp256k1P))\n            return false;\n        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\n        if (!(0, utils_js_1.inRange)(s, _1n, secp256k1N))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\n    }\n    catch (error) {\n        return false;\n    }\n}\n/**\n * Schnorr signatures over secp256k1.\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n * @example\n * import { schnorr } from '@noble/curves/secp256k1';\n * const priv = schnorr.utils.randomPrivateKey();\n * const pub = schnorr.getPublicKey(priv);\n * const msg = new TextEncoder().encode('hello');\n * const sig = schnorr.sign(msg, priv);\n * const isValid = schnorr.verify(sig, msg, pub);\n */\nexports.schnorr = (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE: utils_js_1.numberToBytesBE,\n        bytesToNumberBE: utils_js_1.bytesToNumberBE,\n        taggedHash,\n        mod: modular_js_1.mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.isogenyMap)(Fpk1, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fpk1, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fpk1.create(BigInt('-11')),\n}))();\nconst htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fpk1.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha256_1.sha256,\n}))();\n/** secp256k1 hash-to-curve from [RFC 9380](https://www.rfc-editor.org/rfc/rfc9380). */\nexports.hashToCurve = (() => htf.hashToCurve)();\n/** secp256k1 encode-to-curve from [RFC 9380](https://www.rfc-editor.org/rfc/rfc9380). */\nexports.encodeToCurve = (() => htf.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map","\"use strict\";\n/**\n * Internal assertion helpers.\n * @module\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.anumber = anumber;\nexports.abytes = abytes;\nexports.ahash = ahash;\nexports.aexists = aexists;\nexports.aoutput = aoutput;\n/** Asserts something is positive integer. */\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n/** Is number an Uint8Array? Copied from utils for perf. */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n/** Asserts something is hash */\nfunction ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nfunction aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nfunction aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\n//# sourceMappingURL=_assert.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HashMD = void 0;\nexports.setBigUint64 = setBigUint64;\nexports.Chi = Chi;\nexports.Maj = Maj;\n/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nconst _assert_js_1 = require(\"./_assert.js\");\nconst utils_js_1 = require(\"./utils.js\");\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/** Choice: a ? b : c */\nfunction Chi(a, b, c) {\n    return (a & b) ^ (~a & c);\n}\n/** Majority function, true if any two inputs is true. */\nfunction Maj(a, b, c) {\n    return (a & b) ^ (a & c) ^ (b & c);\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nclass HashMD extends utils_js_1.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0, utils_js_1.createView)(this.buffer);\n    }\n    update(data) {\n        (0, _assert_js_1.aexists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0, utils_js_1.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0, utils_js_1.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0, _assert_js_1.aexists)(this);\n        (0, _assert_js_1.aoutput)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0, utils_js_1.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\nexports.HashMD = HashMD;\n//# sourceMappingURL=_md.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.crypto = void 0;\nexports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hmac = exports.HMAC = void 0;\n/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\nconst _assert_js_1 = require(\"./_assert.js\");\nconst utils_js_1 = require(\"./utils.js\");\nclass HMAC extends utils_js_1.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0, _assert_js_1.ahash)(hash);\n        const key = (0, utils_js_1.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0, _assert_js_1.aexists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0, _assert_js_1.aexists)(this);\n        (0, _assert_js_1.abytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\nexports.HMAC = HMAC;\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nexports.hmac = hmac;\nexports.hmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ripemd160 = exports.RIPEMD160 = void 0;\n/**\n * RIPEMD-160 legacy hash function.\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n * @module\n */\nconst _md_js_1 = require(\"./_md.js\");\nconst utils_js_1 = require(\"./utils.js\");\nconst Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);\nconst Id = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((_, i) => i));\nconst Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);\nlet idxL = [Id];\nlet idxR = [Pi];\nfor (let i = 0; i < 4; i++)\n    for (let j of [idxL, idxR])\n        j.push(j[i].map((k) => Rho[k]));\nconst shifts = /* @__PURE__ */ [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => new Uint8Array(i));\nconst shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst Kl = /* @__PURE__ */ new Uint32Array([\n    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr = /* @__PURE__ */ new Uint32Array([\n    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// It's called f() in spec.\nfunction f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    else if (group === 1)\n        return (x & y) | (~x & z);\n    else if (group === 2)\n        return (x | ~y) ^ z;\n    else if (group === 3)\n        return (x & z) | (y & ~z);\n    else\n        return x ^ (y | ~z);\n}\n// Temporary buffer, not used to store anything between runs\nconst R_BUF = /* @__PURE__ */ new Uint32Array(16);\nclass RIPEMD160 extends _md_js_1.HashMD {\n    constructor() {\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            R_BUF[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = ((0, utils_js_1.rotl)(al + f(group, bl, cl, dl) + R_BUF[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = (0, utils_js_1.rotl)(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = ((0, utils_js_1.rotl)(ar + f(rGroup, br, cr, dr) + R_BUF[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = (0, utils_js_1.rotl)(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        R_BUF.fill(0);\n    }\n    destroy() {\n        this.destroyed = true;\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\nexports.RIPEMD160 = RIPEMD160;\n/** RIPEMD-160 - a legacy hash function from 1990s. */\nexports.ripemd160 = (0, utils_js_1.wrapConstructor)(() => new RIPEMD160());\n//# sourceMappingURL=ripemd160.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sha1 = exports.SHA1 = void 0;\n/**\n * SHA1 (RFC 3174) legacy hash function.\n * @module\n */\nconst _md_js_1 = require(\"./_md.js\");\nconst utils_js_1 = require(\"./utils.js\");\n// Initial state\nconst SHA1_IV = /* @__PURE__ */ new Uint32Array([\n    0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA1_W = /* @__PURE__ */ new Uint32Array(80);\nclass SHA1 extends _md_js_1.HashMD {\n    constructor() {\n        super(64, 20, 8, false);\n        this.A = SHA1_IV[0] | 0;\n        this.B = SHA1_IV[1] | 0;\n        this.C = SHA1_IV[2] | 0;\n        this.D = SHA1_IV[3] | 0;\n        this.E = SHA1_IV[4] | 0;\n    }\n    get() {\n        const { A, B, C, D, E } = this;\n        return [A, B, C, D, E];\n    }\n    set(A, B, C, D, E) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA1_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 80; i++)\n            SHA1_W[i] = (0, utils_js_1.rotl)(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);\n        // Compression function main loop, 80 rounds\n        let { A, B, C, D, E } = this;\n        for (let i = 0; i < 80; i++) {\n            let F, K;\n            if (i < 20) {\n                F = (0, _md_js_1.Chi)(B, C, D);\n                K = 0x5a827999;\n            }\n            else if (i < 40) {\n                F = B ^ C ^ D;\n                K = 0x6ed9eba1;\n            }\n            else if (i < 60) {\n                F = (0, _md_js_1.Maj)(B, C, D);\n                K = 0x8f1bbcdc;\n            }\n            else {\n                F = B ^ C ^ D;\n                K = 0xca62c1d6;\n            }\n            const T = ((0, utils_js_1.rotl)(A, 5) + F + E + K + SHA1_W[i]) | 0;\n            E = D;\n            D = C;\n            C = (0, utils_js_1.rotl)(B, 30);\n            B = A;\n            A = T;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        this.set(A, B, C, D, E);\n    }\n    roundClean() {\n        SHA1_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\nexports.SHA1 = SHA1;\n/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */\nexports.sha1 = (0, utils_js_1.wrapConstructor)(() => new SHA1());\n//# sourceMappingURL=sha1.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sha224 = exports.sha256 = exports.SHA256 = void 0;\n/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nconst _md_js_1 = require(\"./_md.js\");\nconst utils_js_1 = require(\"./utils.js\");\n/** Round constants: first 32 bits of fractional parts of the cube roots of the first 64 primes 2..311). */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n/** Initial state: first 32 bits of fractional parts of the square roots of the first 8 primes 2..19. */\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n/**\n * Temporary buffer, not used to store anything between runs.\n * Named this way because it matches specification.\n */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_js_1.HashMD {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);\n            const T1 = (H + sigma1 + (0, _md_js_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);\n            const T2 = (sigma0 + (0, _md_js_1.Maj)(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\nexports.SHA256 = SHA256;\n/**\n * Constants taken from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf.\n */\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/** SHA2-256 hash function */\nexports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());\n/** SHA2-224 hash function */\nexports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map","\"use strict\";\n/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Hash = exports.nextTick = exports.byteSwapIfBE = exports.isLE = void 0;\nexports.isBytes = isBytes;\nexports.u8 = u8;\nexports.u32 = u32;\nexports.createView = createView;\nexports.rotr = rotr;\nexports.rotl = rotl;\nexports.byteSwap = byteSwap;\nexports.byteSwap32 = byteSwap32;\nexports.bytesToHex = bytesToHex;\nexports.hexToBytes = hexToBytes;\nexports.asyncLoop = asyncLoop;\nexports.utf8ToBytes = utf8ToBytes;\nexports.toBytes = toBytes;\nexports.concatBytes = concatBytes;\nexports.checkOpts = checkOpts;\nexports.wrapConstructor = wrapConstructor;\nexports.wrapConstructorWithOpts = wrapConstructorWithOpts;\nexports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;\nexports.randomBytes = randomBytes;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nconst crypto_1 = require(\"@noble/hashes/crypto\");\nconst _assert_js_1 = require(\"./_assert.js\");\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n// Cast array to different type\nfunction u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\nfunction u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n// Cast array to view\nfunction createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nfunction rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nfunction rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexports.isLE = (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n// The byte swap operation for uint32\nfunction byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nexports.byteSwapIfBE = exports.isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** In place byte swap for Uint32Array */\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    (0, _assert_js_1.abytes)(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nconst nextTick = async () => { };\nexports.nextTick = nextTick;\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\n/**\n * Convert JS string to byte array.\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('utf8ToBytes expected string, got ' + typeof str);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    (0, _assert_js_1.abytes)(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        (0, _assert_js_1.abytes)(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n/** For runtime check if class implements interface */\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.Hash = Hash;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** Wraps hash function, creating an interface on top of it */\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nfunction randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {\n        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === 'function') {\n        return crypto_1.crypto.randomBytes(bytesLength);\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","import bitcore from \"bitcore-lib\";\nexport function verifyMessage(publicKey, text, sig) {\n  var message = new bitcore.Message(text);\n  var signature = bitcore.crypto.Signature.fromCompact(Buffer.from(sig, \"base64\"));\n  var hash = message.magicHash();\n\n  // recover the public key\n  var ecdsa = new bitcore.crypto.ECDSA();\n  ecdsa.hashbuf = hash;\n  ecdsa.sig = signature;\n  var pubkeyInSig = ecdsa.toPublicKey();\n  var pubkeyInSigString = new bitcore.PublicKey(Object.assign({}, pubkeyInSig.toObject(), {\n    compressed: true\n  })).toString();\n  if (pubkeyInSigString != publicKey) {\n    return false;\n  }\n  return bitcore.crypto.ECDSA.verify(hash, signature, pubkeyInSig);\n}","export * from \"./utils\";","'use strict'\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n// @ts-ignore\nvar _Buffer = require('safe-buffer').Buffer\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }\n    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return _Buffer.alloc(0) }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (psz < source.length) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = _Buffer.allocUnsafe(zeroes + (size - it4))\n    vch.fill(0x00, 0, zeroes)\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n","'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.bech32m = exports.bech32 = void 0;\nconst ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\nconst ALPHABET_MAP = {};\nfor (let z = 0; z < ALPHABET.length; z++) {\n    const x = ALPHABET.charAt(z);\n    ALPHABET_MAP[x] = z;\n}\nfunction polymodStep(pre) {\n    const b = pre >> 25;\n    return (((pre & 0x1ffffff) << 5) ^\n        (-((b >> 0) & 1) & 0x3b6a57b2) ^\n        (-((b >> 1) & 1) & 0x26508e6d) ^\n        (-((b >> 2) & 1) & 0x1ea119fa) ^\n        (-((b >> 3) & 1) & 0x3d4233dd) ^\n        (-((b >> 4) & 1) & 0x2a1462b3));\n}\nfunction prefixChk(prefix) {\n    let chk = 1;\n    for (let i = 0; i < prefix.length; ++i) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            return 'Invalid prefix (' + prefix + ')';\n        chk = polymodStep(chk) ^ (c >> 5);\n    }\n    chk = polymodStep(chk);\n    for (let i = 0; i < prefix.length; ++i) {\n        const v = prefix.charCodeAt(i);\n        chk = polymodStep(chk) ^ (v & 0x1f);\n    }\n    return chk;\n}\nfunction convert(data, inBits, outBits, pad) {\n    let value = 0;\n    let bits = 0;\n    const maxV = (1 << outBits) - 1;\n    const result = [];\n    for (let i = 0; i < data.length; ++i) {\n        value = (value << inBits) | data[i];\n        bits += inBits;\n        while (bits >= outBits) {\n            bits -= outBits;\n            result.push((value >> bits) & maxV);\n        }\n    }\n    if (pad) {\n        if (bits > 0) {\n            result.push((value << (outBits - bits)) & maxV);\n        }\n    }\n    else {\n        if (bits >= inBits)\n            return 'Excess padding';\n        if ((value << (outBits - bits)) & maxV)\n            return 'Non-zero padding';\n    }\n    return result;\n}\nfunction toWords(bytes) {\n    return convert(bytes, 8, 5, true);\n}\nfunction fromWordsUnsafe(words) {\n    const res = convert(words, 5, 8, false);\n    if (Array.isArray(res))\n        return res;\n}\nfunction fromWords(words) {\n    const res = convert(words, 5, 8, false);\n    if (Array.isArray(res))\n        return res;\n    throw new Error(res);\n}\nfunction getLibraryFromEncoding(encoding) {\n    let ENCODING_CONST;\n    if (encoding === 'bech32') {\n        ENCODING_CONST = 1;\n    }\n    else {\n        ENCODING_CONST = 0x2bc830a3;\n    }\n    function encode(prefix, words, LIMIT) {\n        LIMIT = LIMIT || 90;\n        if (prefix.length + 7 + words.length > LIMIT)\n            throw new TypeError('Exceeds length limit');\n        prefix = prefix.toLowerCase();\n        // determine chk mod\n        let chk = prefixChk(prefix);\n        if (typeof chk === 'string')\n            throw new Error(chk);\n        let result = prefix + '1';\n        for (let i = 0; i < words.length; ++i) {\n            const x = words[i];\n            if (x >> 5 !== 0)\n                throw new Error('Non 5-bit word');\n            chk = polymodStep(chk) ^ x;\n            result += ALPHABET.charAt(x);\n        }\n        for (let i = 0; i < 6; ++i) {\n            chk = polymodStep(chk);\n        }\n        chk ^= ENCODING_CONST;\n        for (let i = 0; i < 6; ++i) {\n            const v = (chk >> ((5 - i) * 5)) & 0x1f;\n            result += ALPHABET.charAt(v);\n        }\n        return result;\n    }\n    function __decode(str, LIMIT) {\n        LIMIT = LIMIT || 90;\n        if (str.length < 8)\n            return str + ' too short';\n        if (str.length > LIMIT)\n            return 'Exceeds length limit';\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        const uppered = str.toUpperCase();\n        if (str !== lowered && str !== uppered)\n            return 'Mixed-case string ' + str;\n        str = lowered;\n        const split = str.lastIndexOf('1');\n        if (split === -1)\n            return 'No separator character for ' + str;\n        if (split === 0)\n            return 'Missing prefix for ' + str;\n        const prefix = str.slice(0, split);\n        const wordChars = str.slice(split + 1);\n        if (wordChars.length < 6)\n            return 'Data too short';\n        let chk = prefixChk(prefix);\n        if (typeof chk === 'string')\n            return chk;\n        const words = [];\n        for (let i = 0; i < wordChars.length; ++i) {\n            const c = wordChars.charAt(i);\n            const v = ALPHABET_MAP[c];\n            if (v === undefined)\n                return 'Unknown character ' + c;\n            chk = polymodStep(chk) ^ v;\n            // not in the checksum?\n            if (i + 6 >= wordChars.length)\n                continue;\n            words.push(v);\n        }\n        if (chk !== ENCODING_CONST)\n            return 'Invalid checksum for ' + str;\n        return { prefix, words };\n    }\n    function decodeUnsafe(str, LIMIT) {\n        const res = __decode(str, LIMIT);\n        if (typeof res === 'object')\n            return res;\n    }\n    function decode(str, LIMIT) {\n        const res = __decode(str, LIMIT);\n        if (typeof res === 'object')\n            return res;\n        throw new Error(res);\n    }\n    return {\n        decodeUnsafe,\n        decode,\n        encode,\n        toWords,\n        fromWordsUnsafe,\n        fromWords,\n    };\n}\nexports.bech32 = getLibraryFromEncoding('bech32');\nexports.bech32m = getLibraryFromEncoding('bech32m');\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst parser_1 = require('../parser');\nfunction combine(psbts) {\n  const self = psbts[0];\n  const selfKeyVals = parser_1.psbtToKeyVals(self);\n  const others = psbts.slice(1);\n  if (others.length === 0) throw new Error('Combine: Nothing to combine');\n  const selfTx = getTx(self);\n  if (selfTx === undefined) {\n    throw new Error('Combine: Self missing transaction');\n  }\n  const selfGlobalSet = getKeySet(selfKeyVals.globalKeyVals);\n  const selfInputSets = selfKeyVals.inputKeyVals.map(getKeySet);\n  const selfOutputSets = selfKeyVals.outputKeyVals.map(getKeySet);\n  for (const other of others) {\n    const otherTx = getTx(other);\n    if (\n      otherTx === undefined ||\n      !otherTx.toBuffer().equals(selfTx.toBuffer())\n    ) {\n      throw new Error(\n        'Combine: One of the Psbts does not have the same transaction.',\n      );\n    }\n    const otherKeyVals = parser_1.psbtToKeyVals(other);\n    const otherGlobalSet = getKeySet(otherKeyVals.globalKeyVals);\n    otherGlobalSet.forEach(\n      keyPusher(\n        selfGlobalSet,\n        selfKeyVals.globalKeyVals,\n        otherKeyVals.globalKeyVals,\n      ),\n    );\n    const otherInputSets = otherKeyVals.inputKeyVals.map(getKeySet);\n    otherInputSets.forEach((inputSet, idx) =>\n      inputSet.forEach(\n        keyPusher(\n          selfInputSets[idx],\n          selfKeyVals.inputKeyVals[idx],\n          otherKeyVals.inputKeyVals[idx],\n        ),\n      ),\n    );\n    const otherOutputSets = otherKeyVals.outputKeyVals.map(getKeySet);\n    otherOutputSets.forEach((outputSet, idx) =>\n      outputSet.forEach(\n        keyPusher(\n          selfOutputSets[idx],\n          selfKeyVals.outputKeyVals[idx],\n          otherKeyVals.outputKeyVals[idx],\n        ),\n      ),\n    );\n  }\n  return parser_1.psbtFromKeyVals(selfTx, {\n    globalMapKeyVals: selfKeyVals.globalKeyVals,\n    inputKeyVals: selfKeyVals.inputKeyVals,\n    outputKeyVals: selfKeyVals.outputKeyVals,\n  });\n}\nexports.combine = combine;\nfunction keyPusher(selfSet, selfKeyVals, otherKeyVals) {\n  return key => {\n    if (selfSet.has(key)) return;\n    const newKv = otherKeyVals.filter(kv => kv.key.toString('hex') === key)[0];\n    selfKeyVals.push(newKv);\n    selfSet.add(key);\n  };\n}\nfunction getTx(psbt) {\n  return psbt.globalMap.unsignedTx;\n}\nfunction getKeySet(keyVals) {\n  const set = new Set();\n  keyVals.forEach(keyVal => {\n    const hex = keyVal.key.toString('hex');\n    if (set.has(hex))\n      throw new Error('Combine: KeyValue Map keys should be unique');\n    set.add(hex);\n  });\n  return set;\n}\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nconst range = n => [...Array(n).keys()];\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.GlobalTypes.GLOBAL_XPUB) {\n    throw new Error(\n      'Decode Error: could not decode globalXpub with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if (keyVal.key.length !== 79 || ![2, 3].includes(keyVal.key[46])) {\n    throw new Error(\n      'Decode Error: globalXpub has invalid extended pubkey in key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if ((keyVal.value.length / 4) % 1 !== 0) {\n    throw new Error(\n      'Decode Error: Global GLOBAL_XPUB value length should be multiple of 4',\n    );\n  }\n  const extendedPubkey = keyVal.key.slice(1);\n  const data = {\n    masterFingerprint: keyVal.value.slice(0, 4),\n    extendedPubkey,\n    path: 'm',\n  };\n  for (const i of range(keyVal.value.length / 4 - 1)) {\n    const val = keyVal.value.readUInt32LE(i * 4 + 4);\n    const isHard = !!(val & 0x80000000);\n    const idx = val & 0x7fffffff;\n    data.path += '/' + idx.toString(10) + (isHard ? \"'\" : '');\n  }\n  return data;\n}\nexports.decode = decode;\nfunction encode(data) {\n  const head = Buffer.from([typeFields_1.GlobalTypes.GLOBAL_XPUB]);\n  const key = Buffer.concat([head, data.extendedPubkey]);\n  const splitPath = data.path.split('/');\n  const value = Buffer.allocUnsafe(splitPath.length * 4);\n  data.masterFingerprint.copy(value, 0);\n  let offset = 4;\n  splitPath.slice(1).forEach(level => {\n    const isHard = level.slice(-1) === \"'\";\n    let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);\n    if (isHard) num += 0x80000000;\n    value.writeUInt32LE(num, offset);\n    offset += 4;\n  });\n  return {\n    key,\n    value,\n  };\n}\nexports.encode = encode;\nexports.expected =\n  '{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }';\nfunction check(data) {\n  const epk = data.extendedPubkey;\n  const mfp = data.masterFingerprint;\n  const p = data.path;\n  return (\n    Buffer.isBuffer(epk) &&\n    epk.length === 78 &&\n    [2, 3].indexOf(epk[45]) > -1 &&\n    Buffer.isBuffer(mfp) &&\n    mfp.length === 4 &&\n    typeof p === 'string' &&\n    !!p.match(/^m(\\/\\d+'?)*$/)\n  );\n}\nexports.check = check;\nfunction canAddToArray(array, item, dupeSet) {\n  const dupeString = item.extendedPubkey.toString('hex');\n  if (dupeSet.has(dupeString)) return false;\n  dupeSet.add(dupeString);\n  return (\n    array.filter(v => v.extendedPubkey.equals(item.extendedPubkey)).length === 0\n  );\n}\nexports.canAddToArray = canAddToArray;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction encode(data) {\n  return {\n    key: Buffer.from([typeFields_1.GlobalTypes.UNSIGNED_TX]),\n    value: data.toBuffer(),\n  };\n}\nexports.encode = encode;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../typeFields');\nconst globalXpub = require('./global/globalXpub');\nconst unsignedTx = require('./global/unsignedTx');\nconst finalScriptSig = require('./input/finalScriptSig');\nconst finalScriptWitness = require('./input/finalScriptWitness');\nconst nonWitnessUtxo = require('./input/nonWitnessUtxo');\nconst partialSig = require('./input/partialSig');\nconst porCommitment = require('./input/porCommitment');\nconst sighashType = require('./input/sighashType');\nconst tapKeySig = require('./input/tapKeySig');\nconst tapLeafScript = require('./input/tapLeafScript');\nconst tapMerkleRoot = require('./input/tapMerkleRoot');\nconst tapScriptSig = require('./input/tapScriptSig');\nconst witnessUtxo = require('./input/witnessUtxo');\nconst tapTree = require('./output/tapTree');\nconst bip32Derivation = require('./shared/bip32Derivation');\nconst checkPubkey = require('./shared/checkPubkey');\nconst redeemScript = require('./shared/redeemScript');\nconst tapBip32Derivation = require('./shared/tapBip32Derivation');\nconst tapInternalKey = require('./shared/tapInternalKey');\nconst witnessScript = require('./shared/witnessScript');\nconst globals = {\n  unsignedTx,\n  globalXpub,\n  // pass an Array of key bytes that require pubkey beside the key\n  checkPubkey: checkPubkey.makeChecker([]),\n};\nexports.globals = globals;\nconst inputs = {\n  nonWitnessUtxo,\n  partialSig,\n  sighashType,\n  finalScriptSig,\n  finalScriptWitness,\n  porCommitment,\n  witnessUtxo,\n  bip32Derivation: bip32Derivation.makeConverter(\n    typeFields_1.InputTypes.BIP32_DERIVATION,\n  ),\n  redeemScript: redeemScript.makeConverter(\n    typeFields_1.InputTypes.REDEEM_SCRIPT,\n  ),\n  witnessScript: witnessScript.makeConverter(\n    typeFields_1.InputTypes.WITNESS_SCRIPT,\n  ),\n  checkPubkey: checkPubkey.makeChecker([\n    typeFields_1.InputTypes.PARTIAL_SIG,\n    typeFields_1.InputTypes.BIP32_DERIVATION,\n  ]),\n  tapKeySig,\n  tapScriptSig,\n  tapLeafScript,\n  tapBip32Derivation: tapBip32Derivation.makeConverter(\n    typeFields_1.InputTypes.TAP_BIP32_DERIVATION,\n  ),\n  tapInternalKey: tapInternalKey.makeConverter(\n    typeFields_1.InputTypes.TAP_INTERNAL_KEY,\n  ),\n  tapMerkleRoot,\n};\nexports.inputs = inputs;\nconst outputs = {\n  bip32Derivation: bip32Derivation.makeConverter(\n    typeFields_1.OutputTypes.BIP32_DERIVATION,\n  ),\n  redeemScript: redeemScript.makeConverter(\n    typeFields_1.OutputTypes.REDEEM_SCRIPT,\n  ),\n  witnessScript: witnessScript.makeConverter(\n    typeFields_1.OutputTypes.WITNESS_SCRIPT,\n  ),\n  checkPubkey: checkPubkey.makeChecker([\n    typeFields_1.OutputTypes.BIP32_DERIVATION,\n  ]),\n  tapBip32Derivation: tapBip32Derivation.makeConverter(\n    typeFields_1.OutputTypes.TAP_BIP32_DERIVATION,\n  ),\n  tapTree,\n  tapInternalKey: tapInternalKey.makeConverter(\n    typeFields_1.OutputTypes.TAP_INTERNAL_KEY,\n  ),\n};\nexports.outputs = outputs;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTSIG) {\n    throw new Error(\n      'Decode Error: could not decode finalScriptSig with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  return keyVal.value;\n}\nexports.decode = decode;\nfunction encode(data) {\n  const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTSIG]);\n  return {\n    key,\n    value: data,\n  };\n}\nexports.encode = encode;\nexports.expected = 'Buffer';\nfunction check(data) {\n  return Buffer.isBuffer(data);\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.finalScriptSig === undefined;\n}\nexports.canAdd = canAdd;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTWITNESS) {\n    throw new Error(\n      'Decode Error: could not decode finalScriptWitness with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  return keyVal.value;\n}\nexports.decode = decode;\nfunction encode(data) {\n  const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTWITNESS]);\n  return {\n    key,\n    value: data,\n  };\n}\nexports.encode = encode;\nexports.expected = 'Buffer';\nfunction check(data) {\n  return Buffer.isBuffer(data);\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return (\n    !!currentData && !!newData && currentData.finalScriptWitness === undefined\n  );\n}\nexports.canAdd = canAdd;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.NON_WITNESS_UTXO) {\n    throw new Error(\n      'Decode Error: could not decode nonWitnessUtxo with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  return keyVal.value;\n}\nexports.decode = decode;\nfunction encode(data) {\n  return {\n    key: Buffer.from([typeFields_1.InputTypes.NON_WITNESS_UTXO]),\n    value: data,\n  };\n}\nexports.encode = encode;\nexports.expected = 'Buffer';\nfunction check(data) {\n  return Buffer.isBuffer(data);\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.nonWitnessUtxo === undefined;\n}\nexports.canAdd = canAdd;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.PARTIAL_SIG) {\n    throw new Error(\n      'Decode Error: could not decode partialSig with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if (\n    !(keyVal.key.length === 34 || keyVal.key.length === 66) ||\n    ![2, 3, 4].includes(keyVal.key[1])\n  ) {\n    throw new Error(\n      'Decode Error: partialSig has invalid pubkey in key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  const pubkey = keyVal.key.slice(1);\n  return {\n    pubkey,\n    signature: keyVal.value,\n  };\n}\nexports.decode = decode;\nfunction encode(pSig) {\n  const head = Buffer.from([typeFields_1.InputTypes.PARTIAL_SIG]);\n  return {\n    key: Buffer.concat([head, pSig.pubkey]),\n    value: pSig.signature,\n  };\n}\nexports.encode = encode;\nexports.expected = '{ pubkey: Buffer; signature: Buffer; }';\nfunction check(data) {\n  return (\n    Buffer.isBuffer(data.pubkey) &&\n    Buffer.isBuffer(data.signature) &&\n    [33, 65].includes(data.pubkey.length) &&\n    [2, 3, 4].includes(data.pubkey[0]) &&\n    isDerSigWithSighash(data.signature)\n  );\n}\nexports.check = check;\nfunction isDerSigWithSighash(buf) {\n  if (!Buffer.isBuffer(buf) || buf.length < 9) return false;\n  if (buf[0] !== 0x30) return false;\n  if (buf.length !== buf[1] + 3) return false;\n  if (buf[2] !== 0x02) return false;\n  const rLen = buf[3];\n  if (rLen > 33 || rLen < 1) return false;\n  if (buf[3 + rLen + 1] !== 0x02) return false;\n  const sLen = buf[3 + rLen + 2];\n  if (sLen > 33 || sLen < 1) return false;\n  if (buf.length !== 3 + rLen + 2 + sLen + 2) return false;\n  return true;\n}\nfunction canAddToArray(array, item, dupeSet) {\n  const dupeString = item.pubkey.toString('hex');\n  if (dupeSet.has(dupeString)) return false;\n  dupeSet.add(dupeString);\n  return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;\n}\nexports.canAddToArray = canAddToArray;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.POR_COMMITMENT) {\n    throw new Error(\n      'Decode Error: could not decode porCommitment with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  return keyVal.value.toString('utf8');\n}\nexports.decode = decode;\nfunction encode(data) {\n  const key = Buffer.from([typeFields_1.InputTypes.POR_COMMITMENT]);\n  return {\n    key,\n    value: Buffer.from(data, 'utf8'),\n  };\n}\nexports.encode = encode;\nexports.expected = 'string';\nfunction check(data) {\n  return typeof data === 'string';\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.porCommitment === undefined;\n}\nexports.canAdd = canAdd;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.SIGHASH_TYPE) {\n    throw new Error(\n      'Decode Error: could not decode sighashType with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  return keyVal.value.readUInt32LE(0);\n}\nexports.decode = decode;\nfunction encode(data) {\n  const key = Buffer.from([typeFields_1.InputTypes.SIGHASH_TYPE]);\n  const value = Buffer.allocUnsafe(4);\n  value.writeUInt32LE(data, 0);\n  return {\n    key,\n    value,\n  };\n}\nexports.encode = encode;\nexports.expected = 'number';\nfunction check(data) {\n  return typeof data === 'number';\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.sighashType === undefined;\n}\nexports.canAdd = canAdd;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (\n    keyVal.key[0] !== typeFields_1.InputTypes.TAP_KEY_SIG ||\n    keyVal.key.length !== 1\n  ) {\n    throw new Error(\n      'Decode Error: could not decode tapKeySig with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if (!check(keyVal.value)) {\n    throw new Error(\n      'Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature',\n    );\n  }\n  return keyVal.value;\n}\nexports.decode = decode;\nfunction encode(value) {\n  const key = Buffer.from([typeFields_1.InputTypes.TAP_KEY_SIG]);\n  return { key, value };\n}\nexports.encode = encode;\nexports.expected = 'Buffer';\nfunction check(data) {\n  return Buffer.isBuffer(data) && (data.length === 64 || data.length === 65);\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.tapKeySig === undefined;\n}\nexports.canAdd = canAdd;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_LEAF_SCRIPT) {\n    throw new Error(\n      'Decode Error: could not decode tapLeafScript with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if ((keyVal.key.length - 2) % 32 !== 0) {\n    throw new Error(\n      'Decode Error: tapLeafScript has invalid control block in key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  const leafVersion = keyVal.value[keyVal.value.length - 1];\n  if ((keyVal.key[1] & 0xfe) !== leafVersion) {\n    throw new Error(\n      'Decode Error: tapLeafScript bad leaf version in key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  const script = keyVal.value.slice(0, -1);\n  const controlBlock = keyVal.key.slice(1);\n  return { controlBlock, script, leafVersion };\n}\nexports.decode = decode;\nfunction encode(tScript) {\n  const head = Buffer.from([typeFields_1.InputTypes.TAP_LEAF_SCRIPT]);\n  const verBuf = Buffer.from([tScript.leafVersion]);\n  return {\n    key: Buffer.concat([head, tScript.controlBlock]),\n    value: Buffer.concat([tScript.script, verBuf]),\n  };\n}\nexports.encode = encode;\nexports.expected =\n  '{ controlBlock: Buffer; leafVersion: number, script: Buffer; }';\nfunction check(data) {\n  return (\n    Buffer.isBuffer(data.controlBlock) &&\n    (data.controlBlock.length - 1) % 32 === 0 &&\n    (data.controlBlock[0] & 0xfe) === data.leafVersion &&\n    Buffer.isBuffer(data.script)\n  );\n}\nexports.check = check;\nfunction canAddToArray(array, item, dupeSet) {\n  const dupeString = item.controlBlock.toString('hex');\n  if (dupeSet.has(dupeString)) return false;\n  dupeSet.add(dupeString);\n  return (\n    array.filter(v => v.controlBlock.equals(item.controlBlock)).length === 0\n  );\n}\nexports.canAddToArray = canAddToArray;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (\n    keyVal.key[0] !== typeFields_1.InputTypes.TAP_MERKLE_ROOT ||\n    keyVal.key.length !== 1\n  ) {\n    throw new Error(\n      'Decode Error: could not decode tapMerkleRoot with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if (!check(keyVal.value)) {\n    throw new Error('Decode Error: tapMerkleRoot not a 32-byte hash');\n  }\n  return keyVal.value;\n}\nexports.decode = decode;\nfunction encode(value) {\n  const key = Buffer.from([typeFields_1.InputTypes.TAP_MERKLE_ROOT]);\n  return { key, value };\n}\nexports.encode = encode;\nexports.expected = 'Buffer';\nfunction check(data) {\n  return Buffer.isBuffer(data) && data.length === 32;\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.tapMerkleRoot === undefined;\n}\nexports.canAdd = canAdd;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_SCRIPT_SIG) {\n    throw new Error(\n      'Decode Error: could not decode tapScriptSig with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if (keyVal.key.length !== 65) {\n    throw new Error(\n      'Decode Error: tapScriptSig has invalid key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if (keyVal.value.length !== 64 && keyVal.value.length !== 65) {\n    throw new Error(\n      'Decode Error: tapScriptSig has invalid signature in key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  const pubkey = keyVal.key.slice(1, 33);\n  const leafHash = keyVal.key.slice(33);\n  return {\n    pubkey,\n    leafHash,\n    signature: keyVal.value,\n  };\n}\nexports.decode = decode;\nfunction encode(tSig) {\n  const head = Buffer.from([typeFields_1.InputTypes.TAP_SCRIPT_SIG]);\n  return {\n    key: Buffer.concat([head, tSig.pubkey, tSig.leafHash]),\n    value: tSig.signature,\n  };\n}\nexports.encode = encode;\nexports.expected = '{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }';\nfunction check(data) {\n  return (\n    Buffer.isBuffer(data.pubkey) &&\n    Buffer.isBuffer(data.leafHash) &&\n    Buffer.isBuffer(data.signature) &&\n    data.pubkey.length === 32 &&\n    data.leafHash.length === 32 &&\n    (data.signature.length === 64 || data.signature.length === 65)\n  );\n}\nexports.check = check;\nfunction canAddToArray(array, item, dupeSet) {\n  const dupeString =\n    item.pubkey.toString('hex') + item.leafHash.toString('hex');\n  if (dupeSet.has(dupeString)) return false;\n  dupeSet.add(dupeString);\n  return (\n    array.filter(\n      v => v.pubkey.equals(item.pubkey) && v.leafHash.equals(item.leafHash),\n    ).length === 0\n  );\n}\nexports.canAddToArray = canAddToArray;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nconst tools_1 = require('../tools');\nconst varuint = require('../varint');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.WITNESS_UTXO) {\n    throw new Error(\n      'Decode Error: could not decode witnessUtxo with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  const value = tools_1.readUInt64LE(keyVal.value, 0);\n  let _offset = 8;\n  const scriptLen = varuint.decode(keyVal.value, _offset);\n  _offset += varuint.encodingLength(scriptLen);\n  const script = keyVal.value.slice(_offset);\n  if (script.length !== scriptLen) {\n    throw new Error('Decode Error: WITNESS_UTXO script is not proper length');\n  }\n  return {\n    script,\n    value,\n  };\n}\nexports.decode = decode;\nfunction encode(data) {\n  const { script, value } = data;\n  const varintLen = varuint.encodingLength(script.length);\n  const result = Buffer.allocUnsafe(8 + varintLen + script.length);\n  tools_1.writeUInt64LE(result, value, 0);\n  varuint.encode(script.length, result, 8);\n  script.copy(result, 8 + varintLen);\n  return {\n    key: Buffer.from([typeFields_1.InputTypes.WITNESS_UTXO]),\n    value: result,\n  };\n}\nexports.encode = encode;\nexports.expected = '{ script: Buffer; value: number; }';\nfunction check(data) {\n  return Buffer.isBuffer(data.script) && typeof data.value === 'number';\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.witnessUtxo === undefined;\n}\nexports.canAdd = canAdd;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nconst varuint = require('../varint');\nfunction decode(keyVal) {\n  if (\n    keyVal.key[0] !== typeFields_1.OutputTypes.TAP_TREE ||\n    keyVal.key.length !== 1\n  ) {\n    throw new Error(\n      'Decode Error: could not decode tapTree with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  let _offset = 0;\n  const data = [];\n  while (_offset < keyVal.value.length) {\n    const depth = keyVal.value[_offset++];\n    const leafVersion = keyVal.value[_offset++];\n    const scriptLen = varuint.decode(keyVal.value, _offset);\n    _offset += varuint.encodingLength(scriptLen);\n    data.push({\n      depth,\n      leafVersion,\n      script: keyVal.value.slice(_offset, _offset + scriptLen),\n    });\n    _offset += scriptLen;\n  }\n  return { leaves: data };\n}\nexports.decode = decode;\nfunction encode(tree) {\n  const key = Buffer.from([typeFields_1.OutputTypes.TAP_TREE]);\n  const bufs = [].concat(\n    ...tree.leaves.map(tapLeaf => [\n      Buffer.of(tapLeaf.depth, tapLeaf.leafVersion),\n      varuint.encode(tapLeaf.script.length),\n      tapLeaf.script,\n    ]),\n  );\n  return {\n    key,\n    value: Buffer.concat(bufs),\n  };\n}\nexports.encode = encode;\nexports.expected =\n  '{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }';\nfunction check(data) {\n  return (\n    Array.isArray(data.leaves) &&\n    data.leaves.every(\n      tapLeaf =>\n        tapLeaf.depth >= 0 &&\n        tapLeaf.depth <= 128 &&\n        (tapLeaf.leafVersion & 0xfe) === tapLeaf.leafVersion &&\n        Buffer.isBuffer(tapLeaf.script),\n    )\n  );\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.tapTree === undefined;\n}\nexports.canAdd = canAdd;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst range = n => [...Array(n).keys()];\nconst isValidDERKey = pubkey =>\n  (pubkey.length === 33 && [2, 3].includes(pubkey[0])) ||\n  (pubkey.length === 65 && 4 === pubkey[0]);\nfunction makeConverter(TYPE_BYTE, isValidPubkey = isValidDERKey) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE) {\n      throw new Error(\n        'Decode Error: could not decode bip32Derivation with key 0x' +\n          keyVal.key.toString('hex'),\n      );\n    }\n    const pubkey = keyVal.key.slice(1);\n    if (!isValidPubkey(pubkey)) {\n      throw new Error(\n        'Decode Error: bip32Derivation has invalid pubkey in key 0x' +\n          keyVal.key.toString('hex'),\n      );\n    }\n    if ((keyVal.value.length / 4) % 1 !== 0) {\n      throw new Error(\n        'Decode Error: Input BIP32_DERIVATION value length should be multiple of 4',\n      );\n    }\n    const data = {\n      masterFingerprint: keyVal.value.slice(0, 4),\n      pubkey,\n      path: 'm',\n    };\n    for (const i of range(keyVal.value.length / 4 - 1)) {\n      const val = keyVal.value.readUInt32LE(i * 4 + 4);\n      const isHard = !!(val & 0x80000000);\n      const idx = val & 0x7fffffff;\n      data.path += '/' + idx.toString(10) + (isHard ? \"'\" : '');\n    }\n    return data;\n  }\n  function encode(data) {\n    const head = Buffer.from([TYPE_BYTE]);\n    const key = Buffer.concat([head, data.pubkey]);\n    const splitPath = data.path.split('/');\n    const value = Buffer.allocUnsafe(splitPath.length * 4);\n    data.masterFingerprint.copy(value, 0);\n    let offset = 4;\n    splitPath.slice(1).forEach(level => {\n      const isHard = level.slice(-1) === \"'\";\n      let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);\n      if (isHard) num += 0x80000000;\n      value.writeUInt32LE(num, offset);\n      offset += 4;\n    });\n    return {\n      key,\n      value,\n    };\n  }\n  const expected =\n    '{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }';\n  function check(data) {\n    return (\n      Buffer.isBuffer(data.pubkey) &&\n      Buffer.isBuffer(data.masterFingerprint) &&\n      typeof data.path === 'string' &&\n      isValidPubkey(data.pubkey) &&\n      data.masterFingerprint.length === 4\n    );\n  }\n  function canAddToArray(array, item, dupeSet) {\n    const dupeString = item.pubkey.toString('hex');\n    if (dupeSet.has(dupeString)) return false;\n    dupeSet.add(dupeString);\n    return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAddToArray,\n  };\n}\nexports.makeConverter = makeConverter;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nfunction makeChecker(pubkeyTypes) {\n  return checkPubkey;\n  function checkPubkey(keyVal) {\n    let pubkey;\n    if (pubkeyTypes.includes(keyVal.key[0])) {\n      pubkey = keyVal.key.slice(1);\n      if (\n        !(pubkey.length === 33 || pubkey.length === 65) ||\n        ![2, 3, 4].includes(pubkey[0])\n      ) {\n        throw new Error(\n          'Format Error: invalid pubkey in key 0x' + keyVal.key.toString('hex'),\n        );\n      }\n    }\n    return pubkey;\n  }\n}\nexports.makeChecker = makeChecker;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nfunction makeConverter(TYPE_BYTE) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE) {\n      throw new Error(\n        'Decode Error: could not decode redeemScript with key 0x' +\n          keyVal.key.toString('hex'),\n      );\n    }\n    return keyVal.value;\n  }\n  function encode(data) {\n    const key = Buffer.from([TYPE_BYTE]);\n    return {\n      key,\n      value: data,\n    };\n  }\n  const expected = 'Buffer';\n  function check(data) {\n    return Buffer.isBuffer(data);\n  }\n  function canAdd(currentData, newData) {\n    return !!currentData && !!newData && currentData.redeemScript === undefined;\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAdd,\n  };\n}\nexports.makeConverter = makeConverter;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst varuint = require('../varint');\nconst bip32Derivation = require('./bip32Derivation');\nconst isValidBIP340Key = pubkey => pubkey.length === 32;\nfunction makeConverter(TYPE_BYTE) {\n  const parent = bip32Derivation.makeConverter(TYPE_BYTE, isValidBIP340Key);\n  function decode(keyVal) {\n    const nHashes = varuint.decode(keyVal.value);\n    const nHashesLen = varuint.encodingLength(nHashes);\n    const base = parent.decode({\n      key: keyVal.key,\n      value: keyVal.value.slice(nHashesLen + nHashes * 32),\n    });\n    const leafHashes = new Array(nHashes);\n    for (let i = 0, _offset = nHashesLen; i < nHashes; i++, _offset += 32) {\n      leafHashes[i] = keyVal.value.slice(_offset, _offset + 32);\n    }\n    return Object.assign({}, base, { leafHashes });\n  }\n  function encode(data) {\n    const base = parent.encode(data);\n    const nHashesLen = varuint.encodingLength(data.leafHashes.length);\n    const nHashesBuf = Buffer.allocUnsafe(nHashesLen);\n    varuint.encode(data.leafHashes.length, nHashesBuf);\n    const value = Buffer.concat([nHashesBuf, ...data.leafHashes, base.value]);\n    return Object.assign({}, base, { value });\n  }\n  const expected =\n    '{ ' +\n    'masterFingerprint: Buffer; ' +\n    'pubkey: Buffer; ' +\n    'path: string; ' +\n    'leafHashes: Buffer[]; ' +\n    '}';\n  function check(data) {\n    return (\n      Array.isArray(data.leafHashes) &&\n      data.leafHashes.every(\n        leafHash => Buffer.isBuffer(leafHash) && leafHash.length === 32,\n      ) &&\n      parent.check(data)\n    );\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAddToArray: parent.canAddToArray,\n  };\n}\nexports.makeConverter = makeConverter;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nfunction makeConverter(TYPE_BYTE) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE || keyVal.key.length !== 1) {\n      throw new Error(\n        'Decode Error: could not decode tapInternalKey with key 0x' +\n          keyVal.key.toString('hex'),\n      );\n    }\n    if (keyVal.value.length !== 32) {\n      throw new Error(\n        'Decode Error: tapInternalKey not a 32-byte x-only pubkey',\n      );\n    }\n    return keyVal.value;\n  }\n  function encode(value) {\n    const key = Buffer.from([TYPE_BYTE]);\n    return { key, value };\n  }\n  const expected = 'Buffer';\n  function check(data) {\n    return Buffer.isBuffer(data) && data.length === 32;\n  }\n  function canAdd(currentData, newData) {\n    return (\n      !!currentData && !!newData && currentData.tapInternalKey === undefined\n    );\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAdd,\n  };\n}\nexports.makeConverter = makeConverter;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nfunction makeConverter(TYPE_BYTE) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE) {\n      throw new Error(\n        'Decode Error: could not decode witnessScript with key 0x' +\n          keyVal.key.toString('hex'),\n      );\n    }\n    return keyVal.value;\n  }\n  function encode(data) {\n    const key = Buffer.from([TYPE_BYTE]);\n    return {\n      key,\n      value: data,\n    };\n  }\n  const expected = 'Buffer';\n  function check(data) {\n    return Buffer.isBuffer(data);\n  }\n  function canAdd(currentData, newData) {\n    return (\n      !!currentData && !!newData && currentData.witnessScript === undefined\n    );\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAdd,\n  };\n}\nexports.makeConverter = makeConverter;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst varuint = require('./varint');\nexports.range = n => [...Array(n).keys()];\nfunction reverseBuffer(buffer) {\n  if (buffer.length < 1) return buffer;\n  let j = buffer.length - 1;\n  let tmp = 0;\n  for (let i = 0; i < buffer.length / 2; i++) {\n    tmp = buffer[i];\n    buffer[i] = buffer[j];\n    buffer[j] = tmp;\n    j--;\n  }\n  return buffer;\n}\nexports.reverseBuffer = reverseBuffer;\nfunction keyValsToBuffer(keyVals) {\n  const buffers = keyVals.map(keyValToBuffer);\n  buffers.push(Buffer.from([0]));\n  return Buffer.concat(buffers);\n}\nexports.keyValsToBuffer = keyValsToBuffer;\nfunction keyValToBuffer(keyVal) {\n  const keyLen = keyVal.key.length;\n  const valLen = keyVal.value.length;\n  const keyVarIntLen = varuint.encodingLength(keyLen);\n  const valVarIntLen = varuint.encodingLength(valLen);\n  const buffer = Buffer.allocUnsafe(\n    keyVarIntLen + keyLen + valVarIntLen + valLen,\n  );\n  varuint.encode(keyLen, buffer, 0);\n  keyVal.key.copy(buffer, keyVarIntLen);\n  varuint.encode(valLen, buffer, keyVarIntLen + keyLen);\n  keyVal.value.copy(buffer, keyVarIntLen + keyLen + valVarIntLen);\n  return buffer;\n}\nexports.keyValToBuffer = keyValToBuffer;\n// https://github.com/feross/buffer/blob/master/index.js#L1127\nfunction verifuint(value, max) {\n  if (typeof value !== 'number')\n    throw new Error('cannot write a non-number as a number');\n  if (value < 0)\n    throw new Error('specified a negative value for writing an unsigned value');\n  if (value > max) throw new Error('RangeError: value out of range');\n  if (Math.floor(value) !== value)\n    throw new Error('value has a fractional component');\n}\nfunction readUInt64LE(buffer, offset) {\n  const a = buffer.readUInt32LE(offset);\n  let b = buffer.readUInt32LE(offset + 4);\n  b *= 0x100000000;\n  verifuint(b + a, 0x001fffffffffffff);\n  return b + a;\n}\nexports.readUInt64LE = readUInt64LE;\nfunction writeUInt64LE(buffer, value, offset) {\n  verifuint(value, 0x001fffffffffffff);\n  buffer.writeInt32LE(value & -1, offset);\n  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);\n  return offset + 8;\n}\nexports.writeUInt64LE = writeUInt64LE;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\n// Number.MAX_SAFE_INTEGER\nconst MAX_SAFE_INTEGER = 9007199254740991;\nfunction checkUInt53(n) {\n  if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0)\n    throw new RangeError('value out of range');\n}\nfunction encode(_number, buffer, offset) {\n  checkUInt53(_number);\n  if (!buffer) buffer = Buffer.allocUnsafe(encodingLength(_number));\n  if (!Buffer.isBuffer(buffer))\n    throw new TypeError('buffer must be a Buffer instance');\n  if (!offset) offset = 0;\n  // 8 bit\n  if (_number < 0xfd) {\n    buffer.writeUInt8(_number, offset);\n    Object.assign(encode, { bytes: 1 });\n    // 16 bit\n  } else if (_number <= 0xffff) {\n    buffer.writeUInt8(0xfd, offset);\n    buffer.writeUInt16LE(_number, offset + 1);\n    Object.assign(encode, { bytes: 3 });\n    // 32 bit\n  } else if (_number <= 0xffffffff) {\n    buffer.writeUInt8(0xfe, offset);\n    buffer.writeUInt32LE(_number, offset + 1);\n    Object.assign(encode, { bytes: 5 });\n    // 64 bit\n  } else {\n    buffer.writeUInt8(0xff, offset);\n    buffer.writeUInt32LE(_number >>> 0, offset + 1);\n    buffer.writeUInt32LE((_number / 0x100000000) | 0, offset + 5);\n    Object.assign(encode, { bytes: 9 });\n  }\n  return buffer;\n}\nexports.encode = encode;\nfunction decode(buffer, offset) {\n  if (!Buffer.isBuffer(buffer))\n    throw new TypeError('buffer must be a Buffer instance');\n  if (!offset) offset = 0;\n  const first = buffer.readUInt8(offset);\n  // 8 bit\n  if (first < 0xfd) {\n    Object.assign(decode, { bytes: 1 });\n    return first;\n    // 16 bit\n  } else if (first === 0xfd) {\n    Object.assign(decode, { bytes: 3 });\n    return buffer.readUInt16LE(offset + 1);\n    // 32 bit\n  } else if (first === 0xfe) {\n    Object.assign(decode, { bytes: 5 });\n    return buffer.readUInt32LE(offset + 1);\n    // 64 bit\n  } else {\n    Object.assign(decode, { bytes: 9 });\n    const lo = buffer.readUInt32LE(offset + 1);\n    const hi = buffer.readUInt32LE(offset + 5);\n    const _number = hi * 0x0100000000 + lo;\n    checkUInt53(_number);\n    return _number;\n  }\n}\nexports.decode = decode;\nfunction encodingLength(_number) {\n  checkUInt53(_number);\n  return _number < 0xfd\n    ? 1\n    : _number <= 0xffff\n    ? 3\n    : _number <= 0xffffffff\n    ? 5\n    : 9;\n}\nexports.encodingLength = encodingLength;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst convert = require('../converter');\nconst tools_1 = require('../converter/tools');\nconst varuint = require('../converter/varint');\nconst typeFields_1 = require('../typeFields');\nfunction psbtFromBuffer(buffer, txGetter) {\n  let offset = 0;\n  function varSlice() {\n    const keyLen = varuint.decode(buffer, offset);\n    offset += varuint.encodingLength(keyLen);\n    const key = buffer.slice(offset, offset + keyLen);\n    offset += keyLen;\n    return key;\n  }\n  function readUInt32BE() {\n    const num = buffer.readUInt32BE(offset);\n    offset += 4;\n    return num;\n  }\n  function readUInt8() {\n    const num = buffer.readUInt8(offset);\n    offset += 1;\n    return num;\n  }\n  function getKeyValue() {\n    const key = varSlice();\n    const value = varSlice();\n    return {\n      key,\n      value,\n    };\n  }\n  function checkEndOfKeyValPairs() {\n    if (offset >= buffer.length) {\n      throw new Error('Format Error: Unexpected End of PSBT');\n    }\n    const isEnd = buffer.readUInt8(offset) === 0;\n    if (isEnd) {\n      offset++;\n    }\n    return isEnd;\n  }\n  if (readUInt32BE() !== 0x70736274) {\n    throw new Error('Format Error: Invalid Magic Number');\n  }\n  if (readUInt8() !== 0xff) {\n    throw new Error(\n      'Format Error: Magic Number must be followed by 0xff separator',\n    );\n  }\n  const globalMapKeyVals = [];\n  const globalKeyIndex = {};\n  while (!checkEndOfKeyValPairs()) {\n    const keyVal = getKeyValue();\n    const hexKey = keyVal.key.toString('hex');\n    if (globalKeyIndex[hexKey]) {\n      throw new Error(\n        'Format Error: Keys must be unique for global keymap: key ' + hexKey,\n      );\n    }\n    globalKeyIndex[hexKey] = 1;\n    globalMapKeyVals.push(keyVal);\n  }\n  const unsignedTxMaps = globalMapKeyVals.filter(\n    keyVal => keyVal.key[0] === typeFields_1.GlobalTypes.UNSIGNED_TX,\n  );\n  if (unsignedTxMaps.length !== 1) {\n    throw new Error('Format Error: Only one UNSIGNED_TX allowed');\n  }\n  const unsignedTx = txGetter(unsignedTxMaps[0].value);\n  // Get input and output counts to loop the respective fields\n  const { inputCount, outputCount } = unsignedTx.getInputOutputCounts();\n  const inputKeyVals = [];\n  const outputKeyVals = [];\n  // Get input fields\n  for (const index of tools_1.range(inputCount)) {\n    const inputKeyIndex = {};\n    const input = [];\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = keyVal.key.toString('hex');\n      if (inputKeyIndex[hexKey]) {\n        throw new Error(\n          'Format Error: Keys must be unique for each input: ' +\n            'input index ' +\n            index +\n            ' key ' +\n            hexKey,\n        );\n      }\n      inputKeyIndex[hexKey] = 1;\n      input.push(keyVal);\n    }\n    inputKeyVals.push(input);\n  }\n  for (const index of tools_1.range(outputCount)) {\n    const outputKeyIndex = {};\n    const output = [];\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = keyVal.key.toString('hex');\n      if (outputKeyIndex[hexKey]) {\n        throw new Error(\n          'Format Error: Keys must be unique for each output: ' +\n            'output index ' +\n            index +\n            ' key ' +\n            hexKey,\n        );\n      }\n      outputKeyIndex[hexKey] = 1;\n      output.push(keyVal);\n    }\n    outputKeyVals.push(output);\n  }\n  return psbtFromKeyVals(unsignedTx, {\n    globalMapKeyVals,\n    inputKeyVals,\n    outputKeyVals,\n  });\n}\nexports.psbtFromBuffer = psbtFromBuffer;\nfunction checkKeyBuffer(type, keyBuf, keyNum) {\n  if (!keyBuf.equals(Buffer.from([keyNum]))) {\n    throw new Error(\n      `Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`,\n    );\n  }\n}\nexports.checkKeyBuffer = checkKeyBuffer;\nfunction psbtFromKeyVals(\n  unsignedTx,\n  { globalMapKeyVals, inputKeyVals, outputKeyVals },\n) {\n  // That was easy :-)\n  const globalMap = {\n    unsignedTx,\n  };\n  let txCount = 0;\n  for (const keyVal of globalMapKeyVals) {\n    // If a globalMap item needs pubkey, uncomment\n    // const pubkey = convert.globals.checkPubkey(keyVal);\n    switch (keyVal.key[0]) {\n      case typeFields_1.GlobalTypes.UNSIGNED_TX:\n        checkKeyBuffer(\n          'global',\n          keyVal.key,\n          typeFields_1.GlobalTypes.UNSIGNED_TX,\n        );\n        if (txCount > 0) {\n          throw new Error('Format Error: GlobalMap has multiple UNSIGNED_TX');\n        }\n        txCount++;\n        break;\n      case typeFields_1.GlobalTypes.GLOBAL_XPUB:\n        if (globalMap.globalXpub === undefined) {\n          globalMap.globalXpub = [];\n        }\n        globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));\n        break;\n      default:\n        // This will allow inclusion during serialization.\n        if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];\n        globalMap.unknownKeyVals.push(keyVal);\n    }\n  }\n  // Get input and output counts to loop the respective fields\n  const inputCount = inputKeyVals.length;\n  const outputCount = outputKeyVals.length;\n  const inputs = [];\n  const outputs = [];\n  // Get input fields\n  for (const index of tools_1.range(inputCount)) {\n    const input = {};\n    for (const keyVal of inputKeyVals[index]) {\n      convert.inputs.checkPubkey(keyVal);\n      switch (keyVal.key[0]) {\n        case typeFields_1.InputTypes.NON_WITNESS_UTXO:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.NON_WITNESS_UTXO,\n          );\n          if (input.nonWitnessUtxo !== undefined) {\n            throw new Error(\n              'Format Error: Input has multiple NON_WITNESS_UTXO',\n            );\n          }\n          input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.WITNESS_UTXO:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.WITNESS_UTXO,\n          );\n          if (input.witnessUtxo !== undefined) {\n            throw new Error('Format Error: Input has multiple WITNESS_UTXO');\n          }\n          input.witnessUtxo = convert.inputs.witnessUtxo.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.PARTIAL_SIG:\n          if (input.partialSig === undefined) {\n            input.partialSig = [];\n          }\n          input.partialSig.push(convert.inputs.partialSig.decode(keyVal));\n          break;\n        case typeFields_1.InputTypes.SIGHASH_TYPE:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.SIGHASH_TYPE,\n          );\n          if (input.sighashType !== undefined) {\n            throw new Error('Format Error: Input has multiple SIGHASH_TYPE');\n          }\n          input.sighashType = convert.inputs.sighashType.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.REDEEM_SCRIPT,\n          );\n          if (input.redeemScript !== undefined) {\n            throw new Error('Format Error: Input has multiple REDEEM_SCRIPT');\n          }\n          input.redeemScript = convert.inputs.redeemScript.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.WITNESS_SCRIPT,\n          );\n          if (input.witnessScript !== undefined) {\n            throw new Error('Format Error: Input has multiple WITNESS_SCRIPT');\n          }\n          input.witnessScript = convert.inputs.witnessScript.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.BIP32_DERIVATION:\n          if (input.bip32Derivation === undefined) {\n            input.bip32Derivation = [];\n          }\n          input.bip32Derivation.push(\n            convert.inputs.bip32Derivation.decode(keyVal),\n          );\n          break;\n        case typeFields_1.InputTypes.FINAL_SCRIPTSIG:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.FINAL_SCRIPTSIG,\n          );\n          input.finalScriptSig = convert.inputs.finalScriptSig.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.FINAL_SCRIPTWITNESS:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.FINAL_SCRIPTWITNESS,\n          );\n          input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(\n            keyVal,\n          );\n          break;\n        case typeFields_1.InputTypes.POR_COMMITMENT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.POR_COMMITMENT,\n          );\n          input.porCommitment = convert.inputs.porCommitment.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.TAP_KEY_SIG:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.TAP_KEY_SIG,\n          );\n          input.tapKeySig = convert.inputs.tapKeySig.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.TAP_SCRIPT_SIG:\n          if (input.tapScriptSig === undefined) {\n            input.tapScriptSig = [];\n          }\n          input.tapScriptSig.push(convert.inputs.tapScriptSig.decode(keyVal));\n          break;\n        case typeFields_1.InputTypes.TAP_LEAF_SCRIPT:\n          if (input.tapLeafScript === undefined) {\n            input.tapLeafScript = [];\n          }\n          input.tapLeafScript.push(convert.inputs.tapLeafScript.decode(keyVal));\n          break;\n        case typeFields_1.InputTypes.TAP_BIP32_DERIVATION:\n          if (input.tapBip32Derivation === undefined) {\n            input.tapBip32Derivation = [];\n          }\n          input.tapBip32Derivation.push(\n            convert.inputs.tapBip32Derivation.decode(keyVal),\n          );\n          break;\n        case typeFields_1.InputTypes.TAP_INTERNAL_KEY:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.TAP_INTERNAL_KEY,\n          );\n          input.tapInternalKey = convert.inputs.tapInternalKey.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.TAP_MERKLE_ROOT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.TAP_MERKLE_ROOT,\n          );\n          input.tapMerkleRoot = convert.inputs.tapMerkleRoot.decode(keyVal);\n          break;\n        default:\n          // This will allow inclusion during serialization.\n          if (!input.unknownKeyVals) input.unknownKeyVals = [];\n          input.unknownKeyVals.push(keyVal);\n      }\n    }\n    inputs.push(input);\n  }\n  for (const index of tools_1.range(outputCount)) {\n    const output = {};\n    for (const keyVal of outputKeyVals[index]) {\n      convert.outputs.checkPubkey(keyVal);\n      switch (keyVal.key[0]) {\n        case typeFields_1.OutputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.REDEEM_SCRIPT,\n          );\n          if (output.redeemScript !== undefined) {\n            throw new Error('Format Error: Output has multiple REDEEM_SCRIPT');\n          }\n          output.redeemScript = convert.outputs.redeemScript.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.WITNESS_SCRIPT,\n          );\n          if (output.witnessScript !== undefined) {\n            throw new Error('Format Error: Output has multiple WITNESS_SCRIPT');\n          }\n          output.witnessScript = convert.outputs.witnessScript.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.BIP32_DERIVATION:\n          if (output.bip32Derivation === undefined) {\n            output.bip32Derivation = [];\n          }\n          output.bip32Derivation.push(\n            convert.outputs.bip32Derivation.decode(keyVal),\n          );\n          break;\n        case typeFields_1.OutputTypes.TAP_INTERNAL_KEY:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.TAP_INTERNAL_KEY,\n          );\n          output.tapInternalKey = convert.outputs.tapInternalKey.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.TAP_TREE:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.TAP_TREE,\n          );\n          output.tapTree = convert.outputs.tapTree.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.TAP_BIP32_DERIVATION:\n          if (output.tapBip32Derivation === undefined) {\n            output.tapBip32Derivation = [];\n          }\n          output.tapBip32Derivation.push(\n            convert.outputs.tapBip32Derivation.decode(keyVal),\n          );\n          break;\n        default:\n          if (!output.unknownKeyVals) output.unknownKeyVals = [];\n          output.unknownKeyVals.push(keyVal);\n      }\n    }\n    outputs.push(output);\n  }\n  return { globalMap, inputs, outputs };\n}\nexports.psbtFromKeyVals = psbtFromKeyVals;\n","'use strict';\nfunction __export(m) {\n  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, '__esModule', { value: true });\n__export(require('./fromBuffer'));\n__export(require('./toBuffer'));\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst convert = require('../converter');\nconst tools_1 = require('../converter/tools');\nfunction psbtToBuffer({ globalMap, inputs, outputs }) {\n  const { globalKeyVals, inputKeyVals, outputKeyVals } = psbtToKeyVals({\n    globalMap,\n    inputs,\n    outputs,\n  });\n  const globalBuffer = tools_1.keyValsToBuffer(globalKeyVals);\n  const keyValsOrEmptyToBuffer = keyVals =>\n    keyVals.length === 0\n      ? [Buffer.from([0])]\n      : keyVals.map(tools_1.keyValsToBuffer);\n  const inputBuffers = keyValsOrEmptyToBuffer(inputKeyVals);\n  const outputBuffers = keyValsOrEmptyToBuffer(outputKeyVals);\n  const header = Buffer.allocUnsafe(5);\n  header.writeUIntBE(0x70736274ff, 0, 5);\n  return Buffer.concat(\n    [header, globalBuffer].concat(inputBuffers, outputBuffers),\n  );\n}\nexports.psbtToBuffer = psbtToBuffer;\nconst sortKeyVals = (a, b) => {\n  return a.key.compare(b.key);\n};\nfunction keyValsFromMap(keyValMap, converterFactory) {\n  const keyHexSet = new Set();\n  const keyVals = Object.entries(keyValMap).reduce((result, [key, value]) => {\n    if (key === 'unknownKeyVals') return result;\n    // We are checking for undefined anyways. So ignore TS error\n    // @ts-ignore\n    const converter = converterFactory[key];\n    if (converter === undefined) return result;\n    const encodedKeyVals = (Array.isArray(value) ? value : [value]).map(\n      converter.encode,\n    );\n    const keyHexes = encodedKeyVals.map(kv => kv.key.toString('hex'));\n    keyHexes.forEach(hex => {\n      if (keyHexSet.has(hex))\n        throw new Error('Serialize Error: Duplicate key: ' + hex);\n      keyHexSet.add(hex);\n    });\n    return result.concat(encodedKeyVals);\n  }, []);\n  // Get other keyVals that have not yet been gotten\n  const otherKeyVals = keyValMap.unknownKeyVals\n    ? keyValMap.unknownKeyVals.filter(keyVal => {\n        return !keyHexSet.has(keyVal.key.toString('hex'));\n      })\n    : [];\n  return keyVals.concat(otherKeyVals).sort(sortKeyVals);\n}\nfunction psbtToKeyVals({ globalMap, inputs, outputs }) {\n  // First parse the global keyVals\n  // Get any extra keyvals to pass along\n  return {\n    globalKeyVals: keyValsFromMap(globalMap, convert.globals),\n    inputKeyVals: inputs.map(i => keyValsFromMap(i, convert.inputs)),\n    outputKeyVals: outputs.map(o => keyValsFromMap(o, convert.outputs)),\n  };\n}\nexports.psbtToKeyVals = psbtToKeyVals;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst combiner_1 = require('./combiner');\nconst parser_1 = require('./parser');\nconst typeFields_1 = require('./typeFields');\nconst utils_1 = require('./utils');\nclass Psbt {\n  constructor(tx) {\n    this.inputs = [];\n    this.outputs = [];\n    this.globalMap = {\n      unsignedTx: tx,\n    };\n  }\n  static fromBase64(data, txFromBuffer) {\n    const buffer = Buffer.from(data, 'base64');\n    return this.fromBuffer(buffer, txFromBuffer);\n  }\n  static fromHex(data, txFromBuffer) {\n    const buffer = Buffer.from(data, 'hex');\n    return this.fromBuffer(buffer, txFromBuffer);\n  }\n  static fromBuffer(buffer, txFromBuffer) {\n    const results = parser_1.psbtFromBuffer(buffer, txFromBuffer);\n    const psbt = new this(results.globalMap.unsignedTx);\n    Object.assign(psbt, results);\n    return psbt;\n  }\n  toBase64() {\n    const buffer = this.toBuffer();\n    return buffer.toString('base64');\n  }\n  toHex() {\n    const buffer = this.toBuffer();\n    return buffer.toString('hex');\n  }\n  toBuffer() {\n    return parser_1.psbtToBuffer(this);\n  }\n  updateGlobal(updateData) {\n    utils_1.updateGlobal(updateData, this.globalMap);\n    return this;\n  }\n  updateInput(inputIndex, updateData) {\n    const input = utils_1.checkForInput(this.inputs, inputIndex);\n    utils_1.updateInput(updateData, input);\n    return this;\n  }\n  updateOutput(outputIndex, updateData) {\n    const output = utils_1.checkForOutput(this.outputs, outputIndex);\n    utils_1.updateOutput(updateData, output);\n    return this;\n  }\n  addUnknownKeyValToGlobal(keyVal) {\n    utils_1.checkHasKey(\n      keyVal,\n      this.globalMap.unknownKeyVals,\n      utils_1.getEnumLength(typeFields_1.GlobalTypes),\n    );\n    if (!this.globalMap.unknownKeyVals) this.globalMap.unknownKeyVals = [];\n    this.globalMap.unknownKeyVals.push(keyVal);\n    return this;\n  }\n  addUnknownKeyValToInput(inputIndex, keyVal) {\n    const input = utils_1.checkForInput(this.inputs, inputIndex);\n    utils_1.checkHasKey(\n      keyVal,\n      input.unknownKeyVals,\n      utils_1.getEnumLength(typeFields_1.InputTypes),\n    );\n    if (!input.unknownKeyVals) input.unknownKeyVals = [];\n    input.unknownKeyVals.push(keyVal);\n    return this;\n  }\n  addUnknownKeyValToOutput(outputIndex, keyVal) {\n    const output = utils_1.checkForOutput(this.outputs, outputIndex);\n    utils_1.checkHasKey(\n      keyVal,\n      output.unknownKeyVals,\n      utils_1.getEnumLength(typeFields_1.OutputTypes),\n    );\n    if (!output.unknownKeyVals) output.unknownKeyVals = [];\n    output.unknownKeyVals.push(keyVal);\n    return this;\n  }\n  addInput(inputData) {\n    this.globalMap.unsignedTx.addInput(inputData);\n    this.inputs.push({\n      unknownKeyVals: [],\n    });\n    const addKeyVals = inputData.unknownKeyVals || [];\n    const inputIndex = this.inputs.length - 1;\n    if (!Array.isArray(addKeyVals)) {\n      throw new Error('unknownKeyVals must be an Array');\n    }\n    addKeyVals.forEach(keyVal =>\n      this.addUnknownKeyValToInput(inputIndex, keyVal),\n    );\n    utils_1.addInputAttributes(this.inputs, inputData);\n    return this;\n  }\n  addOutput(outputData) {\n    this.globalMap.unsignedTx.addOutput(outputData);\n    this.outputs.push({\n      unknownKeyVals: [],\n    });\n    const addKeyVals = outputData.unknownKeyVals || [];\n    const outputIndex = this.outputs.length - 1;\n    if (!Array.isArray(addKeyVals)) {\n      throw new Error('unknownKeyVals must be an Array');\n    }\n    addKeyVals.forEach(keyVal =>\n      this.addUnknownKeyValToOutput(outputIndex, keyVal),\n    );\n    utils_1.addOutputAttributes(this.outputs, outputData);\n    return this;\n  }\n  clearFinalizedInput(inputIndex) {\n    const input = utils_1.checkForInput(this.inputs, inputIndex);\n    utils_1.inputCheckUncleanFinalized(inputIndex, input);\n    for (const key of Object.keys(input)) {\n      if (\n        ![\n          'witnessUtxo',\n          'nonWitnessUtxo',\n          'finalScriptSig',\n          'finalScriptWitness',\n          'unknownKeyVals',\n        ].includes(key)\n      ) {\n        // @ts-ignore\n        delete input[key];\n      }\n    }\n    return this;\n  }\n  combine(...those) {\n    // Combine this with those.\n    // Return self for chaining.\n    const result = combiner_1.combine([this].concat(those));\n    Object.assign(this, result);\n    return this;\n  }\n  getTransaction() {\n    return this.globalMap.unsignedTx.toBuffer();\n  }\n}\nexports.Psbt = Psbt;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nvar GlobalTypes;\n(function(GlobalTypes) {\n  GlobalTypes[(GlobalTypes['UNSIGNED_TX'] = 0)] = 'UNSIGNED_TX';\n  GlobalTypes[(GlobalTypes['GLOBAL_XPUB'] = 1)] = 'GLOBAL_XPUB';\n})((GlobalTypes = exports.GlobalTypes || (exports.GlobalTypes = {})));\nexports.GLOBAL_TYPE_NAMES = ['unsignedTx', 'globalXpub'];\nvar InputTypes;\n(function(InputTypes) {\n  InputTypes[(InputTypes['NON_WITNESS_UTXO'] = 0)] = 'NON_WITNESS_UTXO';\n  InputTypes[(InputTypes['WITNESS_UTXO'] = 1)] = 'WITNESS_UTXO';\n  InputTypes[(InputTypes['PARTIAL_SIG'] = 2)] = 'PARTIAL_SIG';\n  InputTypes[(InputTypes['SIGHASH_TYPE'] = 3)] = 'SIGHASH_TYPE';\n  InputTypes[(InputTypes['REDEEM_SCRIPT'] = 4)] = 'REDEEM_SCRIPT';\n  InputTypes[(InputTypes['WITNESS_SCRIPT'] = 5)] = 'WITNESS_SCRIPT';\n  InputTypes[(InputTypes['BIP32_DERIVATION'] = 6)] = 'BIP32_DERIVATION';\n  InputTypes[(InputTypes['FINAL_SCRIPTSIG'] = 7)] = 'FINAL_SCRIPTSIG';\n  InputTypes[(InputTypes['FINAL_SCRIPTWITNESS'] = 8)] = 'FINAL_SCRIPTWITNESS';\n  InputTypes[(InputTypes['POR_COMMITMENT'] = 9)] = 'POR_COMMITMENT';\n  InputTypes[(InputTypes['TAP_KEY_SIG'] = 19)] = 'TAP_KEY_SIG';\n  InputTypes[(InputTypes['TAP_SCRIPT_SIG'] = 20)] = 'TAP_SCRIPT_SIG';\n  InputTypes[(InputTypes['TAP_LEAF_SCRIPT'] = 21)] = 'TAP_LEAF_SCRIPT';\n  InputTypes[(InputTypes['TAP_BIP32_DERIVATION'] = 22)] =\n    'TAP_BIP32_DERIVATION';\n  InputTypes[(InputTypes['TAP_INTERNAL_KEY'] = 23)] = 'TAP_INTERNAL_KEY';\n  InputTypes[(InputTypes['TAP_MERKLE_ROOT'] = 24)] = 'TAP_MERKLE_ROOT';\n})((InputTypes = exports.InputTypes || (exports.InputTypes = {})));\nexports.INPUT_TYPE_NAMES = [\n  'nonWitnessUtxo',\n  'witnessUtxo',\n  'partialSig',\n  'sighashType',\n  'redeemScript',\n  'witnessScript',\n  'bip32Derivation',\n  'finalScriptSig',\n  'finalScriptWitness',\n  'porCommitment',\n  'tapKeySig',\n  'tapScriptSig',\n  'tapLeafScript',\n  'tapBip32Derivation',\n  'tapInternalKey',\n  'tapMerkleRoot',\n];\nvar OutputTypes;\n(function(OutputTypes) {\n  OutputTypes[(OutputTypes['REDEEM_SCRIPT'] = 0)] = 'REDEEM_SCRIPT';\n  OutputTypes[(OutputTypes['WITNESS_SCRIPT'] = 1)] = 'WITNESS_SCRIPT';\n  OutputTypes[(OutputTypes['BIP32_DERIVATION'] = 2)] = 'BIP32_DERIVATION';\n  OutputTypes[(OutputTypes['TAP_INTERNAL_KEY'] = 5)] = 'TAP_INTERNAL_KEY';\n  OutputTypes[(OutputTypes['TAP_TREE'] = 6)] = 'TAP_TREE';\n  OutputTypes[(OutputTypes['TAP_BIP32_DERIVATION'] = 7)] =\n    'TAP_BIP32_DERIVATION';\n})((OutputTypes = exports.OutputTypes || (exports.OutputTypes = {})));\nexports.OUTPUT_TYPE_NAMES = [\n  'redeemScript',\n  'witnessScript',\n  'bip32Derivation',\n  'tapInternalKey',\n  'tapTree',\n  'tapBip32Derivation',\n];\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst converter = require('./converter');\nfunction checkForInput(inputs, inputIndex) {\n  const input = inputs[inputIndex];\n  if (input === undefined) throw new Error(`No input #${inputIndex}`);\n  return input;\n}\nexports.checkForInput = checkForInput;\nfunction checkForOutput(outputs, outputIndex) {\n  const output = outputs[outputIndex];\n  if (output === undefined) throw new Error(`No output #${outputIndex}`);\n  return output;\n}\nexports.checkForOutput = checkForOutput;\nfunction checkHasKey(checkKeyVal, keyVals, enumLength) {\n  if (checkKeyVal.key[0] < enumLength) {\n    throw new Error(\n      `Use the method for your specific key instead of addUnknownKeyVal*`,\n    );\n  }\n  if (\n    keyVals &&\n    keyVals.filter(kv => kv.key.equals(checkKeyVal.key)).length !== 0\n  ) {\n    throw new Error(`Duplicate Key: ${checkKeyVal.key.toString('hex')}`);\n  }\n}\nexports.checkHasKey = checkHasKey;\nfunction getEnumLength(myenum) {\n  let count = 0;\n  Object.keys(myenum).forEach(val => {\n    if (Number(isNaN(Number(val)))) {\n      count++;\n    }\n  });\n  return count;\n}\nexports.getEnumLength = getEnumLength;\nfunction inputCheckUncleanFinalized(inputIndex, input) {\n  let result = false;\n  if (input.nonWitnessUtxo || input.witnessUtxo) {\n    const needScriptSig = !!input.redeemScript;\n    const needWitnessScript = !!input.witnessScript;\n    const scriptSigOK = !needScriptSig || !!input.finalScriptSig;\n    const witnessScriptOK = !needWitnessScript || !!input.finalScriptWitness;\n    const hasOneFinal = !!input.finalScriptSig || !!input.finalScriptWitness;\n    result = scriptSigOK && witnessScriptOK && hasOneFinal;\n  }\n  if (result === false) {\n    throw new Error(\n      `Input #${inputIndex} has too much or too little data to clean`,\n    );\n  }\n}\nexports.inputCheckUncleanFinalized = inputCheckUncleanFinalized;\nfunction throwForUpdateMaker(typeName, name, expected, data) {\n  throw new Error(\n    `Data for ${typeName} key ${name} is incorrect: Expected ` +\n      `${expected} and got ${JSON.stringify(data)}`,\n  );\n}\nfunction updateMaker(typeName) {\n  return (updateData, mainData) => {\n    for (const name of Object.keys(updateData)) {\n      // @ts-ignore\n      const data = updateData[name];\n      // @ts-ignore\n      const { canAdd, canAddToArray, check, expected } =\n        // @ts-ignore\n        converter[typeName + 's'][name] || {};\n      const isArray = !!canAddToArray;\n      // If unknown data. ignore and do not add\n      if (check) {\n        if (isArray) {\n          if (\n            !Array.isArray(data) ||\n            // @ts-ignore\n            (mainData[name] && !Array.isArray(mainData[name]))\n          ) {\n            throw new Error(`Key type ${name} must be an array`);\n          }\n          if (!data.every(check)) {\n            throwForUpdateMaker(typeName, name, expected, data);\n          }\n          // @ts-ignore\n          const arr = mainData[name] || [];\n          const dupeCheckSet = new Set();\n          if (!data.every(v => canAddToArray(arr, v, dupeCheckSet))) {\n            throw new Error('Can not add duplicate data to array');\n          }\n          // @ts-ignore\n          mainData[name] = arr.concat(data);\n        } else {\n          if (!check(data)) {\n            throwForUpdateMaker(typeName, name, expected, data);\n          }\n          if (!canAdd(mainData, data)) {\n            throw new Error(`Can not add duplicate data to ${typeName}`);\n          }\n          // @ts-ignore\n          mainData[name] = data;\n        }\n      }\n    }\n  };\n}\nexports.updateGlobal = updateMaker('global');\nexports.updateInput = updateMaker('input');\nexports.updateOutput = updateMaker('output');\nfunction addInputAttributes(inputs, data) {\n  const index = inputs.length - 1;\n  const input = checkForInput(inputs, index);\n  exports.updateInput(data, input);\n}\nexports.addInputAttributes = addInputAttributes;\nfunction addOutputAttributes(outputs, data) {\n  const index = outputs.length - 1;\n  const output = checkForOutput(outputs, index);\n  exports.updateOutput(data, output);\n}\nexports.addOutputAttributes = addOutputAttributes;\nfunction defaultVersionSetter(version, txBuf) {\n  if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {\n    throw new Error('Set Version: Invalid Transaction');\n  }\n  txBuf.writeUInt32LE(version, 0);\n  return txBuf;\n}\nexports.defaultVersionSetter = defaultVersionSetter;\nfunction defaultLocktimeSetter(locktime, txBuf) {\n  if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {\n    throw new Error('Set Locktime: Invalid Transaction');\n  }\n  txBuf.writeUInt32LE(locktime, txBuf.length - 4);\n  return txBuf;\n}\nexports.defaultLocktimeSetter = defaultLocktimeSetter;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Import dependencies\nconst fast_sha256_1 = require(\"fast-sha256\");\nconst bitcoin = __importStar(require(\"bitcoinjs-lib\"));\n/**\n * Class that handles BIP-322 related operations.\n * Reference: https://github.com/LegReq/bip0322-signatures/blob/master/BIP0322_signing.ipynb\n */\nclass BIP322 {\n    /**\n     * Compute the message hash as specified in the BIP-322.\n     * The standard is specified in BIP-340 as:\n     *      The function hashtag(x) where tag is a UTF-8 encoded tag name and x is a byte array returns the 32-byte hash SHA256(SHA256(tag) || SHA256(tag) || x).\n     * @param message Message to be hashed\n     * @returns Hashed message\n     */\n    static hashMessage(message) {\n        // Compute the message hash - SHA256(SHA256(tag) || SHA256(tag) || message)\n        const tagHasher = new fast_sha256_1.Hash();\n        tagHasher.update(this.TAG);\n        const tagHash = tagHasher.digest();\n        const messageHasher = new fast_sha256_1.Hash();\n        messageHasher.update(tagHash);\n        messageHasher.update(tagHash);\n        messageHasher.update(Buffer.from(message));\n        const messageHash = messageHasher.digest();\n        return messageHash;\n    }\n    /**\n     * Build a to_spend transaction using simple signature in accordance to the BIP-322.\n     * @param message Message to be signed using BIP-322\n     * @param scriptPublicKey The script public key for the signing wallet\n     * @returns Bitcoin transaction that correspond to the to_spend transaction\n     */\n    static buildToSpendTx(message, scriptPublicKey) {\n        // Create PSBT object for constructing the transaction\n        const psbt = new bitcoin.Psbt();\n        // Set default value for nVersion and nLockTime\n        psbt.setVersion(0); // nVersion = 0\n        psbt.setLocktime(0); // nLockTime = 0\n        // Compute the message hash - SHA256(SHA256(tag) || SHA256(tag) || message)\n        const messageHash = this.hashMessage(message);\n        // Construct the scriptSig - OP_0 PUSH32[ message_hash ]\n        const scriptSigPartOne = new Uint8Array([0x00, 0x20]); // OP_0 PUSH32\n        const scriptSig = new Uint8Array(scriptSigPartOne.length + messageHash.length);\n        scriptSig.set(scriptSigPartOne);\n        scriptSig.set(messageHash, scriptSigPartOne.length);\n        // Set the input\n        psbt.addInput({\n            hash: '0'.repeat(64), // vin[0].prevout.hash = 0000...000\n            index: 0xFFFFFFFF, // vin[0].prevout.n = 0xFFFFFFFF\n            sequence: 0, // vin[0].nSequence = 0\n            finalScriptSig: Buffer.from(scriptSig), // vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n            witnessScript: Buffer.from([]) // vin[0].scriptWitness = []\n        });\n        // Set the output\n        psbt.addOutput({\n            value: 0, // vout[0].nValue = 0\n            script: scriptPublicKey // vout[0].scriptPubKey = message_challenge\n        });\n        // Return transaction\n        return psbt.extractTransaction();\n    }\n    /**\n     * Build a to_sign transaction using simple signature in accordance to the BIP-322.\n     * @param toSpendTxId Transaction ID of the to_spend transaction as constructed by buildToSpendTx\n     * @param witnessScript The script public key for the signing wallet, or the redeemScript for P2SH-P2WPKH address\n     * @param isRedeemScript Set to true if the provided witnessScript is a redeemScript for P2SH-P2WPKH address, default to false\n     * @param tapInternalKey Used to set the taproot internal public key of a taproot signing address when provided, default to undefined\n     * @returns Ready-to-be-signed bitcoinjs.Psbt transaction\n     */\n    static buildToSignTx(toSpendTxId, witnessScript, isRedeemScript = false, tapInternalKey = undefined) {\n        // Create PSBT object for constructing the transaction\n        const psbt = new bitcoin.Psbt();\n        // Set default value for nVersion and nLockTime\n        psbt.setVersion(0); // nVersion = 0\n        psbt.setLocktime(0); // nLockTime = 0\n        // Set the input\n        psbt.addInput({\n            hash: toSpendTxId, // vin[0].prevout.hash = to_spend.txid\n            index: 0, // vin[0].prevout.n = 0\n            sequence: 0, // vin[0].nSequence = 0\n            witnessUtxo: {\n                script: witnessScript,\n                value: 0\n            }\n        });\n        // Set redeemScript as witnessScript if isRedeemScript\n        if (isRedeemScript) {\n            psbt.updateInput(0, {\n                redeemScript: witnessScript\n            });\n        }\n        // Set tapInternalKey if provided\n        if (tapInternalKey) {\n            psbt.updateInput(0, {\n                tapInternalKey: tapInternalKey\n            });\n        }\n        // Set the output\n        psbt.addOutput({\n            value: 0, // vout[0].nValue = 0\n            script: Buffer.from([0x6a]) // vout[0].scriptPubKey = OP_RETURN\n        });\n        return psbt;\n    }\n    /**\n     * Encode witness stack in a signed BIP-322 PSBT into its base-64 encoded format.\n     * @param signedPsbt Signed PSBT\n     * @returns Base-64 encoded witness data\n     */\n    static encodeWitness(signedPsbt) {\n        // Obtain the signed witness data\n        const witness = signedPsbt.data.inputs[0].finalScriptWitness;\n        // Check if the witness data is present\n        if (witness) {\n            // Return the base-64 encoded witness stack\n            return witness.toString('base64');\n        }\n        else {\n            throw new Error('Cannot encode empty witness stack.');\n        }\n    }\n}\n// BIP322 message tag\nBIP322.TAG = Buffer.from(\"BIP0322-signed-message\");\nexports.default = BIP322;\n//# sourceMappingURL=BIP322.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Import dependencies\nconst BIP322_1 = __importDefault(require(\"./BIP322\"));\nconst ecpair_1 = __importDefault(require(\"ecpair\"));\nconst helpers_1 = require(\"./helpers\");\nconst bitcoin = __importStar(require(\"bitcoinjs-lib\"));\nconst secp256k1_1 = __importDefault(require(\"@bitcoinerlab/secp256k1\"));\nconst bitcoinMessage = __importStar(require(\"bitcoinjs-message\"));\n/**\n * Class that signs BIP-322 signature using a private key.\n * Reference: https://github.com/LegReq/bip0322-signatures/blob/master/BIP0322_signing.ipynb\n */\nclass Signer {\n    /**\n     * Sign a BIP-322 signature from P2WPKH, P2SH-P2WPKH, and single-key-spend P2TR address and its corresponding private key.\n     * Network is automatically inferred from the given address.\n     *\n     * @param privateKey Private key used to sign the message\n     * @param address Address to be signing the message\n     * @param message message_challenge to be signed by the address\n     * @returns BIP-322 simple signature, encoded in base-64\n     */\n    static sign(privateKey, address, message) {\n        // Initialize private key used to sign the transaction\n        const ECPair = (0, ecpair_1.default)(secp256k1_1.default);\n        let signer = ECPair.fromWIF(privateKey, [bitcoin.networks.bitcoin, bitcoin.networks.testnet, bitcoin.networks.regtest]);\n        // Check if the private key can sign message for the given address\n        if (!this.checkPubKeyCorrespondToAddress(signer.publicKey, address)) {\n            throw new Error(`Invalid private key provided for signing message for ${address}.`);\n        }\n        // Handle legacy P2PKH signature\n        if (helpers_1.Address.isP2PKH(address)) {\n            // For P2PKH address, sign a legacy signature\n            // Reference: https://github.com/bitcoinjs/bitcoinjs-message/blob/c43430f4c03c292c719e7801e425d887cbdf7464/README.md?plain=1#L21\n            return bitcoinMessage.sign(message, signer.privateKey, signer.compressed);\n        }\n        // Convert address into corresponding script pubkey\n        const scriptPubKey = helpers_1.Address.convertAdressToScriptPubkey(address);\n        // Draft corresponding toSpend using the message and script pubkey\n        const toSpendTx = BIP322_1.default.buildToSpendTx(message, scriptPubKey);\n        // Draft corresponding toSign transaction based on the address type\n        let toSignTx;\n        if (helpers_1.Address.isP2SH(address)) {\n            // P2SH-P2WPKH signing path\n            // Derive the P2SH-P2WPKH redeemScript from the corresponding hashed public key\n            const redeemScript = bitcoin.payments.p2wpkh({\n                hash: bitcoin.crypto.hash160(signer.publicKey),\n                network: helpers_1.Address.getNetworkFromAddess(address)\n            }).output;\n            toSignTx = BIP322_1.default.buildToSignTx(toSpendTx.getId(), redeemScript, true);\n        }\n        else if (helpers_1.Address.isP2WPKH(address)) {\n            // P2WPKH signing path\n            toSignTx = BIP322_1.default.buildToSignTx(toSpendTx.getId(), scriptPubKey);\n        }\n        else {\n            // P2TR signing path\n            // Extract the taproot internal public key\n            const internalPublicKey = helpers_1.Key.toXOnly(signer.publicKey);\n            // Tweak the private key for signing, since the output and address uses tweaked key\n            // Reference: https://github.com/bitcoinjs/bitcoinjs-lib/blob/1a9119b53bcea4b83a6aa8b948f0e6370209b1b4/test/integration/taproot.spec.ts#L55\n            signer = signer.tweak(bitcoin.crypto.taggedHash('TapTweak', internalPublicKey));\n            // Draft a toSign transaction that spends toSpend transaction\n            toSignTx = BIP322_1.default.buildToSignTx(toSpendTx.getId(), scriptPubKey, false, internalPublicKey);\n            // Set the sighashType to bitcoin.Transaction.SIGHASH_ALL since it defaults to SIGHASH_DEFAULT\n            toSignTx.updateInput(0, {\n                sighashType: bitcoin.Transaction.SIGHASH_ALL\n            });\n        }\n        // Sign the toSign transaction\n        const toSignTxSigned = toSignTx.signAllInputs(signer, [bitcoin.Transaction.SIGHASH_ALL]).finalizeAllInputs();\n        // Extract and return the signature\n        return BIP322_1.default.encodeWitness(toSignTxSigned);\n    }\n    /**\n     * Check if a given public key is the public key for a claimed address.\n     * @param publicKey Public key to be tested\n     * @param claimedAddress Address claimed to be derived based on the provided public key\n     * @returns True if the claimedAddress can be derived by the provided publicKey, false if otherwise\n     */\n    static checkPubKeyCorrespondToAddress(publicKey, claimedAddress) {\n        // Derive the same address type from the provided public key\n        let derivedAddresses;\n        if (helpers_1.Address.isP2PKH(claimedAddress)) {\n            derivedAddresses = helpers_1.Address.convertPubKeyIntoAddress(publicKey, 'p2pkh');\n        }\n        else if (helpers_1.Address.isP2SH(claimedAddress)) {\n            derivedAddresses = helpers_1.Address.convertPubKeyIntoAddress(publicKey, 'p2sh-p2wpkh');\n        }\n        else if (helpers_1.Address.isP2WPKH(claimedAddress)) {\n            derivedAddresses = helpers_1.Address.convertPubKeyIntoAddress(publicKey, 'p2wpkh');\n        }\n        else if (helpers_1.Address.isP2TR(claimedAddress)) {\n            derivedAddresses = helpers_1.Address.convertPubKeyIntoAddress(publicKey, 'p2tr');\n        }\n        else {\n            throw new Error('Unable to sign BIP-322 message for unsupported address type.'); // Unsupported address type\n        }\n        // Check if the derived address correspond to the claimedAddress\n        return ((derivedAddresses.mainnet === claimedAddress) || (derivedAddresses.testnet === claimedAddress) ||\n            (derivedAddresses.regtest === claimedAddress));\n    }\n}\nexports.default = Signer;\n//# sourceMappingURL=Signer.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Import dependencies\nconst BIP322_1 = __importDefault(require(\"./BIP322\"));\nconst bitcoin = __importStar(require(\"bitcoinjs-lib\"));\nconst secp256k1_1 = __importDefault(require(\"@bitcoinerlab/secp256k1\"));\nconst helpers_1 = require(\"./helpers\");\nconst bitcoinMessage = __importStar(require(\"bitcoinjs-message\"));\nconst bitcoinjs_1 = require(\"./bitcoinjs\");\n/**\n * Class that handles BIP-322 signature verification.\n * Reference: https://github.com/LegReq/bip0322-signatures/blob/master/BIP0322_verification.ipynb\n */\nclass Verifier {\n    /**\n     * Verify a BIP-322 signature from P2WPKH, P2SH-P2WPKH, and single-key-spend P2TR address.\n     * @param signerAddress Address of the signing address\n     * @param message message_challenge signed by the address\n     * @param signatureBase64 Signature produced by the signing address\n     * @param useStrictVerification If true, apply strict BIP-137 verification and enforce address flag verification; otherwise, address flag is ignored during verification\n     * @returns True if the provided signature is a valid BIP-322 signature for the given message and address, false if otherwise\n     * @throws If the provided signature fails basic validation, or if unsupported address and signature are provided\n     */\n    static verifySignature(signerAddress, message, signatureBase64, useStrictVerification = false) {\n        // Check whether the given signerAddress is valid\n        if (!helpers_1.Address.isValidBitcoinAddress(signerAddress)) {\n            throw new Error(\"Invalid Bitcoin address is provided.\");\n        }\n        // Handle legacy BIP-137 signature\n        // For P2PKH address, assume the signature is also a legacy signature\n        if (helpers_1.Address.isP2PKH(signerAddress) || helpers_1.BIP137.isBIP137Signature(signatureBase64)) {\n            return this.verifyBIP137Signature(signerAddress, message, signatureBase64, useStrictVerification);\n        }\n        // Convert address into corresponding script pubkey\n        const scriptPubKey = helpers_1.Address.convertAdressToScriptPubkey(signerAddress);\n        // Draft corresponding toSpend and toSign transaction using the message and script pubkey\n        const toSpendTx = BIP322_1.default.buildToSpendTx(message, scriptPubKey);\n        const toSignTx = BIP322_1.default.buildToSignTx(toSpendTx.getId(), scriptPubKey);\n        // Add the witness stack into the toSignTx\n        toSignTx.updateInput(0, {\n            finalScriptWitness: Buffer.from(signatureBase64, 'base64')\n        });\n        // Obtain the signature within the witness components\n        const witness = toSignTx.extractTransaction().ins[0].witness;\n        const encodedSignature = witness[0];\n        // Branch depending on whether the signing address is a non-taproot or a taproot address\n        if (helpers_1.Address.isP2WPKHWitness(witness)) {\n            // For non-taproot segwit transaciton, public key is included as the second part of the witness data\n            const publicKey = witness[1];\n            const { signature } = (0, bitcoinjs_1.decodeScriptSignature)(encodedSignature);\n            // Compute OP_HASH160(publicKey)\n            const hashedPubkey = bitcoin.crypto.hash160(publicKey);\n            // Common path variable\n            let hashToSign; // Hash expected to be signed by the signing address\n            if (helpers_1.Address.isP2SH(signerAddress)) {\n                // P2SH-P2WPKH verification path\n                // Compute the hash that correspond to the toSignTx\n                hashToSign = this.getHashForSigP2SHInP2WPKH(toSignTx, hashedPubkey);\n                // The original locking script for P2SH-P2WPKH is OP_0 <PubKeyHash>\n                const lockingScript = Buffer.concat([Buffer.from([0x00, 0x14]), hashedPubkey]);\n                // Compute OP_HASH160(lockingScript)\n                const hashedLockingScript = bitcoin.crypto.hash160(lockingScript);\n                // For nested segwit (P2SH-P2WPKH) address, the hashed locking script is located from the 3rd byte to the last 2nd byte as OP_HASH160 <HASH> OP_EQUAL\n                const hashedLockingScriptInScriptPubKey = scriptPubKey.subarray(2, -1);\n                // Check if the P2SH locking script OP_HASH160 <HASH> OP_EQUAL is satisified\n                if (Buffer.compare(hashedLockingScript, hashedLockingScriptInScriptPubKey) !== 0) {\n                    return false; // Reject signature if the hashed locking script is different from the hashed locking script in the scriptPubKey\n                }\n            }\n            else {\n                // P2WPKH verification path\n                // Compute the hash that correspond to the toSignTx\n                hashToSign = this.getHashForSigP2WPKH(toSignTx);\n                // For native segwit address, the hashed public key is located from the 3rd to the end as OP_0 <HASH>\n                const hashedPubkeyInScriptPubkey = scriptPubKey.subarray(2);\n                // Check if OP_HASH160(publicKey) === hashedPubkeyInScriptPubkey\n                if (Buffer.compare(hashedPubkey, hashedPubkeyInScriptPubkey) !== 0) {\n                    return false; // Reject signature if the hashed public key did not match\n                }\n            }\n            // Computing OP_CHECKSIG in Javascript\n            return secp256k1_1.default.verify(hashToSign, publicKey, signature);\n        }\n        else if (helpers_1.Address.isP2TR(signerAddress)) {\n            // Check if the witness stack correspond to a single-key-spend P2TR address\n            if (!helpers_1.Address.isSingleKeyP2TRWitness(witness)) {\n                throw new Error('BIP-322 verification from script-spend P2TR is unsupported.');\n            }\n            // For taproot address, the public key is located starting from the 3rd byte of the script public key\n            const publicKey = scriptPubKey.subarray(2);\n            // Compute the hash to be signed by the signing address\n            // Reference: https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#user-content-Taproot_key_path_spending_signature_validation\n            let hashToSign;\n            let signature;\n            if (encodedSignature.byteLength === 64) {\n                // If a BIP-341 signature is 64 bytes, the signature is signed using SIGHASH_DEFAULT 0x00 \n                hashToSign = this.getHashForSigP2TR(toSignTx, 0x00);\n                // And the entirety of the encoded signature is the actual signature\n                signature = encodedSignature;\n            }\n            else if (encodedSignature.byteLength === 65) {\n                // If a BIP-341 signature is 65 bytes, the signature is signed using SIGHASH included at the last byte of the signature\n                hashToSign = this.getHashForSigP2TR(toSignTx, encodedSignature[64]);\n                // And encodedSignature[0:64] holds the actual signature\n                signature = encodedSignature.subarray(0, -1);\n            }\n            else {\n                // Fail validation if the signature is not 64 or 65 bytes\n                throw new Error('Invalid Schnorr signature provided.');\n            }\n            // Computing OP_CHECKSIG in Javascript\n            return secp256k1_1.default.verifySchnorr(hashToSign, publicKey, signature);\n        }\n        else {\n            throw new Error('Only P2WPKH, P2SH-P2WPKH, and single-key-spend P2TR BIP-322 verification is supported. Unsupported address is provided.');\n        }\n    }\n    /**\n     * Verify a legacy BIP-137 signature.\n     * Note that a signature is considered valid for all types of addresses that can be derived from the recovered public key.\n     * @param signerAddress Address of the signing address\n     * @param message message_challenge signed by the address\n     * @param signatureBase64 Signature produced by the signing address\n     * @param useStrictVerification If true, apply strict BIP-137 verification and enforce address flag verification; otherwise, address flag is ignored during verification\n     * @returns True if the provided signature is a valid BIP-137 signature for the given message and address, false if otherwise\n     * @throws If the provided signature fails basic validation, or if unsupported address and signature are provided\n     */\n    static verifyBIP137Signature(signerAddress, message, signatureBase64, useStrictVerification) {\n        if (useStrictVerification) {\n            return this.bitcoinMessageVerifyWrap(message, signerAddress, signatureBase64);\n        }\n        // Recover the public key associated with the signature\n        const publicKeySignedRaw = helpers_1.BIP137.derivePubKey(message, signatureBase64);\n        // Compress and uncompress the public key if necessary\n        let publicKeySignedUncompressed;\n        let publicKeySigned;\n        if (publicKeySignedRaw.byteLength === 65) {\n            publicKeySignedUncompressed = publicKeySignedRaw; // The key recovered is an uncompressed key\n            publicKeySigned = helpers_1.Key.compressPublicKey(publicKeySignedRaw);\n        }\n        else {\n            publicKeySignedUncompressed = helpers_1.Key.uncompressPublicKey(publicKeySignedRaw);\n            publicKeySigned = publicKeySignedRaw; // The key recovered is a compressed key\n        }\n        // Obtain the equivalent signing address in all address types (except taproot) to prepare for validation from bitcoinjs-message\n        // Taproot address is not needed since technically BIP-137 signatures does not support taproot address\n        const p2pkhSigningAddressUncompressed = helpers_1.Address.convertPubKeyIntoAddress(publicKeySignedUncompressed, 'p2pkh').mainnet;\n        const p2pkhSigningAddressCompressed = helpers_1.Address.convertPubKeyIntoAddress(publicKeySigned, 'p2pkh').mainnet;\n        const p2shSigningAddress = helpers_1.Address.convertPubKeyIntoAddress(publicKeySigned, 'p2sh-p2wpkh').mainnet;\n        const p2wpkhSigningAddress = helpers_1.Address.convertPubKeyIntoAddress(publicKeySigned, 'p2wpkh').mainnet;\n        // Make sure that public key recovered corresponds to the claimed signing address\n        if (helpers_1.Address.isP2PKH(signerAddress)) {\n            // Derive P2PKH address from both the uncompressed raw public key, and the compressed public key\n            const p2pkhAddressDerivedUncompressed = helpers_1.Address.convertPubKeyIntoAddress(publicKeySignedUncompressed, 'p2pkh');\n            const p2pkhAddressDerivedCompressed = helpers_1.Address.convertPubKeyIntoAddress(publicKeySigned, 'p2pkh');\n            // Assert that the derived address is identical to the claimed signing address\n            if (p2pkhAddressDerivedUncompressed.mainnet !== signerAddress && p2pkhAddressDerivedUncompressed.testnet !== signerAddress &&\n                p2pkhAddressDerivedUncompressed.regtest !== signerAddress &&\n                p2pkhAddressDerivedCompressed.mainnet !== signerAddress && p2pkhAddressDerivedCompressed.testnet !== signerAddress &&\n                p2pkhAddressDerivedCompressed.regtest !== signerAddress) {\n                return false; // Derived address did not match with the claimed signing address\n            }\n        }\n        else if (helpers_1.Address.isP2SH(signerAddress)) {\n            // Assume it is a P2SH-P2WPKH address, derive a P2SH-P2WPKH address based on the public key recovered\n            const p2shAddressDerived = helpers_1.Address.convertPubKeyIntoAddress(publicKeySigned, 'p2sh-p2wpkh');\n            // Assert that the derived address is identical to the claimed signing address\n            if (p2shAddressDerived.mainnet !== signerAddress && p2shAddressDerived.testnet !== signerAddress &&\n                p2shAddressDerived.regtest !== signerAddress) {\n                return false; // Derived address did not match with the claimed signing address\n            }\n        }\n        else if (helpers_1.Address.isP2WPKH(signerAddress)) {\n            // Assume it is a P2WPKH address, derive a P2WPKH address based on the public key recovered\n            const p2wpkhAddressDerived = helpers_1.Address.convertPubKeyIntoAddress(publicKeySigned, 'p2wpkh');\n            // Assert that the derived address is identical to the claimed signing address\n            if (p2wpkhAddressDerived.mainnet !== signerAddress && p2wpkhAddressDerived.testnet !== signerAddress &&\n                p2wpkhAddressDerived.regtest !== signerAddress) {\n                return false; // Derived address did not match with the claimed signing address\n            }\n        }\n        else {\n            // Assume it is a P2TR address, derive a P2TR address based on the public key recovered\n            const p2trAddressDerived = helpers_1.Address.convertPubKeyIntoAddress(publicKeySigned, 'p2tr');\n            // Assert that the derived address is identical to the claimed signing address\n            if (p2trAddressDerived.mainnet !== signerAddress && p2trAddressDerived.testnet !== signerAddress &&\n                p2trAddressDerived.regtest !== signerAddress) {\n                return false; // Derived address did not match with the claimed signing address\n            }\n        }\n        // Validate the signature using bitcoinjs-message if address assertion succeeded\n        // Accept the signature if it originates from any address derivable from the public key\n        const validity = (this.bitcoinMessageVerifyWrap(message, p2pkhSigningAddressUncompressed, signatureBase64) ||\n            this.bitcoinMessageVerifyWrap(message, p2pkhSigningAddressCompressed, signatureBase64) ||\n            this.bitcoinMessageVerifyWrap(message, p2shSigningAddress, signatureBase64) ||\n            this.bitcoinMessageVerifyWrap(message, p2wpkhSigningAddress, signatureBase64));\n        return validity;\n    }\n    /**\n     * Wraps the Bitcoin message verification process to avoid throwing exceptions.\n     * This method attempts to verify a BIP-137 message using the provided address and\n     * signature. It encapsulates the verification process within a try-catch block,\n     * catching any errors that occur during verification and returning false instead\n     * of allowing the exception to propagate.\n     *\n     * The process is as follows:\n     * 1. The `bitcoinjs-message.verify` function is called with the message, address,\n     *    and signature provided in Base64 encoding.\n     * 2. If the verification is successful, the method returns true.\n     * 3. If any error occurs during the verification, the method catches the error\n     *    and returns false, signaling an unsuccessful verification.\n     *\n     * @param message The Bitcoin message to be verified.\n     * @param address The Bitcoin address to which the message is allegedly signed.\n     * @param signatureBase64 The Base64 encoded signature corresponding to the message.\n     * @return boolean Returns true if the message is successfully verified, otherwise false.\n     */\n    static bitcoinMessageVerifyWrap(message, address, signatureBase64) {\n        try {\n            return bitcoinMessage.verify(message, address, signatureBase64);\n        }\n        catch (err) {\n            return false; // Instead of throwing, just return false\n        }\n    }\n    /**\n     * Compute the hash to be signed for a given P2WPKH BIP-322 toSign transaction.\n     * @param toSignTx PSBT instance of the toSign transaction\n     * @returns Computed transaction hash that requires signing\n     */\n    static getHashForSigP2WPKH(toSignTx) {\n        // Create a signing script to unlock the P2WPKH output based on the P2PKH template\n        // Reference: https://github.com/bitcoinjs/bitcoinjs-lib/blob/1a9119b53bcea4b83a6aa8b948f0e6370209b1b4/ts_src/psbt.ts#L1654\n        const signingScript = bitcoin.payments.p2pkh({\n            hash: toSignTx.data.inputs[0].witnessUtxo.script.subarray(2)\n        }).output;\n        // Return computed transaction hash to be signed \n        return toSignTx.extractTransaction().hashForWitnessV0(0, signingScript, 0, bitcoin.Transaction.SIGHASH_ALL);\n    }\n    /**\n     * Compute the hash to be signed for a given P2SH-P2WPKH BIP-322 toSign transaction.\n     * @param toSignTx PSBT instance of the toSign transaction\n     * @param hashedPubkey Hashed public key of the signing address\n     * @returns Computed transaction hash that requires signing\n     */\n    static getHashForSigP2SHInP2WPKH(toSignTx, hashedPubkey) {\n        // Create a signing script to unlock the P2WPKH output based on the P2PKH template\n        // Reference: https://github.com/bitcoinjs/bitcoinjs-lib/blob/1a9119b53bcea4b83a6aa8b948f0e6370209b1b4/ts_src/psbt.ts#L1654\n        // Like P2WPKH, the hash for deriving the meaningfulScript for a P2SH-P2WPKH transaction is its public key hash\n        // It can be derived by hashing the provided public key in the witness stack\n        const signingScript = bitcoin.payments.p2pkh({\n            hash: hashedPubkey\n        }).output;\n        // Return computed transaction hash to be signed \n        return toSignTx.extractTransaction().hashForWitnessV0(0, signingScript, 0, bitcoin.Transaction.SIGHASH_ALL);\n    }\n    /**\n     * Compute the hash to be signed for a given P2TR BIP-322 toSign transaction.\n     * @param toSignTx PSBT instance of the toSign transaction\n     * @param hashType Hash type used to sign the toSign transaction, must be either 0x00 or 0x01\n     * @returns Computed transaction hash that requires signing\n     * @throws Error if hashType is anything other than 0x00 or 0x01\n     */\n    static getHashForSigP2TR(toSignTx, hashType) {\n        // BIP-322 states that 'all signatures must use the SIGHASH_ALL flag'\n        // But, in BIP-341, SIGHASH_DEFAULT (0x00) is equivalent to SIGHASH_ALL (0x01) so both should be allowed \n        if (hashType !== bitcoin.Transaction.SIGHASH_DEFAULT && hashType !== bitcoin.Transaction.SIGHASH_ALL) {\n            // Throw error if hashType is neither SIGHASH_DEFAULT or SIGHASH_ALL\n            throw new Error('Invalid SIGHASH used in signature. Must be either SIGHASH_ALL or SIGHASH_DEFAULT.');\n        }\n        // Return computed transaction hash to be signed\n        return toSignTx.extractTransaction().hashForWitnessV1(0, [toSignTx.data.inputs[0].witnessUtxo.script], [0], hashType);\n    }\n}\nexports.default = Verifier;\n//# sourceMappingURL=Verifier.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeScriptSignature = void 0;\n// Taken from https://github.com/bitcoinjs/bitcoinjs-lib/blob/5d2ff1c61165932e2814d5f37630e6720168561c/ts_src/script_signature.ts#L29\nfunction decodeScriptSignature(buffer) {\n    const hashType = buffer.readUInt8(buffer.length - 1);\n    const hashTypeMod = hashType & ~0x80;\n    if (hashTypeMod <= 0 || hashTypeMod >= 4)\n        throw new Error('Invalid hashType ' + hashType);\n    const decoded = decode2(buffer.slice(0, -1));\n    const r = fromDER(decoded.r);\n    const s = fromDER(decoded.s);\n    const signature = Buffer.concat([r, s], 64);\n    return { signature, hashType };\n}\nexports.decodeScriptSignature = decodeScriptSignature;\nfunction fromDER(x) {\n    if (x[0] === 0x00)\n        x = x.slice(1);\n    const buffer = Buffer.alloc(32, 0);\n    const bstart = Math.max(0, 32 - x.length);\n    x.copy(buffer, bstart);\n    return buffer;\n}\nfunction decode2(buffer) {\n    if (buffer.length < 8)\n        throw new Error('DER sequence length is too short');\n    if (buffer.length > 72)\n        throw new Error('DER sequence length is too long');\n    if (buffer[0] !== 0x30)\n        throw new Error('Expected DER sequence');\n    if (buffer[1] !== buffer.length - 2)\n        throw new Error('DER sequence length is invalid');\n    if (buffer[2] !== 0x02)\n        throw new Error('Expected DER integer');\n    const lenR = buffer[3];\n    if (lenR === 0)\n        throw new Error('R length is zero');\n    if (5 + lenR >= buffer.length)\n        throw new Error('R length is too long');\n    if (buffer[4 + lenR] !== 0x02)\n        throw new Error('Expected DER integer (2)');\n    const lenS = buffer[5 + lenR];\n    if (lenS === 0)\n        throw new Error('S length is zero');\n    if (6 + lenR + lenS !== buffer.length)\n        throw new Error('S length is invalid');\n    if (buffer[4] & 0x80)\n        throw new Error('R value is negative');\n    if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80))\n        throw new Error('R value excessively padded');\n    if (buffer[lenR + 6] & 0x80)\n        throw new Error('S value is negative');\n    if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80))\n        throw new Error('S value excessively padded');\n    // non-BIP66 - extract R, S values\n    return {\n        r: buffer.slice(4, 4 + lenR),\n        s: buffer.slice(6 + lenR),\n    };\n}\n//# sourceMappingURL=DecodeScriptSignature.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeScriptSignature = void 0;\nconst DecodeScriptSignature_1 = require(\"./DecodeScriptSignature\");\nObject.defineProperty(exports, \"decodeScriptSignature\", { enumerable: true, get: function () { return DecodeScriptSignature_1.decodeScriptSignature; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Import dependency\nconst Key_1 = __importDefault(require(\"./Key\"));\nconst bitcoin = __importStar(require(\"bitcoinjs-lib\"));\n/**\n * Class that implement address-related utility functions.\n */\nclass Address {\n    /**\n     * Check if a given Bitcoin address is a pay-to-public-key-hash (p2pkh) address.\n     * @param address Bitcoin address to be checked\n     * @returns True if the provided address correspond to a valid P2PKH address, false if otherwise\n     */\n    static isP2PKH(address) {\n        // Check if the provided address is a P2PKH address\n        if (address[0] === '1' || address[0] === 'm' || address[0] === 'n') {\n            return true; // P2PKH address\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * Check if a given Bitcoin address is a pay-to-script-hash (P2SH) address.\n     * @param address Bitcoin address to be checked\n     * @returns True if the provided address correspond to a valid P2SH address, false if otherwise\n     */\n    static isP2SH(address) {\n        // Check if the provided address is a P2SH address\n        if (address[0] === '3' || address[0] === '2') {\n            return true; // P2SH address\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * Check if a given Bitcoin address is a pay-to-witness-public-key-hash (P2WPKH) address.\n     * @param address Bitcoin address to be checked\n     * @returns True if the provided address correspond to a valid P2WPKH address, false if otherwise\n     */\n    static isP2WPKH(address) {\n        // Check if the provided address is a P2WPKH/P2WSH address\n        if (/^(bc1q|tb1q|bcrt1q)/.test(address)) {\n            // Either a P2WPKH / P2WSH address\n            // Convert the address into a scriptPubKey\n            const scriptPubKey = this.convertAdressToScriptPubkey(address);\n            // Check if the scriptPubKey is exactly 22 bytes since P2WPKH scriptPubKey should be 0014<20-BYTE-PUBKEY-HASH>\n            if (scriptPubKey.byteLength === 22) {\n                return true; // P2WPKH\n            }\n            else {\n                return false; // Not P2WPKH, probably P2WSH\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * Check if a given Bitcoin address is a taproot address.\n     * @param address Bitcoin address to be checked\n     * @returns True if the provided address is a taproot address, false if otherwise\n     */\n    static isP2TR(address) {\n        if (/^(bc1p|tb1p|bcrt1p)/.test(address)) {\n            return true; // P2TR address\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * Check if a given witness stack corresponds to a P2WPKH address.\n     * @param witness Witness data associated with the toSign BIP-322 transaction\n     * @returns True if the provided witness stack correspond to a valid P2WPKH address, false if otherwise\n     */\n    static isP2WPKHWitness(witness) {\n        // Check whether the witness stack is as expected for a P2WPKH address\n        // It should contain exactly two items, with the second item being a public key with 33 bytes, and the first byte must be either 0x02/0x03\n        if (witness.length === 2 && witness[1].byteLength === 33 && (witness[1][0] === 0x02 || witness[1][0] === 0x03)) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * Check if a given witness stack corresponds to a single-key-spend P2TR address.\n     * @param witness Witness data associated with the toSign BIP-322 transaction\n     * @returns True if the provided address and witness stack correspond to a valid single-key-spend P2TR address, false if otherwise\n     */\n    static isSingleKeyP2TRWitness(witness) {\n        // Check whether the witness stack is as expected for a single-key-spend taproot address\n        // It should contain exactly one items which is the signature for the transaction\n        if (witness.length === 1) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * Determine network type by checking addresses prefixes\n     * Reference: https://en.bitcoin.it/wiki/List_of_address_prefixes\n     *\n     * Adopted from https://github.com/ACken2/bip322-js/pull/6 by Czino\n     *\n     * @param address Bitcoin address\n     * @returns Network type\n     * @throws If the address type is not recognized\n     */\n    static getNetworkFromAddess(address) {\n        if (/^(bc1q|bc1p|1|3)/.test(address)) {\n            return bitcoin.networks.bitcoin;\n        }\n        else if (/^(tb1q|tb1p|2|m|n)/.test(address)) {\n            return bitcoin.networks.testnet;\n        }\n        else if (/^(bcrt1q|bcrt1p)/.test(address)) {\n            return bitcoin.networks.regtest;\n        }\n        throw new Error(\"Unknown address type\");\n    }\n    /**\n     * Convert a given Bitcoin address into its corresponding script public key.\n     * Reference: https://github.com/buidl-bitcoin/buidl-python/blob/d79e9808e8ca60975d315be41293cb40d968626d/buidl/script.py#L607\n     * @param address Bitcoin address\n     * @returns Script public key of the given Bitcoin address\n     * @throws Error when the provided address is not a valid Bitcoin address\n     */\n    static convertAdressToScriptPubkey(address) {\n        if (address[0] === '1' || address[0] === 'm' || address[0] === 'n') {\n            // P2PKH address\n            return bitcoin.payments.p2pkh({\n                address: address,\n                network: this.getNetworkFromAddess(address)\n            }).output;\n        }\n        else if (address[0] === '3' || address[0] === '2') {\n            // P2SH address\n            return bitcoin.payments.p2sh({\n                address: address,\n                network: this.getNetworkFromAddess(address)\n            }).output;\n        }\n        else if (/^(bc1q|tb1q|bcrt1q)/.test(address)) {\n            // P2WPKH or P2WSH address\n            if (address.length === 42 || (address.includes('bcrt1q') && address.length === 44)) {\n                // P2WPKH address\n                return bitcoin.payments.p2wpkh({\n                    address: address,\n                    network: this.getNetworkFromAddess(address)\n                }).output;\n            }\n            else if (address.length === 62 || (address.includes('bcrt1q') && address.length === 64)) {\n                // P2WSH address\n                return bitcoin.payments.p2wsh({\n                    address: address,\n                    network: this.getNetworkFromAddess(address)\n                }).output;\n            }\n        }\n        else if (/^(bc1p|tb1p|bcrt1p)/.test(address)) {\n            if (address.length === 62 || (address.includes('bcrt1p') && address.length === 64)) {\n                // P2TR address\n                return bitcoin.payments.p2tr({\n                    address: address,\n                    network: this.getNetworkFromAddess(address)\n                }).output;\n            }\n        }\n        throw new Error(\"Unknown address type\");\n    }\n    /**\n     * Convert a given public key into a corresponding Bitcoin address.\n     * @param publicKey Public key for deriving the address, or internal public key for deriving taproot address\n     * @param addressType Bitcoin address type to be derived, must be either 'p2pkh', 'p2sh-p2wpkh', 'p2wpkh', or 'p2tr'\n     * @returns Bitcoin address that correspond to the given public key in both mainnet and testnet\n     */\n    static convertPubKeyIntoAddress(publicKey, addressType) {\n        switch (addressType) {\n            case 'p2pkh':\n                return {\n                    mainnet: bitcoin.payments.p2pkh({ pubkey: publicKey, network: bitcoin.networks.bitcoin }).address,\n                    testnet: bitcoin.payments.p2pkh({ pubkey: publicKey, network: bitcoin.networks.testnet }).address,\n                    regtest: bitcoin.payments.p2pkh({ pubkey: publicKey, network: bitcoin.networks.regtest }).address\n                };\n            case 'p2sh-p2wpkh':\n                // Reference: https://github.com/bitcoinjs/bitcoinjs-lib/blob/1a9119b53bcea4b83a6aa8b948f0e6370209b1b4/test/integration/addresses.spec.ts#L70\n                return {\n                    mainnet: bitcoin.payments.p2sh({\n                        redeem: bitcoin.payments.p2wpkh({ pubkey: publicKey, network: bitcoin.networks.bitcoin }),\n                        network: bitcoin.networks.bitcoin\n                    }).address,\n                    testnet: bitcoin.payments.p2sh({\n                        redeem: bitcoin.payments.p2wpkh({ pubkey: publicKey, network: bitcoin.networks.testnet }),\n                        network: bitcoin.networks.testnet\n                    }).address,\n                    regtest: bitcoin.payments.p2sh({\n                        redeem: bitcoin.payments.p2wpkh({ pubkey: publicKey, network: bitcoin.networks.regtest }),\n                        network: bitcoin.networks.regtest\n                    }).address\n                };\n            case 'p2wpkh':\n                return {\n                    mainnet: bitcoin.payments.p2wpkh({ pubkey: publicKey, network: bitcoin.networks.bitcoin }).address,\n                    testnet: bitcoin.payments.p2wpkh({ pubkey: publicKey, network: bitcoin.networks.testnet }).address,\n                    regtest: bitcoin.payments.p2wpkh({ pubkey: publicKey, network: bitcoin.networks.regtest }).address\n                };\n            case 'p2tr':\n                // Convert full-length public key into internal public key if necessary\n                const internalPubkey = Key_1.default.toXOnly(publicKey);\n                return {\n                    mainnet: bitcoin.payments.p2tr({ internalPubkey: internalPubkey, network: bitcoin.networks.bitcoin }).address,\n                    testnet: bitcoin.payments.p2tr({ internalPubkey: internalPubkey, network: bitcoin.networks.testnet }).address,\n                    regtest: bitcoin.payments.p2tr({ internalPubkey: internalPubkey, network: bitcoin.networks.regtest }).address\n                };\n            default:\n                throw new Error('Cannot convert public key into unsupported address type.');\n        }\n    }\n    /**\n     * Validates a given Bitcoin address.\n     * This method checks if the provided Bitcoin address is valid by attempting to decode it\n     * for different Bitcoin networks: mainnet, testnet, and regtest. The method uses the\n     * bitcoinjs-lib's address module for decoding.\n     *\n     * The process is as follows:\n     * 1. Attempt to decode the address for the Bitcoin mainnet. If decoding succeeds,\n     *    the method returns true, indicating the address is valid for mainnet.\n     * 2. If the first step fails, catch the resulting error and attempt to decode the\n     *    address for the Bitcoin testnet. If decoding succeeds, the method returns true,\n     *    indicating the address is valid for testnet.\n     * 3. If the second step fails, catch the resulting error and attempt to decode the\n     *    address for the Bitcoin regtest network. If decoding succeeds, the method returns\n     *    true, indicating the address is valid for regtest.\n     * 4. If all attempts fail, the method returns false, indicating the address is not valid\n     *    for any of the checked networks.\n     *\n     * @param address The Bitcoin address to validate.\n     * @return boolean Returns true if the address is valid for any of the Bitcoin networks,\n     *                 otherwise returns false.\n     */\n    static isValidBitcoinAddress(address) {\n        try {\n            // Attempt to decode the address using bitcoinjs-lib's address module at mainnet\n            bitcoin.address.toOutputScript(address, bitcoin.networks.bitcoin);\n            return true; // If decoding succeeds, the address is valid\n        }\n        catch (error) { }\n        try {\n            // Attempt to decode the address using bitcoinjs-lib's address module at testnet\n            bitcoin.address.toOutputScript(address, bitcoin.networks.testnet);\n            return true; // If decoding succeeds, the address is valid\n        }\n        catch (error) { }\n        try {\n            // Attempt to decode the address using bitcoinjs-lib's address module at regtest\n            bitcoin.address.toOutputScript(address, bitcoin.networks.regtest);\n            return true; // If decoding succeeds, the address is valid\n        }\n        catch (error) { }\n        return false; // Probably not a valid address\n    }\n}\nexports.default = Address;\n//# sourceMappingURL=Address.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Import dependencies\nconst secp256k1_1 = __importDefault(require(\"secp256k1\"));\nconst bitcoinMessage = __importStar(require(\"bitcoinjs-message\"));\n/**\n * Class that implement BIP137-related utility functions.\n */\nclass BIP137 {\n    /**\n     * Check if a given signature satisified the format of a BIP-137 signature.\n     * @param signature Base64-encoded signature to be checked\n     * @returns True if the provided signature correspond to a valid BIP-137 signature, false if otherwise\n     */\n    static isBIP137Signature(signature) {\n        // Check if the provided signature satisified the format of a BIP-137 signature\n        const signatureBuffer = Buffer.from(signature, 'base64');\n        if (signatureBuffer.byteLength === 65) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * Derive the public key that signed a valid BIP-137 signature.\n     * @param message Message signed by the signature\n     * @param signature Base-64 encoded signature to be decoded\n     * @returns Public key that signs the provided signature\n     */\n    static derivePubKey(message, signature) {\n        // Compute the hash signed by the signer\n        const messageHash = bitcoinMessage.magicHash(message);\n        // Decode the provided BIP-137 signature\n        const signatureDecoded = this.decodeSignature(Buffer.from(signature, 'base64'));\n        // Recover the public key\n        return Buffer.from(secp256k1_1.default.ecdsaRecover(signatureDecoded.signature, signatureDecoded.recovery, messageHash, signatureDecoded.compressed));\n    }\n    /**\n     * Decode a BIP-137 signature.\n     * Function copied from bitcoinjs-message library.\n     * @param signature BIP-137 signature to be decoded\n     * @returns Decoded BIP-137 signature\n     */\n    static decodeSignature(signature) {\n        if (signature.length !== 65)\n            throw new Error('Invalid signature length');\n        const flagByte = signature.readUInt8(0) - 27;\n        if (flagByte > 19 || flagByte < 0) {\n            throw new Error('Invalid signature parameter');\n        }\n        return {\n            compressed: !!(flagByte & 12),\n            recovery: flagByte & 3,\n            signature: signature.subarray(1)\n        };\n    }\n}\nexports.default = BIP137;\n//# sourceMappingURL=BIP137.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst elliptic_1 = require(\"elliptic\");\n/**\n * Class that implement key-related utility functions.\n */\nclass Key {\n    /**\n     * Converts a 33-byte Bitcoin public key to a 32-byte x-only public key as used in Taproot.\n     * This function checks if the provided public key buffer is already 32 bytes long,\n     * in which case it returns the buffer unchanged. If the buffer is 33 bytes long, it\n     * assumes that the first byte is the parity byte used for indicating the y-coordinate\n     * in traditional SEC1 encoding and removes this byte, thereby converting the public key\n     * to an x-only format suitable for use with Bitcoin's Taproot.\n     *\n     * Adopted from https://github.com/ACken2/bip322-js/pull/6 by Czino\n     *\n     * @param publicKey The buffer containing the 33-byte or 32-byte public key to be converted.\n     * @returns A 32-byte buffer of the x-only public key.\n     * @throws If the public key is neither 32-byte nor 33-byte long\n     */\n    static toXOnly(publicKey) {\n        // Throw if the input key length is invalid\n        if (publicKey.length !== 32 && publicKey.length !== 33) {\n            throw new Error(\"Invalid public key length\");\n        }\n        // Otherwise, return the key (with the first byte removed if it is 33-byte long)\n        return Buffer.from(publicKey.length === 32 ? publicKey : publicKey.subarray(1, 33));\n    }\n    /**\n     * Compresses an uncompressed public key using the elliptic curve secp256k1.\n     * This method takes a public key in its uncompressed form and returns a compressed\n     * representation of the public key. Elliptic curve public keys can be represented in\n     * a shorter form known as compressed format which saves space and still retains the\n     * full public key's capabilities. The method uses the elliptic library to convert the\n     * uncompressed public key into its compressed form.\n     *\n     * The steps involved in the process are:\n     * 1. Initialize a new elliptic curve instance for the secp256k1 curve.\n     * 2. Create a key pair object from the uncompressed public key buffer.\n     * 3. Extract the compressed public key from the key pair object.\n     * 4. Return the compressed public key as a Buffer object.\n     *\n     * @param uncompressedPublicKey A Buffer containing the uncompressed public key.\n     * @return Buffer Returns a Buffer containing the compressed public key.\n     * @throws Error Throws an error if the provided public key cannot be compressed,\n     *         typically indicating that the key is not valid.\n     */\n    static compressPublicKey(uncompressedPublicKey) {\n        // Initialize elliptic curve\n        const ec = new elliptic_1.ec('secp256k1');\n        // Try to compress the provided public key\n        try {\n            // Create a key pair from the uncompressed public key buffer\n            const keyPair = ec.keyFromPublic(Buffer.from(uncompressedPublicKey));\n            // Get the compressed public key as a Buffer\n            const compressedPublicKey = Buffer.from(keyPair.getPublic(true, 'array'));\n            return compressedPublicKey;\n        }\n        catch (err) {\n            throw new Error('Fails to compress the provided public key. Please check if the provided key is a valid uncompressed public key.');\n        }\n    }\n    /**\n     * Uncompresses a given public key using the elliptic curve secp256k1.\n     * This method accepts a compressed public key and attempts to convert it into its\n     * uncompressed form. Public keys are often compressed to save space, but certain\n     * operations require the full uncompressed key. This method uses the elliptic\n     * library to perform the conversion.\n     *\n     * The function operates as follows:\n     * 1. Initialize a new elliptic curve instance using secp256k1.\n     * 2. Attempt to create a key pair from the compressed public key buffer.\n     * 3. Extract the uncompressed public key from the key pair object.\n     * 4. Return the uncompressed public key as a Buffer object.\n     * If the compressed public key provided is invalid and cannot be uncompressed,\n     * the method will throw an error with a descriptive message.\n     *\n     * @param compressedPublicKey A Buffer containing the compressed public key.\n     * @return Buffer The uncompressed public key as a Buffer.\n     * @throws Error Throws an error if the provided public key cannot be uncompressed,\n     *         typically indicating that the key is not valid.\n     */\n    static uncompressPublicKey(compressedPublicKey) {\n        // Initialize elliptic curve\n        const ec = new elliptic_1.ec('secp256k1');\n        // Try to uncompress the provided public key\n        try {\n            // Create a key pair from the compressed public key buffer\n            const keyPair = ec.keyFromPublic(Buffer.from(compressedPublicKey));\n            // Get the compressed public key as a Buffer\n            const uncompressedPublicKey = Buffer.from(keyPair.getPublic(false, 'array'));\n            return uncompressedPublicKey;\n        }\n        catch (err) {\n            throw new Error('Fails to uncompress the provided public key. Please check if the provided key is a valid compressed public key.');\n        }\n    }\n}\nexports.default = Key;\n//# sourceMappingURL=Key.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Class that implement variable length integer (VarInt) in Javascript.\n * Reference: https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer\n */\nclass VarInt {\n    /**\n     * Encode an integer i as a variable length integer.\n     * Reference: https://github.com/buidl-bitcoin/buidl-python/blob/d79e9808e8ca60975d315be41293cb40d968626d/buidl/helper.py#L180\n     * @param i Integer to be encoded\n     * @returns Encoded varint\n     */\n    static encode(i) {\n        if (i < 0xFD) {\n            const buffer = Buffer.alloc(1);\n            buffer.writeUInt8(i);\n            return buffer;\n        }\n        else if (i < 0x10000) {\n            const buffer = Buffer.alloc(3);\n            buffer.writeUInt8(0xfd);\n            buffer.writeUInt16LE(i, 1);\n            return buffer;\n        }\n        else if (i < 0x100000000) {\n            const buffer = Buffer.alloc(5);\n            buffer.writeUInt8(0xfe);\n            buffer.writeUInt32LE(i, 1);\n            return buffer;\n        }\n        else if (i < 0x1000000000000) {\n            const buffer = Buffer.alloc(9);\n            buffer.writeUInt8(0xff);\n            buffer.writeUIntLE(i, 1, 6); // Cannot write UInt64LE in Node JS\n            buffer.writeUInt8(0x00, 7); // Pad two extra 0x00 at the end to emulate UInt64LE\n            buffer.writeUInt8(0x00, 8);\n            return buffer;\n        }\n        else {\n            throw new Error(`Integer too large: ${i}`);\n        }\n    }\n    /**\n     * Decode a variable length integer from a Buffer into a number.\n     * Reference: https://github.com/buidl-bitcoin/buidl-python/blob/d79e9808e8ca60975d315be41293cb40d968626d/buidl/helper.py#L160\n     * @param b Buffer which contain the varint\n     * @returns Decoded number\n     */\n    static decode(b) {\n        // Check for empty buffer\n        if (b.byteLength === 0) {\n            throw new Error('Empty buffer provided');\n        }\n        // Read first byte from the buffer\n        const i = b.readUInt8();\n        // Check if i is indicating its length\n        if (i === 0xfd) {\n            // 0xfd means the next two bytes are the number\n            return b.readUInt16LE(1);\n        }\n        else if (i === 0xfe) {\n            // 0xfe means the next four bytes are the number\n            return b.readUInt32LE(1);\n        }\n        else if (i === 0xff) {\n            // 0xff means the next eight bytes are the number, but Node JS can only read up to 6 bytes\n            return b.readUIntLE(1, 6);\n        }\n        else {\n            // Anything else is just the integer\n            return i;\n        }\n    }\n}\nexports.default = VarInt;\n//# sourceMappingURL=VarInt.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Import dependency\nconst VarInt_1 = __importDefault(require(\"./VarInt\"));\n/**\n * Class that implement variable length string (VarStr) in Javascript.\n * Reference: https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_string\n */\nclass VarStr {\n    /**\n     * Encode a string buffer as a variable length string.\n     * Reference: https://github.com/buidl-bitcoin/buidl-python/blob/d79e9808e8ca60975d315be41293cb40d968626d/buidl/helper.py#L203\n     * @param s String buffer to be encoded\n     * @returns Encoded varstr\n     */\n    static encode(s) {\n        // Encode the length of the string using encodeVarInt\n        const lengthBuffer = VarInt_1.default.encode(s.length);\n        // Concat the actual string right after the length of the string\n        return Buffer.concat([lengthBuffer, s]);\n    }\n    /**\n     * Decode a variable length string from a Buffer into a string buffer.\n     * Reference: https://github.com/buidl-bitcoin/buidl-python/blob/d79e9808e8ca60975d315be41293cb40d968626d/buidl/helper.py#L194\n     * @param v Varstr to be decoded\n     * @returns Decoded string buffer\n     */\n    static decode(v) {\n        // Find the length of the string by using read_varint on the string\n        const length = VarInt_1.default.decode(v);\n        // Get the length of the VarInt used to represent the length of the string\n        const lengthByteLength = VarInt_1.default.encode(length).byteLength;\n        // Return from lengthByteLength to (length + lengthByteLength) in the buffer which contain the actual string\n        return v.subarray(lengthByteLength, length + lengthByteLength);\n    }\n}\nexports.default = VarStr;\n//# sourceMappingURL=VarStr.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Import dependencies\nconst VarInt_1 = __importDefault(require(\"./VarInt\"));\nconst VarStr_1 = __importDefault(require(\"./VarStr\"));\n/**\n * Class that implement witness data serialization and deserialization.\n */\nclass Witness {\n    /**\n     * Encode array of witness into its base-64 encoded format.\n     * Follows the encoding scheme found in buidl-python:\n     *      https://github.com/buidl-bitcoin/buidl-python/blob/d79e9808e8ca60975d315be41293cb40d968626d/buidl/witness.py#L35\n     * @param witnesses Array of witness data\n     * @returns Base-64 encoded witness data\n     */\n    static serialize(witnesses) {\n        // The first element to be included is the length of the witness array as VarInt\n        let witnessStack = VarInt_1.default.encode(witnesses.length);\n        // Then, for each witness array,\n        witnesses.forEach((witness) => {\n            // Append each witness as a VarStr to the witness stack\n            witnessStack = Buffer.concat([witnessStack, VarStr_1.default.encode(Buffer.from(witness))]);\n        });\n        // Return the base-64 encoded witness stack\n        return witnessStack.toString('base64');\n    }\n    /**\n     * Decode encoded witness data, either as a base-64 encoded string or as a decoded string in a buffer, into an array of witness.\n     * Follows the decoding scheme found in buidl-python:\n     *      https://github.com/buidl-bitcoin/buidl-python/blob/d79e9808e8ca60975d315be41293cb40d968626d/buidl/witness.py#L62\n     * @param encodedWitness Base-64 encoded witness data, or encoded witness data that have already been decoded\n     * @returns Decoded witness data\n     */\n    static deserialize(encodedWitness) {\n        // Store the decoded witness stack\n        let witnessDecoded = [];\n        // Preprocess the encodedWitness if needed\n        let witnessToDecode;\n        if (typeof encodedWitness === 'string') {\n            // Decode the encoded witness if it is a string (assuming it is encoded using base-64)\n            witnessToDecode = Buffer.from(encodedWitness, 'base64');\n        }\n        else {\n            witnessToDecode = encodedWitness;\n        }\n        // Read a VarInt which indicate the number of elements within the original witness array\n        const witnessCount = VarInt_1.default.decode(witnessToDecode);\n        // Slice the VarInt in front of the witness buffer before decoding each witness\n        const varIntLength = VarInt_1.default.encode(witnessCount).byteLength;\n        witnessToDecode = witnessToDecode.subarray(varIntLength);\n        // Loop for each witness encoded\n        for (let i = 0; i < witnessCount; i++) {\n            // Read a VarStr from the remaining buffer\n            const witness = VarStr_1.default.decode(witnessToDecode);\n            // Append the decoded witness to witnessDecoded\n            witnessDecoded.push(witness);\n            // Slice the read witness off witnessToDecode before next iteration\n            const witnessLength = VarStr_1.default.encode(witness).byteLength;\n            witnessToDecode = witnessToDecode.subarray(witnessLength);\n        }\n        // Return deserialized witness data\n        return witnessDecoded;\n    }\n}\nexports.default = Witness;\n//# sourceMappingURL=Witness.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Witness = exports.VarStr = exports.VarInt = exports.Key = exports.BIP137 = exports.Address = void 0;\nconst Address_1 = __importDefault(require(\"./Address\"));\nexports.Address = Address_1.default;\nconst BIP137_1 = __importDefault(require(\"./BIP137\"));\nexports.BIP137 = BIP137_1.default;\nconst Key_1 = __importDefault(require(\"./Key\"));\nexports.Key = Key_1.default;\nconst VarInt_1 = __importDefault(require(\"./VarInt\"));\nexports.VarInt = VarInt_1.default;\nconst VarStr_1 = __importDefault(require(\"./VarStr\"));\nexports.VarStr = VarStr_1.default;\nconst Witness_1 = __importDefault(require(\"./Witness\"));\nexports.Witness = Witness_1.default;\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Witness = exports.Key = exports.BIP137 = exports.Address = exports.Verifier = exports.Signer = exports.BIP322 = void 0;\n// Import modules to be exported\nconst BIP322_1 = __importDefault(require(\"./BIP322\"));\nexports.BIP322 = BIP322_1.default;\nconst Signer_1 = __importDefault(require(\"./Signer\"));\nexports.Signer = Signer_1.default;\nconst Verifier_1 = __importDefault(require(\"./Verifier\"));\nexports.Verifier = Verifier_1.default;\nconst helpers_1 = require(\"./helpers\");\nObject.defineProperty(exports, \"Address\", { enumerable: true, get: function () { return helpers_1.Address; } });\nObject.defineProperty(exports, \"BIP137\", { enumerable: true, get: function () { return helpers_1.BIP137; } });\nObject.defineProperty(exports, \"Key\", { enumerable: true, get: function () { return helpers_1.Key; } });\nObject.defineProperty(exports, \"Witness\", { enumerable: true, get: function () { return helpers_1.Witness; } });\n// Provide a ECC library to bitcoinjs-lib\nconst secp256k1_1 = __importDefault(require(\"@bitcoinerlab/secp256k1\"));\nconst bitcoin = __importStar(require(\"bitcoinjs-lib\"));\nbitcoin.initEccLib(secp256k1_1.default);\n//# sourceMappingURL=index.js.map","module.exports = require('./lib')(require('./lib/elliptic'))\n","const EC = require('elliptic').ec\n\nconst ec = new EC('secp256k1')\nconst ecparams = ec.curve\n\n// Hack, we can not use bn.js@5, while elliptic uses bn.js@4\n// See https://github.com/indutny/elliptic/issues/191#issuecomment-569888758\nconst BN = ecparams.n.constructor\n\nfunction loadCompressedPublicKey (first, xbuf) {\n  let x = new BN(xbuf)\n\n  // overflow\n  if (x.cmp(ecparams.p) >= 0) return null\n  x = x.toRed(ecparams.red)\n\n  // compute corresponding Y\n  let y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt()\n  if ((first === 0x03) !== y.isOdd()) y = y.redNeg()\n\n  // x*x*x + b = y*y\n  const x3 = x.redSqr().redIMul(x)\n  if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null\n\n  return ec.keyPair({ pub: { x: x, y: y } })\n}\n\nfunction loadUncompressedPublicKey (first, xbuf, ybuf) {\n  let x = new BN(xbuf)\n  let y = new BN(ybuf)\n\n  // overflow\n  if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null\n\n  x = x.toRed(ecparams.red)\n  y = y.toRed(ecparams.red)\n\n  // is odd flag\n  if ((first === 0x06 || first === 0x07) && y.isOdd() !== (first === 0x07)) return null\n\n  // x*x*x + b = y*y\n  const x3 = x.redSqr().redIMul(x)\n  if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null\n\n  return ec.keyPair({ pub: { x: x, y: y } })\n}\n\nfunction loadPublicKey (pubkey) {\n  // length should be validated in interface\n  const first = pubkey[0]\n  switch (first) {\n    case 0x02:\n    case 0x03:\n      if (pubkey.length !== 33) return null\n      return loadCompressedPublicKey(first, pubkey.subarray(1, 33))\n    case 0x04:\n    case 0x06:\n    case 0x07:\n      if (pubkey.length !== 65) return null\n      return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65))\n    default:\n      return null\n  }\n}\n\nfunction savePublicKey (output, point) {\n  const pubkey = point.encode(null, output.length === 33)\n  // Loop should be faster because we do not need create extra Uint8Array\n  // output.set(new Uint8Array(pubkey))\n  for (let i = 0; i < output.length; ++i) output[i] = pubkey[i]\n}\n\nmodule.exports = {\n  contextRandomize () {\n    return 0\n  },\n\n  privateKeyVerify (seckey) {\n    const bn = new BN(seckey)\n    return bn.cmp(ecparams.n) < 0 && !bn.isZero() ? 0 : 1\n  },\n\n  privateKeyNegate (seckey) {\n    const bn = new BN(seckey)\n    const negate = ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Uint8Array, 'be', 32)\n    seckey.set(negate)\n    return 0\n  },\n\n  privateKeyTweakAdd (seckey, tweak) {\n    const bn = new BN(tweak)\n    if (bn.cmp(ecparams.n) >= 0) return 1\n\n    bn.iadd(new BN(seckey))\n    if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n)\n    if (bn.isZero()) return 1\n\n    const tweaked = bn.toArrayLike(Uint8Array, 'be', 32)\n    seckey.set(tweaked)\n\n    return 0\n  },\n\n  privateKeyTweakMul (seckey, tweak) {\n    let bn = new BN(tweak)\n    if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1\n\n    bn.imul(new BN(seckey))\n    if (bn.cmp(ecparams.n) >= 0) bn = bn.umod(ecparams.n)\n\n    const tweaked = bn.toArrayLike(Uint8Array, 'be', 32)\n    seckey.set(tweaked)\n\n    return 0\n  },\n\n  publicKeyVerify (pubkey) {\n    const pair = loadPublicKey(pubkey)\n    return pair === null ? 1 : 0\n  },\n\n  publicKeyCreate (output, seckey) {\n    const bn = new BN(seckey)\n    if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1\n\n    const point = ec.keyFromPrivate(seckey).getPublic()\n    savePublicKey(output, point)\n\n    return 0\n  },\n\n  publicKeyConvert (output, pubkey) {\n    const pair = loadPublicKey(pubkey)\n    if (pair === null) return 1\n\n    const point = pair.getPublic()\n    savePublicKey(output, point)\n\n    return 0\n  },\n\n  publicKeyNegate (output, pubkey) {\n    const pair = loadPublicKey(pubkey)\n    if (pair === null) return 1\n\n    const point = pair.getPublic()\n    point.y = point.y.redNeg()\n    savePublicKey(output, point)\n\n    return 0\n  },\n\n  publicKeyCombine (output, pubkeys) {\n    const pairs = new Array(pubkeys.length)\n    for (let i = 0; i < pubkeys.length; ++i) {\n      pairs[i] = loadPublicKey(pubkeys[i])\n      if (pairs[i] === null) return 1\n    }\n\n    let point = pairs[0].getPublic()\n    for (let i = 1; i < pairs.length; ++i) point = point.add(pairs[i].pub)\n    if (point.isInfinity()) return 2\n\n    savePublicKey(output, point)\n\n    return 0\n  },\n\n  publicKeyTweakAdd (output, pubkey, tweak) {\n    const pair = loadPublicKey(pubkey)\n    if (pair === null) return 1\n\n    tweak = new BN(tweak)\n    if (tweak.cmp(ecparams.n) >= 0) return 2\n\n    const point = pair.getPublic().add(ecparams.g.mul(tweak))\n    if (point.isInfinity()) return 2\n\n    savePublicKey(output, point)\n\n    return 0\n  },\n\n  publicKeyTweakMul (output, pubkey, tweak) {\n    const pair = loadPublicKey(pubkey)\n    if (pair === null) return 1\n\n    tweak = new BN(tweak)\n    if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) return 2\n\n    const point = pair.getPublic().mul(tweak)\n    savePublicKey(output, point)\n\n    return 0\n  },\n\n  signatureNormalize (sig) {\n    const r = new BN(sig.subarray(0, 32))\n    const s = new BN(sig.subarray(32, 64))\n    if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) return 1\n\n    if (s.cmp(ec.nh) === 1) {\n      sig.set(ecparams.n.sub(s).toArrayLike(Uint8Array, 'be', 32), 32)\n    }\n\n    return 0\n  },\n\n  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js\n  // Adapted for Uint8Array instead Buffer\n  signatureExport (obj, sig) {\n    const sigR = sig.subarray(0, 32)\n    const sigS = sig.subarray(32, 64)\n    if (new BN(sigR).cmp(ecparams.n) >= 0) return 1\n    if (new BN(sigS).cmp(ecparams.n) >= 0) return 1\n\n    const { output } = obj\n\n    // Prepare R\n    let r = output.subarray(4, 4 + 33)\n    r[0] = 0x00\n    r.set(sigR, 1)\n\n    let lenR = 33\n    let posR = 0\n    for (; lenR > 1 && r[posR] === 0x00 && !(r[posR + 1] & 0x80); --lenR, ++posR);\n\n    r = r.subarray(posR)\n    if (r[0] & 0x80) return 1\n    if (lenR > 1 && (r[0] === 0x00) && !(r[1] & 0x80)) return 1\n\n    // Prepare S\n    let s = output.subarray(6 + 33, 6 + 33 + 33)\n    s[0] = 0x00\n    s.set(sigS, 1)\n\n    let lenS = 33\n    let posS = 0\n    for (; lenS > 1 && s[posS] === 0x00 && !(s[posS + 1] & 0x80); --lenS, ++posS);\n\n    s = s.subarray(posS)\n    if (s[0] & 0x80) return 1\n    if (lenS > 1 && (s[0] === 0x00) && !(s[1] & 0x80)) return 1\n\n    // Set output length for return\n    obj.outputlen = 6 + lenR + lenS\n\n    // Output in specified format\n    // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]\n    output[0] = 0x30\n    output[1] = obj.outputlen - 2\n    output[2] = 0x02\n    output[3] = r.length\n    output.set(r, 4)\n    output[4 + lenR] = 0x02\n    output[5 + lenR] = s.length\n    output.set(s, 6 + lenR)\n\n    return 0\n  },\n\n  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js\n  // Adapted for Uint8Array instead Buffer\n  signatureImport (output, sig) {\n    if (sig.length < 8) return 1\n    if (sig.length > 72) return 1\n    if (sig[0] !== 0x30) return 1\n    if (sig[1] !== sig.length - 2) return 1\n    if (sig[2] !== 0x02) return 1\n\n    const lenR = sig[3]\n    if (lenR === 0) return 1\n    if (5 + lenR >= sig.length) return 1\n    if (sig[4 + lenR] !== 0x02) return 1\n\n    const lenS = sig[5 + lenR]\n    if (lenS === 0) return 1\n    if ((6 + lenR + lenS) !== sig.length) return 1\n\n    if (sig[4] & 0x80) return 1\n    if (lenR > 1 && (sig[4] === 0x00) && !(sig[5] & 0x80)) return 1\n\n    if (sig[lenR + 6] & 0x80) return 1\n    if (lenS > 1 && (sig[lenR + 6] === 0x00) && !(sig[lenR + 7] & 0x80)) return 1\n\n    let sigR = sig.subarray(4, 4 + lenR)\n    if (sigR.length === 33 && sigR[0] === 0x00) sigR = sigR.subarray(1)\n    if (sigR.length > 32) return 1\n\n    let sigS = sig.subarray(6 + lenR)\n    if (sigS.length === 33 && sigS[0] === 0x00) sigS = sigS.slice(1)\n    if (sigS.length > 32) throw new Error('S length is too long')\n\n    let r = new BN(sigR)\n    if (r.cmp(ecparams.n) >= 0) r = new BN(0)\n\n    let s = new BN(sig.subarray(6 + lenR))\n    if (s.cmp(ecparams.n) >= 0) s = new BN(0)\n\n    output.set(r.toArrayLike(Uint8Array, 'be', 32), 0)\n    output.set(s.toArrayLike(Uint8Array, 'be', 32), 32)\n\n    return 0\n  },\n\n  ecdsaSign (obj, message, seckey, data, noncefn) {\n    if (noncefn) {\n      const _noncefn = noncefn\n      noncefn = (counter) => {\n        const nonce = _noncefn(message, seckey, null, data, counter)\n\n        const isValid = nonce instanceof Uint8Array && nonce.length === 32\n        if (!isValid) throw new Error('This is the way')\n\n        return new BN(nonce)\n      }\n    }\n\n    const d = new BN(seckey)\n    if (d.cmp(ecparams.n) >= 0 || d.isZero()) return 1\n\n    let sig\n    try {\n      sig = ec.sign(message, seckey, { canonical: true, k: noncefn, pers: data })\n    } catch (err) {\n      return 1\n    }\n\n    obj.signature.set(sig.r.toArrayLike(Uint8Array, 'be', 32), 0)\n    obj.signature.set(sig.s.toArrayLike(Uint8Array, 'be', 32), 32)\n    obj.recid = sig.recoveryParam\n\n    return 0\n  },\n\n  ecdsaVerify (sig, msg32, pubkey) {\n    const sigObj = { r: sig.subarray(0, 32), s: sig.subarray(32, 64) }\n\n    const sigr = new BN(sigObj.r)\n    const sigs = new BN(sigObj.s)\n    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1\n    if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return 3\n\n    const pair = loadPublicKey(pubkey)\n    if (pair === null) return 2\n\n    const point = pair.getPublic()\n    const isValid = ec.verify(msg32, sigObj, point)\n    return isValid ? 0 : 3\n  },\n\n  ecdsaRecover (output, sig, recid, msg32) {\n    const sigObj = { r: sig.slice(0, 32), s: sig.slice(32, 64) }\n\n    const sigr = new BN(sigObj.r)\n    const sigs = new BN(sigObj.s)\n    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1\n\n    if (sigr.isZero() || sigs.isZero()) return 2\n\n    // Can throw `throw new Error('Unable to find sencond key candinate');`\n    let point\n    try {\n      point = ec.recoverPubKey(msg32, sigObj, recid)\n    } catch (err) {\n      return 2\n    }\n\n    savePublicKey(output, point)\n\n    return 0\n  },\n\n  ecdh (output, pubkey, seckey, data, hashfn, xbuf, ybuf) {\n    const pair = loadPublicKey(pubkey)\n    if (pair === null) return 1\n\n    const scalar = new BN(seckey)\n    if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) return 2\n\n    const point = pair.getPublic().mul(scalar)\n\n    if (hashfn === undefined) {\n      const data = point.encode(null, true)\n      const sha256 = ec.hash().update(data).digest()\n      for (let i = 0; i < 32; ++i) output[i] = sha256[i]\n    } else {\n      if (!xbuf) xbuf = new Uint8Array(32)\n      const x = point.getX().toArray('be', 32)\n      for (let i = 0; i < 32; ++i) xbuf[i] = x[i]\n\n      if (!ybuf) ybuf = new Uint8Array(32)\n      const y = point.getY().toArray('be', 32)\n      for (let i = 0; i < 32; ++i) ybuf[i] = y[i]\n\n      const hash = hashfn(xbuf, ybuf, data)\n\n      const isValid = hash instanceof Uint8Array && hash.length === output.length\n      if (!isValid) return 2\n\n      output.set(hash)\n    }\n\n    return 0\n  }\n}\n","const errors = {\n  IMPOSSIBLE_CASE: 'Impossible case. Please create issue.',\n  TWEAK_ADD:\n    'The tweak was out of range or the resulted private key is invalid',\n  TWEAK_MUL: 'The tweak was out of range or equal to zero',\n  CONTEXT_RANDOMIZE_UNKNOW: 'Unknow error on context randomization',\n  SECKEY_INVALID: 'Private Key is invalid',\n  PUBKEY_PARSE: 'Public Key could not be parsed',\n  PUBKEY_SERIALIZE: 'Public Key serialization error',\n  PUBKEY_COMBINE: 'The sum of the public keys is not valid',\n  SIG_PARSE: 'Signature could not be parsed',\n  SIGN: 'The nonce generation function failed, or the private key was invalid',\n  RECOVER: 'Public key could not be recover',\n  ECDH: 'Scalar was invalid (zero or overflow)'\n}\n\nfunction assert (cond, msg) {\n  if (!cond) throw new Error(msg)\n}\n\nfunction isUint8Array (name, value, length) {\n  assert(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`)\n\n  if (length !== undefined) {\n    if (Array.isArray(length)) {\n      const numbers = length.join(', ')\n      const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`\n      assert(length.includes(value.length), msg)\n    } else {\n      const msg = `Expected ${name} to be an Uint8Array with length ${length}`\n      assert(value.length === length, msg)\n    }\n  }\n}\n\nfunction isCompressed (value) {\n  assert(toTypeString(value) === 'Boolean', 'Expected compressed to be a Boolean')\n}\n\nfunction getAssertedOutput (output = (len) => new Uint8Array(len), length) {\n  if (typeof output === 'function') output = output(length)\n  isUint8Array('output', output, length)\n  return output\n}\n\nfunction toTypeString (value) {\n  return Object.prototype.toString.call(value).slice(8, -1)\n}\n\nmodule.exports = (secp256k1) => {\n  return {\n    contextRandomize (seed) {\n      assert(\n        seed === null || seed instanceof Uint8Array,\n        'Expected seed to be an Uint8Array or null'\n      )\n      if (seed !== null) isUint8Array('seed', seed, 32)\n\n      switch (secp256k1.contextRandomize(seed)) {\n        case 1:\n          throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW)\n      }\n    },\n\n    privateKeyVerify (seckey) {\n      isUint8Array('private key', seckey, 32)\n\n      return secp256k1.privateKeyVerify(seckey) === 0\n    },\n\n    privateKeyNegate (seckey) {\n      isUint8Array('private key', seckey, 32)\n\n      switch (secp256k1.privateKeyNegate(seckey)) {\n        case 0:\n          return seckey\n        case 1:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    privateKeyTweakAdd (seckey, tweak) {\n      isUint8Array('private key', seckey, 32)\n      isUint8Array('tweak', tweak, 32)\n\n      switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {\n        case 0:\n          return seckey\n        case 1:\n          throw new Error(errors.TWEAK_ADD)\n      }\n    },\n\n    privateKeyTweakMul (seckey, tweak) {\n      isUint8Array('private key', seckey, 32)\n      isUint8Array('tweak', tweak, 32)\n\n      switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {\n        case 0:\n          return seckey\n        case 1:\n          throw new Error(errors.TWEAK_MUL)\n      }\n    },\n\n    publicKeyVerify (pubkey) {\n      isUint8Array('public key', pubkey, [33, 65])\n\n      return secp256k1.publicKeyVerify(pubkey) === 0\n    },\n\n    publicKeyCreate (seckey, compressed = true, output) {\n      isUint8Array('private key', seckey, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyCreate(output, seckey)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.SECKEY_INVALID)\n        case 2:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyConvert (pubkey, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyConvert(output, pubkey)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyNegate (pubkey, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyNegate(output, pubkey)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n        case 3:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyCombine (pubkeys, compressed = true, output) {\n      assert(Array.isArray(pubkeys), 'Expected public keys to be an Array')\n      assert(pubkeys.length > 0, 'Expected public keys array will have more than zero items')\n      for (const pubkey of pubkeys) {\n        isUint8Array('public key', pubkey, [33, 65])\n      }\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyCombine(output, pubkeys)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.PUBKEY_COMBINE)\n        case 3:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyTweakAdd (pubkey, tweak, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isUint8Array('tweak', tweak, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.TWEAK_ADD)\n      }\n    },\n\n    publicKeyTweakMul (pubkey, tweak, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isUint8Array('tweak', tweak, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.TWEAK_MUL)\n      }\n    },\n\n    signatureNormalize (sig) {\n      isUint8Array('signature', sig, 64)\n\n      switch (secp256k1.signatureNormalize(sig)) {\n        case 0:\n          return sig\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n      }\n    },\n\n    signatureExport (sig, output) {\n      isUint8Array('signature', sig, 64)\n      output = getAssertedOutput(output, 72)\n\n      const obj = { output, outputlen: 72 }\n      switch (secp256k1.signatureExport(obj, sig)) {\n        case 0:\n          return output.slice(0, obj.outputlen)\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    signatureImport (sig, output) {\n      isUint8Array('signature', sig)\n      output = getAssertedOutput(output, 64)\n\n      switch (secp256k1.signatureImport(output, sig)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    ecdsaSign (msg32, seckey, options = {}, output) {\n      isUint8Array('message', msg32, 32)\n      isUint8Array('private key', seckey, 32)\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object')\n      if (options.data !== undefined) isUint8Array('options.data', options.data)\n      if (options.noncefn !== undefined) assert(toTypeString(options.noncefn) === 'Function', 'Expected options.noncefn to be a Function')\n      output = getAssertedOutput(output, 64)\n\n      const obj = { signature: output, recid: null }\n      switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {\n        case 0:\n          return obj\n        case 1:\n          throw new Error(errors.SIGN)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    ecdsaVerify (sig, msg32, pubkey) {\n      isUint8Array('signature', sig, 64)\n      isUint8Array('message', msg32, 32)\n      isUint8Array('public key', pubkey, [33, 65])\n\n      switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {\n        case 0:\n          return true\n        case 3:\n          return false\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.PUBKEY_PARSE)\n      }\n    },\n\n    ecdsaRecover (sig, recid, msg32, compressed = true, output) {\n      isUint8Array('signature', sig, 64)\n      assert(\n        toTypeString(recid) === 'Number' &&\n          recid >= 0 &&\n          recid <= 3,\n        'Expected recovery id to be a Number within interval [0, 3]'\n      )\n      isUint8Array('message', msg32, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.RECOVER)\n        case 3:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    ecdh (pubkey, seckey, options = {}, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isUint8Array('private key', seckey, 32)\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object')\n      if (options.data !== undefined) isUint8Array('options.data', options.data)\n      if (options.hashfn !== undefined) {\n        assert(toTypeString(options.hashfn) === 'Function', 'Expected options.hashfn to be a Function')\n        if (options.xbuf !== undefined) isUint8Array('options.xbuf', options.xbuf, 32)\n        if (options.ybuf !== undefined) isUint8Array('options.ybuf', options.ybuf, 32)\n        isUint8Array('output', output)\n      } else {\n        output = getAssertedOutput(output, 32)\n      }\n\n      switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.ECDH)\n      }\n    }\n  }\n}\n","'use strict'\n\nvar base58 = require('bs58')\n\nmodule.exports = function (checksumFn) {\n  // Encode a buffer as a base58-check encoded string\n  function encode (payload) {\n    var payloadU8 = Uint8Array.from(payload)\n    var checksum = checksumFn(payloadU8)\n    var length = payloadU8.length + 4\n    var both = new Uint8Array(length)\n    both.set(payloadU8, 0)\n    both.set(checksum.subarray(0, 4), payloadU8.length)\n    return base58.encode(both, length)\n  }\n\n  function decodeRaw (buffer) {\n    var payload = buffer.slice(0, -4)\n    var checksum = buffer.slice(-4)\n    var newChecksum = checksumFn(payload)\n\n    if (checksum[0] ^ newChecksum[0] |\n        checksum[1] ^ newChecksum[1] |\n        checksum[2] ^ newChecksum[2] |\n        checksum[3] ^ newChecksum[3]) return\n\n    return payload\n  }\n\n  // Decode a base58-check encoded string to a buffer, no result if checksum is wrong\n  function decodeUnsafe (string) {\n    var buffer = base58.decodeUnsafe(string)\n    if (!buffer) return\n\n    return decodeRaw(buffer)\n  }\n\n  function decode (string) {\n    var buffer = base58.decode(string)\n    var payload = decodeRaw(buffer, checksumFn)\n    if (!payload) throw new Error('Invalid checksum')\n    return payload\n  }\n\n  return {\n    encode: encode,\n    decode: decode,\n    decodeUnsafe: decodeUnsafe\n  }\n}\n","'use strict'\n\nvar { sha256 } = require('@noble/hashes/sha256')\nvar bs58checkBase = require('./base')\n\n// SHA256(SHA256(buffer))\nfunction sha256x2 (buffer) {\n  return sha256(sha256(buffer))\n}\n\nmodule.exports = bs58checkBase(sha256x2)\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.toOutputScript =\n  exports.fromOutputScript =\n  exports.toBech32 =\n  exports.toBase58Check =\n  exports.fromBech32 =\n  exports.fromBase58Check =\n    void 0;\nconst networks = require('./networks');\nconst payments = require('./payments');\nconst bscript = require('./script');\nconst types_1 = require('./types');\nconst bech32_1 = require('bech32');\nconst bs58check = require('bs58check');\nconst FUTURE_SEGWIT_MAX_SIZE = 40;\nconst FUTURE_SEGWIT_MIN_SIZE = 2;\nconst FUTURE_SEGWIT_MAX_VERSION = 16;\nconst FUTURE_SEGWIT_MIN_VERSION = 2;\nconst FUTURE_SEGWIT_VERSION_DIFF = 0x50;\nconst FUTURE_SEGWIT_VERSION_WARNING =\n  'WARNING: Sending to a future segwit version address can lead to loss of funds. ' +\n  'End users MUST be warned carefully in the GUI and asked if they wish to proceed ' +\n  'with caution. Wallets should verify the segwit version from the output of fromBech32, ' +\n  'then decide when it is safe to use which version of segwit.';\nfunction _toFutureSegwitAddress(output, network) {\n  const data = output.slice(2);\n  if (\n    data.length < FUTURE_SEGWIT_MIN_SIZE ||\n    data.length > FUTURE_SEGWIT_MAX_SIZE\n  )\n    throw new TypeError('Invalid program length for segwit address');\n  const version = output[0] - FUTURE_SEGWIT_VERSION_DIFF;\n  if (\n    version < FUTURE_SEGWIT_MIN_VERSION ||\n    version > FUTURE_SEGWIT_MAX_VERSION\n  )\n    throw new TypeError('Invalid version for segwit address');\n  if (output[1] !== data.length)\n    throw new TypeError('Invalid script for segwit address');\n  console.warn(FUTURE_SEGWIT_VERSION_WARNING);\n  return toBech32(data, version, network.bech32);\n}\n/**\n * decode address with base58 specification,  return address version and address hash if valid\n */\nfunction fromBase58Check(address) {\n  const payload = Buffer.from(bs58check.decode(address));\n  // TODO: 4.0.0, move to \"toOutputScript\"\n  if (payload.length < 21) throw new TypeError(address + ' is too short');\n  if (payload.length > 21) throw new TypeError(address + ' is too long');\n  const version = payload.readUInt8(0);\n  const hash = payload.slice(1);\n  return { version, hash };\n}\nexports.fromBase58Check = fromBase58Check;\n/**\n * decode address with bech32 specification,  return address version、address prefix and address data if valid\n */\nfunction fromBech32(address) {\n  let result;\n  let version;\n  try {\n    result = bech32_1.bech32.decode(address);\n  } catch (e) {}\n  if (result) {\n    version = result.words[0];\n    if (version !== 0) throw new TypeError(address + ' uses wrong encoding');\n  } else {\n    result = bech32_1.bech32m.decode(address);\n    version = result.words[0];\n    if (version === 0) throw new TypeError(address + ' uses wrong encoding');\n  }\n  const data = bech32_1.bech32.fromWords(result.words.slice(1));\n  return {\n    version,\n    prefix: result.prefix,\n    data: Buffer.from(data),\n  };\n}\nexports.fromBech32 = fromBech32;\n/**\n * encode address hash to base58 address with version\n */\nfunction toBase58Check(hash, version) {\n  (0, types_1.typeforce)(\n    (0, types_1.tuple)(types_1.Hash160bit, types_1.UInt8),\n    arguments,\n  );\n  const payload = Buffer.allocUnsafe(21);\n  payload.writeUInt8(version, 0);\n  hash.copy(payload, 1);\n  return bs58check.encode(payload);\n}\nexports.toBase58Check = toBase58Check;\n/**\n * encode address hash to bech32 address with version and prefix\n */\nfunction toBech32(data, version, prefix) {\n  const words = bech32_1.bech32.toWords(data);\n  words.unshift(version);\n  return version === 0\n    ? bech32_1.bech32.encode(prefix, words)\n    : bech32_1.bech32m.encode(prefix, words);\n}\nexports.toBech32 = toBech32;\n/**\n * decode address from output script with network, return address if matched\n */\nfunction fromOutputScript(output, network) {\n  // TODO: Network\n  network = network || networks.bitcoin;\n  try {\n    return payments.p2pkh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2sh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wpkh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wsh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2tr({ output, network }).address;\n  } catch (e) {}\n  try {\n    return _toFutureSegwitAddress(output, network);\n  } catch (e) {}\n  throw new Error(bscript.toASM(output) + ' has no matching Address');\n}\nexports.fromOutputScript = fromOutputScript;\n/**\n * encodes address to output script with network, return output script if address matched\n */\nfunction toOutputScript(address, network) {\n  network = network || networks.bitcoin;\n  let decodeBase58;\n  let decodeBech32;\n  try {\n    decodeBase58 = fromBase58Check(address);\n  } catch (e) {}\n  if (decodeBase58) {\n    if (decodeBase58.version === network.pubKeyHash)\n      return payments.p2pkh({ hash: decodeBase58.hash }).output;\n    if (decodeBase58.version === network.scriptHash)\n      return payments.p2sh({ hash: decodeBase58.hash }).output;\n  } else {\n    try {\n      decodeBech32 = fromBech32(address);\n    } catch (e) {}\n    if (decodeBech32) {\n      if (decodeBech32.prefix !== network.bech32)\n        throw new Error(address + ' has an invalid prefix');\n      if (decodeBech32.version === 0) {\n        if (decodeBech32.data.length === 20)\n          return payments.p2wpkh({ hash: decodeBech32.data }).output;\n        if (decodeBech32.data.length === 32)\n          return payments.p2wsh({ hash: decodeBech32.data }).output;\n      } else if (decodeBech32.version === 1) {\n        if (decodeBech32.data.length === 32)\n          return payments.p2tr({ pubkey: decodeBech32.data }).output;\n      } else if (\n        decodeBech32.version >= FUTURE_SEGWIT_MIN_VERSION &&\n        decodeBech32.version <= FUTURE_SEGWIT_MAX_VERSION &&\n        decodeBech32.data.length >= FUTURE_SEGWIT_MIN_SIZE &&\n        decodeBech32.data.length <= FUTURE_SEGWIT_MAX_SIZE\n      ) {\n        console.warn(FUTURE_SEGWIT_VERSION_WARNING);\n        return bscript.compile([\n          decodeBech32.version + FUTURE_SEGWIT_VERSION_DIFF,\n          decodeBech32.data,\n        ]);\n      }\n    }\n  }\n  throw new Error(address + ' has no matching Script');\n}\nexports.toOutputScript = toOutputScript;\n","'use strict';\n// Reference https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki\n// Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]\n// NOTE: SIGHASH byte ignored AND restricted, truncate before use\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.encode = exports.decode = exports.check = void 0;\nfunction check(buffer) {\n  if (buffer.length < 8) return false;\n  if (buffer.length > 72) return false;\n  if (buffer[0] !== 0x30) return false;\n  if (buffer[1] !== buffer.length - 2) return false;\n  if (buffer[2] !== 0x02) return false;\n  const lenR = buffer[3];\n  if (lenR === 0) return false;\n  if (5 + lenR >= buffer.length) return false;\n  if (buffer[4 + lenR] !== 0x02) return false;\n  const lenS = buffer[5 + lenR];\n  if (lenS === 0) return false;\n  if (6 + lenR + lenS !== buffer.length) return false;\n  if (buffer[4] & 0x80) return false;\n  if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80)) return false;\n  if (buffer[lenR + 6] & 0x80) return false;\n  if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80))\n    return false;\n  return true;\n}\nexports.check = check;\nfunction decode(buffer) {\n  if (buffer.length < 8) throw new Error('DER sequence length is too short');\n  if (buffer.length > 72) throw new Error('DER sequence length is too long');\n  if (buffer[0] !== 0x30) throw new Error('Expected DER sequence');\n  if (buffer[1] !== buffer.length - 2)\n    throw new Error('DER sequence length is invalid');\n  if (buffer[2] !== 0x02) throw new Error('Expected DER integer');\n  const lenR = buffer[3];\n  if (lenR === 0) throw new Error('R length is zero');\n  if (5 + lenR >= buffer.length) throw new Error('R length is too long');\n  if (buffer[4 + lenR] !== 0x02) throw new Error('Expected DER integer (2)');\n  const lenS = buffer[5 + lenR];\n  if (lenS === 0) throw new Error('S length is zero');\n  if (6 + lenR + lenS !== buffer.length) throw new Error('S length is invalid');\n  if (buffer[4] & 0x80) throw new Error('R value is negative');\n  if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80))\n    throw new Error('R value excessively padded');\n  if (buffer[lenR + 6] & 0x80) throw new Error('S value is negative');\n  if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80))\n    throw new Error('S value excessively padded');\n  // non-BIP66 - extract R, S values\n  return {\n    r: buffer.slice(4, 4 + lenR),\n    s: buffer.slice(6 + lenR),\n  };\n}\nexports.decode = decode;\n/*\n * Expects r and s to be positive DER integers.\n *\n * The DER format uses the most significant bit as a sign bit (& 0x80).\n * If the significant bit is set AND the integer is positive, a 0x00 is prepended.\n *\n * Examples:\n *\n *      0 =>     0x00\n *      1 =>     0x01\n *     -1 =>     0xff\n *    127 =>     0x7f\n *   -127 =>     0x81\n *    128 =>   0x0080\n *   -128 =>     0x80\n *    255 =>   0x00ff\n *   -255 =>   0xff01\n *  16300 =>   0x3fac\n * -16300 =>   0xc054\n *  62300 => 0x00f35c\n * -62300 => 0xff0ca4\n */\nfunction encode(r, s) {\n  const lenR = r.length;\n  const lenS = s.length;\n  if (lenR === 0) throw new Error('R length is zero');\n  if (lenS === 0) throw new Error('S length is zero');\n  if (lenR > 33) throw new Error('R length is too long');\n  if (lenS > 33) throw new Error('S length is too long');\n  if (r[0] & 0x80) throw new Error('R value is negative');\n  if (s[0] & 0x80) throw new Error('S value is negative');\n  if (lenR > 1 && r[0] === 0x00 && !(r[1] & 0x80))\n    throw new Error('R value excessively padded');\n  if (lenS > 1 && s[0] === 0x00 && !(s[1] & 0x80))\n    throw new Error('S value excessively padded');\n  const signature = Buffer.allocUnsafe(6 + lenR + lenS);\n  // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]\n  signature[0] = 0x30;\n  signature[1] = signature.length - 2;\n  signature[2] = 0x02;\n  signature[3] = r.length;\n  r.copy(signature, 4);\n  signature[4 + lenR] = 0x02;\n  signature[5 + lenR] = s.length;\n  s.copy(signature, 6 + lenR);\n  return signature;\n}\nexports.encode = encode;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.Block = void 0;\nconst bufferutils_1 = require('./bufferutils');\nconst bcrypto = require('./crypto');\nconst merkle_1 = require('./merkle');\nconst transaction_1 = require('./transaction');\nconst types = require('./types');\nconst { typeforce } = types;\nconst errorMerkleNoTxes = new TypeError(\n  'Cannot compute merkle root for zero transactions',\n);\nconst errorWitnessNotSegwit = new TypeError(\n  'Cannot compute witness commit for non-segwit block',\n);\nclass Block {\n  constructor() {\n    this.version = 1;\n    this.prevHash = undefined;\n    this.merkleRoot = undefined;\n    this.timestamp = 0;\n    this.witnessCommit = undefined;\n    this.bits = 0;\n    this.nonce = 0;\n    this.transactions = undefined;\n  }\n  static fromBuffer(buffer) {\n    if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)');\n    const bufferReader = new bufferutils_1.BufferReader(buffer);\n    const block = new Block();\n    block.version = bufferReader.readInt32();\n    block.prevHash = bufferReader.readSlice(32);\n    block.merkleRoot = bufferReader.readSlice(32);\n    block.timestamp = bufferReader.readUInt32();\n    block.bits = bufferReader.readUInt32();\n    block.nonce = bufferReader.readUInt32();\n    if (buffer.length === 80) return block;\n    const readTransaction = () => {\n      const tx = transaction_1.Transaction.fromBuffer(\n        bufferReader.buffer.slice(bufferReader.offset),\n        true,\n      );\n      bufferReader.offset += tx.byteLength();\n      return tx;\n    };\n    const nTransactions = bufferReader.readVarInt();\n    block.transactions = [];\n    for (let i = 0; i < nTransactions; ++i) {\n      const tx = readTransaction();\n      block.transactions.push(tx);\n    }\n    const witnessCommit = block.getWitnessCommit();\n    // This Block contains a witness commit\n    if (witnessCommit) block.witnessCommit = witnessCommit;\n    return block;\n  }\n  static fromHex(hex) {\n    return Block.fromBuffer(Buffer.from(hex, 'hex'));\n  }\n  static calculateTarget(bits) {\n    const exponent = ((bits & 0xff000000) >> 24) - 3;\n    const mantissa = bits & 0x007fffff;\n    const target = Buffer.alloc(32, 0);\n    target.writeUIntBE(mantissa, 29 - exponent, 3);\n    return target;\n  }\n  static calculateMerkleRoot(transactions, forWitness) {\n    typeforce([{ getHash: types.Function }], transactions);\n    if (transactions.length === 0) throw errorMerkleNoTxes;\n    if (forWitness && !txesHaveWitnessCommit(transactions))\n      throw errorWitnessNotSegwit;\n    const hashes = transactions.map(transaction =>\n      transaction.getHash(forWitness),\n    );\n    const rootHash = (0, merkle_1.fastMerkleRoot)(hashes, bcrypto.hash256);\n    return forWitness\n      ? bcrypto.hash256(\n          Buffer.concat([rootHash, transactions[0].ins[0].witness[0]]),\n        )\n      : rootHash;\n  }\n  getWitnessCommit() {\n    if (!txesHaveWitnessCommit(this.transactions)) return null;\n    // The merkle root for the witness data is in an OP_RETURN output.\n    // There is no rule for the index of the output, so use filter to find it.\n    // The root is prepended with 0xaa21a9ed so check for 0x6a24aa21a9ed\n    // If multiple commits are found, the output with highest index is assumed.\n    const witnessCommits = this.transactions[0].outs\n      .filter(out =>\n        out.script.slice(0, 6).equals(Buffer.from('6a24aa21a9ed', 'hex')),\n      )\n      .map(out => out.script.slice(6, 38));\n    if (witnessCommits.length === 0) return null;\n    // Use the commit with the highest output (should only be one though)\n    const result = witnessCommits[witnessCommits.length - 1];\n    if (!(result instanceof Buffer && result.length === 32)) return null;\n    return result;\n  }\n  hasWitnessCommit() {\n    if (\n      this.witnessCommit instanceof Buffer &&\n      this.witnessCommit.length === 32\n    )\n      return true;\n    if (this.getWitnessCommit() !== null) return true;\n    return false;\n  }\n  hasWitness() {\n    return anyTxHasWitness(this.transactions);\n  }\n  weight() {\n    const base = this.byteLength(false, false);\n    const total = this.byteLength(false, true);\n    return base * 3 + total;\n  }\n  byteLength(headersOnly, allowWitness = true) {\n    if (headersOnly || !this.transactions) return 80;\n    return (\n      80 +\n      bufferutils_1.varuint.encodingLength(this.transactions.length) +\n      this.transactions.reduce((a, x) => a + x.byteLength(allowWitness), 0)\n    );\n  }\n  getHash() {\n    return bcrypto.hash256(this.toBuffer(true));\n  }\n  getId() {\n    return (0, bufferutils_1.reverseBuffer)(this.getHash()).toString('hex');\n  }\n  getUTCDate() {\n    const date = new Date(0); // epoch\n    date.setUTCSeconds(this.timestamp);\n    return date;\n  }\n  // TODO: buffer, offset compatibility\n  toBuffer(headersOnly) {\n    const buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));\n    const bufferWriter = new bufferutils_1.BufferWriter(buffer);\n    bufferWriter.writeInt32(this.version);\n    bufferWriter.writeSlice(this.prevHash);\n    bufferWriter.writeSlice(this.merkleRoot);\n    bufferWriter.writeUInt32(this.timestamp);\n    bufferWriter.writeUInt32(this.bits);\n    bufferWriter.writeUInt32(this.nonce);\n    if (headersOnly || !this.transactions) return buffer;\n    bufferutils_1.varuint.encode(\n      this.transactions.length,\n      buffer,\n      bufferWriter.offset,\n    );\n    bufferWriter.offset += bufferutils_1.varuint.encode.bytes;\n    this.transactions.forEach(tx => {\n      const txSize = tx.byteLength(); // TODO: extract from toBuffer?\n      tx.toBuffer(buffer, bufferWriter.offset);\n      bufferWriter.offset += txSize;\n    });\n    return buffer;\n  }\n  toHex(headersOnly) {\n    return this.toBuffer(headersOnly).toString('hex');\n  }\n  checkTxRoots() {\n    // If the Block has segwit transactions but no witness commit,\n    // there's no way it can be valid, so fail the check.\n    const hasWitnessCommit = this.hasWitnessCommit();\n    if (!hasWitnessCommit && this.hasWitness()) return false;\n    return (\n      this.__checkMerkleRoot() &&\n      (hasWitnessCommit ? this.__checkWitnessCommit() : true)\n    );\n  }\n  checkProofOfWork() {\n    const hash = (0, bufferutils_1.reverseBuffer)(this.getHash());\n    const target = Block.calculateTarget(this.bits);\n    return hash.compare(target) <= 0;\n  }\n  __checkMerkleRoot() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    const actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);\n    return this.merkleRoot.compare(actualMerkleRoot) === 0;\n  }\n  __checkWitnessCommit() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;\n    const actualWitnessCommit = Block.calculateMerkleRoot(\n      this.transactions,\n      true,\n    );\n    return this.witnessCommit.compare(actualWitnessCommit) === 0;\n  }\n}\nexports.Block = Block;\nfunction txesHaveWitnessCommit(transactions) {\n  return (\n    transactions instanceof Array &&\n    transactions[0] &&\n    transactions[0].ins &&\n    transactions[0].ins instanceof Array &&\n    transactions[0].ins[0] &&\n    transactions[0].ins[0].witness &&\n    transactions[0].ins[0].witness instanceof Array &&\n    transactions[0].ins[0].witness.length > 0\n  );\n}\nfunction anyTxHasWitness(transactions) {\n  return (\n    transactions instanceof Array &&\n    transactions.some(\n      tx =>\n        typeof tx === 'object' &&\n        tx.ins instanceof Array &&\n        tx.ins.some(\n          input =>\n            typeof input === 'object' &&\n            input.witness instanceof Array &&\n            input.witness.length > 0,\n        ),\n    )\n  );\n}\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.BufferReader =\n  exports.BufferWriter =\n  exports.cloneBuffer =\n  exports.reverseBuffer =\n  exports.writeUInt64LE =\n  exports.readUInt64LE =\n  exports.varuint =\n    void 0;\nconst types = require('./types');\nconst { typeforce } = types;\nconst varuint = require('varuint-bitcoin');\nexports.varuint = varuint;\n// https://github.com/feross/buffer/blob/master/index.js#L1127\nfunction verifuint(value, max) {\n  if (typeof value !== 'number')\n    throw new Error('cannot write a non-number as a number');\n  if (value < 0)\n    throw new Error('specified a negative value for writing an unsigned value');\n  if (value > max) throw new Error('RangeError: value out of range');\n  if (Math.floor(value) !== value)\n    throw new Error('value has a fractional component');\n}\nfunction readUInt64LE(buffer, offset) {\n  const a = buffer.readUInt32LE(offset);\n  let b = buffer.readUInt32LE(offset + 4);\n  b *= 0x100000000;\n  verifuint(b + a, 0x001fffffffffffff);\n  return b + a;\n}\nexports.readUInt64LE = readUInt64LE;\n/**\n * Writes a 64-bit unsigned integer in little-endian format to the specified buffer at the given offset.\n *\n * @param buffer - The buffer to write the value to.\n * @param value - The 64-bit unsigned integer value to write.\n * @param offset - The offset in the buffer where the value should be written.\n * @returns The new offset after writing the value.\n */\nfunction writeUInt64LE(buffer, value, offset) {\n  verifuint(value, 0x001fffffffffffff);\n  buffer.writeInt32LE(value & -1, offset);\n  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);\n  return offset + 8;\n}\nexports.writeUInt64LE = writeUInt64LE;\n/**\n * Reverses the order of bytes in a buffer.\n * @param buffer - The buffer to reverse.\n * @returns A new buffer with the bytes reversed.\n */\nfunction reverseBuffer(buffer) {\n  if (buffer.length < 1) return buffer;\n  let j = buffer.length - 1;\n  let tmp = 0;\n  for (let i = 0; i < buffer.length / 2; i++) {\n    tmp = buffer[i];\n    buffer[i] = buffer[j];\n    buffer[j] = tmp;\n    j--;\n  }\n  return buffer;\n}\nexports.reverseBuffer = reverseBuffer;\nfunction cloneBuffer(buffer) {\n  const clone = Buffer.allocUnsafe(buffer.length);\n  buffer.copy(clone);\n  return clone;\n}\nexports.cloneBuffer = cloneBuffer;\n/**\n * Helper class for serialization of bitcoin data types into a pre-allocated buffer.\n */\nclass BufferWriter {\n  static withCapacity(size) {\n    return new BufferWriter(Buffer.alloc(size));\n  }\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n  }\n  writeUInt8(i) {\n    this.offset = this.buffer.writeUInt8(i, this.offset);\n  }\n  writeInt32(i) {\n    this.offset = this.buffer.writeInt32LE(i, this.offset);\n  }\n  writeUInt32(i) {\n    this.offset = this.buffer.writeUInt32LE(i, this.offset);\n  }\n  writeUInt64(i) {\n    this.offset = writeUInt64LE(this.buffer, i, this.offset);\n  }\n  writeVarInt(i) {\n    varuint.encode(i, this.buffer, this.offset);\n    this.offset += varuint.encode.bytes;\n  }\n  writeSlice(slice) {\n    if (this.buffer.length < this.offset + slice.length) {\n      throw new Error('Cannot write slice out of bounds');\n    }\n    this.offset += slice.copy(this.buffer, this.offset);\n  }\n  writeVarSlice(slice) {\n    this.writeVarInt(slice.length);\n    this.writeSlice(slice);\n  }\n  writeVector(vector) {\n    this.writeVarInt(vector.length);\n    vector.forEach(buf => this.writeVarSlice(buf));\n  }\n  end() {\n    if (this.buffer.length === this.offset) {\n      return this.buffer;\n    }\n    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);\n  }\n}\nexports.BufferWriter = BufferWriter;\n/**\n * Helper class for reading of bitcoin data types from a buffer.\n */\nclass BufferReader {\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n  }\n  readUInt8() {\n    const result = this.buffer.readUInt8(this.offset);\n    this.offset++;\n    return result;\n  }\n  readInt32() {\n    const result = this.buffer.readInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n  readUInt32() {\n    const result = this.buffer.readUInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n  readUInt64() {\n    const result = readUInt64LE(this.buffer, this.offset);\n    this.offset += 8;\n    return result;\n  }\n  readVarInt() {\n    const vi = varuint.decode(this.buffer, this.offset);\n    this.offset += varuint.decode.bytes;\n    return vi;\n  }\n  readSlice(n) {\n    if (this.buffer.length < this.offset + n) {\n      throw new Error('Cannot read slice out of bounds');\n    }\n    const result = this.buffer.slice(this.offset, this.offset + n);\n    this.offset += n;\n    return result;\n  }\n  readVarSlice() {\n    return this.readSlice(this.readVarInt());\n  }\n  readVector() {\n    const count = this.readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(this.readVarSlice());\n    return vector;\n  }\n}\nexports.BufferReader = BufferReader;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.taggedHash =\n  exports.TAGGED_HASH_PREFIXES =\n  exports.TAGS =\n  exports.hash256 =\n  exports.hash160 =\n  exports.sha256 =\n  exports.sha1 =\n  exports.ripemd160 =\n    void 0;\n/**\n * A module for hashing functions.\n * include ripemd160、sha1、sha256、hash160、hash256、taggedHash\n *\n * @packageDocumentation\n */\nconst ripemd160_1 = require('@noble/hashes/ripemd160');\nconst sha1_1 = require('@noble/hashes/sha1');\nconst sha256_1 = require('@noble/hashes/sha256');\nfunction ripemd160(buffer) {\n  return Buffer.from((0, ripemd160_1.ripemd160)(Uint8Array.from(buffer)));\n}\nexports.ripemd160 = ripemd160;\nfunction sha1(buffer) {\n  return Buffer.from((0, sha1_1.sha1)(Uint8Array.from(buffer)));\n}\nexports.sha1 = sha1;\nfunction sha256(buffer) {\n  return Buffer.from((0, sha256_1.sha256)(Uint8Array.from(buffer)));\n}\nexports.sha256 = sha256;\nfunction hash160(buffer) {\n  return Buffer.from(\n    (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(Uint8Array.from(buffer))),\n  );\n}\nexports.hash160 = hash160;\nfunction hash256(buffer) {\n  return Buffer.from(\n    (0, sha256_1.sha256)((0, sha256_1.sha256)(Uint8Array.from(buffer))),\n  );\n}\nexports.hash256 = hash256;\nexports.TAGS = [\n  'BIP0340/challenge',\n  'BIP0340/aux',\n  'BIP0340/nonce',\n  'TapLeaf',\n  'TapBranch',\n  'TapSighash',\n  'TapTweak',\n  'KeyAgg list',\n  'KeyAgg coefficient',\n];\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\n/**\n * Defines the tagged hash prefixes used in the crypto module.\n */\nexports.TAGGED_HASH_PREFIXES = {\n  'BIP0340/challenge': Buffer.from([\n    123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125, 179, 130,\n    210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81, 143, 109, 72, 211, 124,\n    123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125, 179, 130,\n    210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81, 143, 109, 72, 211, 124,\n  ]),\n  'BIP0340/aux': Buffer.from([\n    241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152, 126, 160,\n    105, 38, 88, 57, 236, 193, 31, 151, 45, 119, 165, 46, 216, 193, 204, 144,\n    241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152, 126, 160,\n    105, 38, 88, 57, 236, 193, 31, 151, 45, 119, 165, 46, 216, 193, 204, 144,\n  ]),\n  'BIP0340/nonce': Buffer.from([\n    7, 73, 119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18, 28, 244,\n    52, 215, 62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191, 235, 47, 7, 73,\n    119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18, 28, 244, 52, 215,\n    62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191, 235, 47,\n  ]),\n  TapLeaf: Buffer.from([\n    174, 234, 143, 220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38, 56, 211,\n    95, 28, 181, 64, 8, 212, 211, 87, 202, 3, 190, 120, 233, 238, 174, 234, 143,\n    220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38, 56, 211, 95, 28, 181,\n    64, 8, 212, 211, 87, 202, 3, 190, 120, 233, 238,\n  ]),\n  TapBranch: Buffer.from([\n    25, 65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92, 1, 247,\n    33, 111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91, 245, 22, 160, 21, 25,\n    65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92, 1, 247, 33,\n    111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91, 245, 22, 160, 21,\n  ]),\n  TapSighash: Buffer.from([\n    244, 10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70, 97, 237, 61,\n    149, 253, 102, 163, 19, 235, 135, 35, 117, 151, 198, 40, 228, 160, 49, 244,\n    10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70, 97, 237, 61, 149,\n    253, 102, 163, 19, 235, 135, 35, 117, 151, 198, 40, 228, 160, 49,\n  ]),\n  TapTweak: Buffer.from([\n    232, 15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67, 198, 62, 66,\n    156, 188, 235, 21, 217, 64, 251, 181, 197, 161, 244, 175, 87, 197, 233, 232,\n    15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67, 198, 62, 66, 156,\n    188, 235, 21, 217, 64, 251, 181, 197, 161, 244, 175, 87, 197, 233,\n  ]),\n  'KeyAgg list': Buffer.from([\n    72, 28, 151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78, 44, 126,\n    215, 49, 156, 89, 74, 92, 110, 199, 158, 160, 212, 153, 2, 148, 240, 72, 28,\n    151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78, 44, 126, 215, 49,\n    156, 89, 74, 92, 110, 199, 158, 160, 212, 153, 2, 148, 240,\n  ]),\n  'KeyAgg coefficient': Buffer.from([\n    191, 201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86, 109, 100,\n    130, 78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205, 82, 201, 129, 191,\n    201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86, 109, 100, 130,\n    78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205, 82, 201, 129,\n  ]),\n};\nfunction taggedHash(prefix, data) {\n  return sha256(Buffer.concat([exports.TAGGED_HASH_PREFIXES[prefix], data]));\n}\nexports.taggedHash = taggedHash;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.getEccLib = exports.initEccLib = void 0;\nconst _ECCLIB_CACHE = {};\n/**\n * Initializes the ECC library with the provided instance.\n * If `eccLib` is `undefined`, the library will be cleared.\n * If `eccLib` is a new instance, it will be verified before setting it as the active library.\n *\n * @param eccLib The instance of the ECC library to initialize.\n * @param opts Extra initialization options. Use {DANGER_DO_NOT_VERIFY_ECCLIB:true} if ecc verification should not be executed. Not recommended!\n */\nfunction initEccLib(eccLib, opts) {\n  if (!eccLib) {\n    // allow clearing the library\n    _ECCLIB_CACHE.eccLib = eccLib;\n  } else if (eccLib !== _ECCLIB_CACHE.eccLib) {\n    if (!opts?.DANGER_DO_NOT_VERIFY_ECCLIB)\n      // new instance, verify it\n      verifyEcc(eccLib);\n    _ECCLIB_CACHE.eccLib = eccLib;\n  }\n}\nexports.initEccLib = initEccLib;\n/**\n * Retrieves the ECC Library instance.\n * Throws an error if the ECC Library is not provided.\n * You must call initEccLib() with a valid TinySecp256k1Interface instance before calling this function.\n * @returns The ECC Library instance.\n * @throws Error if the ECC Library is not provided.\n */\nfunction getEccLib() {\n  if (!_ECCLIB_CACHE.eccLib)\n    throw new Error(\n      'No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance',\n    );\n  return _ECCLIB_CACHE.eccLib;\n}\nexports.getEccLib = getEccLib;\nconst h = hex => Buffer.from(hex, 'hex');\n/**\n * Verifies the ECC functionality.\n *\n * @param ecc - The TinySecp256k1Interface object.\n */\nfunction verifyEcc(ecc) {\n  assert(typeof ecc.isXOnlyPoint === 'function');\n  assert(\n    ecc.isXOnlyPoint(\n      h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),\n    ),\n  );\n  assert(\n    ecc.isXOnlyPoint(\n      h('fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e'),\n    ),\n  );\n  assert(\n    ecc.isXOnlyPoint(\n      h('f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9'),\n    ),\n  );\n  assert(\n    ecc.isXOnlyPoint(\n      h('0000000000000000000000000000000000000000000000000000000000000001'),\n    ),\n  );\n  assert(\n    !ecc.isXOnlyPoint(\n      h('0000000000000000000000000000000000000000000000000000000000000000'),\n    ),\n  );\n  assert(\n    !ecc.isXOnlyPoint(\n      h('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n    ),\n  );\n  assert(typeof ecc.xOnlyPointAddTweak === 'function');\n  tweakAddVectors.forEach(t => {\n    const r = ecc.xOnlyPointAddTweak(h(t.pubkey), h(t.tweak));\n    if (t.result === null) {\n      assert(r === null);\n    } else {\n      assert(r !== null);\n      assert(r.parity === t.parity);\n      assert(Buffer.from(r.xOnlyPubkey).equals(h(t.result)));\n    }\n  });\n}\nfunction assert(bool) {\n  if (!bool) throw new Error('ecc library invalid');\n}\nconst tweakAddVectors = [\n  {\n    pubkey: '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n    tweak: 'fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140',\n    parity: -1,\n    result: null,\n  },\n  {\n    pubkey: '1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b',\n    tweak: 'a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac',\n    parity: 1,\n    result: 'e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf',\n  },\n  {\n    pubkey: '2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991',\n    tweak: '823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47',\n    parity: 0,\n    result: '9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c',\n  },\n];\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.initEccLib =\n  exports.Transaction =\n  exports.opcodes =\n  exports.Psbt =\n  exports.Block =\n  exports.script =\n  exports.payments =\n  exports.networks =\n  exports.crypto =\n  exports.address =\n    void 0;\nconst address = require('./address');\nexports.address = address;\nconst crypto = require('./crypto');\nexports.crypto = crypto;\nconst networks = require('./networks');\nexports.networks = networks;\nconst payments = require('./payments');\nexports.payments = payments;\nconst script = require('./script');\nexports.script = script;\nvar block_1 = require('./block');\nObject.defineProperty(exports, 'Block', {\n  enumerable: true,\n  get: function () {\n    return block_1.Block;\n  },\n});\nvar psbt_1 = require('./psbt');\nObject.defineProperty(exports, 'Psbt', {\n  enumerable: true,\n  get: function () {\n    return psbt_1.Psbt;\n  },\n});\n/** @hidden */\nvar ops_1 = require('./ops');\nObject.defineProperty(exports, 'opcodes', {\n  enumerable: true,\n  get: function () {\n    return ops_1.OPS;\n  },\n});\nvar transaction_1 = require('./transaction');\nObject.defineProperty(exports, 'Transaction', {\n  enumerable: true,\n  get: function () {\n    return transaction_1.Transaction;\n  },\n});\nvar ecc_lib_1 = require('./ecc_lib');\nObject.defineProperty(exports, 'initEccLib', {\n  enumerable: true,\n  get: function () {\n    return ecc_lib_1.initEccLib;\n  },\n});\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.fastMerkleRoot = void 0;\n/**\n * Calculates the Merkle root of an array of buffers using a specified digest function.\n *\n * @param values - The array of buffers.\n * @param digestFn - The digest function used to calculate the hash of the concatenated buffers.\n * @returns The Merkle root as a buffer.\n * @throws {TypeError} If the values parameter is not an array or the digestFn parameter is not a function.\n */\nfunction fastMerkleRoot(values, digestFn) {\n  if (!Array.isArray(values)) throw TypeError('Expected values Array');\n  if (typeof digestFn !== 'function')\n    throw TypeError('Expected digest Function');\n  let length = values.length;\n  const results = values.concat();\n  while (length > 1) {\n    let j = 0;\n    for (let i = 0; i < length; i += 2, ++j) {\n      const left = results[i];\n      const right = i + 1 === length ? left : results[i + 1];\n      const data = Buffer.concat([left, right]);\n      results[j] = digestFn(data);\n    }\n    length = j;\n  }\n  return results[0];\n}\nexports.fastMerkleRoot = fastMerkleRoot;\n","'use strict';\n// https://en.bitcoin.it/wiki/List_of_address_prefixes\n// Dogecoin BIP32 is a proposed standard: https://bitcointalk.org/index.php?topic=409731\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.testnet = exports.regtest = exports.bitcoin = void 0;\n/**\n * Represents the Bitcoin network configuration.\n */\nexports.bitcoin = {\n  /**\n   * The message prefix used for signing Bitcoin messages.\n   */\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  /**\n   * The Bech32 prefix used for Bitcoin addresses.\n   */\n  bech32: 'bc',\n  /**\n   * The BIP32 key prefixes for Bitcoin.\n   */\n  bip32: {\n    /**\n     * The public key prefix for BIP32 extended public keys.\n     */\n    public: 0x0488b21e,\n    /**\n     * The private key prefix for BIP32 extended private keys.\n     */\n    private: 0x0488ade4,\n  },\n  /**\n   * The prefix for Bitcoin public key hashes.\n   */\n  pubKeyHash: 0x00,\n  /**\n   * The prefix for Bitcoin script hashes.\n   */\n  scriptHash: 0x05,\n  /**\n   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.\n   */\n  wif: 0x80,\n};\n/**\n * Represents the regtest network configuration.\n */\nexports.regtest = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'bcrt',\n  bip32: {\n    public: 0x043587cf,\n    private: 0x04358394,\n  },\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  wif: 0xef,\n};\n/**\n * Represents the testnet network configuration.\n */\nexports.testnet = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'tb',\n  bip32: {\n    public: 0x043587cf,\n    private: 0x04358394,\n  },\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  wif: 0xef,\n};\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.REVERSE_OPS = exports.OPS = void 0;\nconst OPS = {\n  OP_FALSE: 0,\n  OP_0: 0,\n  OP_PUSHDATA1: 76,\n  OP_PUSHDATA2: 77,\n  OP_PUSHDATA4: 78,\n  OP_1NEGATE: 79,\n  OP_RESERVED: 80,\n  OP_TRUE: 81,\n  OP_1: 81,\n  OP_2: 82,\n  OP_3: 83,\n  OP_4: 84,\n  OP_5: 85,\n  OP_6: 86,\n  OP_7: 87,\n  OP_8: 88,\n  OP_9: 89,\n  OP_10: 90,\n  OP_11: 91,\n  OP_12: 92,\n  OP_13: 93,\n  OP_14: 94,\n  OP_15: 95,\n  OP_16: 96,\n  OP_NOP: 97,\n  OP_VER: 98,\n  OP_IF: 99,\n  OP_NOTIF: 100,\n  OP_VERIF: 101,\n  OP_VERNOTIF: 102,\n  OP_ELSE: 103,\n  OP_ENDIF: 104,\n  OP_VERIFY: 105,\n  OP_RETURN: 106,\n  OP_TOALTSTACK: 107,\n  OP_FROMALTSTACK: 108,\n  OP_2DROP: 109,\n  OP_2DUP: 110,\n  OP_3DUP: 111,\n  OP_2OVER: 112,\n  OP_2ROT: 113,\n  OP_2SWAP: 114,\n  OP_IFDUP: 115,\n  OP_DEPTH: 116,\n  OP_DROP: 117,\n  OP_DUP: 118,\n  OP_NIP: 119,\n  OP_OVER: 120,\n  OP_PICK: 121,\n  OP_ROLL: 122,\n  OP_ROT: 123,\n  OP_SWAP: 124,\n  OP_TUCK: 125,\n  OP_CAT: 126,\n  OP_SUBSTR: 127,\n  OP_LEFT: 128,\n  OP_RIGHT: 129,\n  OP_SIZE: 130,\n  OP_INVERT: 131,\n  OP_AND: 132,\n  OP_OR: 133,\n  OP_XOR: 134,\n  OP_EQUAL: 135,\n  OP_EQUALVERIFY: 136,\n  OP_RESERVED1: 137,\n  OP_RESERVED2: 138,\n  OP_1ADD: 139,\n  OP_1SUB: 140,\n  OP_2MUL: 141,\n  OP_2DIV: 142,\n  OP_NEGATE: 143,\n  OP_ABS: 144,\n  OP_NOT: 145,\n  OP_0NOTEQUAL: 146,\n  OP_ADD: 147,\n  OP_SUB: 148,\n  OP_MUL: 149,\n  OP_DIV: 150,\n  OP_MOD: 151,\n  OP_LSHIFT: 152,\n  OP_RSHIFT: 153,\n  OP_BOOLAND: 154,\n  OP_BOOLOR: 155,\n  OP_NUMEQUAL: 156,\n  OP_NUMEQUALVERIFY: 157,\n  OP_NUMNOTEQUAL: 158,\n  OP_LESSTHAN: 159,\n  OP_GREATERTHAN: 160,\n  OP_LESSTHANOREQUAL: 161,\n  OP_GREATERTHANOREQUAL: 162,\n  OP_MIN: 163,\n  OP_MAX: 164,\n  OP_WITHIN: 165,\n  OP_RIPEMD160: 166,\n  OP_SHA1: 167,\n  OP_SHA256: 168,\n  OP_HASH160: 169,\n  OP_HASH256: 170,\n  OP_CODESEPARATOR: 171,\n  OP_CHECKSIG: 172,\n  OP_CHECKSIGVERIFY: 173,\n  OP_CHECKMULTISIG: 174,\n  OP_CHECKMULTISIGVERIFY: 175,\n  OP_NOP1: 176,\n  OP_NOP2: 177,\n  OP_CHECKLOCKTIMEVERIFY: 177,\n  OP_NOP3: 178,\n  OP_CHECKSEQUENCEVERIFY: 178,\n  OP_NOP4: 179,\n  OP_NOP5: 180,\n  OP_NOP6: 181,\n  OP_NOP7: 182,\n  OP_NOP8: 183,\n  OP_NOP9: 184,\n  OP_NOP10: 185,\n  OP_CHECKSIGADD: 186,\n  OP_PUBKEYHASH: 253,\n  OP_PUBKEY: 254,\n  OP_INVALIDOPCODE: 255,\n};\nexports.OPS = OPS;\nconst REVERSE_OPS = {};\nexports.REVERSE_OPS = REVERSE_OPS;\nfor (const op of Object.keys(OPS)) {\n  const code = OPS[op];\n  REVERSE_OPS[code] = op;\n}\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.tweakKey =\n  exports.tapTweakHash =\n  exports.tapleafHash =\n  exports.findScriptPath =\n  exports.toHashTree =\n  exports.rootHashFromPath =\n  exports.MAX_TAPTREE_DEPTH =\n  exports.LEAF_VERSION_TAPSCRIPT =\n    void 0;\nconst buffer_1 = require('buffer');\nconst ecc_lib_1 = require('../ecc_lib');\nconst bcrypto = require('../crypto');\nconst bufferutils_1 = require('../bufferutils');\nconst types_1 = require('../types');\nexports.LEAF_VERSION_TAPSCRIPT = 0xc0;\nexports.MAX_TAPTREE_DEPTH = 128;\nconst isHashBranch = ht => 'left' in ht && 'right' in ht;\n/**\n * Calculates the root hash from a given control block and leaf hash.\n * @param controlBlock - The control block buffer.\n * @param leafHash - The leaf hash buffer.\n * @returns The root hash buffer.\n * @throws {TypeError} If the control block length is less than 33.\n */\nfunction rootHashFromPath(controlBlock, leafHash) {\n  if (controlBlock.length < 33)\n    throw new TypeError(\n      `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`,\n    );\n  const m = (controlBlock.length - 33) / 32;\n  let kj = leafHash;\n  for (let j = 0; j < m; j++) {\n    const ej = controlBlock.slice(33 + 32 * j, 65 + 32 * j);\n    if (kj.compare(ej) < 0) {\n      kj = tapBranchHash(kj, ej);\n    } else {\n      kj = tapBranchHash(ej, kj);\n    }\n  }\n  return kj;\n}\nexports.rootHashFromPath = rootHashFromPath;\n/**\n * Build a hash tree of merkle nodes from the scripts binary tree.\n * @param scriptTree - the tree of scripts to pairwise hash.\n */\nfunction toHashTree(scriptTree) {\n  if ((0, types_1.isTapleaf)(scriptTree))\n    return { hash: tapleafHash(scriptTree) };\n  const hashes = [toHashTree(scriptTree[0]), toHashTree(scriptTree[1])];\n  hashes.sort((a, b) => a.hash.compare(b.hash));\n  const [left, right] = hashes;\n  return {\n    hash: tapBranchHash(left.hash, right.hash),\n    left,\n    right,\n  };\n}\nexports.toHashTree = toHashTree;\n/**\n * Given a HashTree, finds the path from a particular hash to the root.\n * @param node - the root of the tree\n * @param hash - the hash to search for\n * @returns - array of sibling hashes, from leaf (inclusive) to root\n * (exclusive) needed to prove inclusion of the specified hash. undefined if no\n * path is found\n */\nfunction findScriptPath(node, hash) {\n  if (isHashBranch(node)) {\n    const leftPath = findScriptPath(node.left, hash);\n    if (leftPath !== undefined) return [...leftPath, node.right.hash];\n    const rightPath = findScriptPath(node.right, hash);\n    if (rightPath !== undefined) return [...rightPath, node.left.hash];\n  } else if (node.hash.equals(hash)) {\n    return [];\n  }\n  return undefined;\n}\nexports.findScriptPath = findScriptPath;\nfunction tapleafHash(leaf) {\n  const version = leaf.version || exports.LEAF_VERSION_TAPSCRIPT;\n  return bcrypto.taggedHash(\n    'TapLeaf',\n    buffer_1.Buffer.concat([\n      buffer_1.Buffer.from([version]),\n      serializeScript(leaf.output),\n    ]),\n  );\n}\nexports.tapleafHash = tapleafHash;\nfunction tapTweakHash(pubKey, h) {\n  return bcrypto.taggedHash(\n    'TapTweak',\n    buffer_1.Buffer.concat(h ? [pubKey, h] : [pubKey]),\n  );\n}\nexports.tapTweakHash = tapTweakHash;\nfunction tweakKey(pubKey, h) {\n  if (!buffer_1.Buffer.isBuffer(pubKey)) return null;\n  if (pubKey.length !== 32) return null;\n  if (h && h.length !== 32) return null;\n  const tweakHash = tapTweakHash(pubKey, h);\n  const res = (0, ecc_lib_1.getEccLib)().xOnlyPointAddTweak(pubKey, tweakHash);\n  if (!res || res.xOnlyPubkey === null) return null;\n  return {\n    parity: res.parity,\n    x: buffer_1.Buffer.from(res.xOnlyPubkey),\n  };\n}\nexports.tweakKey = tweakKey;\nfunction tapBranchHash(a, b) {\n  return bcrypto.taggedHash('TapBranch', buffer_1.Buffer.concat([a, b]));\n}\nfunction serializeScript(s) {\n  const varintLen = bufferutils_1.varuint.encodingLength(s.length);\n  const buffer = buffer_1.Buffer.allocUnsafe(varintLen); // better\n  bufferutils_1.varuint.encode(s.length, buffer);\n  return buffer_1.Buffer.concat([buffer, s]);\n}\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.p2data = void 0;\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst types_1 = require('../types');\nconst lazy = require('./lazy');\nconst OPS = bscript.OPS;\n// output: OP_RETURN ...\n/**\n * Embeds data in a Bitcoin payment.\n * @param a - The payment object.\n * @param opts - Optional payment options.\n * @returns The modified payment object.\n * @throws {TypeError} If there is not enough data or if the output is invalid.\n */\nfunction p2data(a, opts) {\n  if (!a.data && !a.output) throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n      data: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n      ),\n    },\n    a,\n  );\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'embed', network };\n  lazy.prop(o, 'output', () => {\n    if (!a.data) return;\n    return bscript.compile([OPS.OP_RETURN].concat(a.data));\n  });\n  lazy.prop(o, 'data', () => {\n    if (!a.output) return;\n    return bscript.decompile(a.output).slice(1);\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      const chunks = bscript.decompile(a.output);\n      if (chunks[0] !== OPS.OP_RETURN) throw new TypeError('Output is invalid');\n      if (!chunks.slice(1).every(types_1.typeforce.Buffer))\n        throw new TypeError('Output is invalid');\n      if (a.data && !(0, types_1.stacksEqual)(a.data, o.data))\n        throw new TypeError('Data mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2data = p2data;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.p2tr =\n  exports.p2wsh =\n  exports.p2wpkh =\n  exports.p2sh =\n  exports.p2pkh =\n  exports.p2pk =\n  exports.p2ms =\n  exports.embed =\n    void 0;\nconst embed_1 = require('./embed');\nObject.defineProperty(exports, 'embed', {\n  enumerable: true,\n  get: function () {\n    return embed_1.p2data;\n  },\n});\nconst p2ms_1 = require('./p2ms');\nObject.defineProperty(exports, 'p2ms', {\n  enumerable: true,\n  get: function () {\n    return p2ms_1.p2ms;\n  },\n});\nconst p2pk_1 = require('./p2pk');\nObject.defineProperty(exports, 'p2pk', {\n  enumerable: true,\n  get: function () {\n    return p2pk_1.p2pk;\n  },\n});\nconst p2pkh_1 = require('./p2pkh');\nObject.defineProperty(exports, 'p2pkh', {\n  enumerable: true,\n  get: function () {\n    return p2pkh_1.p2pkh;\n  },\n});\nconst p2sh_1 = require('./p2sh');\nObject.defineProperty(exports, 'p2sh', {\n  enumerable: true,\n  get: function () {\n    return p2sh_1.p2sh;\n  },\n});\nconst p2wpkh_1 = require('./p2wpkh');\nObject.defineProperty(exports, 'p2wpkh', {\n  enumerable: true,\n  get: function () {\n    return p2wpkh_1.p2wpkh;\n  },\n});\nconst p2wsh_1 = require('./p2wsh');\nObject.defineProperty(exports, 'p2wsh', {\n  enumerable: true,\n  get: function () {\n    return p2wsh_1.p2wsh;\n  },\n});\nconst p2tr_1 = require('./p2tr');\nObject.defineProperty(exports, 'p2tr', {\n  enumerable: true,\n  get: function () {\n    return p2tr_1.p2tr;\n  },\n});\n// TODO\n// witness commitment\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.value = exports.prop = void 0;\nfunction prop(object, name, f) {\n  Object.defineProperty(object, name, {\n    configurable: true,\n    enumerable: true,\n    get() {\n      const _value = f.call(this);\n      this[name] = _value;\n      return _value;\n    },\n    set(_value) {\n      Object.defineProperty(this, name, {\n        configurable: true,\n        enumerable: true,\n        value: _value,\n        writable: true,\n      });\n    },\n  });\n}\nexports.prop = prop;\nfunction value(f) {\n  let _value;\n  return () => {\n    if (_value !== undefined) return _value;\n    _value = f();\n    return _value;\n  };\n}\nexports.value = value;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.p2ms = void 0;\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst types_1 = require('../types');\nconst lazy = require('./lazy');\nconst OPS = bscript.OPS;\nconst OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1\n// input: OP_0 [signatures ...]\n// output: m [pubKeys ...] n OP_CHECKMULTISIG\n/**\n * Represents a function that creates a Pay-to-Multisig (P2MS) payment object.\n * @param a - The payment object.\n * @param opts - Optional payment options.\n * @returns The created payment object.\n * @throws {TypeError} If the provided data is not valid.\n */\nfunction p2ms(a, opts) {\n  if (\n    !a.input &&\n    !a.output &&\n    !(a.pubkeys && a.m !== undefined) &&\n    !a.signatures\n  )\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  function isAcceptableSignature(x) {\n    return (\n      bscript.isCanonicalScriptSignature(x) ||\n      (opts.allowIncomplete && x === OPS.OP_0) !== undefined\n    );\n  }\n  (0, types_1.typeforce)(\n    {\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      m: types_1.typeforce.maybe(types_1.typeforce.Number),\n      n: types_1.typeforce.maybe(types_1.typeforce.Number),\n      output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n      pubkeys: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(types_1.isPoint),\n      ),\n      signatures: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(isAcceptableSignature),\n      ),\n      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n    },\n    a,\n  );\n  const network = a.network || networks_1.bitcoin;\n  const o = { network };\n  let chunks = [];\n  let decoded = false;\n  function decode(output) {\n    if (decoded) return;\n    decoded = true;\n    chunks = bscript.decompile(output);\n    o.m = chunks[0] - OP_INT_BASE;\n    o.n = chunks[chunks.length - 2] - OP_INT_BASE;\n    o.pubkeys = chunks.slice(1, -2);\n  }\n  lazy.prop(o, 'output', () => {\n    if (!a.m) return;\n    if (!o.n) return;\n    if (!a.pubkeys) return;\n    return bscript.compile(\n      [].concat(\n        OP_INT_BASE + a.m,\n        a.pubkeys,\n        OP_INT_BASE + o.n,\n        OPS.OP_CHECKMULTISIG,\n      ),\n    );\n  });\n  lazy.prop(o, 'm', () => {\n    if (!o.output) return;\n    decode(o.output);\n    return o.m;\n  });\n  lazy.prop(o, 'n', () => {\n    if (!o.pubkeys) return;\n    return o.pubkeys.length;\n  });\n  lazy.prop(o, 'pubkeys', () => {\n    if (!a.output) return;\n    decode(a.output);\n    return o.pubkeys;\n  });\n  lazy.prop(o, 'signatures', () => {\n    if (!a.input) return;\n    return bscript.decompile(a.input).slice(1);\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.signatures) return;\n    return bscript.compile([OPS.OP_0].concat(a.signatures));\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  lazy.prop(o, 'name', () => {\n    if (!o.m || !o.n) return;\n    return `p2ms(${o.m} of ${o.n})`;\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      decode(a.output);\n      if (!types_1.typeforce.Number(chunks[0]))\n        throw new TypeError('Output is invalid');\n      if (!types_1.typeforce.Number(chunks[chunks.length - 2]))\n        throw new TypeError('Output is invalid');\n      if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG)\n        throw new TypeError('Output is invalid');\n      if (o.m <= 0 || o.n > 16 || o.m > o.n || o.n !== chunks.length - 3)\n        throw new TypeError('Output is invalid');\n      if (!o.pubkeys.every(x => (0, types_1.isPoint)(x)))\n        throw new TypeError('Output is invalid');\n      if (a.m !== undefined && a.m !== o.m) throw new TypeError('m mismatch');\n      if (a.n !== undefined && a.n !== o.n) throw new TypeError('n mismatch');\n      if (a.pubkeys && !(0, types_1.stacksEqual)(a.pubkeys, o.pubkeys))\n        throw new TypeError('Pubkeys mismatch');\n    }\n    if (a.pubkeys) {\n      if (a.n !== undefined && a.n !== a.pubkeys.length)\n        throw new TypeError('Pubkey count mismatch');\n      o.n = a.pubkeys.length;\n      if (o.n < o.m) throw new TypeError('Pubkey count cannot be less than m');\n    }\n    if (a.signatures) {\n      if (a.signatures.length < o.m)\n        throw new TypeError('Not enough signatures provided');\n      if (a.signatures.length > o.m)\n        throw new TypeError('Too many signatures provided');\n    }\n    if (a.input) {\n      if (a.input[0] !== OPS.OP_0) throw new TypeError('Input is invalid');\n      if (\n        o.signatures.length === 0 ||\n        !o.signatures.every(isAcceptableSignature)\n      )\n        throw new TypeError('Input has invalid signature(s)');\n      if (a.signatures && !(0, types_1.stacksEqual)(a.signatures, o.signatures))\n        throw new TypeError('Signature mismatch');\n      if (a.m !== undefined && a.m !== a.signatures.length)\n        throw new TypeError('Signature count mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2ms = p2ms;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.p2pk = void 0;\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst types_1 = require('../types');\nconst lazy = require('./lazy');\nconst OPS = bscript.OPS;\n// input: {signature}\n// output: {pubKey} OP_CHECKSIG\n/**\n * Creates a pay-to-public-key (P2PK) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2PK payment object.\n * @throws {TypeError} If the required data is not provided or if the data is invalid.\n */\nfunction p2pk(a, opts) {\n  if (!a.input && !a.output && !a.pubkey && !a.input && !a.signature)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n      pubkey: types_1.typeforce.maybe(types_1.isPoint),\n      signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),\n      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n    },\n    a,\n  );\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2pk', network };\n  lazy.prop(o, 'output', () => {\n    if (!a.pubkey) return;\n    return bscript.compile([a.pubkey, OPS.OP_CHECKSIG]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (!a.output) return;\n    return a.output.slice(1, -1);\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.input) return;\n    return _chunks()[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.signature) return;\n    return bscript.compile([a.signature]);\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      if (a.output[a.output.length - 1] !== OPS.OP_CHECKSIG)\n        throw new TypeError('Output is invalid');\n      if (!(0, types_1.isPoint)(o.pubkey))\n        throw new TypeError('Output pubkey is invalid');\n      if (a.pubkey && !a.pubkey.equals(o.pubkey))\n        throw new TypeError('Pubkey mismatch');\n    }\n    if (a.signature) {\n      if (a.input && !a.input.equals(o.input))\n        throw new TypeError('Signature mismatch');\n    }\n    if (a.input) {\n      if (_chunks().length !== 1) throw new TypeError('Input is invalid');\n      if (!bscript.isCanonicalScriptSignature(o.signature))\n        throw new TypeError('Input has invalid signature');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2pk = p2pk;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.p2pkh = void 0;\nconst bcrypto = require('../crypto');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst types_1 = require('../types');\nconst lazy = require('./lazy');\nconst bs58check = require('bs58check');\nconst OPS = bscript.OPS;\n// input: {signature} {pubkey}\n// output: OP_DUP OP_HASH160 {hash160(pubkey)} OP_EQUALVERIFY OP_CHECKSIG\n/**\n * Creates a Pay-to-Public-Key-Hash (P2PKH) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2PKH payment object.\n * @throws {TypeError} If the required data is not provided or if the data is invalid.\n */\nfunction p2pkh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.input)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      address: types_1.typeforce.maybe(types_1.typeforce.String),\n      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),\n      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(25)),\n      pubkey: types_1.typeforce.maybe(types_1.isPoint),\n      signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),\n      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    const payload = Buffer.from(bs58check.decode(a.address));\n    const version = payload.readUInt8(0);\n    const hash = payload.slice(1);\n    return { version, hash };\n  });\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2pkh', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const payload = Buffer.allocUnsafe(21);\n    payload.writeUInt8(network.pubKeyHash, 0);\n    o.hash.copy(payload, 1);\n    return bs58check.encode(payload);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(3, 23);\n    if (a.address) return _address().hash;\n    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([\n      OPS.OP_DUP,\n      OPS.OP_HASH160,\n      o.hash,\n      OPS.OP_EQUALVERIFY,\n      OPS.OP_CHECKSIG,\n    ]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (!a.input) return;\n    return _chunks()[1];\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.input) return;\n    return _chunks()[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.pubkey) return;\n    if (!a.signature) return;\n    return bscript.compile([a.signature, a.pubkey]);\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (_address().version !== network.pubKeyHash)\n        throw new TypeError('Invalid version or Network mismatch');\n      if (_address().hash.length !== 20) throw new TypeError('Invalid address');\n      hash = _address().hash;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 25 ||\n        a.output[0] !== OPS.OP_DUP ||\n        a.output[1] !== OPS.OP_HASH160 ||\n        a.output[2] !== 0x14 ||\n        a.output[23] !== OPS.OP_EQUALVERIFY ||\n        a.output[24] !== OPS.OP_CHECKSIG\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(3, 23);\n      if (hash.length > 0 && !hash.equals(hash2))\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    if (a.pubkey) {\n      const pkh = bcrypto.hash160(a.pubkey);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n      else hash = pkh;\n    }\n    if (a.input) {\n      const chunks = _chunks();\n      if (chunks.length !== 2) throw new TypeError('Input is invalid');\n      if (!bscript.isCanonicalScriptSignature(chunks[0]))\n        throw new TypeError('Input has invalid signature');\n      if (!(0, types_1.isPoint)(chunks[1]))\n        throw new TypeError('Input has invalid pubkey');\n      if (a.signature && !a.signature.equals(chunks[0]))\n        throw new TypeError('Signature mismatch');\n      if (a.pubkey && !a.pubkey.equals(chunks[1]))\n        throw new TypeError('Pubkey mismatch');\n      const pkh = bcrypto.hash160(chunks[1]);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2pkh = p2pkh;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.p2sh = void 0;\nconst bcrypto = require('../crypto');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst types_1 = require('../types');\nconst lazy = require('./lazy');\nconst bs58check = require('bs58check');\nconst OPS = bscript.OPS;\n// input: [redeemScriptSig ...] {redeemScript}\n// witness: <?>\n// output: OP_HASH160 {hash160(redeemScript)} OP_EQUAL\n/**\n * Creates a Pay-to-Script-Hash (P2SH) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2SH payment object.\n * @throws {TypeError} If the required data is not provided or if the data is invalid.\n */\nfunction p2sh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.redeem && !a.input)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      address: types_1.typeforce.maybe(types_1.typeforce.String),\n      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),\n      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(23)),\n      redeem: types_1.typeforce.maybe({\n        network: types_1.typeforce.maybe(types_1.typeforce.Object),\n        output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n        input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n        witness: types_1.typeforce.maybe(\n          types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n        ),\n      }),\n      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n      witness: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n      ),\n    },\n    a,\n  );\n  let network = a.network;\n  if (!network) {\n    network = (a.redeem && a.redeem.network) || networks_1.bitcoin;\n  }\n  const o = { network };\n  const _address = lazy.value(() => {\n    const payload = Buffer.from(bs58check.decode(a.address));\n    const version = payload.readUInt8(0);\n    const hash = payload.slice(1);\n    return { version, hash };\n  });\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const _redeem = lazy.value(() => {\n    const chunks = _chunks();\n    const lastChunk = chunks[chunks.length - 1];\n    return {\n      network,\n      output: lastChunk === OPS.OP_FALSE ? Buffer.from([]) : lastChunk,\n      input: bscript.compile(chunks.slice(0, -1)),\n      witness: a.witness || [],\n    };\n  });\n  // output dependents\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const payload = Buffer.allocUnsafe(21);\n    payload.writeUInt8(o.network.scriptHash, 0);\n    o.hash.copy(payload, 1);\n    return bs58check.encode(payload);\n  });\n  lazy.prop(o, 'hash', () => {\n    // in order of least effort\n    if (a.output) return a.output.slice(2, 22);\n    if (a.address) return _address().hash;\n    if (o.redeem && o.redeem.output) return bcrypto.hash160(o.redeem.output);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_HASH160, o.hash, OPS.OP_EQUAL]);\n  });\n  // input dependents\n  lazy.prop(o, 'redeem', () => {\n    if (!a.input) return;\n    return _redeem();\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.redeem || !a.redeem.input || !a.redeem.output) return;\n    return bscript.compile(\n      [].concat(bscript.decompile(a.redeem.input), a.redeem.output),\n    );\n  });\n  lazy.prop(o, 'witness', () => {\n    if (o.redeem && o.redeem.witness) return o.redeem.witness;\n    if (o.input) return [];\n  });\n  lazy.prop(o, 'name', () => {\n    const nameParts = ['p2sh'];\n    if (o.redeem !== undefined && o.redeem.name !== undefined)\n      nameParts.push(o.redeem.name);\n    return nameParts.join('-');\n  });\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (_address().version !== network.scriptHash)\n        throw new TypeError('Invalid version or Network mismatch');\n      if (_address().hash.length !== 20) throw new TypeError('Invalid address');\n      hash = _address().hash;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 23 ||\n        a.output[0] !== OPS.OP_HASH160 ||\n        a.output[1] !== 0x14 ||\n        a.output[22] !== OPS.OP_EQUAL\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(2, 22);\n      if (hash.length > 0 && !hash.equals(hash2))\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    // inlined to prevent 'no-inner-declarations' failing\n    const checkRedeem = redeem => {\n      // is the redeem output empty/invalid?\n      if (redeem.output) {\n        const decompile = bscript.decompile(redeem.output);\n        if (!decompile || decompile.length < 1)\n          throw new TypeError('Redeem.output too short');\n        if (redeem.output.byteLength > 520)\n          throw new TypeError(\n            'Redeem.output unspendable if larger than 520 bytes',\n          );\n        if (bscript.countNonPushOnlyOPs(decompile) > 201)\n          throw new TypeError(\n            'Redeem.output unspendable with more than 201 non-push ops',\n          );\n        // match hash against other sources\n        const hash2 = bcrypto.hash160(redeem.output);\n        if (hash.length > 0 && !hash.equals(hash2))\n          throw new TypeError('Hash mismatch');\n        else hash = hash2;\n      }\n      if (redeem.input) {\n        const hasInput = redeem.input.length > 0;\n        const hasWitness = redeem.witness && redeem.witness.length > 0;\n        if (!hasInput && !hasWitness) throw new TypeError('Empty input');\n        if (hasInput && hasWitness)\n          throw new TypeError('Input and witness provided');\n        if (hasInput) {\n          const richunks = bscript.decompile(redeem.input);\n          if (!bscript.isPushOnly(richunks))\n            throw new TypeError('Non push-only scriptSig');\n        }\n      }\n    };\n    if (a.input) {\n      const chunks = _chunks();\n      if (!chunks || chunks.length < 1) throw new TypeError('Input too short');\n      if (!Buffer.isBuffer(_redeem().output))\n        throw new TypeError('Input is invalid');\n      checkRedeem(_redeem());\n    }\n    if (a.redeem) {\n      if (a.redeem.network && a.redeem.network !== network)\n        throw new TypeError('Network mismatch');\n      if (a.input) {\n        const redeem = _redeem();\n        if (a.redeem.output && !a.redeem.output.equals(redeem.output))\n          throw new TypeError('Redeem.output mismatch');\n        if (a.redeem.input && !a.redeem.input.equals(redeem.input))\n          throw new TypeError('Redeem.input mismatch');\n      }\n      checkRedeem(a.redeem);\n    }\n    if (a.witness) {\n      if (\n        a.redeem &&\n        a.redeem.witness &&\n        !(0, types_1.stacksEqual)(a.redeem.witness, a.witness)\n      )\n        throw new TypeError('Witness and redeem.witness mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2sh = p2sh;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.p2tr = void 0;\nconst buffer_1 = require('buffer');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst types_1 = require('../types');\nconst ecc_lib_1 = require('../ecc_lib');\nconst bip341_1 = require('./bip341');\nconst lazy = require('./lazy');\nconst bech32_1 = require('bech32');\nconst address_1 = require('../address');\nconst OPS = bscript.OPS;\nconst TAPROOT_WITNESS_VERSION = 0x01;\nconst ANNEX_PREFIX = 0x50;\n/**\n * Creates a Pay-to-Taproot (P2TR) payment object.\n *\n * @param a - The payment object containing the necessary data for P2TR.\n * @param opts - Optional payment options.\n * @returns The P2TR payment object.\n * @throws {TypeError} If the provided data is invalid or insufficient.\n */\nfunction p2tr(a, opts) {\n  if (\n    !a.address &&\n    !a.output &&\n    !a.pubkey &&\n    !a.internalPubkey &&\n    !(a.witness && a.witness.length > 1)\n  )\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      address: types_1.typeforce.maybe(types_1.typeforce.String),\n      input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),\n      internalPubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),\n      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),\n      pubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),\n      signature: types_1.typeforce.maybe(\n        types_1.typeforce.anyOf(\n          types_1.typeforce.BufferN(64),\n          types_1.typeforce.BufferN(65),\n        ),\n      ),\n      witness: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n      ),\n      scriptTree: types_1.typeforce.maybe(types_1.isTaptree),\n      redeem: types_1.typeforce.maybe({\n        output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n        redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number),\n        witness: types_1.typeforce.maybe(\n          types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n        ),\n      }),\n      redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    return (0, address_1.fromBech32)(a.address);\n  });\n  // remove annex if present, ignored by taproot\n  const _witness = lazy.value(() => {\n    if (!a.witness || !a.witness.length) return;\n    if (\n      a.witness.length >= 2 &&\n      a.witness[a.witness.length - 1][0] === ANNEX_PREFIX\n    ) {\n      return a.witness.slice(0, -1);\n    }\n    return a.witness.slice();\n  });\n  const _hashTree = lazy.value(() => {\n    if (a.scriptTree) return (0, bip341_1.toHashTree)(a.scriptTree);\n    if (a.hash) return { hash: a.hash };\n    return;\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2tr', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.pubkey) return;\n    const words = bech32_1.bech32m.toWords(o.pubkey);\n    words.unshift(TAPROOT_WITNESS_VERSION);\n    return bech32_1.bech32m.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    const hashTree = _hashTree();\n    if (hashTree) return hashTree.hash;\n    const w = _witness();\n    if (w && w.length > 1) {\n      const controlBlock = w[w.length - 1];\n      const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;\n      const script = w[w.length - 2];\n      const leafHash = (0, bip341_1.tapleafHash)({\n        output: script,\n        version: leafVersion,\n      });\n      return (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);\n    }\n    return null;\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.pubkey) return;\n    return bscript.compile([OPS.OP_1, o.pubkey]);\n  });\n  lazy.prop(o, 'redeemVersion', () => {\n    if (a.redeemVersion) return a.redeemVersion;\n    if (\n      a.redeem &&\n      a.redeem.redeemVersion !== undefined &&\n      a.redeem.redeemVersion !== null\n    ) {\n      return a.redeem.redeemVersion;\n    }\n    return bip341_1.LEAF_VERSION_TAPSCRIPT;\n  });\n  lazy.prop(o, 'redeem', () => {\n    const witness = _witness(); // witness without annex\n    if (!witness || witness.length < 2) return;\n    return {\n      output: witness[witness.length - 2],\n      witness: witness.slice(0, -2),\n      redeemVersion:\n        witness[witness.length - 1][0] & types_1.TAPLEAF_VERSION_MASK,\n    };\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (a.pubkey) return a.pubkey;\n    if (a.output) return a.output.slice(2);\n    if (a.address) return _address().data;\n    if (o.internalPubkey) {\n      const tweakedKey = (0, bip341_1.tweakKey)(o.internalPubkey, o.hash);\n      if (tweakedKey) return tweakedKey.x;\n    }\n  });\n  lazy.prop(o, 'internalPubkey', () => {\n    if (a.internalPubkey) return a.internalPubkey;\n    const witness = _witness();\n    if (witness && witness.length > 1)\n      return witness[witness.length - 1].slice(1, 33);\n  });\n  lazy.prop(o, 'signature', () => {\n    if (a.signature) return a.signature;\n    const witness = _witness(); // witness without annex\n    if (!witness || witness.length !== 1) return;\n    return witness[0];\n  });\n  lazy.prop(o, 'witness', () => {\n    if (a.witness) return a.witness;\n    const hashTree = _hashTree();\n    if (hashTree && a.redeem && a.redeem.output && a.internalPubkey) {\n      const leafHash = (0, bip341_1.tapleafHash)({\n        output: a.redeem.output,\n        version: o.redeemVersion,\n      });\n      const path = (0, bip341_1.findScriptPath)(hashTree, leafHash);\n      if (!path) return;\n      const outputKey = (0, bip341_1.tweakKey)(a.internalPubkey, hashTree.hash);\n      if (!outputKey) return;\n      const controlBock = buffer_1.Buffer.concat(\n        [\n          buffer_1.Buffer.from([o.redeemVersion | outputKey.parity]),\n          a.internalPubkey,\n        ].concat(path),\n      );\n      return [a.redeem.output, controlBock];\n    }\n    if (a.signature) return [a.signature];\n  });\n  // extended validation\n  if (opts.validate) {\n    let pubkey = buffer_1.Buffer.from([]);\n    if (a.address) {\n      if (network && network.bech32 !== _address().prefix)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== TAPROOT_WITNESS_VERSION)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 32)\n        throw new TypeError('Invalid address data');\n      pubkey = _address().data;\n    }\n    if (a.pubkey) {\n      if (pubkey.length > 0 && !pubkey.equals(a.pubkey))\n        throw new TypeError('Pubkey mismatch');\n      else pubkey = a.pubkey;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 34 ||\n        a.output[0] !== OPS.OP_1 ||\n        a.output[1] !== 0x20\n      )\n        throw new TypeError('Output is invalid');\n      if (pubkey.length > 0 && !pubkey.equals(a.output.slice(2)))\n        throw new TypeError('Pubkey mismatch');\n      else pubkey = a.output.slice(2);\n    }\n    if (a.internalPubkey) {\n      const tweakedKey = (0, bip341_1.tweakKey)(a.internalPubkey, o.hash);\n      if (pubkey.length > 0 && !pubkey.equals(tweakedKey.x))\n        throw new TypeError('Pubkey mismatch');\n      else pubkey = tweakedKey.x;\n    }\n    if (pubkey && pubkey.length) {\n      if (!(0, ecc_lib_1.getEccLib)().isXOnlyPoint(pubkey))\n        throw new TypeError('Invalid pubkey for p2tr');\n    }\n    const hashTree = _hashTree();\n    if (a.hash && hashTree) {\n      if (!a.hash.equals(hashTree.hash)) throw new TypeError('Hash mismatch');\n    }\n    if (a.redeem && a.redeem.output && hashTree) {\n      const leafHash = (0, bip341_1.tapleafHash)({\n        output: a.redeem.output,\n        version: o.redeemVersion,\n      });\n      if (!(0, bip341_1.findScriptPath)(hashTree, leafHash))\n        throw new TypeError('Redeem script not in tree');\n    }\n    const witness = _witness();\n    // compare the provided redeem data with the one computed from witness\n    if (a.redeem && o.redeem) {\n      if (a.redeem.redeemVersion) {\n        if (a.redeem.redeemVersion !== o.redeem.redeemVersion)\n          throw new TypeError('Redeem.redeemVersion and witness mismatch');\n      }\n      if (a.redeem.output) {\n        if (bscript.decompile(a.redeem.output).length === 0)\n          throw new TypeError('Redeem.output is invalid');\n        // output redeem is constructed from the witness\n        if (o.redeem.output && !a.redeem.output.equals(o.redeem.output))\n          throw new TypeError('Redeem.output and witness mismatch');\n      }\n      if (a.redeem.witness) {\n        if (\n          o.redeem.witness &&\n          !(0, types_1.stacksEqual)(a.redeem.witness, o.redeem.witness)\n        )\n          throw new TypeError('Redeem.witness and witness mismatch');\n      }\n    }\n    if (witness && witness.length) {\n      if (witness.length === 1) {\n        // key spending\n        if (a.signature && !a.signature.equals(witness[0]))\n          throw new TypeError('Signature mismatch');\n      } else {\n        // script path spending\n        const controlBlock = witness[witness.length - 1];\n        if (controlBlock.length < 33)\n          throw new TypeError(\n            `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`,\n          );\n        if ((controlBlock.length - 33) % 32 !== 0)\n          throw new TypeError(\n            `The control-block length of ${controlBlock.length} is incorrect!`,\n          );\n        const m = (controlBlock.length - 33) / 32;\n        if (m > 128)\n          throw new TypeError(\n            `The script path is too long. Got ${m}, expected max 128.`,\n          );\n        const internalPubkey = controlBlock.slice(1, 33);\n        if (a.internalPubkey && !a.internalPubkey.equals(internalPubkey))\n          throw new TypeError('Internal pubkey mismatch');\n        if (!(0, ecc_lib_1.getEccLib)().isXOnlyPoint(internalPubkey))\n          throw new TypeError('Invalid internalPubkey for p2tr witness');\n        const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;\n        const script = witness[witness.length - 2];\n        const leafHash = (0, bip341_1.tapleafHash)({\n          output: script,\n          version: leafVersion,\n        });\n        const hash = (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);\n        const outputKey = (0, bip341_1.tweakKey)(internalPubkey, hash);\n        if (!outputKey)\n          // todo: needs test data\n          throw new TypeError('Invalid outputKey for p2tr witness');\n        if (pubkey.length && !pubkey.equals(outputKey.x))\n          throw new TypeError('Pubkey mismatch for p2tr witness');\n        if (outputKey.parity !== (controlBlock[0] & 1))\n          throw new Error('Incorrect parity');\n      }\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2tr = p2tr;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.p2wpkh = void 0;\nconst bcrypto = require('../crypto');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst types_1 = require('../types');\nconst lazy = require('./lazy');\nconst bech32_1 = require('bech32');\nconst OPS = bscript.OPS;\nconst EMPTY_BUFFER = Buffer.alloc(0);\n// witness: {signature} {pubKey}\n// input: <>\n// output: OP_0 {pubKeyHash}\n/**\n * Creates a pay-to-witness-public-key-hash (p2wpkh) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The p2wpkh payment object.\n * @throws {TypeError} If the required data is missing or invalid.\n */\nfunction p2wpkh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      address: types_1.typeforce.maybe(types_1.typeforce.String),\n      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),\n      input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(22)),\n      pubkey: types_1.typeforce.maybe(types_1.isPoint),\n      signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),\n      witness: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n      ),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    const result = bech32_1.bech32.decode(a.address);\n    const version = result.words.shift();\n    const data = bech32_1.bech32.fromWords(result.words);\n    return {\n      version,\n      prefix: result.prefix,\n      data: Buffer.from(data),\n    };\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2wpkh', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const words = bech32_1.bech32.toWords(o.hash);\n    words.unshift(0x00);\n    return bech32_1.bech32.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(2, 22);\n    if (a.address) return _address().data;\n    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_0, o.hash]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (a.pubkey) return a.pubkey;\n    if (!a.witness) return;\n    return a.witness[1];\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.witness) return;\n    return a.witness[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!o.witness) return;\n    return EMPTY_BUFFER;\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!a.pubkey) return;\n    if (!a.signature) return;\n    return [a.signature, a.pubkey];\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (network && network.bech32 !== _address().prefix)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== 0x00)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 20)\n        throw new TypeError('Invalid address data');\n      hash = _address().data;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 22 ||\n        a.output[0] !== OPS.OP_0 ||\n        a.output[1] !== 0x14\n      )\n        throw new TypeError('Output is invalid');\n      if (hash.length > 0 && !hash.equals(a.output.slice(2)))\n        throw new TypeError('Hash mismatch');\n      else hash = a.output.slice(2);\n    }\n    if (a.pubkey) {\n      const pkh = bcrypto.hash160(a.pubkey);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n      else hash = pkh;\n      if (!(0, types_1.isPoint)(a.pubkey) || a.pubkey.length !== 33)\n        throw new TypeError('Invalid pubkey for p2wpkh');\n    }\n    if (a.witness) {\n      if (a.witness.length !== 2) throw new TypeError('Witness is invalid');\n      if (!bscript.isCanonicalScriptSignature(a.witness[0]))\n        throw new TypeError('Witness has invalid signature');\n      if (!(0, types_1.isPoint)(a.witness[1]) || a.witness[1].length !== 33)\n        throw new TypeError('Witness has invalid pubkey');\n      if (a.signature && !a.signature.equals(a.witness[0]))\n        throw new TypeError('Signature mismatch');\n      if (a.pubkey && !a.pubkey.equals(a.witness[1]))\n        throw new TypeError('Pubkey mismatch');\n      const pkh = bcrypto.hash160(a.witness[1]);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2wpkh = p2wpkh;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.p2wsh = void 0;\nconst bcrypto = require('../crypto');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst types_1 = require('../types');\nconst lazy = require('./lazy');\nconst bech32_1 = require('bech32');\nconst OPS = bscript.OPS;\nconst EMPTY_BUFFER = Buffer.alloc(0);\nfunction chunkHasUncompressedPubkey(chunk) {\n  if (\n    Buffer.isBuffer(chunk) &&\n    chunk.length === 65 &&\n    chunk[0] === 0x04 &&\n    (0, types_1.isPoint)(chunk)\n  ) {\n    return true;\n  } else {\n    return false;\n  }\n}\n// input: <>\n// witness: [redeemScriptSig ...] {redeemScript}\n// output: OP_0 {sha256(redeemScript)}\n/**\n * Creates a Pay-to-Witness-Script-Hash (P2WSH) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2WSH payment object.\n * @throws {TypeError} If the required data is missing or invalid.\n */\nfunction p2wsh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.redeem && !a.witness)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      address: types_1.typeforce.maybe(types_1.typeforce.String),\n      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),\n      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),\n      redeem: types_1.typeforce.maybe({\n        input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n        network: types_1.typeforce.maybe(types_1.typeforce.Object),\n        output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n        witness: types_1.typeforce.maybe(\n          types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n        ),\n      }),\n      input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),\n      witness: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n      ),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    const result = bech32_1.bech32.decode(a.address);\n    const version = result.words.shift();\n    const data = bech32_1.bech32.fromWords(result.words);\n    return {\n      version,\n      prefix: result.prefix,\n      data: Buffer.from(data),\n    };\n  });\n  const _rchunks = lazy.value(() => {\n    return bscript.decompile(a.redeem.input);\n  });\n  let network = a.network;\n  if (!network) {\n    network = (a.redeem && a.redeem.network) || networks_1.bitcoin;\n  }\n  const o = { network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const words = bech32_1.bech32.toWords(o.hash);\n    words.unshift(0x00);\n    return bech32_1.bech32.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(2);\n    if (a.address) return _address().data;\n    if (o.redeem && o.redeem.output) return bcrypto.sha256(o.redeem.output);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_0, o.hash]);\n  });\n  lazy.prop(o, 'redeem', () => {\n    if (!a.witness) return;\n    return {\n      output: a.witness[a.witness.length - 1],\n      input: EMPTY_BUFFER,\n      witness: a.witness.slice(0, -1),\n    };\n  });\n  lazy.prop(o, 'input', () => {\n    if (!o.witness) return;\n    return EMPTY_BUFFER;\n  });\n  lazy.prop(o, 'witness', () => {\n    // transform redeem input to witness stack?\n    if (\n      a.redeem &&\n      a.redeem.input &&\n      a.redeem.input.length > 0 &&\n      a.redeem.output &&\n      a.redeem.output.length > 0\n    ) {\n      const stack = bscript.toStack(_rchunks());\n      // assign, and blank the existing input\n      o.redeem = Object.assign({ witness: stack }, a.redeem);\n      o.redeem.input = EMPTY_BUFFER;\n      return [].concat(stack, a.redeem.output);\n    }\n    if (!a.redeem) return;\n    if (!a.redeem.output) return;\n    if (!a.redeem.witness) return;\n    return [].concat(a.redeem.witness, a.redeem.output);\n  });\n  lazy.prop(o, 'name', () => {\n    const nameParts = ['p2wsh'];\n    if (o.redeem !== undefined && o.redeem.name !== undefined)\n      nameParts.push(o.redeem.name);\n    return nameParts.join('-');\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (_address().prefix !== network.bech32)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== 0x00)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 32)\n        throw new TypeError('Invalid address data');\n      hash = _address().data;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 34 ||\n        a.output[0] !== OPS.OP_0 ||\n        a.output[1] !== 0x20\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(2);\n      if (hash.length > 0 && !hash.equals(hash2))\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    if (a.redeem) {\n      if (a.redeem.network && a.redeem.network !== network)\n        throw new TypeError('Network mismatch');\n      // is there two redeem sources?\n      if (\n        a.redeem.input &&\n        a.redeem.input.length > 0 &&\n        a.redeem.witness &&\n        a.redeem.witness.length > 0\n      )\n        throw new TypeError('Ambiguous witness source');\n      // is the redeem output non-empty/valid?\n      if (a.redeem.output) {\n        const decompile = bscript.decompile(a.redeem.output);\n        if (!decompile || decompile.length < 1)\n          throw new TypeError('Redeem.output is invalid');\n        if (a.redeem.output.byteLength > 3600)\n          throw new TypeError(\n            'Redeem.output unspendable if larger than 3600 bytes',\n          );\n        if (bscript.countNonPushOnlyOPs(decompile) > 201)\n          throw new TypeError(\n            'Redeem.output unspendable with more than 201 non-push ops',\n          );\n        // match hash against other sources\n        const hash2 = bcrypto.sha256(a.redeem.output);\n        if (hash.length > 0 && !hash.equals(hash2))\n          throw new TypeError('Hash mismatch');\n        else hash = hash2;\n      }\n      if (a.redeem.input && !bscript.isPushOnly(_rchunks()))\n        throw new TypeError('Non push-only scriptSig');\n      if (\n        a.witness &&\n        a.redeem.witness &&\n        !(0, types_1.stacksEqual)(a.witness, a.redeem.witness)\n      )\n        throw new TypeError('Witness and redeem.witness mismatch');\n      if (\n        (a.redeem.input && _rchunks().some(chunkHasUncompressedPubkey)) ||\n        (a.redeem.output &&\n          (bscript.decompile(a.redeem.output) || []).some(\n            chunkHasUncompressedPubkey,\n          ))\n      ) {\n        throw new TypeError(\n          'redeem.input or redeem.output contains uncompressed pubkey',\n        );\n      }\n    }\n    if (a.witness && a.witness.length > 0) {\n      const wScript = a.witness[a.witness.length - 1];\n      if (a.redeem && a.redeem.output && !a.redeem.output.equals(wScript))\n        throw new TypeError('Witness and redeem.output mismatch');\n      if (\n        a.witness.some(chunkHasUncompressedPubkey) ||\n        (bscript.decompile(wScript) || []).some(chunkHasUncompressedPubkey)\n      )\n        throw new TypeError('Witness contains uncompressed pubkey');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2wsh = p2wsh;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.Psbt = void 0;\nconst bip174_1 = require('bip174');\nconst varuint = require('bip174/src/lib/converter/varint');\nconst utils_1 = require('bip174/src/lib/utils');\nconst address_1 = require('./address');\nconst bufferutils_1 = require('./bufferutils');\nconst networks_1 = require('./networks');\nconst payments = require('./payments');\nconst bip341_1 = require('./payments/bip341');\nconst bscript = require('./script');\nconst transaction_1 = require('./transaction');\nconst bip371_1 = require('./psbt/bip371');\nconst psbtutils_1 = require('./psbt/psbtutils');\n/**\n * These are the default arguments for a Psbt instance.\n */\nconst DEFAULT_OPTS = {\n  /**\n   * A bitcoinjs Network object. This is only used if you pass an `address`\n   * parameter to addOutput. Otherwise it is not needed and can be left default.\n   */\n  network: networks_1.bitcoin,\n  /**\n   * When extractTransaction is called, the fee rate is checked.\n   * THIS IS NOT TO BE RELIED ON.\n   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.\n   */\n  maximumFeeRate: 5000, // satoshi per byte\n};\n/**\n * Psbt class can parse and generate a PSBT binary based off of the BIP174.\n * There are 6 roles that this class fulfills. (Explained in BIP174)\n *\n * Creator: This can be done with `new Psbt()`\n *\n * Updater: This can be done with `psbt.addInput(input)`, `psbt.addInputs(inputs)`,\n *   `psbt.addOutput(output)`, `psbt.addOutputs(outputs)` when you are looking to\n *   add new inputs and outputs to the PSBT, and `psbt.updateGlobal(itemObject)`,\n *   `psbt.updateInput(itemObject)`, `psbt.updateOutput(itemObject)`\n *   addInput requires hash: Buffer | string; and index: number; as attributes\n *   and can also include any attributes that are used in updateInput method.\n *   addOutput requires script: Buffer; and value: number; and likewise can include\n *   data for updateOutput.\n *   For a list of what attributes should be what types. Check the bip174 library.\n *   Also, check the integration tests for some examples of usage.\n *\n * Signer: There are a few methods. signAllInputs and signAllInputsAsync, which will search all input\n *   information for your pubkey or pubkeyhash, and only sign inputs where it finds\n *   your info. Or you can explicitly sign a specific input with signInput and\n *   signInputAsync. For the async methods you can create a SignerAsync object\n *   and use something like a hardware wallet to sign with. (You must implement this)\n *\n * Combiner: psbts can be combined easily with `psbt.combine(psbt2, psbt3, psbt4 ...)`\n *   the psbt calling combine will always have precedence when a conflict occurs.\n *   Combine checks if the internal bitcoin transaction is the same, so be sure that\n *   all sequences, version, locktime, etc. are the same before combining.\n *\n * Input Finalizer: This role is fairly important. Not only does it need to construct\n *   the input scriptSigs and witnesses, but it SHOULD verify the signatures etc.\n *   Before running `psbt.finalizeAllInputs()` please run `psbt.validateSignaturesOfAllInputs()`\n *   Running any finalize method will delete any data in the input(s) that are no longer\n *   needed due to the finalized scripts containing the information.\n *\n * Transaction Extractor: This role will perform some checks before returning a\n *   Transaction object. Such as fee rate not being larger than maximumFeeRate etc.\n */\nclass Psbt {\n  static fromBase64(data, opts = {}) {\n    const buffer = Buffer.from(data, 'base64');\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromHex(data, opts = {}) {\n    const buffer = Buffer.from(data, 'hex');\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromBuffer(buffer, opts = {}) {\n    const psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer);\n    const psbt = new Psbt(opts, psbtBase);\n    checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);\n    return psbt;\n  }\n  constructor(opts = {}, data = new bip174_1.Psbt(new PsbtTransaction())) {\n    this.data = data;\n    // set defaults\n    this.opts = Object.assign({}, DEFAULT_OPTS, opts);\n    this.__CACHE = {\n      __NON_WITNESS_UTXO_TX_CACHE: [],\n      __NON_WITNESS_UTXO_BUF_CACHE: [],\n      __TX_IN_CACHE: {},\n      __TX: this.data.globalMap.unsignedTx.tx,\n      // Psbt's predecessor (TransactionBuilder - now removed) behavior\n      // was to not confirm input values  before signing.\n      // Even though we highly encourage people to get\n      // the full parent transaction to verify values, the ability to\n      // sign non-segwit inputs without the full transaction was often\n      // requested. So the only way to activate is to use @ts-ignore.\n      // We will disable exporting the Psbt when unsafe sign is active.\n      // because it is not BIP174 compliant.\n      __UNSAFE_SIGN_NONSEGWIT: false,\n    };\n    if (this.data.inputs.length === 0) this.setVersion(2);\n    // Make data hidden when enumerating\n    const dpew = (obj, attr, enumerable, writable) =>\n      Object.defineProperty(obj, attr, {\n        enumerable,\n        writable,\n      });\n    dpew(this, '__CACHE', false, true);\n    dpew(this, 'opts', false, true);\n  }\n  get inputCount() {\n    return this.data.inputs.length;\n  }\n  get version() {\n    return this.__CACHE.__TX.version;\n  }\n  set version(version) {\n    this.setVersion(version);\n  }\n  get locktime() {\n    return this.__CACHE.__TX.locktime;\n  }\n  set locktime(locktime) {\n    this.setLocktime(locktime);\n  }\n  get txInputs() {\n    return this.__CACHE.__TX.ins.map(input => ({\n      hash: (0, bufferutils_1.cloneBuffer)(input.hash),\n      index: input.index,\n      sequence: input.sequence,\n    }));\n  }\n  get txOutputs() {\n    return this.__CACHE.__TX.outs.map(output => {\n      let address;\n      try {\n        address = (0, address_1.fromOutputScript)(\n          output.script,\n          this.opts.network,\n        );\n      } catch (_) {}\n      return {\n        script: (0, bufferutils_1.cloneBuffer)(output.script),\n        value: output.value,\n        address,\n      };\n    });\n  }\n  combine(...those) {\n    this.data.combine(...those.map(o => o.data));\n    return this;\n  }\n  clone() {\n    // TODO: more efficient cloning\n    const res = Psbt.fromBuffer(this.data.toBuffer());\n    res.opts = JSON.parse(JSON.stringify(this.opts));\n    return res;\n  }\n  setMaximumFeeRate(satoshiPerByte) {\n    check32Bit(satoshiPerByte); // 42.9 BTC per byte IS excessive... so throw\n    this.opts.maximumFeeRate = satoshiPerByte;\n  }\n  setVersion(version) {\n    check32Bit(version);\n    checkInputsForPartialSig(this.data.inputs, 'setVersion');\n    const c = this.__CACHE;\n    c.__TX.version = version;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setLocktime(locktime) {\n    check32Bit(locktime);\n    checkInputsForPartialSig(this.data.inputs, 'setLocktime');\n    const c = this.__CACHE;\n    c.__TX.locktime = locktime;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setInputSequence(inputIndex, sequence) {\n    check32Bit(sequence);\n    checkInputsForPartialSig(this.data.inputs, 'setInputSequence');\n    const c = this.__CACHE;\n    if (c.__TX.ins.length <= inputIndex) {\n      throw new Error('Input index too high');\n    }\n    c.__TX.ins[inputIndex].sequence = sequence;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addInputs(inputDatas) {\n    inputDatas.forEach(inputData => this.addInput(inputData));\n    return this;\n  }\n  addInput(inputData) {\n    if (\n      arguments.length > 1 ||\n      !inputData ||\n      inputData.hash === undefined ||\n      inputData.index === undefined\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addInput. ` +\n          `Requires single object with at least [hash] and [index]`,\n      );\n    }\n    (0, bip371_1.checkTaprootInputFields)(inputData, inputData, 'addInput');\n    checkInputsForPartialSig(this.data.inputs, 'addInput');\n    if (inputData.witnessScript) checkInvalidP2WSH(inputData.witnessScript);\n    const c = this.__CACHE;\n    this.data.addInput(inputData);\n    const txIn = c.__TX.ins[c.__TX.ins.length - 1];\n    checkTxInputCache(c, txIn);\n    const inputIndex = this.data.inputs.length - 1;\n    const input = this.data.inputs[inputIndex];\n    if (input.nonWitnessUtxo) {\n      addNonWitnessTxCache(this.__CACHE, input, inputIndex);\n    }\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addOutputs(outputDatas) {\n    outputDatas.forEach(outputData => this.addOutput(outputData));\n    return this;\n  }\n  addOutput(outputData) {\n    if (\n      arguments.length > 1 ||\n      !outputData ||\n      outputData.value === undefined ||\n      (outputData.address === undefined && outputData.script === undefined)\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addOutput. ` +\n          `Requires single object with at least [script or address] and [value]`,\n      );\n    }\n    checkInputsForPartialSig(this.data.inputs, 'addOutput');\n    const { address } = outputData;\n    if (typeof address === 'string') {\n      const { network } = this.opts;\n      const script = (0, address_1.toOutputScript)(address, network);\n      outputData = Object.assign({}, outputData, { script });\n    }\n    (0, bip371_1.checkTaprootOutputFields)(outputData, outputData, 'addOutput');\n    const c = this.__CACHE;\n    this.data.addOutput(outputData);\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  extractTransaction(disableFeeCheck) {\n    if (!this.data.inputs.every(isFinalized)) throw new Error('Not finalized');\n    const c = this.__CACHE;\n    if (!disableFeeCheck) {\n      checkFees(this, c, this.opts);\n    }\n    if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;\n    const tx = c.__TX.clone();\n    inputFinalizeGetAmts(this.data.inputs, tx, c, true);\n    return tx;\n  }\n  getFeeRate() {\n    return getTxCacheValue(\n      '__FEE_RATE',\n      'fee rate',\n      this.data.inputs,\n      this.__CACHE,\n    );\n  }\n  getFee() {\n    return getTxCacheValue('__FEE', 'fee', this.data.inputs, this.__CACHE);\n  }\n  finalizeAllInputs() {\n    (0, utils_1.checkForInput)(this.data.inputs, 0); // making sure we have at least one\n    range(this.data.inputs.length).forEach(idx => this.finalizeInput(idx));\n    return this;\n  }\n  finalizeInput(inputIndex, finalScriptsFunc) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    if ((0, bip371_1.isTaprootInput)(input))\n      return this._finalizeTaprootInput(\n        inputIndex,\n        input,\n        undefined,\n        finalScriptsFunc,\n      );\n    return this._finalizeInput(inputIndex, input, finalScriptsFunc);\n  }\n  finalizeTaprootInput(\n    inputIndex,\n    tapLeafHashToFinalize,\n    finalScriptsFunc = bip371_1.tapScriptFinalizer,\n  ) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    if ((0, bip371_1.isTaprootInput)(input))\n      return this._finalizeTaprootInput(\n        inputIndex,\n        input,\n        tapLeafHashToFinalize,\n        finalScriptsFunc,\n      );\n    throw new Error(`Cannot finalize input #${inputIndex}. Not Taproot.`);\n  }\n  _finalizeInput(inputIndex, input, finalScriptsFunc = getFinalScripts) {\n    const { script, isP2SH, isP2WSH, isSegwit } = getScriptFromInput(\n      inputIndex,\n      input,\n      this.__CACHE,\n    );\n    if (!script) throw new Error(`No script found for input #${inputIndex}`);\n    checkPartialSigSighashes(input);\n    const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(\n      inputIndex,\n      input,\n      script,\n      isSegwit,\n      isP2SH,\n      isP2WSH,\n    );\n    if (finalScriptSig) this.data.updateInput(inputIndex, { finalScriptSig });\n    if (finalScriptWitness)\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    if (!finalScriptSig && !finalScriptWitness)\n      throw new Error(`Unknown error finalizing input #${inputIndex}`);\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n  _finalizeTaprootInput(\n    inputIndex,\n    input,\n    tapLeafHashToFinalize,\n    finalScriptsFunc = bip371_1.tapScriptFinalizer,\n  ) {\n    if (!input.witnessUtxo)\n      throw new Error(\n        `Cannot finalize input #${inputIndex}. Missing withness utxo.`,\n      );\n    // Check key spend first. Increased privacy and reduced block space.\n    if (input.tapKeySig) {\n      const payment = payments.p2tr({\n        output: input.witnessUtxo.script,\n        signature: input.tapKeySig,\n      });\n      const finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(\n        payment.witness,\n      );\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    } else {\n      const { finalScriptWitness } = finalScriptsFunc(\n        inputIndex,\n        input,\n        tapLeafHashToFinalize,\n      );\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    }\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n  getInputType(inputIndex) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    const script = getScriptFromUtxo(inputIndex, input, this.__CACHE);\n    const result = getMeaningfulScript(\n      script,\n      inputIndex,\n      'input',\n      input.redeemScript || redeemFromFinalScriptSig(input.finalScriptSig),\n      input.witnessScript ||\n        redeemFromFinalWitnessScript(input.finalScriptWitness),\n    );\n    const type = result.type === 'raw' ? '' : result.type + '-';\n    const mainType = classifyScript(result.meaningfulScript);\n    return type + mainType;\n  }\n  inputHasPubkey(inputIndex, pubkey) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    return pubkeyInInput(pubkey, input, inputIndex, this.__CACHE);\n  }\n  inputHasHDKey(inputIndex, root) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return (\n      !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine)\n    );\n  }\n  outputHasPubkey(outputIndex, pubkey) {\n    const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);\n    return pubkeyInOutput(pubkey, output, outputIndex, this.__CACHE);\n  }\n  outputHasHDKey(outputIndex, root) {\n    const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return (\n      !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine)\n    );\n  }\n  validateSignaturesOfAllInputs(validator) {\n    (0, utils_1.checkForInput)(this.data.inputs, 0); // making sure we have at least one\n    const results = range(this.data.inputs.length).map(idx =>\n      this.validateSignaturesOfInput(idx, validator),\n    );\n    return results.reduce((final, res) => res === true && final, true);\n  }\n  validateSignaturesOfInput(inputIndex, validator, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    if ((0, bip371_1.isTaprootInput)(input))\n      return this.validateSignaturesOfTaprootInput(\n        inputIndex,\n        validator,\n        pubkey,\n      );\n    return this._validateSignaturesOfInput(inputIndex, validator, pubkey);\n  }\n  _validateSignaturesOfInput(inputIndex, validator, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    const partialSig = (input || {}).partialSig;\n    if (!input || !partialSig || partialSig.length < 1)\n      throw new Error('No signatures to validate');\n    if (typeof validator !== 'function')\n      throw new Error('Need validator function to validate signatures');\n    const mySigs = pubkey\n      ? partialSig.filter(sig => sig.pubkey.equals(pubkey))\n      : partialSig;\n    if (mySigs.length < 1) throw new Error('No signatures for this pubkey');\n    const results = [];\n    let hashCache;\n    let scriptCache;\n    let sighashCache;\n    for (const pSig of mySigs) {\n      const sig = bscript.signature.decode(pSig.signature);\n      const { hash, script } =\n        sighashCache !== sig.hashType\n          ? getHashForSig(\n              inputIndex,\n              Object.assign({}, input, { sighashType: sig.hashType }),\n              this.__CACHE,\n              true,\n            )\n          : { hash: hashCache, script: scriptCache };\n      sighashCache = sig.hashType;\n      hashCache = hash;\n      scriptCache = script;\n      checkScriptForPubkey(pSig.pubkey, script, 'verify');\n      results.push(validator(pSig.pubkey, hash, sig.signature));\n    }\n    return results.every(res => res === true);\n  }\n  validateSignaturesOfTaprootInput(inputIndex, validator, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    const tapKeySig = (input || {}).tapKeySig;\n    const tapScriptSig = (input || {}).tapScriptSig;\n    if (!input && !tapKeySig && !(tapScriptSig && !tapScriptSig.length))\n      throw new Error('No signatures to validate');\n    if (typeof validator !== 'function')\n      throw new Error('Need validator function to validate signatures');\n    pubkey = pubkey && (0, bip371_1.toXOnly)(pubkey);\n    const allHashses = pubkey\n      ? getTaprootHashesForSig(\n          inputIndex,\n          input,\n          this.data.inputs,\n          pubkey,\n          this.__CACHE,\n        )\n      : getAllTaprootHashesForSig(\n          inputIndex,\n          input,\n          this.data.inputs,\n          this.__CACHE,\n        );\n    if (!allHashses.length) throw new Error('No signatures for this pubkey');\n    const tapKeyHash = allHashses.find(h => !h.leafHash);\n    let validationResultCount = 0;\n    if (tapKeySig && tapKeyHash) {\n      const isValidTapkeySig = validator(\n        tapKeyHash.pubkey,\n        tapKeyHash.hash,\n        trimTaprootSig(tapKeySig),\n      );\n      if (!isValidTapkeySig) return false;\n      validationResultCount++;\n    }\n    if (tapScriptSig) {\n      for (const tapSig of tapScriptSig) {\n        const tapSigHash = allHashses.find(h => tapSig.pubkey.equals(h.pubkey));\n        if (tapSigHash) {\n          const isValidTapScriptSig = validator(\n            tapSig.pubkey,\n            tapSigHash.hash,\n            trimTaprootSig(tapSig.signature),\n          );\n          if (!isValidTapScriptSig) return false;\n          validationResultCount++;\n        }\n      }\n    }\n    return validationResultCount > 0;\n  }\n  signAllInputsHD(\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInputHD(i, hdKeyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsHDAsync(\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const results = [];\n      const promises = [];\n      for (const i of range(this.data.inputs.length)) {\n        promises.push(\n          this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInputHD(\n    inputIndex,\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n    signers.forEach(signer => this.signInput(inputIndex, signer, sighashTypes));\n    return this;\n  }\n  signInputHDAsync(\n    inputIndex,\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n      const promises = signers.map(signer =>\n        this.signInputAsync(inputIndex, signer, sighashTypes),\n      );\n      return Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(reject);\n    });\n  }\n  signAllInputs(keyPair, sighashTypes) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    // TODO: Add a pubkey/pubkeyhash cache to each input\n    // as input information is added, then eventually\n    // optimize this method.\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInput(i, keyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsAsync(keyPair, sighashTypes) {\n    return new Promise((resolve, reject) => {\n      if (!keyPair || !keyPair.publicKey)\n        return reject(new Error('Need Signer to sign input'));\n      // TODO: Add a pubkey/pubkeyhash cache to each input\n      // as input information is added, then eventually\n      // optimize this method.\n      const results = [];\n      const promises = [];\n      for (const [i] of this.data.inputs.entries()) {\n        promises.push(\n          this.signInputAsync(i, keyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInput(inputIndex, keyPair, sighashTypes) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    if ((0, bip371_1.isTaprootInput)(input)) {\n      return this._signTaprootInput(\n        inputIndex,\n        input,\n        keyPair,\n        undefined,\n        sighashTypes,\n      );\n    }\n    return this._signInput(inputIndex, keyPair, sighashTypes);\n  }\n  signTaprootInput(inputIndex, keyPair, tapLeafHashToSign, sighashTypes) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    if ((0, bip371_1.isTaprootInput)(input))\n      return this._signTaprootInput(\n        inputIndex,\n        input,\n        keyPair,\n        tapLeafHashToSign,\n        sighashTypes,\n      );\n    throw new Error(`Input #${inputIndex} is not of type Taproot.`);\n  }\n  _signInput(\n    inputIndex,\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    const { hash, sighashType } = getHashAndSighashType(\n      this.data.inputs,\n      inputIndex,\n      keyPair.publicKey,\n      this.__CACHE,\n      sighashTypes,\n    );\n    const partialSig = [\n      {\n        pubkey: keyPair.publicKey,\n        signature: bscript.signature.encode(keyPair.sign(hash), sighashType),\n      },\n    ];\n    this.data.updateInput(inputIndex, { partialSig });\n    return this;\n  }\n  _signTaprootInput(\n    inputIndex,\n    input,\n    keyPair,\n    tapLeafHashToSign,\n    allowedSighashTypes = [transaction_1.Transaction.SIGHASH_DEFAULT],\n  ) {\n    const hashesForSig = this.checkTaprootHashesForSig(\n      inputIndex,\n      input,\n      keyPair,\n      tapLeafHashToSign,\n      allowedSighashTypes,\n    );\n    const tapKeySig = hashesForSig\n      .filter(h => !h.leafHash)\n      .map(h =>\n        (0, bip371_1.serializeTaprootSignature)(\n          keyPair.signSchnorr(h.hash),\n          input.sighashType,\n        ),\n      )[0];\n    const tapScriptSig = hashesForSig\n      .filter(h => !!h.leafHash)\n      .map(h => ({\n        pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),\n        signature: (0, bip371_1.serializeTaprootSignature)(\n          keyPair.signSchnorr(h.hash),\n          input.sighashType,\n        ),\n        leafHash: h.leafHash,\n      }));\n    if (tapKeySig) {\n      this.data.updateInput(inputIndex, { tapKeySig });\n    }\n    if (tapScriptSig.length) {\n      this.data.updateInput(inputIndex, { tapScriptSig });\n    }\n    return this;\n  }\n  signInputAsync(inputIndex, keyPair, sighashTypes) {\n    return Promise.resolve().then(() => {\n      if (!keyPair || !keyPair.publicKey)\n        throw new Error('Need Signer to sign input');\n      const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n      if ((0, bip371_1.isTaprootInput)(input))\n        return this._signTaprootInputAsync(\n          inputIndex,\n          input,\n          keyPair,\n          undefined,\n          sighashTypes,\n        );\n      return this._signInputAsync(inputIndex, keyPair, sighashTypes);\n    });\n  }\n  signTaprootInputAsync(inputIndex, keyPair, tapLeafHash, sighashTypes) {\n    return Promise.resolve().then(() => {\n      if (!keyPair || !keyPair.publicKey)\n        throw new Error('Need Signer to sign input');\n      const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n      if ((0, bip371_1.isTaprootInput)(input))\n        return this._signTaprootInputAsync(\n          inputIndex,\n          input,\n          keyPair,\n          tapLeafHash,\n          sighashTypes,\n        );\n      throw new Error(`Input #${inputIndex} is not of type Taproot.`);\n    });\n  }\n  _signInputAsync(\n    inputIndex,\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    const { hash, sighashType } = getHashAndSighashType(\n      this.data.inputs,\n      inputIndex,\n      keyPair.publicKey,\n      this.__CACHE,\n      sighashTypes,\n    );\n    return Promise.resolve(keyPair.sign(hash)).then(signature => {\n      const partialSig = [\n        {\n          pubkey: keyPair.publicKey,\n          signature: bscript.signature.encode(signature, sighashType),\n        },\n      ];\n      this.data.updateInput(inputIndex, { partialSig });\n    });\n  }\n  async _signTaprootInputAsync(\n    inputIndex,\n    input,\n    keyPair,\n    tapLeafHash,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_DEFAULT],\n  ) {\n    const hashesForSig = this.checkTaprootHashesForSig(\n      inputIndex,\n      input,\n      keyPair,\n      tapLeafHash,\n      sighashTypes,\n    );\n    const signaturePromises = [];\n    const tapKeyHash = hashesForSig.filter(h => !h.leafHash)[0];\n    if (tapKeyHash) {\n      const tapKeySigPromise = Promise.resolve(\n        keyPair.signSchnorr(tapKeyHash.hash),\n      ).then(sig => {\n        return {\n          tapKeySig: (0, bip371_1.serializeTaprootSignature)(\n            sig,\n            input.sighashType,\n          ),\n        };\n      });\n      signaturePromises.push(tapKeySigPromise);\n    }\n    const tapScriptHashes = hashesForSig.filter(h => !!h.leafHash);\n    if (tapScriptHashes.length) {\n      const tapScriptSigPromises = tapScriptHashes.map(tsh => {\n        return Promise.resolve(keyPair.signSchnorr(tsh.hash)).then(\n          signature => {\n            const tapScriptSig = [\n              {\n                pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),\n                signature: (0, bip371_1.serializeTaprootSignature)(\n                  signature,\n                  input.sighashType,\n                ),\n                leafHash: tsh.leafHash,\n              },\n            ];\n            return { tapScriptSig };\n          },\n        );\n      });\n      signaturePromises.push(...tapScriptSigPromises);\n    }\n    return Promise.all(signaturePromises).then(results => {\n      results.forEach(v => this.data.updateInput(inputIndex, v));\n    });\n  }\n  checkTaprootHashesForSig(\n    inputIndex,\n    input,\n    keyPair,\n    tapLeafHashToSign,\n    allowedSighashTypes,\n  ) {\n    if (typeof keyPair.signSchnorr !== 'function')\n      throw new Error(\n        `Need Schnorr Signer to sign taproot input #${inputIndex}.`,\n      );\n    const hashesForSig = getTaprootHashesForSig(\n      inputIndex,\n      input,\n      this.data.inputs,\n      keyPair.publicKey,\n      this.__CACHE,\n      tapLeafHashToSign,\n      allowedSighashTypes,\n    );\n    if (!hashesForSig || !hashesForSig.length)\n      throw new Error(\n        `Can not sign for input #${inputIndex} with the key ${keyPair.publicKey.toString(\n          'hex',\n        )}`,\n      );\n    return hashesForSig;\n  }\n  toBuffer() {\n    checkCache(this.__CACHE);\n    return this.data.toBuffer();\n  }\n  toHex() {\n    checkCache(this.__CACHE);\n    return this.data.toHex();\n  }\n  toBase64() {\n    checkCache(this.__CACHE);\n    return this.data.toBase64();\n  }\n  updateGlobal(updateData) {\n    this.data.updateGlobal(updateData);\n    return this;\n  }\n  updateInput(inputIndex, updateData) {\n    if (updateData.witnessScript) checkInvalidP2WSH(updateData.witnessScript);\n    (0, bip371_1.checkTaprootInputFields)(\n      this.data.inputs[inputIndex],\n      updateData,\n      'updateInput',\n    );\n    this.data.updateInput(inputIndex, updateData);\n    if (updateData.nonWitnessUtxo) {\n      addNonWitnessTxCache(\n        this.__CACHE,\n        this.data.inputs[inputIndex],\n        inputIndex,\n      );\n    }\n    return this;\n  }\n  updateOutput(outputIndex, updateData) {\n    const outputData = this.data.outputs[outputIndex];\n    (0, bip371_1.checkTaprootOutputFields)(\n      outputData,\n      updateData,\n      'updateOutput',\n    );\n    this.data.updateOutput(outputIndex, updateData);\n    return this;\n  }\n  addUnknownKeyValToGlobal(keyVal) {\n    this.data.addUnknownKeyValToGlobal(keyVal);\n    return this;\n  }\n  addUnknownKeyValToInput(inputIndex, keyVal) {\n    this.data.addUnknownKeyValToInput(inputIndex, keyVal);\n    return this;\n  }\n  addUnknownKeyValToOutput(outputIndex, keyVal) {\n    this.data.addUnknownKeyValToOutput(outputIndex, keyVal);\n    return this;\n  }\n  clearFinalizedInput(inputIndex) {\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n}\nexports.Psbt = Psbt;\n/**\n * This function is needed to pass to the bip174 base class's fromBuffer.\n * It takes the \"transaction buffer\" portion of the psbt buffer and returns a\n * Transaction (From the bip174 library) interface.\n */\nconst transactionFromBuffer = buffer => new PsbtTransaction(buffer);\n/**\n * This class implements the Transaction interface from bip174 library.\n * It contains a bitcoinjs-lib Transaction object.\n */\nclass PsbtTransaction {\n  constructor(buffer = Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {\n    this.tx = transaction_1.Transaction.fromBuffer(buffer);\n    checkTxEmpty(this.tx);\n    Object.defineProperty(this, 'tx', {\n      enumerable: false,\n      writable: true,\n    });\n  }\n  getInputOutputCounts() {\n    return {\n      inputCount: this.tx.ins.length,\n      outputCount: this.tx.outs.length,\n    };\n  }\n  addInput(input) {\n    if (\n      input.hash === undefined ||\n      input.index === undefined ||\n      (!Buffer.isBuffer(input.hash) && typeof input.hash !== 'string') ||\n      typeof input.index !== 'number'\n    ) {\n      throw new Error('Error adding input.');\n    }\n    const hash =\n      typeof input.hash === 'string'\n        ? (0, bufferutils_1.reverseBuffer)(Buffer.from(input.hash, 'hex'))\n        : input.hash;\n    this.tx.addInput(hash, input.index, input.sequence);\n  }\n  addOutput(output) {\n    if (\n      output.script === undefined ||\n      output.value === undefined ||\n      !Buffer.isBuffer(output.script) ||\n      typeof output.value !== 'number'\n    ) {\n      throw new Error('Error adding output.');\n    }\n    this.tx.addOutput(output.script, output.value);\n  }\n  toBuffer() {\n    return this.tx.toBuffer();\n  }\n}\nfunction canFinalize(input, script, scriptType) {\n  switch (scriptType) {\n    case 'pubkey':\n    case 'pubkeyhash':\n    case 'witnesspubkeyhash':\n      return hasSigs(1, input.partialSig);\n    case 'multisig':\n      const p2ms = payments.p2ms({ output: script });\n      return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);\n    default:\n      return false;\n  }\n}\nfunction checkCache(cache) {\n  if (cache.__UNSAFE_SIGN_NONSEGWIT !== false) {\n    throw new Error('Not BIP174 compliant, can not export');\n  }\n}\nfunction hasSigs(neededSigs, partialSig, pubkeys) {\n  if (!partialSig) return false;\n  let sigs;\n  if (pubkeys) {\n    sigs = pubkeys\n      .map(pkey => {\n        const pubkey = compressPubkey(pkey);\n        return partialSig.find(pSig => pSig.pubkey.equals(pubkey));\n      })\n      .filter(v => !!v);\n  } else {\n    sigs = partialSig;\n  }\n  if (sigs.length > neededSigs) throw new Error('Too many signatures');\n  return sigs.length === neededSigs;\n}\nfunction isFinalized(input) {\n  return !!input.finalScriptSig || !!input.finalScriptWitness;\n}\nfunction bip32DerivationIsMine(root) {\n  return d => {\n    if (!d.masterFingerprint.equals(root.fingerprint)) return false;\n    if (!root.derivePath(d.path).publicKey.equals(d.pubkey)) return false;\n    return true;\n  };\n}\nfunction check32Bit(num) {\n  if (\n    typeof num !== 'number' ||\n    num !== Math.floor(num) ||\n    num > 0xffffffff ||\n    num < 0\n  ) {\n    throw new Error('Invalid 32 bit integer');\n  }\n}\nfunction checkFees(psbt, cache, opts) {\n  const feeRate = cache.__FEE_RATE || psbt.getFeeRate();\n  const vsize = cache.__EXTRACTED_TX.virtualSize();\n  const satoshis = feeRate * vsize;\n  if (feeRate >= opts.maximumFeeRate) {\n    throw new Error(\n      `Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in ` +\n        `fees, which is ${feeRate} satoshi per byte for a transaction ` +\n        `with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per ` +\n        `byte). Use setMaximumFeeRate method to raise your threshold, or ` +\n        `pass true to the first arg of extractTransaction.`,\n    );\n  }\n}\nfunction checkInputsForPartialSig(inputs, action) {\n  inputs.forEach(input => {\n    const throws = (0, bip371_1.isTaprootInput)(input)\n      ? (0, bip371_1.checkTaprootInputForSigs)(input, action)\n      : (0, psbtutils_1.checkInputForSig)(input, action);\n    if (throws)\n      throw new Error('Can not modify transaction, signatures exist.');\n  });\n}\nfunction checkPartialSigSighashes(input) {\n  if (!input.sighashType || !input.partialSig) return;\n  const { partialSig, sighashType } = input;\n  partialSig.forEach(pSig => {\n    const { hashType } = bscript.signature.decode(pSig.signature);\n    if (sighashType !== hashType) {\n      throw new Error('Signature sighash does not match input sighash type');\n    }\n  });\n}\nfunction checkScriptForPubkey(pubkey, script, action) {\n  if (!(0, psbtutils_1.pubkeyInScript)(pubkey, script)) {\n    throw new Error(\n      `Can not ${action} for this input with the key ${pubkey.toString('hex')}`,\n    );\n  }\n}\nfunction checkTxEmpty(tx) {\n  const isEmpty = tx.ins.every(\n    input =>\n      input.script &&\n      input.script.length === 0 &&\n      input.witness &&\n      input.witness.length === 0,\n  );\n  if (!isEmpty) {\n    throw new Error('Format Error: Transaction ScriptSigs are not empty');\n  }\n}\nfunction checkTxForDupeIns(tx, cache) {\n  tx.ins.forEach(input => {\n    checkTxInputCache(cache, input);\n  });\n}\nfunction checkTxInputCache(cache, input) {\n  const key =\n    (0, bufferutils_1.reverseBuffer)(Buffer.from(input.hash)).toString('hex') +\n    ':' +\n    input.index;\n  if (cache.__TX_IN_CACHE[key]) throw new Error('Duplicate input detected.');\n  cache.__TX_IN_CACHE[key] = 1;\n}\nfunction scriptCheckerFactory(payment, paymentScriptName) {\n  return (inputIndex, scriptPubKey, redeemScript, ioType) => {\n    const redeemScriptOutput = payment({\n      redeem: { output: redeemScript },\n    }).output;\n    if (!scriptPubKey.equals(redeemScriptOutput)) {\n      throw new Error(\n        `${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`,\n      );\n    }\n  };\n}\nconst checkRedeemScript = scriptCheckerFactory(payments.p2sh, 'Redeem script');\nconst checkWitnessScript = scriptCheckerFactory(\n  payments.p2wsh,\n  'Witness script',\n);\nfunction getTxCacheValue(key, name, inputs, c) {\n  if (!inputs.every(isFinalized))\n    throw new Error(`PSBT must be finalized to calculate ${name}`);\n  if (key === '__FEE_RATE' && c.__FEE_RATE) return c.__FEE_RATE;\n  if (key === '__FEE' && c.__FEE) return c.__FEE;\n  let tx;\n  let mustFinalize = true;\n  if (c.__EXTRACTED_TX) {\n    tx = c.__EXTRACTED_TX;\n    mustFinalize = false;\n  } else {\n    tx = c.__TX.clone();\n  }\n  inputFinalizeGetAmts(inputs, tx, c, mustFinalize);\n  if (key === '__FEE_RATE') return c.__FEE_RATE;\n  else if (key === '__FEE') return c.__FEE;\n}\nfunction getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {\n  const scriptType = classifyScript(script);\n  if (!canFinalize(input, script, scriptType))\n    throw new Error(`Can not finalize input #${inputIndex}`);\n  return prepareFinalScripts(\n    script,\n    scriptType,\n    input.partialSig,\n    isSegwit,\n    isP2SH,\n    isP2WSH,\n  );\n}\nfunction prepareFinalScripts(\n  script,\n  scriptType,\n  partialSig,\n  isSegwit,\n  isP2SH,\n  isP2WSH,\n) {\n  let finalScriptSig;\n  let finalScriptWitness;\n  // Wow, the payments API is very handy\n  const payment = getPayment(script, scriptType, partialSig);\n  const p2wsh = !isP2WSH ? null : payments.p2wsh({ redeem: payment });\n  const p2sh = !isP2SH ? null : payments.p2sh({ redeem: p2wsh || payment });\n  if (isSegwit) {\n    if (p2wsh) {\n      finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(\n        p2wsh.witness,\n      );\n    } else {\n      finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(\n        payment.witness,\n      );\n    }\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    }\n  } else {\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    } else {\n      finalScriptSig = payment.input;\n    }\n  }\n  return {\n    finalScriptSig,\n    finalScriptWitness,\n  };\n}\nfunction getHashAndSighashType(\n  inputs,\n  inputIndex,\n  pubkey,\n  cache,\n  sighashTypes,\n) {\n  const input = (0, utils_1.checkForInput)(inputs, inputIndex);\n  const { hash, sighashType, script } = getHashForSig(\n    inputIndex,\n    input,\n    cache,\n    false,\n    sighashTypes,\n  );\n  checkScriptForPubkey(pubkey, script, 'sign');\n  return {\n    hash,\n    sighashType,\n  };\n}\nfunction getHashForSig(inputIndex, input, cache, forValidate, sighashTypes) {\n  const unsignedTx = cache.__TX;\n  const sighashType =\n    input.sighashType || transaction_1.Transaction.SIGHASH_ALL;\n  checkSighashTypeAllowed(sighashType, sighashTypes);\n  let hash;\n  let prevout;\n  if (input.nonWitnessUtxo) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n      cache,\n      input,\n      inputIndex,\n    );\n    const prevoutHash = unsignedTx.ins[inputIndex].hash;\n    const utxoHash = nonWitnessUtxoTx.getHash();\n    // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout\n    if (!prevoutHash.equals(utxoHash)) {\n      throw new Error(\n        `Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`,\n      );\n    }\n    const prevoutIndex = unsignedTx.ins[inputIndex].index;\n    prevout = nonWitnessUtxoTx.outs[prevoutIndex];\n  } else if (input.witnessUtxo) {\n    prevout = input.witnessUtxo;\n  } else {\n    throw new Error('Need a Utxo input item for signing');\n  }\n  const { meaningfulScript, type } = getMeaningfulScript(\n    prevout.script,\n    inputIndex,\n    'input',\n    input.redeemScript,\n    input.witnessScript,\n  );\n  if (['p2sh-p2wsh', 'p2wsh'].indexOf(type) >= 0) {\n    hash = unsignedTx.hashForWitnessV0(\n      inputIndex,\n      meaningfulScript,\n      prevout.value,\n      sighashType,\n    );\n  } else if ((0, psbtutils_1.isP2WPKH)(meaningfulScript)) {\n    // P2WPKH uses the P2PKH template for prevoutScript when signing\n    const signingScript = payments.p2pkh({\n      hash: meaningfulScript.slice(2),\n    }).output;\n    hash = unsignedTx.hashForWitnessV0(\n      inputIndex,\n      signingScript,\n      prevout.value,\n      sighashType,\n    );\n  } else {\n    // non-segwit\n    if (\n      input.nonWitnessUtxo === undefined &&\n      cache.__UNSAFE_SIGN_NONSEGWIT === false\n    )\n      throw new Error(\n        `Input #${inputIndex} has witnessUtxo but non-segwit script: ` +\n          `${meaningfulScript.toString('hex')}`,\n      );\n    if (!forValidate && cache.__UNSAFE_SIGN_NONSEGWIT !== false)\n      console.warn(\n        'Warning: Signing non-segwit inputs without the full parent transaction ' +\n          'means there is a chance that a miner could feed you incorrect information ' +\n          \"to trick you into paying large fees. This behavior is the same as Psbt's predecessor \" +\n          '(TransactionBuilder - now removed) when signing non-segwit scripts. You are not ' +\n          'able to export this Psbt with toBuffer|toBase64|toHex since it is not ' +\n          'BIP174 compliant.\\n*********************\\nPROCEED WITH CAUTION!\\n' +\n          '*********************',\n      );\n    hash = unsignedTx.hashForSignature(\n      inputIndex,\n      meaningfulScript,\n      sighashType,\n    );\n  }\n  return {\n    script: meaningfulScript,\n    sighashType,\n    hash,\n  };\n}\nfunction getAllTaprootHashesForSig(inputIndex, input, inputs, cache) {\n  const allPublicKeys = [];\n  if (input.tapInternalKey) {\n    const key = getPrevoutTaprootKey(inputIndex, input, cache);\n    if (key) {\n      allPublicKeys.push(key);\n    }\n  }\n  if (input.tapScriptSig) {\n    const tapScriptPubkeys = input.tapScriptSig.map(tss => tss.pubkey);\n    allPublicKeys.push(...tapScriptPubkeys);\n  }\n  const allHashes = allPublicKeys.map(pubicKey =>\n    getTaprootHashesForSig(inputIndex, input, inputs, pubicKey, cache),\n  );\n  return allHashes.flat();\n}\nfunction getPrevoutTaprootKey(inputIndex, input, cache) {\n  const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);\n  return (0, psbtutils_1.isP2TR)(script) ? script.subarray(2, 34) : null;\n}\nfunction trimTaprootSig(signature) {\n  return signature.length === 64 ? signature : signature.subarray(0, 64);\n}\nfunction getTaprootHashesForSig(\n  inputIndex,\n  input,\n  inputs,\n  pubkey,\n  cache,\n  tapLeafHashToSign,\n  allowedSighashTypes,\n) {\n  const unsignedTx = cache.__TX;\n  const sighashType =\n    input.sighashType || transaction_1.Transaction.SIGHASH_DEFAULT;\n  checkSighashTypeAllowed(sighashType, allowedSighashTypes);\n  const prevOuts = inputs.map((i, index) =>\n    getScriptAndAmountFromUtxo(index, i, cache),\n  );\n  const signingScripts = prevOuts.map(o => o.script);\n  const values = prevOuts.map(o => o.value);\n  const hashes = [];\n  if (input.tapInternalKey && !tapLeafHashToSign) {\n    const outputKey =\n      getPrevoutTaprootKey(inputIndex, input, cache) || Buffer.from([]);\n    if ((0, bip371_1.toXOnly)(pubkey).equals(outputKey)) {\n      const tapKeyHash = unsignedTx.hashForWitnessV1(\n        inputIndex,\n        signingScripts,\n        values,\n        sighashType,\n      );\n      hashes.push({ pubkey, hash: tapKeyHash });\n    }\n  }\n  const tapLeafHashes = (input.tapLeafScript || [])\n    .filter(tapLeaf => (0, psbtutils_1.pubkeyInScript)(pubkey, tapLeaf.script))\n    .map(tapLeaf => {\n      const hash = (0, bip341_1.tapleafHash)({\n        output: tapLeaf.script,\n        version: tapLeaf.leafVersion,\n      });\n      return Object.assign({ hash }, tapLeaf);\n    })\n    .filter(\n      tapLeaf => !tapLeafHashToSign || tapLeafHashToSign.equals(tapLeaf.hash),\n    )\n    .map(tapLeaf => {\n      const tapScriptHash = unsignedTx.hashForWitnessV1(\n        inputIndex,\n        signingScripts,\n        values,\n        sighashType,\n        tapLeaf.hash,\n      );\n      return {\n        pubkey,\n        hash: tapScriptHash,\n        leafHash: tapLeaf.hash,\n      };\n    });\n  return hashes.concat(tapLeafHashes);\n}\nfunction checkSighashTypeAllowed(sighashType, sighashTypes) {\n  if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {\n    const str = sighashTypeToString(sighashType);\n    throw new Error(\n      `Sighash type is not allowed. Retry the sign method passing the ` +\n        `sighashTypes array of whitelisted types. Sighash type: ${str}`,\n    );\n  }\n}\nfunction getPayment(script, scriptType, partialSig) {\n  let payment;\n  switch (scriptType) {\n    case 'multisig':\n      const sigs = getSortedSigs(script, partialSig);\n      payment = payments.p2ms({\n        output: script,\n        signatures: sigs,\n      });\n      break;\n    case 'pubkey':\n      payment = payments.p2pk({\n        output: script,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'pubkeyhash':\n      payment = payments.p2pkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'witnesspubkeyhash':\n      payment = payments.p2wpkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n  }\n  return payment;\n}\nfunction getScriptFromInput(inputIndex, input, cache) {\n  const unsignedTx = cache.__TX;\n  const res = {\n    script: null,\n    isSegwit: false,\n    isP2SH: false,\n    isP2WSH: false,\n  };\n  res.isP2SH = !!input.redeemScript;\n  res.isP2WSH = !!input.witnessScript;\n  if (input.witnessScript) {\n    res.script = input.witnessScript;\n  } else if (input.redeemScript) {\n    res.script = input.redeemScript;\n  } else {\n    if (input.nonWitnessUtxo) {\n      const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n        cache,\n        input,\n        inputIndex,\n      );\n      const prevoutIndex = unsignedTx.ins[inputIndex].index;\n      res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;\n    } else if (input.witnessUtxo) {\n      res.script = input.witnessUtxo.script;\n    }\n  }\n  if (input.witnessScript || (0, psbtutils_1.isP2WPKH)(res.script)) {\n    res.isSegwit = true;\n  }\n  return res;\n}\nfunction getSignersFromHD(inputIndex, inputs, hdKeyPair) {\n  const input = (0, utils_1.checkForInput)(inputs, inputIndex);\n  if (!input.bip32Derivation || input.bip32Derivation.length === 0) {\n    throw new Error('Need bip32Derivation to sign with HD');\n  }\n  const myDerivations = input.bip32Derivation\n    .map(bipDv => {\n      if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {\n        return bipDv;\n      } else {\n        return;\n      }\n    })\n    .filter(v => !!v);\n  if (myDerivations.length === 0) {\n    throw new Error(\n      'Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint',\n    );\n  }\n  const signers = myDerivations.map(bipDv => {\n    const node = hdKeyPair.derivePath(bipDv.path);\n    if (!bipDv.pubkey.equals(node.publicKey)) {\n      throw new Error('pubkey did not match bip32Derivation');\n    }\n    return node;\n  });\n  return signers;\n}\nfunction getSortedSigs(script, partialSig) {\n  const p2ms = payments.p2ms({ output: script });\n  // for each pubkey in order of p2ms script\n  return p2ms.pubkeys\n    .map(pk => {\n      // filter partialSig array by pubkey being equal\n      return (\n        partialSig.filter(ps => {\n          return ps.pubkey.equals(pk);\n        })[0] || {}\n      ).signature;\n      // Any pubkey without a match will return undefined\n      // this last filter removes all the undefined items in the array.\n    })\n    .filter(v => !!v);\n}\nfunction scriptWitnessToWitnessStack(buffer) {\n  let offset = 0;\n  function readSlice(n) {\n    offset += n;\n    return buffer.slice(offset - n, offset);\n  }\n  function readVarInt() {\n    const vi = varuint.decode(buffer, offset);\n    offset += varuint.decode.bytes;\n    return vi;\n  }\n  function readVarSlice() {\n    return readSlice(readVarInt());\n  }\n  function readVector() {\n    const count = readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(readVarSlice());\n    return vector;\n  }\n  return readVector();\n}\nfunction sighashTypeToString(sighashType) {\n  let text =\n    sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY\n      ? 'SIGHASH_ANYONECANPAY | '\n      : '';\n  const sigMod = sighashType & 0x1f;\n  switch (sigMod) {\n    case transaction_1.Transaction.SIGHASH_ALL:\n      text += 'SIGHASH_ALL';\n      break;\n    case transaction_1.Transaction.SIGHASH_SINGLE:\n      text += 'SIGHASH_SINGLE';\n      break;\n    case transaction_1.Transaction.SIGHASH_NONE:\n      text += 'SIGHASH_NONE';\n      break;\n  }\n  return text;\n}\nfunction addNonWitnessTxCache(cache, input, inputIndex) {\n  cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;\n  const tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);\n  cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;\n  const self = cache;\n  const selfIndex = inputIndex;\n  delete input.nonWitnessUtxo;\n  Object.defineProperty(input, 'nonWitnessUtxo', {\n    enumerable: true,\n    get() {\n      const buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];\n      const txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];\n      if (buf !== undefined) {\n        return buf;\n      } else {\n        const newBuf = txCache.toBuffer();\n        self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;\n        return newBuf;\n      }\n    },\n    set(data) {\n      self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;\n    },\n  });\n}\nfunction inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {\n  let inputAmount = 0;\n  inputs.forEach((input, idx) => {\n    if (mustFinalize && input.finalScriptSig)\n      tx.ins[idx].script = input.finalScriptSig;\n    if (mustFinalize && input.finalScriptWitness) {\n      tx.ins[idx].witness = scriptWitnessToWitnessStack(\n        input.finalScriptWitness,\n      );\n    }\n    if (input.witnessUtxo) {\n      inputAmount += input.witnessUtxo.value;\n    } else if (input.nonWitnessUtxo) {\n      const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);\n      const vout = tx.ins[idx].index;\n      const out = nwTx.outs[vout];\n      inputAmount += out.value;\n    }\n  });\n  const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0);\n  const fee = inputAmount - outputAmount;\n  if (fee < 0) {\n    throw new Error('Outputs are spending more than Inputs');\n  }\n  const bytes = tx.virtualSize();\n  cache.__FEE = fee;\n  cache.__EXTRACTED_TX = tx;\n  cache.__FEE_RATE = Math.floor(fee / bytes);\n}\nfunction nonWitnessUtxoTxFromCache(cache, input, inputIndex) {\n  const c = cache.__NON_WITNESS_UTXO_TX_CACHE;\n  if (!c[inputIndex]) {\n    addNonWitnessTxCache(cache, input, inputIndex);\n  }\n  return c[inputIndex];\n}\nfunction getScriptFromUtxo(inputIndex, input, cache) {\n  const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);\n  return script;\n}\nfunction getScriptAndAmountFromUtxo(inputIndex, input, cache) {\n  if (input.witnessUtxo !== undefined) {\n    return {\n      script: input.witnessUtxo.script,\n      value: input.witnessUtxo.value,\n    };\n  } else if (input.nonWitnessUtxo !== undefined) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n      cache,\n      input,\n      inputIndex,\n    );\n    const o = nonWitnessUtxoTx.outs[cache.__TX.ins[inputIndex].index];\n    return { script: o.script, value: o.value };\n  } else {\n    throw new Error(\"Can't find pubkey in input without Utxo data\");\n  }\n}\nfunction pubkeyInInput(pubkey, input, inputIndex, cache) {\n  const script = getScriptFromUtxo(inputIndex, input, cache);\n  const { meaningfulScript } = getMeaningfulScript(\n    script,\n    inputIndex,\n    'input',\n    input.redeemScript,\n    input.witnessScript,\n  );\n  return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);\n}\nfunction pubkeyInOutput(pubkey, output, outputIndex, cache) {\n  const script = cache.__TX.outs[outputIndex].script;\n  const { meaningfulScript } = getMeaningfulScript(\n    script,\n    outputIndex,\n    'output',\n    output.redeemScript,\n    output.witnessScript,\n  );\n  return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);\n}\nfunction redeemFromFinalScriptSig(finalScript) {\n  if (!finalScript) return;\n  const decomp = bscript.decompile(finalScript);\n  if (!decomp) return;\n  const lastItem = decomp[decomp.length - 1];\n  if (\n    !Buffer.isBuffer(lastItem) ||\n    isPubkeyLike(lastItem) ||\n    isSigLike(lastItem)\n  )\n    return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\nfunction redeemFromFinalWitnessScript(finalScript) {\n  if (!finalScript) return;\n  const decomp = scriptWitnessToWitnessStack(finalScript);\n  const lastItem = decomp[decomp.length - 1];\n  if (isPubkeyLike(lastItem)) return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\nfunction compressPubkey(pubkey) {\n  if (pubkey.length === 65) {\n    const parity = pubkey[64] & 1;\n    const newKey = pubkey.slice(0, 33);\n    newKey[0] = 2 | parity;\n    return newKey;\n  }\n  return pubkey.slice();\n}\nfunction isPubkeyLike(buf) {\n  return buf.length === 33 && bscript.isCanonicalPubKey(buf);\n}\nfunction isSigLike(buf) {\n  return bscript.isCanonicalScriptSignature(buf);\n}\nfunction getMeaningfulScript(\n  script,\n  index,\n  ioType,\n  redeemScript,\n  witnessScript,\n) {\n  const isP2SH = (0, psbtutils_1.isP2SHScript)(script);\n  const isP2SHP2WSH =\n    isP2SH && redeemScript && (0, psbtutils_1.isP2WSHScript)(redeemScript);\n  const isP2WSH = (0, psbtutils_1.isP2WSHScript)(script);\n  if (isP2SH && redeemScript === undefined)\n    throw new Error('scriptPubkey is P2SH but redeemScript missing');\n  if ((isP2WSH || isP2SHP2WSH) && witnessScript === undefined)\n    throw new Error(\n      'scriptPubkey or redeemScript is P2WSH but witnessScript missing',\n    );\n  let meaningfulScript;\n  if (isP2SHP2WSH) {\n    meaningfulScript = witnessScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n    checkWitnessScript(index, redeemScript, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2WSH) {\n    meaningfulScript = witnessScript;\n    checkWitnessScript(index, script, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2SH) {\n    meaningfulScript = redeemScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n  } else {\n    meaningfulScript = script;\n  }\n  return {\n    meaningfulScript,\n    type: isP2SHP2WSH\n      ? 'p2sh-p2wsh'\n      : isP2SH\n      ? 'p2sh'\n      : isP2WSH\n      ? 'p2wsh'\n      : 'raw',\n  };\n}\nfunction checkInvalidP2WSH(script) {\n  if (\n    (0, psbtutils_1.isP2WPKH)(script) ||\n    (0, psbtutils_1.isP2SHScript)(script)\n  ) {\n    throw new Error('P2WPKH or P2SH can not be contained within P2WSH');\n  }\n}\nfunction classifyScript(script) {\n  if ((0, psbtutils_1.isP2WPKH)(script)) return 'witnesspubkeyhash';\n  if ((0, psbtutils_1.isP2PKH)(script)) return 'pubkeyhash';\n  if ((0, psbtutils_1.isP2MS)(script)) return 'multisig';\n  if ((0, psbtutils_1.isP2PK)(script)) return 'pubkey';\n  return 'nonstandard';\n}\nfunction range(n) {\n  return [...Array(n).keys()];\n}\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.checkTaprootInputForSigs =\n  exports.tapTreeFromList =\n  exports.tapTreeToList =\n  exports.tweakInternalPubKey =\n  exports.checkTaprootOutputFields =\n  exports.checkTaprootInputFields =\n  exports.isTaprootOutput =\n  exports.isTaprootInput =\n  exports.serializeTaprootSignature =\n  exports.tapScriptFinalizer =\n  exports.toXOnly =\n    void 0;\nconst types_1 = require('../types');\nconst transaction_1 = require('../transaction');\nconst psbtutils_1 = require('./psbtutils');\nconst bip341_1 = require('../payments/bip341');\nconst payments_1 = require('../payments');\nconst psbtutils_2 = require('./psbtutils');\nconst toXOnly = pubKey => (pubKey.length === 32 ? pubKey : pubKey.slice(1, 33));\nexports.toXOnly = toXOnly;\n/**\n * Default tapscript finalizer. It searches for the `tapLeafHashToFinalize` if provided.\n * Otherwise it will search for the tapleaf that has at least one signature and has the shortest path.\n * @param inputIndex the position of the PSBT input.\n * @param input the PSBT input.\n * @param tapLeafHashToFinalize optional, if provided the finalizer will search for a tapleaf that has this hash\n *                              and will try to build the finalScriptWitness.\n * @returns the finalScriptWitness or throws an exception if no tapleaf found.\n */\nfunction tapScriptFinalizer(inputIndex, input, tapLeafHashToFinalize) {\n  const tapLeaf = findTapLeafToFinalize(\n    input,\n    inputIndex,\n    tapLeafHashToFinalize,\n  );\n  try {\n    const sigs = sortSignatures(input, tapLeaf);\n    const witness = sigs.concat(tapLeaf.script).concat(tapLeaf.controlBlock);\n    return {\n      finalScriptWitness: (0, psbtutils_1.witnessStackToScriptWitness)(witness),\n    };\n  } catch (err) {\n    throw new Error(`Can not finalize taproot input #${inputIndex}: ${err}`);\n  }\n}\nexports.tapScriptFinalizer = tapScriptFinalizer;\nfunction serializeTaprootSignature(sig, sighashType) {\n  const sighashTypeByte = sighashType\n    ? Buffer.from([sighashType])\n    : Buffer.from([]);\n  return Buffer.concat([sig, sighashTypeByte]);\n}\nexports.serializeTaprootSignature = serializeTaprootSignature;\nfunction isTaprootInput(input) {\n  return (\n    input &&\n    !!(\n      input.tapInternalKey ||\n      input.tapMerkleRoot ||\n      (input.tapLeafScript && input.tapLeafScript.length) ||\n      (input.tapBip32Derivation && input.tapBip32Derivation.length) ||\n      (input.witnessUtxo && (0, psbtutils_1.isP2TR)(input.witnessUtxo.script))\n    )\n  );\n}\nexports.isTaprootInput = isTaprootInput;\nfunction isTaprootOutput(output, script) {\n  return (\n    output &&\n    !!(\n      output.tapInternalKey ||\n      output.tapTree ||\n      (output.tapBip32Derivation && output.tapBip32Derivation.length) ||\n      (script && (0, psbtutils_1.isP2TR)(script))\n    )\n  );\n}\nexports.isTaprootOutput = isTaprootOutput;\nfunction checkTaprootInputFields(inputData, newInputData, action) {\n  checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action);\n  checkIfTapLeafInTree(inputData, newInputData, action);\n}\nexports.checkTaprootInputFields = checkTaprootInputFields;\nfunction checkTaprootOutputFields(outputData, newOutputData, action) {\n  checkMixedTaprootAndNonTaprootOutputFields(outputData, newOutputData, action);\n  checkTaprootScriptPubkey(outputData, newOutputData);\n}\nexports.checkTaprootOutputFields = checkTaprootOutputFields;\nfunction checkTaprootScriptPubkey(outputData, newOutputData) {\n  if (!newOutputData.tapTree && !newOutputData.tapInternalKey) return;\n  const tapInternalKey =\n    newOutputData.tapInternalKey || outputData.tapInternalKey;\n  const tapTree = newOutputData.tapTree || outputData.tapTree;\n  if (tapInternalKey) {\n    const { script: scriptPubkey } = outputData;\n    const script = getTaprootScripPubkey(tapInternalKey, tapTree);\n    if (scriptPubkey && !scriptPubkey.equals(script))\n      throw new Error('Error adding output. Script or address missmatch.');\n  }\n}\nfunction getTaprootScripPubkey(tapInternalKey, tapTree) {\n  const scriptTree = tapTree && tapTreeFromList(tapTree.leaves);\n  const { output } = (0, payments_1.p2tr)({\n    internalPubkey: tapInternalKey,\n    scriptTree,\n  });\n  return output;\n}\nfunction tweakInternalPubKey(inputIndex, input) {\n  const tapInternalKey = input.tapInternalKey;\n  const outputKey =\n    tapInternalKey &&\n    (0, bip341_1.tweakKey)(tapInternalKey, input.tapMerkleRoot);\n  if (!outputKey)\n    throw new Error(\n      `Cannot tweak tap internal key for input #${inputIndex}. Public key: ${\n        tapInternalKey && tapInternalKey.toString('hex')\n      }`,\n    );\n  return outputKey.x;\n}\nexports.tweakInternalPubKey = tweakInternalPubKey;\n/**\n * Convert a binary tree to a BIP371 type list. Each element of the list is (according to BIP371):\n * One or more tuples representing the depth, leaf version, and script for a leaf in the Taproot tree,\n * allowing the entire tree to be reconstructed. The tuples must be in depth first search order so that\n * the tree is correctly reconstructed.\n * @param tree the binary tap tree\n * @returns a list of BIP 371 tapleaves\n */\nfunction tapTreeToList(tree) {\n  if (!(0, types_1.isTaptree)(tree))\n    throw new Error(\n      'Cannot convert taptree to tapleaf list. Expecting a tapree structure.',\n    );\n  return _tapTreeToList(tree);\n}\nexports.tapTreeToList = tapTreeToList;\n/**\n * Convert a BIP371 TapLeaf list to a TapTree (binary).\n * @param leaves a list of tapleaves where each element of the list is (according to BIP371):\n * One or more tuples representing the depth, leaf version, and script for a leaf in the Taproot tree,\n * allowing the entire tree to be reconstructed. The tuples must be in depth first search order so that\n * the tree is correctly reconstructed.\n * @returns the corresponding taptree, or throws an exception if the tree cannot be reconstructed\n */\nfunction tapTreeFromList(leaves = []) {\n  if (leaves.length === 1 && leaves[0].depth === 0)\n    return {\n      output: leaves[0].script,\n      version: leaves[0].leafVersion,\n    };\n  return instertLeavesInTree(leaves);\n}\nexports.tapTreeFromList = tapTreeFromList;\nfunction checkTaprootInputForSigs(input, action) {\n  const sigs = extractTaprootSigs(input);\n  return sigs.some(sig =>\n    (0, psbtutils_2.signatureBlocksAction)(sig, decodeSchnorrSignature, action),\n  );\n}\nexports.checkTaprootInputForSigs = checkTaprootInputForSigs;\nfunction decodeSchnorrSignature(signature) {\n  return {\n    signature: signature.slice(0, 64),\n    hashType:\n      signature.slice(64)[0] || transaction_1.Transaction.SIGHASH_DEFAULT,\n  };\n}\nfunction extractTaprootSigs(input) {\n  const sigs = [];\n  if (input.tapKeySig) sigs.push(input.tapKeySig);\n  if (input.tapScriptSig)\n    sigs.push(...input.tapScriptSig.map(s => s.signature));\n  if (!sigs.length) {\n    const finalTapKeySig = getTapKeySigFromWithness(input.finalScriptWitness);\n    if (finalTapKeySig) sigs.push(finalTapKeySig);\n  }\n  return sigs;\n}\nfunction getTapKeySigFromWithness(finalScriptWitness) {\n  if (!finalScriptWitness) return;\n  const witness = finalScriptWitness.slice(2);\n  // todo: add schnorr signature validation\n  if (witness.length === 64 || witness.length === 65) return witness;\n}\nfunction _tapTreeToList(tree, leaves = [], depth = 0) {\n  if (depth > bip341_1.MAX_TAPTREE_DEPTH)\n    throw new Error('Max taptree depth exceeded.');\n  if (!tree) return [];\n  if ((0, types_1.isTapleaf)(tree)) {\n    leaves.push({\n      depth,\n      leafVersion: tree.version || bip341_1.LEAF_VERSION_TAPSCRIPT,\n      script: tree.output,\n    });\n    return leaves;\n  }\n  if (tree[0]) _tapTreeToList(tree[0], leaves, depth + 1);\n  if (tree[1]) _tapTreeToList(tree[1], leaves, depth + 1);\n  return leaves;\n}\nfunction instertLeavesInTree(leaves) {\n  let tree;\n  for (const leaf of leaves) {\n    tree = instertLeafInTree(leaf, tree);\n    if (!tree) throw new Error(`No room left to insert tapleaf in tree`);\n  }\n  return tree;\n}\nfunction instertLeafInTree(leaf, tree, depth = 0) {\n  if (depth > bip341_1.MAX_TAPTREE_DEPTH)\n    throw new Error('Max taptree depth exceeded.');\n  if (leaf.depth === depth) {\n    if (!tree)\n      return {\n        output: leaf.script,\n        version: leaf.leafVersion,\n      };\n    return;\n  }\n  if ((0, types_1.isTapleaf)(tree)) return;\n  const leftSide = instertLeafInTree(leaf, tree && tree[0], depth + 1);\n  if (leftSide) return [leftSide, tree && tree[1]];\n  const rightSide = instertLeafInTree(leaf, tree && tree[1], depth + 1);\n  if (rightSide) return [tree && tree[0], rightSide];\n}\nfunction checkMixedTaprootAndNonTaprootInputFields(\n  inputData,\n  newInputData,\n  action,\n) {\n  const isBadTaprootUpdate =\n    isTaprootInput(inputData) && hasNonTaprootFields(newInputData);\n  const isBadNonTaprootUpdate =\n    hasNonTaprootFields(inputData) && isTaprootInput(newInputData);\n  const hasMixedFields =\n    inputData === newInputData &&\n    isTaprootInput(newInputData) &&\n    hasNonTaprootFields(newInputData); // todo: bad? use !===\n  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)\n    throw new Error(\n      `Invalid arguments for Psbt.${action}. ` +\n        `Cannot use both taproot and non-taproot fields.`,\n    );\n}\nfunction checkMixedTaprootAndNonTaprootOutputFields(\n  inputData,\n  newInputData,\n  action,\n) {\n  const isBadTaprootUpdate =\n    isTaprootOutput(inputData) && hasNonTaprootFields(newInputData);\n  const isBadNonTaprootUpdate =\n    hasNonTaprootFields(inputData) && isTaprootOutput(newInputData);\n  const hasMixedFields =\n    inputData === newInputData &&\n    isTaprootOutput(newInputData) &&\n    hasNonTaprootFields(newInputData);\n  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)\n    throw new Error(\n      `Invalid arguments for Psbt.${action}. ` +\n        `Cannot use both taproot and non-taproot fields.`,\n    );\n}\n/**\n * Checks if the tap leaf is part of the tap tree for the given input data.\n * Throws an error if the tap leaf is not part of the tap tree.\n * @param inputData - The original PsbtInput data.\n * @param newInputData - The new PsbtInput data.\n * @param action - The action being performed.\n * @throws {Error} - If the tap leaf is not part of the tap tree.\n */\nfunction checkIfTapLeafInTree(inputData, newInputData, action) {\n  if (newInputData.tapMerkleRoot) {\n    const newLeafsInTree = (newInputData.tapLeafScript || []).every(l =>\n      isTapLeafInTree(l, newInputData.tapMerkleRoot),\n    );\n    const oldLeafsInTree = (inputData.tapLeafScript || []).every(l =>\n      isTapLeafInTree(l, newInputData.tapMerkleRoot),\n    );\n    if (!newLeafsInTree || !oldLeafsInTree)\n      throw new Error(\n        `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`,\n      );\n  } else if (inputData.tapMerkleRoot) {\n    const newLeafsInTree = (newInputData.tapLeafScript || []).every(l =>\n      isTapLeafInTree(l, inputData.tapMerkleRoot),\n    );\n    if (!newLeafsInTree)\n      throw new Error(\n        `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`,\n      );\n  }\n}\n/**\n * Checks if a TapLeafScript is present in a Merkle tree.\n * @param tapLeaf The TapLeafScript to check.\n * @param merkleRoot The Merkle root of the tree. If not provided, the function assumes the TapLeafScript is present.\n * @returns A boolean indicating whether the TapLeafScript is present in the tree.\n */\nfunction isTapLeafInTree(tapLeaf, merkleRoot) {\n  if (!merkleRoot) return true;\n  const leafHash = (0, bip341_1.tapleafHash)({\n    output: tapLeaf.script,\n    version: tapLeaf.leafVersion,\n  });\n  const rootHash = (0, bip341_1.rootHashFromPath)(\n    tapLeaf.controlBlock,\n    leafHash,\n  );\n  return rootHash.equals(merkleRoot);\n}\n/**\n * Sorts the signatures in the input's tapScriptSig array based on their position in the tapLeaf script.\n *\n * @param input - The PsbtInput object.\n * @param tapLeaf - The TapLeafScript object.\n * @returns An array of sorted signatures as Buffers.\n */\nfunction sortSignatures(input, tapLeaf) {\n  const leafHash = (0, bip341_1.tapleafHash)({\n    output: tapLeaf.script,\n    version: tapLeaf.leafVersion,\n  });\n  return (input.tapScriptSig || [])\n    .filter(tss => tss.leafHash.equals(leafHash))\n    .map(tss => addPubkeyPositionInScript(tapLeaf.script, tss))\n    .sort((t1, t2) => t2.positionInScript - t1.positionInScript)\n    .map(t => t.signature);\n}\n/**\n * Adds the position of a public key in a script to a TapScriptSig object.\n * @param script The script in which to find the position of the public key.\n * @param tss The TapScriptSig object to add the position to.\n * @returns A TapScriptSigWitPosition object with the added position.\n */\nfunction addPubkeyPositionInScript(script, tss) {\n  return Object.assign(\n    {\n      positionInScript: (0, psbtutils_1.pubkeyPositionInScript)(\n        tss.pubkey,\n        script,\n      ),\n    },\n    tss,\n  );\n}\n/**\n * Find tapleaf by hash, or get the signed tapleaf with the shortest path.\n */\nfunction findTapLeafToFinalize(input, inputIndex, leafHashToFinalize) {\n  if (!input.tapScriptSig || !input.tapScriptSig.length)\n    throw new Error(\n      `Can not finalize taproot input #${inputIndex}. No tapleaf script signature provided.`,\n    );\n  const tapLeaf = (input.tapLeafScript || [])\n    .sort((a, b) => a.controlBlock.length - b.controlBlock.length)\n    .find(leaf =>\n      canFinalizeLeaf(leaf, input.tapScriptSig, leafHashToFinalize),\n    );\n  if (!tapLeaf)\n    throw new Error(\n      `Can not finalize taproot input #${inputIndex}. Signature for tapleaf script not found.`,\n    );\n  return tapLeaf;\n}\n/**\n * Determines whether a TapLeafScript can be finalized.\n *\n * @param leaf - The TapLeafScript to check.\n * @param tapScriptSig - The array of TapScriptSig objects.\n * @param hash - The optional hash to compare with the leaf hash.\n * @returns A boolean indicating whether the TapLeafScript can be finalized.\n */\nfunction canFinalizeLeaf(leaf, tapScriptSig, hash) {\n  const leafHash = (0, bip341_1.tapleafHash)({\n    output: leaf.script,\n    version: leaf.leafVersion,\n  });\n  const whiteListedHash = !hash || hash.equals(leafHash);\n  return (\n    whiteListedHash &&\n    tapScriptSig.find(tss => tss.leafHash.equals(leafHash)) !== undefined\n  );\n}\n/**\n * Checks if the given PsbtInput or PsbtOutput has non-taproot fields.\n * Non-taproot fields include redeemScript, witnessScript, and bip32Derivation.\n * @param io The PsbtInput or PsbtOutput to check.\n * @returns A boolean indicating whether the given input or output has non-taproot fields.\n */\nfunction hasNonTaprootFields(io) {\n  return (\n    io &&\n    !!(\n      io.redeemScript ||\n      io.witnessScript ||\n      (io.bip32Derivation && io.bip32Derivation.length)\n    )\n  );\n}\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.signatureBlocksAction =\n  exports.checkInputForSig =\n  exports.pubkeyInScript =\n  exports.pubkeyPositionInScript =\n  exports.witnessStackToScriptWitness =\n  exports.isP2TR =\n  exports.isP2SHScript =\n  exports.isP2WSHScript =\n  exports.isP2WPKH =\n  exports.isP2PKH =\n  exports.isP2PK =\n  exports.isP2MS =\n    void 0;\nconst varuint = require('bip174/src/lib/converter/varint');\nconst bscript = require('../script');\nconst transaction_1 = require('../transaction');\nconst crypto_1 = require('../crypto');\nconst payments = require('../payments');\nfunction isPaymentFactory(payment) {\n  return script => {\n    try {\n      payment({ output: script });\n      return true;\n    } catch (err) {\n      return false;\n    }\n  };\n}\nexports.isP2MS = isPaymentFactory(payments.p2ms);\nexports.isP2PK = isPaymentFactory(payments.p2pk);\nexports.isP2PKH = isPaymentFactory(payments.p2pkh);\nexports.isP2WPKH = isPaymentFactory(payments.p2wpkh);\nexports.isP2WSHScript = isPaymentFactory(payments.p2wsh);\nexports.isP2SHScript = isPaymentFactory(payments.p2sh);\nexports.isP2TR = isPaymentFactory(payments.p2tr);\n/**\n * Converts a witness stack to a script witness.\n * @param witness The witness stack to convert.\n * @returns The script witness as a Buffer.\n */\n/**\n * Converts a witness stack to a script witness.\n * @param witness The witness stack to convert.\n * @returns The converted script witness.\n */\nfunction witnessStackToScriptWitness(witness) {\n  let buffer = Buffer.allocUnsafe(0);\n  function writeSlice(slice) {\n    buffer = Buffer.concat([buffer, Buffer.from(slice)]);\n  }\n  function writeVarInt(i) {\n    const currentLen = buffer.length;\n    const varintLen = varuint.encodingLength(i);\n    buffer = Buffer.concat([buffer, Buffer.allocUnsafe(varintLen)]);\n    varuint.encode(i, buffer, currentLen);\n  }\n  function writeVarSlice(slice) {\n    writeVarInt(slice.length);\n    writeSlice(slice);\n  }\n  function writeVector(vector) {\n    writeVarInt(vector.length);\n    vector.forEach(writeVarSlice);\n  }\n  writeVector(witness);\n  return buffer;\n}\nexports.witnessStackToScriptWitness = witnessStackToScriptWitness;\n/**\n * Finds the position of a public key in a script.\n * @param pubkey The public key to search for.\n * @param script The script to search in.\n * @returns The index of the public key in the script, or -1 if not found.\n * @throws {Error} If there is an unknown script error.\n */\nfunction pubkeyPositionInScript(pubkey, script) {\n  const pubkeyHash = (0, crypto_1.hash160)(pubkey);\n  const pubkeyXOnly = pubkey.slice(1, 33); // slice before calling?\n  const decompiled = bscript.decompile(script);\n  if (decompiled === null) throw new Error('Unknown script error');\n  return decompiled.findIndex(element => {\n    if (typeof element === 'number') return false;\n    return (\n      element.equals(pubkey) ||\n      element.equals(pubkeyHash) ||\n      element.equals(pubkeyXOnly)\n    );\n  });\n}\nexports.pubkeyPositionInScript = pubkeyPositionInScript;\n/**\n * Checks if a public key is present in a script.\n * @param pubkey The public key to check.\n * @param script The script to search in.\n * @returns A boolean indicating whether the public key is present in the script.\n */\nfunction pubkeyInScript(pubkey, script) {\n  return pubkeyPositionInScript(pubkey, script) !== -1;\n}\nexports.pubkeyInScript = pubkeyInScript;\n/**\n * Checks if an input contains a signature for a specific action.\n * @param input - The input to check.\n * @param action - The action to check for.\n * @returns A boolean indicating whether the input contains a signature for the specified action.\n */\nfunction checkInputForSig(input, action) {\n  const pSigs = extractPartialSigs(input);\n  return pSigs.some(pSig =>\n    signatureBlocksAction(pSig, bscript.signature.decode, action),\n  );\n}\nexports.checkInputForSig = checkInputForSig;\n/**\n * Determines if a given action is allowed for a signature block.\n * @param signature - The signature block.\n * @param signatureDecodeFn - The function used to decode the signature.\n * @param action - The action to be checked.\n * @returns True if the action is allowed, false otherwise.\n */\nfunction signatureBlocksAction(signature, signatureDecodeFn, action) {\n  const { hashType } = signatureDecodeFn(signature);\n  const whitelist = [];\n  const isAnyoneCanPay =\n    hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY;\n  if (isAnyoneCanPay) whitelist.push('addInput');\n  const hashMod = hashType & 0x1f;\n  switch (hashMod) {\n    case transaction_1.Transaction.SIGHASH_ALL:\n      break;\n    case transaction_1.Transaction.SIGHASH_SINGLE:\n    case transaction_1.Transaction.SIGHASH_NONE:\n      whitelist.push('addOutput');\n      whitelist.push('setInputSequence');\n      break;\n  }\n  if (whitelist.indexOf(action) === -1) {\n    return true;\n  }\n  return false;\n}\nexports.signatureBlocksAction = signatureBlocksAction;\n/**\n * Extracts the signatures from a PsbtInput object.\n * If the input has partial signatures, it returns an array of the signatures.\n * If the input does not have partial signatures, it checks if it has a finalScriptSig or finalScriptWitness.\n * If it does, it extracts the signatures from the final scripts and returns them.\n * If none of the above conditions are met, it returns an empty array.\n *\n * @param input - The PsbtInput object from which to extract the signatures.\n * @returns An array of signatures extracted from the PsbtInput object.\n */\nfunction extractPartialSigs(input) {\n  let pSigs = [];\n  if ((input.partialSig || []).length === 0) {\n    if (!input.finalScriptSig && !input.finalScriptWitness) return [];\n    pSigs = getPsigsFromInputFinalScripts(input);\n  } else {\n    pSigs = input.partialSig;\n  }\n  return pSigs.map(p => p.signature);\n}\n/**\n * Retrieves the partial signatures (Psigs) from the input's final scripts.\n * Psigs are extracted from both the final scriptSig and final scriptWitness of the input.\n * Only canonical script signatures are considered.\n *\n * @param input - The PsbtInput object representing the input.\n * @returns An array of PartialSig objects containing the extracted Psigs.\n */\nfunction getPsigsFromInputFinalScripts(input) {\n  const scriptItems = !input.finalScriptSig\n    ? []\n    : bscript.decompile(input.finalScriptSig) || [];\n  const witnessItems = !input.finalScriptWitness\n    ? []\n    : bscript.decompile(input.finalScriptWitness) || [];\n  return scriptItems\n    .concat(witnessItems)\n    .filter(item => {\n      return Buffer.isBuffer(item) && bscript.isCanonicalScriptSignature(item);\n    })\n    .map(sig => ({ signature: sig }));\n}\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.decode = exports.encode = exports.encodingLength = void 0;\nconst ops_1 = require('./ops');\n/**\n * Calculates the encoding length of a number used for push data in Bitcoin transactions.\n * @param i The number to calculate the encoding length for.\n * @returns The encoding length of the number.\n */\nfunction encodingLength(i) {\n  return i < ops_1.OPS.OP_PUSHDATA1 ? 1 : i <= 0xff ? 2 : i <= 0xffff ? 3 : 5;\n}\nexports.encodingLength = encodingLength;\n/**\n * Encodes a number into a buffer using a variable-length encoding scheme.\n * The encoded buffer is written starting at the specified offset.\n * Returns the size of the encoded buffer.\n *\n * @param buffer - The buffer to write the encoded data into.\n * @param num - The number to encode.\n * @param offset - The offset at which to start writing the encoded buffer.\n * @returns The size of the encoded buffer.\n */\nfunction encode(buffer, num, offset) {\n  const size = encodingLength(num);\n  // ~6 bit\n  if (size === 1) {\n    buffer.writeUInt8(num, offset);\n    // 8 bit\n  } else if (size === 2) {\n    buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA1, offset);\n    buffer.writeUInt8(num, offset + 1);\n    // 16 bit\n  } else if (size === 3) {\n    buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA2, offset);\n    buffer.writeUInt16LE(num, offset + 1);\n    // 32 bit\n  } else {\n    buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA4, offset);\n    buffer.writeUInt32LE(num, offset + 1);\n  }\n  return size;\n}\nexports.encode = encode;\n/**\n * Decodes a buffer and returns information about the opcode, number, and size.\n * @param buffer - The buffer to decode.\n * @param offset - The offset within the buffer to start decoding.\n * @returns An object containing the opcode, number, and size, or null if decoding fails.\n */\nfunction decode(buffer, offset) {\n  const opcode = buffer.readUInt8(offset);\n  let num;\n  let size;\n  // ~6 bit\n  if (opcode < ops_1.OPS.OP_PUSHDATA1) {\n    num = opcode;\n    size = 1;\n    // 8 bit\n  } else if (opcode === ops_1.OPS.OP_PUSHDATA1) {\n    if (offset + 2 > buffer.length) return null;\n    num = buffer.readUInt8(offset + 1);\n    size = 2;\n    // 16 bit\n  } else if (opcode === ops_1.OPS.OP_PUSHDATA2) {\n    if (offset + 3 > buffer.length) return null;\n    num = buffer.readUInt16LE(offset + 1);\n    size = 3;\n    // 32 bit\n  } else {\n    if (offset + 5 > buffer.length) return null;\n    if (opcode !== ops_1.OPS.OP_PUSHDATA4) throw new Error('Unexpected opcode');\n    num = buffer.readUInt32LE(offset + 1);\n    size = 5;\n  }\n  return {\n    opcode,\n    number: num,\n    size,\n  };\n}\nexports.decode = decode;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.signature =\n  exports.number =\n  exports.isCanonicalScriptSignature =\n  exports.isDefinedHashType =\n  exports.isCanonicalPubKey =\n  exports.toStack =\n  exports.fromASM =\n  exports.toASM =\n  exports.decompile =\n  exports.compile =\n  exports.countNonPushOnlyOPs =\n  exports.isPushOnly =\n  exports.OPS =\n    void 0;\n/**\n * Script tools, including decompile, compile, toASM, fromASM, toStack, isCanonicalPubKey, isCanonicalScriptSignature\n * @packageDocumentation\n */\nconst bip66 = require('./bip66');\nconst ops_1 = require('./ops');\nObject.defineProperty(exports, 'OPS', {\n  enumerable: true,\n  get: function () {\n    return ops_1.OPS;\n  },\n});\nconst pushdata = require('./push_data');\nconst scriptNumber = require('./script_number');\nconst scriptSignature = require('./script_signature');\nconst types = require('./types');\nconst { typeforce } = types;\nconst OP_INT_BASE = ops_1.OPS.OP_RESERVED; // OP_1 - 1\nfunction isOPInt(value) {\n  return (\n    types.Number(value) &&\n    (value === ops_1.OPS.OP_0 ||\n      (value >= ops_1.OPS.OP_1 && value <= ops_1.OPS.OP_16) ||\n      value === ops_1.OPS.OP_1NEGATE)\n  );\n}\nfunction isPushOnlyChunk(value) {\n  return types.Buffer(value) || isOPInt(value);\n}\nfunction isPushOnly(value) {\n  return types.Array(value) && value.every(isPushOnlyChunk);\n}\nexports.isPushOnly = isPushOnly;\nfunction countNonPushOnlyOPs(value) {\n  return value.length - value.filter(isPushOnlyChunk).length;\n}\nexports.countNonPushOnlyOPs = countNonPushOnlyOPs;\nfunction asMinimalOP(buffer) {\n  if (buffer.length === 0) return ops_1.OPS.OP_0;\n  if (buffer.length !== 1) return;\n  if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];\n  if (buffer[0] === 0x81) return ops_1.OPS.OP_1NEGATE;\n}\nfunction chunksIsBuffer(buf) {\n  return Buffer.isBuffer(buf);\n}\nfunction chunksIsArray(buf) {\n  return types.Array(buf);\n}\nfunction singleChunkIsBuffer(buf) {\n  return Buffer.isBuffer(buf);\n}\n/**\n * Compiles an array of chunks into a Buffer.\n *\n * @param chunks - The array of chunks to compile.\n * @returns The compiled Buffer.\n * @throws Error if the compilation fails.\n */\nfunction compile(chunks) {\n  // TODO: remove me\n  if (chunksIsBuffer(chunks)) return chunks;\n  typeforce(types.Array, chunks);\n  const bufferSize = chunks.reduce((accum, chunk) => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {\n        return accum + 1;\n      }\n      return accum + pushdata.encodingLength(chunk.length) + chunk.length;\n    }\n    // opcode\n    return accum + 1;\n  }, 0.0);\n  const buffer = Buffer.allocUnsafe(bufferSize);\n  let offset = 0;\n  chunks.forEach(chunk => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      const opcode = asMinimalOP(chunk);\n      if (opcode !== undefined) {\n        buffer.writeUInt8(opcode, offset);\n        offset += 1;\n        return;\n      }\n      offset += pushdata.encode(buffer, chunk.length, offset);\n      chunk.copy(buffer, offset);\n      offset += chunk.length;\n      // opcode\n    } else {\n      buffer.writeUInt8(chunk, offset);\n      offset += 1;\n    }\n  });\n  if (offset !== buffer.length) throw new Error('Could not decode chunks');\n  return buffer;\n}\nexports.compile = compile;\nfunction decompile(buffer) {\n  // TODO: remove me\n  if (chunksIsArray(buffer)) return buffer;\n  typeforce(types.Buffer, buffer);\n  const chunks = [];\n  let i = 0;\n  while (i < buffer.length) {\n    const opcode = buffer[i];\n    // data chunk\n    if (opcode > ops_1.OPS.OP_0 && opcode <= ops_1.OPS.OP_PUSHDATA4) {\n      const d = pushdata.decode(buffer, i);\n      // did reading a pushDataInt fail?\n      if (d === null) return null;\n      i += d.size;\n      // attempt to read too much data?\n      if (i + d.number > buffer.length) return null;\n      const data = buffer.slice(i, i + d.number);\n      i += d.number;\n      // decompile minimally\n      const op = asMinimalOP(data);\n      if (op !== undefined) {\n        chunks.push(op);\n      } else {\n        chunks.push(data);\n      }\n      // opcode\n    } else {\n      chunks.push(opcode);\n      i += 1;\n    }\n  }\n  return chunks;\n}\nexports.decompile = decompile;\n/**\n * Converts the given chunks into an ASM (Assembly) string representation.\n * If the chunks parameter is a Buffer, it will be decompiled into a Stack before conversion.\n * @param chunks - The chunks to convert into ASM.\n * @returns The ASM string representation of the chunks.\n */\nfunction toASM(chunks) {\n  if (chunksIsBuffer(chunks)) {\n    chunks = decompile(chunks);\n  }\n  if (!chunks) {\n    throw new Error('Could not convert invalid chunks to ASM');\n  }\n  return chunks\n    .map(chunk => {\n      // data?\n      if (singleChunkIsBuffer(chunk)) {\n        const op = asMinimalOP(chunk);\n        if (op === undefined) return chunk.toString('hex');\n        chunk = op;\n      }\n      // opcode!\n      return ops_1.REVERSE_OPS[chunk];\n    })\n    .join(' ');\n}\nexports.toASM = toASM;\n/**\n * Converts an ASM string to a Buffer.\n * @param asm The ASM string to convert.\n * @returns The converted Buffer.\n */\nfunction fromASM(asm) {\n  typeforce(types.String, asm);\n  return compile(\n    asm.split(' ').map(chunkStr => {\n      // opcode?\n      if (ops_1.OPS[chunkStr] !== undefined) return ops_1.OPS[chunkStr];\n      typeforce(types.Hex, chunkStr);\n      // data!\n      return Buffer.from(chunkStr, 'hex');\n    }),\n  );\n}\nexports.fromASM = fromASM;\n/**\n * Converts the given chunks into a stack of buffers.\n *\n * @param chunks - The chunks to convert.\n * @returns The stack of buffers.\n */\nfunction toStack(chunks) {\n  chunks = decompile(chunks);\n  typeforce(isPushOnly, chunks);\n  return chunks.map(op => {\n    if (singleChunkIsBuffer(op)) return op;\n    if (op === ops_1.OPS.OP_0) return Buffer.allocUnsafe(0);\n    return scriptNumber.encode(op - OP_INT_BASE);\n  });\n}\nexports.toStack = toStack;\nfunction isCanonicalPubKey(buffer) {\n  return types.isPoint(buffer);\n}\nexports.isCanonicalPubKey = isCanonicalPubKey;\nfunction isDefinedHashType(hashType) {\n  const hashTypeMod = hashType & ~0x80;\n  // return hashTypeMod > SIGHASH_ALL && hashTypeMod < SIGHASH_SINGLE\n  return hashTypeMod > 0x00 && hashTypeMod < 0x04;\n}\nexports.isDefinedHashType = isDefinedHashType;\nfunction isCanonicalScriptSignature(buffer) {\n  if (!Buffer.isBuffer(buffer)) return false;\n  if (!isDefinedHashType(buffer[buffer.length - 1])) return false;\n  return bip66.check(buffer.slice(0, -1));\n}\nexports.isCanonicalScriptSignature = isCanonicalScriptSignature;\nexports.number = scriptNumber;\nexports.signature = scriptSignature;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.encode = exports.decode = void 0;\n/**\n * Decodes a script number from a buffer.\n *\n * @param buffer - The buffer containing the script number.\n * @param maxLength - The maximum length of the script number. Defaults to 4.\n * @param minimal - Whether the script number should be minimal. Defaults to true.\n * @returns The decoded script number.\n * @throws {TypeError} If the script number overflows the maximum length.\n * @throws {Error} If the script number is not minimally encoded when minimal is true.\n */\nfunction decode(buffer, maxLength, minimal) {\n  maxLength = maxLength || 4;\n  minimal = minimal === undefined ? true : minimal;\n  const length = buffer.length;\n  if (length === 0) return 0;\n  if (length > maxLength) throw new TypeError('Script number overflow');\n  if (minimal) {\n    if ((buffer[length - 1] & 0x7f) === 0) {\n      if (length <= 1 || (buffer[length - 2] & 0x80) === 0)\n        throw new Error('Non-minimally encoded script number');\n    }\n  }\n  // 40-bit\n  if (length === 5) {\n    const a = buffer.readUInt32LE(0);\n    const b = buffer.readUInt8(4);\n    if (b & 0x80) return -((b & ~0x80) * 0x100000000 + a);\n    return b * 0x100000000 + a;\n  }\n  // 32-bit / 24-bit / 16-bit / 8-bit\n  let result = 0;\n  for (let i = 0; i < length; ++i) {\n    result |= buffer[i] << (8 * i);\n  }\n  if (buffer[length - 1] & 0x80)\n    return -(result & ~(0x80 << (8 * (length - 1))));\n  return result;\n}\nexports.decode = decode;\nfunction scriptNumSize(i) {\n  return i > 0x7fffffff\n    ? 5\n    : i > 0x7fffff\n    ? 4\n    : i > 0x7fff\n    ? 3\n    : i > 0x7f\n    ? 2\n    : i > 0x00\n    ? 1\n    : 0;\n}\n/**\n * Encodes a number into a Buffer using a specific format.\n *\n * @param _number - The number to encode.\n * @returns The encoded number as a Buffer.\n */\nfunction encode(_number) {\n  let value = Math.abs(_number);\n  const size = scriptNumSize(value);\n  const buffer = Buffer.allocUnsafe(size);\n  const negative = _number < 0;\n  for (let i = 0; i < size; ++i) {\n    buffer.writeUInt8(value & 0xff, i);\n    value >>= 8;\n  }\n  if (buffer[size - 1] & 0x80) {\n    buffer.writeUInt8(negative ? 0x80 : 0x00, size - 1);\n  } else if (negative) {\n    buffer[size - 1] |= 0x80;\n  }\n  return buffer;\n}\nexports.encode = encode;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.encode = exports.decode = void 0;\nconst bip66 = require('./bip66');\nconst script_1 = require('./script');\nconst types = require('./types');\nconst { typeforce } = types;\nconst ZERO = Buffer.alloc(1, 0);\n/**\n * Converts a buffer to a DER-encoded buffer.\n * @param x - The buffer to be converted.\n * @returns The DER-encoded buffer.\n */\nfunction toDER(x) {\n  let i = 0;\n  while (x[i] === 0) ++i;\n  if (i === x.length) return ZERO;\n  x = x.slice(i);\n  if (x[0] & 0x80) return Buffer.concat([ZERO, x], 1 + x.length);\n  return x;\n}\n/**\n * Converts a DER-encoded signature to a buffer.\n * If the first byte of the input buffer is 0x00, it is skipped.\n * The resulting buffer is 32 bytes long, filled with zeros if necessary.\n * @param x - The DER-encoded signature.\n * @returns The converted buffer.\n */\nfunction fromDER(x) {\n  if (x[0] === 0x00) x = x.slice(1);\n  const buffer = Buffer.alloc(32, 0);\n  const bstart = Math.max(0, 32 - x.length);\n  x.copy(buffer, bstart);\n  return buffer;\n}\n// BIP62: 1 byte hashType flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed)\n/**\n * Decodes a buffer into a ScriptSignature object.\n * @param buffer - The buffer to decode.\n * @returns The decoded ScriptSignature object.\n * @throws Error if the hashType is invalid.\n */\nfunction decode(buffer) {\n  const hashType = buffer.readUInt8(buffer.length - 1);\n  if (!(0, script_1.isDefinedHashType)(hashType)) {\n    throw new Error('Invalid hashType ' + hashType);\n  }\n  const decoded = bip66.decode(buffer.slice(0, -1));\n  const r = fromDER(decoded.r);\n  const s = fromDER(decoded.s);\n  const signature = Buffer.concat([r, s], 64);\n  return { signature, hashType };\n}\nexports.decode = decode;\n/**\n * Encodes a signature and hash type into a buffer.\n * @param signature - The signature to encode.\n * @param hashType - The hash type to encode.\n * @returns The encoded buffer.\n * @throws Error if the hashType is invalid.\n */\nfunction encode(signature, hashType) {\n  typeforce(\n    {\n      signature: types.BufferN(64),\n      hashType: types.UInt8,\n    },\n    { signature, hashType },\n  );\n  if (!(0, script_1.isDefinedHashType)(hashType)) {\n    throw new Error('Invalid hashType ' + hashType);\n  }\n  const hashTypeBuffer = Buffer.allocUnsafe(1);\n  hashTypeBuffer.writeUInt8(hashType, 0);\n  const r = toDER(signature.slice(0, 32));\n  const s = toDER(signature.slice(32, 64));\n  return Buffer.concat([bip66.encode(r, s), hashTypeBuffer]);\n}\nexports.encode = encode;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.Transaction = void 0;\nconst bufferutils_1 = require('./bufferutils');\nconst bcrypto = require('./crypto');\nconst bscript = require('./script');\nconst script_1 = require('./script');\nconst types = require('./types');\nconst { typeforce } = types;\nfunction varSliceSize(someScript) {\n  const length = someScript.length;\n  return bufferutils_1.varuint.encodingLength(length) + length;\n}\nfunction vectorSize(someVector) {\n  const length = someVector.length;\n  return (\n    bufferutils_1.varuint.encodingLength(length) +\n    someVector.reduce((sum, witness) => {\n      return sum + varSliceSize(witness);\n    }, 0)\n  );\n}\nconst EMPTY_BUFFER = Buffer.allocUnsafe(0);\nconst EMPTY_WITNESS = [];\nconst ZERO = Buffer.from(\n  '0000000000000000000000000000000000000000000000000000000000000000',\n  'hex',\n);\nconst ONE = Buffer.from(\n  '0000000000000000000000000000000000000000000000000000000000000001',\n  'hex',\n);\nconst VALUE_UINT64_MAX = Buffer.from('ffffffffffffffff', 'hex');\nconst BLANK_OUTPUT = {\n  script: EMPTY_BUFFER,\n  valueBuffer: VALUE_UINT64_MAX,\n};\nfunction isOutput(out) {\n  return out.value !== undefined;\n}\n/**\n * Represents a Bitcoin transaction.\n */\nclass Transaction {\n  constructor() {\n    this.version = 1;\n    this.locktime = 0;\n    this.ins = [];\n    this.outs = [];\n  }\n  static fromBuffer(buffer, _NO_STRICT) {\n    const bufferReader = new bufferutils_1.BufferReader(buffer);\n    const tx = new Transaction();\n    tx.version = bufferReader.readInt32();\n    const marker = bufferReader.readUInt8();\n    const flag = bufferReader.readUInt8();\n    let hasWitnesses = false;\n    if (\n      marker === Transaction.ADVANCED_TRANSACTION_MARKER &&\n      flag === Transaction.ADVANCED_TRANSACTION_FLAG\n    ) {\n      hasWitnesses = true;\n    } else {\n      bufferReader.offset -= 2;\n    }\n    const vinLen = bufferReader.readVarInt();\n    for (let i = 0; i < vinLen; ++i) {\n      tx.ins.push({\n        hash: bufferReader.readSlice(32),\n        index: bufferReader.readUInt32(),\n        script: bufferReader.readVarSlice(),\n        sequence: bufferReader.readUInt32(),\n        witness: EMPTY_WITNESS,\n      });\n    }\n    const voutLen = bufferReader.readVarInt();\n    for (let i = 0; i < voutLen; ++i) {\n      tx.outs.push({\n        value: bufferReader.readUInt64(),\n        script: bufferReader.readVarSlice(),\n      });\n    }\n    if (hasWitnesses) {\n      for (let i = 0; i < vinLen; ++i) {\n        tx.ins[i].witness = bufferReader.readVector();\n      }\n      // was this pointless?\n      if (!tx.hasWitnesses())\n        throw new Error('Transaction has superfluous witness data');\n    }\n    tx.locktime = bufferReader.readUInt32();\n    if (_NO_STRICT) return tx;\n    if (bufferReader.offset !== buffer.length)\n      throw new Error('Transaction has unexpected data');\n    return tx;\n  }\n  static fromHex(hex) {\n    return Transaction.fromBuffer(Buffer.from(hex, 'hex'), false);\n  }\n  static isCoinbaseHash(buffer) {\n    typeforce(types.Hash256bit, buffer);\n    for (let i = 0; i < 32; ++i) {\n      if (buffer[i] !== 0) return false;\n    }\n    return true;\n  }\n  isCoinbase() {\n    return (\n      this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash)\n    );\n  }\n  addInput(hash, index, sequence, scriptSig) {\n    typeforce(\n      types.tuple(\n        types.Hash256bit,\n        types.UInt32,\n        types.maybe(types.UInt32),\n        types.maybe(types.Buffer),\n      ),\n      arguments,\n    );\n    if (types.Null(sequence)) {\n      sequence = Transaction.DEFAULT_SEQUENCE;\n    }\n    // Add the input and return the input's index\n    return (\n      this.ins.push({\n        hash,\n        index,\n        script: scriptSig || EMPTY_BUFFER,\n        sequence: sequence,\n        witness: EMPTY_WITNESS,\n      }) - 1\n    );\n  }\n  addOutput(scriptPubKey, value) {\n    typeforce(types.tuple(types.Buffer, types.Satoshi), arguments);\n    // Add the output and return the output's index\n    return (\n      this.outs.push({\n        script: scriptPubKey,\n        value,\n      }) - 1\n    );\n  }\n  hasWitnesses() {\n    return this.ins.some(x => {\n      return x.witness.length !== 0;\n    });\n  }\n  stripWitnesses() {\n    this.ins.forEach(input => {\n      input.witness = EMPTY_WITNESS; // Set witness data to an empty array\n    });\n  }\n  weight() {\n    const base = this.byteLength(false);\n    const total = this.byteLength(true);\n    return base * 3 + total;\n  }\n  virtualSize() {\n    return Math.ceil(this.weight() / 4);\n  }\n  byteLength(_ALLOW_WITNESS = true) {\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    return (\n      (hasWitnesses ? 10 : 8) +\n      bufferutils_1.varuint.encodingLength(this.ins.length) +\n      bufferutils_1.varuint.encodingLength(this.outs.length) +\n      this.ins.reduce((sum, input) => {\n        return sum + 40 + varSliceSize(input.script);\n      }, 0) +\n      this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0) +\n      (hasWitnesses\n        ? this.ins.reduce((sum, input) => {\n            return sum + vectorSize(input.witness);\n          }, 0)\n        : 0)\n    );\n  }\n  clone() {\n    const newTx = new Transaction();\n    newTx.version = this.version;\n    newTx.locktime = this.locktime;\n    newTx.ins = this.ins.map(txIn => {\n      return {\n        hash: txIn.hash,\n        index: txIn.index,\n        script: txIn.script,\n        sequence: txIn.sequence,\n        witness: txIn.witness,\n      };\n    });\n    newTx.outs = this.outs.map(txOut => {\n      return {\n        script: txOut.script,\n        value: txOut.value,\n      };\n    });\n    return newTx;\n  }\n  /**\n   * Hash transaction for signing a specific input.\n   *\n   * Bitcoin uses a different hash for each signed transaction input.\n   * This method copies the transaction, makes the necessary changes based on the\n   * hashType, and then hashes the result.\n   * This hash can then be used to sign the provided transaction input.\n   */\n  hashForSignature(inIndex, prevOutScript, hashType) {\n    typeforce(\n      types.tuple(types.UInt32, types.Buffer, /* types.UInt8 */ types.Number),\n      arguments,\n    );\n    // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29\n    if (inIndex >= this.ins.length) return ONE;\n    // ignore OP_CODESEPARATOR\n    const ourScript = bscript.compile(\n      bscript.decompile(prevOutScript).filter(x => {\n        return x !== script_1.OPS.OP_CODESEPARATOR;\n      }),\n    );\n    const txTmp = this.clone();\n    // SIGHASH_NONE: ignore all outputs? (wildcard payee)\n    if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {\n      txTmp.outs = [];\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, i) => {\n        if (i === inIndex) return;\n        input.sequence = 0;\n      });\n      // SIGHASH_SINGLE: ignore all outputs, except at the same index?\n    } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {\n      // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60\n      if (inIndex >= this.outs.length) return ONE;\n      // truncate outputs after\n      txTmp.outs.length = inIndex + 1;\n      // \"blank\" outputs before\n      for (let i = 0; i < inIndex; i++) {\n        txTmp.outs[i] = BLANK_OUTPUT;\n      }\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, y) => {\n        if (y === inIndex) return;\n        input.sequence = 0;\n      });\n    }\n    // SIGHASH_ANYONECANPAY: ignore inputs entirely?\n    if (hashType & Transaction.SIGHASH_ANYONECANPAY) {\n      txTmp.ins = [txTmp.ins[inIndex]];\n      txTmp.ins[0].script = ourScript;\n      // SIGHASH_ALL: only ignore input scripts\n    } else {\n      // \"blank\" others input scripts\n      txTmp.ins.forEach(input => {\n        input.script = EMPTY_BUFFER;\n      });\n      txTmp.ins[inIndex].script = ourScript;\n    }\n    // serialize and hash\n    const buffer = Buffer.allocUnsafe(txTmp.byteLength(false) + 4);\n    buffer.writeInt32LE(hashType, buffer.length - 4);\n    txTmp.__toBuffer(buffer, 0, false);\n    return bcrypto.hash256(buffer);\n  }\n  hashForWitnessV1(inIndex, prevOutScripts, values, hashType, leafHash, annex) {\n    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#common-signature-message\n    typeforce(\n      types.tuple(\n        types.UInt32,\n        typeforce.arrayOf(types.Buffer),\n        typeforce.arrayOf(types.Satoshi),\n        types.UInt32,\n      ),\n      arguments,\n    );\n    if (\n      values.length !== this.ins.length ||\n      prevOutScripts.length !== this.ins.length\n    ) {\n      throw new Error('Must supply prevout script and value for all inputs');\n    }\n    const outputType =\n      hashType === Transaction.SIGHASH_DEFAULT\n        ? Transaction.SIGHASH_ALL\n        : hashType & Transaction.SIGHASH_OUTPUT_MASK;\n    const inputType = hashType & Transaction.SIGHASH_INPUT_MASK;\n    const isAnyoneCanPay = inputType === Transaction.SIGHASH_ANYONECANPAY;\n    const isNone = outputType === Transaction.SIGHASH_NONE;\n    const isSingle = outputType === Transaction.SIGHASH_SINGLE;\n    let hashPrevouts = EMPTY_BUFFER;\n    let hashAmounts = EMPTY_BUFFER;\n    let hashScriptPubKeys = EMPTY_BUFFER;\n    let hashSequences = EMPTY_BUFFER;\n    let hashOutputs = EMPTY_BUFFER;\n    if (!isAnyoneCanPay) {\n      let bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        36 * this.ins.length,\n      );\n      this.ins.forEach(txIn => {\n        bufferWriter.writeSlice(txIn.hash);\n        bufferWriter.writeUInt32(txIn.index);\n      });\n      hashPrevouts = bcrypto.sha256(bufferWriter.end());\n      bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        8 * this.ins.length,\n      );\n      values.forEach(value => bufferWriter.writeUInt64(value));\n      hashAmounts = bcrypto.sha256(bufferWriter.end());\n      bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        prevOutScripts.map(varSliceSize).reduce((a, b) => a + b),\n      );\n      prevOutScripts.forEach(prevOutScript =>\n        bufferWriter.writeVarSlice(prevOutScript),\n      );\n      hashScriptPubKeys = bcrypto.sha256(bufferWriter.end());\n      bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        4 * this.ins.length,\n      );\n      this.ins.forEach(txIn => bufferWriter.writeUInt32(txIn.sequence));\n      hashSequences = bcrypto.sha256(bufferWriter.end());\n    }\n    if (!(isNone || isSingle)) {\n      const txOutsSize = this.outs\n        .map(output => 8 + varSliceSize(output.script))\n        .reduce((a, b) => a + b);\n      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(txOutsSize);\n      this.outs.forEach(out => {\n        bufferWriter.writeUInt64(out.value);\n        bufferWriter.writeVarSlice(out.script);\n      });\n      hashOutputs = bcrypto.sha256(bufferWriter.end());\n    } else if (isSingle && inIndex < this.outs.length) {\n      const output = this.outs[inIndex];\n      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        8 + varSliceSize(output.script),\n      );\n      bufferWriter.writeUInt64(output.value);\n      bufferWriter.writeVarSlice(output.script);\n      hashOutputs = bcrypto.sha256(bufferWriter.end());\n    }\n    const spendType = (leafHash ? 2 : 0) + (annex ? 1 : 0);\n    // Length calculation from:\n    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-14\n    // With extension from:\n    // https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#signature-validation\n    const sigMsgSize =\n      174 -\n      (isAnyoneCanPay ? 49 : 0) -\n      (isNone ? 32 : 0) +\n      (annex ? 32 : 0) +\n      (leafHash ? 37 : 0);\n    const sigMsgWriter = bufferutils_1.BufferWriter.withCapacity(sigMsgSize);\n    sigMsgWriter.writeUInt8(hashType);\n    // Transaction\n    sigMsgWriter.writeInt32(this.version);\n    sigMsgWriter.writeUInt32(this.locktime);\n    sigMsgWriter.writeSlice(hashPrevouts);\n    sigMsgWriter.writeSlice(hashAmounts);\n    sigMsgWriter.writeSlice(hashScriptPubKeys);\n    sigMsgWriter.writeSlice(hashSequences);\n    if (!(isNone || isSingle)) {\n      sigMsgWriter.writeSlice(hashOutputs);\n    }\n    // Input\n    sigMsgWriter.writeUInt8(spendType);\n    if (isAnyoneCanPay) {\n      const input = this.ins[inIndex];\n      sigMsgWriter.writeSlice(input.hash);\n      sigMsgWriter.writeUInt32(input.index);\n      sigMsgWriter.writeUInt64(values[inIndex]);\n      sigMsgWriter.writeVarSlice(prevOutScripts[inIndex]);\n      sigMsgWriter.writeUInt32(input.sequence);\n    } else {\n      sigMsgWriter.writeUInt32(inIndex);\n    }\n    if (annex) {\n      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        varSliceSize(annex),\n      );\n      bufferWriter.writeVarSlice(annex);\n      sigMsgWriter.writeSlice(bcrypto.sha256(bufferWriter.end()));\n    }\n    // Output\n    if (isSingle) {\n      sigMsgWriter.writeSlice(hashOutputs);\n    }\n    // BIP342 extension\n    if (leafHash) {\n      sigMsgWriter.writeSlice(leafHash);\n      sigMsgWriter.writeUInt8(0);\n      sigMsgWriter.writeUInt32(0xffffffff);\n    }\n    // Extra zero byte because:\n    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-19\n    return bcrypto.taggedHash(\n      'TapSighash',\n      Buffer.concat([Buffer.from([0x00]), sigMsgWriter.end()]),\n    );\n  }\n  hashForWitnessV0(inIndex, prevOutScript, value, hashType) {\n    typeforce(\n      types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32),\n      arguments,\n    );\n    let tbuffer = Buffer.from([]);\n    let bufferWriter;\n    let hashOutputs = ZERO;\n    let hashPrevouts = ZERO;\n    let hashSequence = ZERO;\n    if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {\n      tbuffer = Buffer.allocUnsafe(36 * this.ins.length);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeSlice(txIn.hash);\n        bufferWriter.writeUInt32(txIn.index);\n      });\n      hashPrevouts = bcrypto.hash256(tbuffer);\n    }\n    if (\n      !(hashType & Transaction.SIGHASH_ANYONECANPAY) &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE\n    ) {\n      tbuffer = Buffer.allocUnsafe(4 * this.ins.length);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeUInt32(txIn.sequence);\n      });\n      hashSequence = bcrypto.hash256(tbuffer);\n    }\n    if (\n      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE\n    ) {\n      const txOutsSize = this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0);\n      tbuffer = Buffer.allocUnsafe(txOutsSize);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.outs.forEach(out => {\n        bufferWriter.writeUInt64(out.value);\n        bufferWriter.writeVarSlice(out.script);\n      });\n      hashOutputs = bcrypto.hash256(tbuffer);\n    } else if (\n      (hashType & 0x1f) === Transaction.SIGHASH_SINGLE &&\n      inIndex < this.outs.length\n    ) {\n      const output = this.outs[inIndex];\n      tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script));\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      bufferWriter.writeUInt64(output.value);\n      bufferWriter.writeVarSlice(output.script);\n      hashOutputs = bcrypto.hash256(tbuffer);\n    }\n    tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript));\n    bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n    const input = this.ins[inIndex];\n    bufferWriter.writeInt32(this.version);\n    bufferWriter.writeSlice(hashPrevouts);\n    bufferWriter.writeSlice(hashSequence);\n    bufferWriter.writeSlice(input.hash);\n    bufferWriter.writeUInt32(input.index);\n    bufferWriter.writeVarSlice(prevOutScript);\n    bufferWriter.writeUInt64(value);\n    bufferWriter.writeUInt32(input.sequence);\n    bufferWriter.writeSlice(hashOutputs);\n    bufferWriter.writeUInt32(this.locktime);\n    bufferWriter.writeUInt32(hashType);\n    return bcrypto.hash256(tbuffer);\n  }\n  getHash(forWitness) {\n    // wtxid for coinbase is always 32 bytes of 0x00\n    if (forWitness && this.isCoinbase()) return Buffer.alloc(32, 0);\n    return bcrypto.hash256(this.__toBuffer(undefined, undefined, forWitness));\n  }\n  getId() {\n    // transaction hash's are displayed in reverse order\n    return (0, bufferutils_1.reverseBuffer)(this.getHash(false)).toString(\n      'hex',\n    );\n  }\n  toBuffer(buffer, initialOffset) {\n    return this.__toBuffer(buffer, initialOffset, true);\n  }\n  toHex() {\n    return this.toBuffer(undefined, undefined).toString('hex');\n  }\n  setInputScript(index, scriptSig) {\n    typeforce(types.tuple(types.Number, types.Buffer), arguments);\n    this.ins[index].script = scriptSig;\n  }\n  setWitness(index, witness) {\n    typeforce(types.tuple(types.Number, [types.Buffer]), arguments);\n    this.ins[index].witness = witness;\n  }\n  __toBuffer(buffer, initialOffset, _ALLOW_WITNESS = false) {\n    if (!buffer) buffer = Buffer.allocUnsafe(this.byteLength(_ALLOW_WITNESS));\n    const bufferWriter = new bufferutils_1.BufferWriter(\n      buffer,\n      initialOffset || 0,\n    );\n    bufferWriter.writeInt32(this.version);\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    if (hasWitnesses) {\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);\n    }\n    bufferWriter.writeVarInt(this.ins.length);\n    this.ins.forEach(txIn => {\n      bufferWriter.writeSlice(txIn.hash);\n      bufferWriter.writeUInt32(txIn.index);\n      bufferWriter.writeVarSlice(txIn.script);\n      bufferWriter.writeUInt32(txIn.sequence);\n    });\n    bufferWriter.writeVarInt(this.outs.length);\n    this.outs.forEach(txOut => {\n      if (isOutput(txOut)) {\n        bufferWriter.writeUInt64(txOut.value);\n      } else {\n        bufferWriter.writeSlice(txOut.valueBuffer);\n      }\n      bufferWriter.writeVarSlice(txOut.script);\n    });\n    if (hasWitnesses) {\n      this.ins.forEach(input => {\n        bufferWriter.writeVector(input.witness);\n      });\n    }\n    bufferWriter.writeUInt32(this.locktime);\n    // avoid slicing unless necessary\n    if (initialOffset !== undefined)\n      return buffer.slice(initialOffset, bufferWriter.offset);\n    return buffer;\n  }\n}\nexports.Transaction = Transaction;\nTransaction.DEFAULT_SEQUENCE = 0xffffffff;\nTransaction.SIGHASH_DEFAULT = 0x00;\nTransaction.SIGHASH_ALL = 0x01;\nTransaction.SIGHASH_NONE = 0x02;\nTransaction.SIGHASH_SINGLE = 0x03;\nTransaction.SIGHASH_ANYONECANPAY = 0x80;\nTransaction.SIGHASH_OUTPUT_MASK = 0x03;\nTransaction.SIGHASH_INPUT_MASK = 0x80;\nTransaction.ADVANCED_TRANSACTION_MARKER = 0x00;\nTransaction.ADVANCED_TRANSACTION_FLAG = 0x01;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.oneOf =\n  exports.Null =\n  exports.BufferN =\n  exports.Function =\n  exports.UInt32 =\n  exports.UInt8 =\n  exports.tuple =\n  exports.maybe =\n  exports.Hex =\n  exports.Buffer =\n  exports.String =\n  exports.Boolean =\n  exports.Array =\n  exports.Number =\n  exports.Hash256bit =\n  exports.Hash160bit =\n  exports.Buffer256bit =\n  exports.isTaptree =\n  exports.isTapleaf =\n  exports.TAPLEAF_VERSION_MASK =\n  exports.Satoshi =\n  exports.isPoint =\n  exports.stacksEqual =\n  exports.typeforce =\n    void 0;\nconst buffer_1 = require('buffer');\nexports.typeforce = require('typeforce');\nconst ZERO32 = buffer_1.Buffer.alloc(32, 0);\nconst EC_P = buffer_1.Buffer.from(\n  'fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f',\n  'hex',\n);\n/**\n * Checks if two arrays of Buffers are equal.\n * @param a - The first array of Buffers.\n * @param b - The second array of Buffers.\n * @returns True if the arrays are equal, false otherwise.\n */\nfunction stacksEqual(a, b) {\n  if (a.length !== b.length) return false;\n  return a.every((x, i) => {\n    return x.equals(b[i]);\n  });\n}\nexports.stacksEqual = stacksEqual;\n/**\n * Checks if the given value is a valid elliptic curve point.\n * @param p - The value to check.\n * @returns True if the value is a valid elliptic curve point, false otherwise.\n */\nfunction isPoint(p) {\n  if (!buffer_1.Buffer.isBuffer(p)) return false;\n  if (p.length < 33) return false;\n  const t = p[0];\n  const x = p.slice(1, 33);\n  if (x.compare(ZERO32) === 0) return false;\n  if (x.compare(EC_P) >= 0) return false;\n  if ((t === 0x02 || t === 0x03) && p.length === 33) {\n    return true;\n  }\n  const y = p.slice(33);\n  if (y.compare(ZERO32) === 0) return false;\n  if (y.compare(EC_P) >= 0) return false;\n  if (t === 0x04 && p.length === 65) return true;\n  return false;\n}\nexports.isPoint = isPoint;\nconst SATOSHI_MAX = 21 * 1e14;\nfunction Satoshi(value) {\n  return exports.typeforce.UInt53(value) && value <= SATOSHI_MAX;\n}\nexports.Satoshi = Satoshi;\nexports.TAPLEAF_VERSION_MASK = 0xfe;\nfunction isTapleaf(o) {\n  if (!o || !('output' in o)) return false;\n  if (!buffer_1.Buffer.isBuffer(o.output)) return false;\n  if (o.version !== undefined)\n    return (o.version & exports.TAPLEAF_VERSION_MASK) === o.version;\n  return true;\n}\nexports.isTapleaf = isTapleaf;\nfunction isTaptree(scriptTree) {\n  if (!(0, exports.Array)(scriptTree)) return isTapleaf(scriptTree);\n  if (scriptTree.length !== 2) return false;\n  return scriptTree.every(t => isTaptree(t));\n}\nexports.isTaptree = isTaptree;\nexports.Buffer256bit = exports.typeforce.BufferN(32);\nexports.Hash160bit = exports.typeforce.BufferN(20);\nexports.Hash256bit = exports.typeforce.BufferN(32);\nexports.Number = exports.typeforce.Number;\nexports.Array = exports.typeforce.Array;\nexports.Boolean = exports.typeforce.Boolean;\nexports.String = exports.typeforce.String;\nexports.Buffer = exports.typeforce.Buffer;\nexports.Hex = exports.typeforce.Hex;\nexports.maybe = exports.typeforce.maybe;\nexports.tuple = exports.typeforce.tuple;\nexports.UInt8 = exports.typeforce.UInt8;\nexports.UInt32 = exports.typeforce.UInt32;\nexports.Function = exports.typeforce.Function;\nexports.BufferN = exports.typeforce.BufferN;\nexports.Null = exports.typeforce.Null;\nexports.oneOf = exports.typeforce.oneOf;\n","const bs58check = require('bs58check')\nconst bech32 = require('bech32')\nconst bufferEquals = require('buffer-equals')\nconst createHash = require('create-hash')\nconst secp256k1 = require('secp256k1')\nconst varuint = require('varuint-bitcoin')\n\nconst SEGWIT_TYPES = {\n  P2WPKH: 'p2wpkh',\n  P2SH_P2WPKH: 'p2sh(p2wpkh)'\n}\n\nfunction sha256 (b) {\n  return createHash('sha256')\n    .update(b)\n    .digest()\n}\nfunction hash256 (buffer) {\n  return sha256(sha256(buffer))\n}\nfunction hash160 (buffer) {\n  return createHash('ripemd160')\n    .update(sha256(buffer))\n    .digest()\n}\n\nfunction encodeSignature (signature, recovery, compressed, segwitType) {\n  if (segwitType !== undefined) {\n    recovery += 8\n    if (segwitType === SEGWIT_TYPES.P2WPKH) recovery += 4\n  } else {\n    if (compressed) recovery += 4\n  }\n  return Buffer.concat([Buffer.alloc(1, recovery + 27), signature])\n}\n\nfunction decodeSignature (buffer) {\n  if (buffer.length !== 65) throw new Error('Invalid signature length')\n\n  const flagByte = buffer.readUInt8(0) - 27\n  if (flagByte > 15 || flagByte < 0) {\n    throw new Error('Invalid signature parameter')\n  }\n\n  return {\n    compressed: !!(flagByte & 12),\n    segwitType: !(flagByte & 8)\n      ? null\n      : !(flagByte & 4)\n        ? SEGWIT_TYPES.P2SH_P2WPKH\n        : SEGWIT_TYPES.P2WPKH,\n    recovery: flagByte & 3,\n    signature: buffer.slice(1)\n  }\n}\n\nfunction magicHash (message, messagePrefix) {\n  messagePrefix = messagePrefix || '\\u0018Bitcoin Signed Message:\\n'\n  if (!Buffer.isBuffer(messagePrefix)) {\n    messagePrefix = Buffer.from(messagePrefix, 'utf8')\n  }\n  if (!Buffer.isBuffer(message)) {\n    message = Buffer.from(message, 'utf8')\n  }\n  const messageVISize = varuint.encodingLength(message.length)\n  const buffer = Buffer.allocUnsafe(\n    messagePrefix.length + messageVISize + message.length\n  )\n  messagePrefix.copy(buffer, 0)\n  varuint.encode(message.length, buffer, messagePrefix.length)\n  message.copy(buffer, messagePrefix.length + messageVISize)\n  return hash256(buffer)\n}\n\nfunction prepareSign (\n  messagePrefixArg,\n  sigOptions\n) {\n  if (typeof messagePrefixArg === 'object' && sigOptions === undefined) {\n    sigOptions = messagePrefixArg\n    messagePrefixArg = undefined\n  }\n  let { segwitType, extraEntropy } = sigOptions || {}\n  if (\n    segwitType &&\n    (typeof segwitType === 'string' || segwitType instanceof String)\n  ) {\n    segwitType = segwitType.toLowerCase()\n  }\n  if (\n    segwitType &&\n    segwitType !== SEGWIT_TYPES.P2SH_P2WPKH &&\n    segwitType !== SEGWIT_TYPES.P2WPKH\n  ) {\n    throw new Error(\n      'Unrecognized segwitType: use \"' +\n        SEGWIT_TYPES.P2SH_P2WPKH +\n        '\" or \"' +\n        SEGWIT_TYPES.P2WPKH +\n        '\"'\n    )\n  }\n\n  return {\n    messagePrefixArg,\n    segwitType,\n    extraEntropy\n  }\n}\n\nfunction isSigner (obj) {\n  return obj && typeof obj.sign === 'function'\n}\n\nfunction sign (\n  message,\n  privateKey,\n  compressed,\n  messagePrefix,\n  sigOptions\n) {\n  const {\n    messagePrefixArg,\n    segwitType,\n    extraEntropy\n  } = prepareSign(messagePrefix, sigOptions)\n  const hash = magicHash(message, messagePrefixArg)\n  const sigObj = isSigner(privateKey)\n    ? privateKey.sign(hash, extraEntropy)\n    : secp256k1.sign(hash, privateKey, { data: extraEntropy })\n  return encodeSignature(\n    sigObj.signature,\n    sigObj.recovery,\n    compressed,\n    segwitType\n  )\n}\n\nfunction signAsync (\n  message,\n  privateKey,\n  compressed,\n  messagePrefix,\n  sigOptions\n) {\n  let messagePrefixArg, segwitType, extraEntropy\n  return Promise.resolve().then(() => {\n    ({\n      messagePrefixArg,\n      segwitType,\n      extraEntropy\n    } = prepareSign(messagePrefix, sigOptions))\n    const hash = magicHash(message, messagePrefixArg)\n    return isSigner(privateKey)\n      ? privateKey.sign(hash, extraEntropy)\n      : secp256k1.sign(hash, privateKey, { data: extraEntropy })\n  }).then((sigObj) => {\n    return encodeSignature(\n      sigObj.signature,\n      sigObj.recovery,\n      compressed,\n      segwitType\n    )\n  })\n}\n\nfunction segwitRedeemHash (publicKeyHash) {\n  const redeemScript = Buffer.concat([\n    Buffer.from('0014', 'hex'),\n    publicKeyHash\n  ])\n  return hash160(redeemScript)\n}\n\nfunction decodeBech32 (address) {\n  const result = bech32.decode(address)\n  const data = bech32.fromWords(result.words.slice(1))\n  return Buffer.from(data)\n}\n\nfunction verify (message, address, signature, messagePrefix, checkSegwitAlways) {\n  if (!Buffer.isBuffer(signature)) signature = Buffer.from(signature, 'base64')\n\n  const parsed = decodeSignature(signature)\n\n  if (checkSegwitAlways && !parsed.compressed) {\n    throw new Error('checkSegwitAlways can only be used with a compressed pubkey signature flagbyte')\n  }\n\n  const hash = magicHash(message, messagePrefix)\n  const publicKey = secp256k1.recover(\n    hash,\n    parsed.signature,\n    parsed.recovery,\n    parsed.compressed\n  )\n  const publicKeyHash = hash160(publicKey)\n  let actual, expected\n\n  if (parsed.segwitType) {\n    if (parsed.segwitType === SEGWIT_TYPES.P2SH_P2WPKH) {\n      actual = segwitRedeemHash(publicKeyHash)\n      expected = bs58check.decode(address).slice(1)\n    } else {\n      // parsed.segwitType === SEGWIT_TYPES.P2WPKH\n      // must be true since we only return null, P2SH_P2WPKH, or P2WPKH\n      // from the decodeSignature function.\n      actual = publicKeyHash\n      expected = decodeBech32(address)\n    }\n  } else {\n    if (checkSegwitAlways) {\n      try {\n        expected = decodeBech32(address)\n        // if address is bech32 it is not p2sh\n        return bufferEquals(publicKeyHash, expected)\n      } catch (e) {\n        const redeemHash = segwitRedeemHash(publicKeyHash)\n        expected = bs58check.decode(address).slice(1)\n        // base58 can be p2pkh or p2sh-p2wpkh\n        return (\n          bufferEquals(publicKeyHash, expected) ||\n          bufferEquals(redeemHash, expected)\n        )\n      }\n    } else {\n      actual = publicKeyHash\n      expected = bs58check.decode(address).slice(1)\n    }\n  }\n\n  return bufferEquals(actual, expected)\n}\n\nmodule.exports = {\n  magicHash: magicHash,\n  sign: sign,\n  signAsync: signAsync,\n  verify: verify\n}\n","'use strict'\nvar ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'\n\n// pre-compute lookup table\nvar ALPHABET_MAP = {}\nfor (var z = 0; z < ALPHABET.length; z++) {\n  var x = ALPHABET.charAt(z)\n\n  if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous')\n  ALPHABET_MAP[x] = z\n}\n\nfunction polymodStep (pre) {\n  var b = pre >> 25\n  return ((pre & 0x1FFFFFF) << 5) ^\n    (-((b >> 0) & 1) & 0x3b6a57b2) ^\n    (-((b >> 1) & 1) & 0x26508e6d) ^\n    (-((b >> 2) & 1) & 0x1ea119fa) ^\n    (-((b >> 3) & 1) & 0x3d4233dd) ^\n    (-((b >> 4) & 1) & 0x2a1462b3)\n}\n\nfunction prefixChk (prefix) {\n  var chk = 1\n  for (var i = 0; i < prefix.length; ++i) {\n    var c = prefix.charCodeAt(i)\n    if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')'\n\n    chk = polymodStep(chk) ^ (c >> 5)\n  }\n  chk = polymodStep(chk)\n\n  for (i = 0; i < prefix.length; ++i) {\n    var v = prefix.charCodeAt(i)\n    chk = polymodStep(chk) ^ (v & 0x1f)\n  }\n  return chk\n}\n\nfunction encode (prefix, words, LIMIT) {\n  LIMIT = LIMIT || 90\n  if ((prefix.length + 7 + words.length) > LIMIT) throw new TypeError('Exceeds length limit')\n\n  prefix = prefix.toLowerCase()\n\n  // determine chk mod\n  var chk = prefixChk(prefix)\n  if (typeof chk === 'string') throw new Error(chk)\n\n  var result = prefix + '1'\n  for (var i = 0; i < words.length; ++i) {\n    var x = words[i]\n    if ((x >> 5) !== 0) throw new Error('Non 5-bit word')\n\n    chk = polymodStep(chk) ^ x\n    result += ALPHABET.charAt(x)\n  }\n\n  for (i = 0; i < 6; ++i) {\n    chk = polymodStep(chk)\n  }\n  chk ^= 1\n\n  for (i = 0; i < 6; ++i) {\n    var v = (chk >> ((5 - i) * 5)) & 0x1f\n    result += ALPHABET.charAt(v)\n  }\n\n  return result\n}\n\nfunction __decode (str, LIMIT) {\n  LIMIT = LIMIT || 90\n  if (str.length < 8) return str + ' too short'\n  if (str.length > LIMIT) return 'Exceeds length limit'\n\n  // don't allow mixed case\n  var lowered = str.toLowerCase()\n  var uppered = str.toUpperCase()\n  if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str\n  str = lowered\n\n  var split = str.lastIndexOf('1')\n  if (split === -1) return 'No separator character for ' + str\n  if (split === 0) return 'Missing prefix for ' + str\n\n  var prefix = str.slice(0, split)\n  var wordChars = str.slice(split + 1)\n  if (wordChars.length < 6) return 'Data too short'\n\n  var chk = prefixChk(prefix)\n  if (typeof chk === 'string') return chk\n\n  var words = []\n  for (var i = 0; i < wordChars.length; ++i) {\n    var c = wordChars.charAt(i)\n    var v = ALPHABET_MAP[c]\n    if (v === undefined) return 'Unknown character ' + c\n    chk = polymodStep(chk) ^ v\n\n    // not in the checksum?\n    if (i + 6 >= wordChars.length) continue\n    words.push(v)\n  }\n\n  if (chk !== 1) return 'Invalid checksum for ' + str\n  return { prefix: prefix, words: words }\n}\n\nfunction decodeUnsafe () {\n  var res = __decode.apply(null, arguments)\n  if (typeof res === 'object') return res\n}\n\nfunction decode (str) {\n  var res = __decode.apply(null, arguments)\n  if (typeof res === 'object') return res\n\n  throw new Error(res)\n}\n\nfunction convert (data, inBits, outBits, pad) {\n  var value = 0\n  var bits = 0\n  var maxV = (1 << outBits) - 1\n\n  var result = []\n  for (var i = 0; i < data.length; ++i) {\n    value = (value << inBits) | data[i]\n    bits += inBits\n\n    while (bits >= outBits) {\n      bits -= outBits\n      result.push((value >> bits) & maxV)\n    }\n  }\n\n  if (pad) {\n    if (bits > 0) {\n      result.push((value << (outBits - bits)) & maxV)\n    }\n  } else {\n    if (bits >= inBits) return 'Excess padding'\n    if ((value << (outBits - bits)) & maxV) return 'Non-zero padding'\n  }\n\n  return result\n}\n\nfunction toWordsUnsafe (bytes) {\n  var res = convert(bytes, 8, 5, true)\n  if (Array.isArray(res)) return res\n}\n\nfunction toWords (bytes) {\n  var res = convert(bytes, 8, 5, true)\n  if (Array.isArray(res)) return res\n\n  throw new Error(res)\n}\n\nfunction fromWordsUnsafe (words) {\n  var res = convert(words, 5, 8, false)\n  if (Array.isArray(res)) return res\n}\n\nfunction fromWords (words) {\n  var res = convert(words, 5, 8, false)\n  if (Array.isArray(res)) return res\n\n  throw new Error(res)\n}\n\nmodule.exports = {\n  decodeUnsafe: decodeUnsafe,\n  decode: decode,\n  encode: encode,\n  toWordsUnsafe: toWordsUnsafe,\n  toWords: toWords,\n  fromWordsUnsafe: fromWordsUnsafe,\n  fromWords: fromWords\n}\n","'use strict';\n\nvar bitcore = module.exports;\n\n// module information\nbitcore.version = 'v' + require('./package.json').version;\nbitcore.versionGuard = function(version) {\n  if (version !== undefined) {\n    var message = 'More than one instance of bitcore-lib found. ' +\n      'Please make sure to require bitcore-lib and check that submodules do' +\n      ' not also include their own bitcore-lib dependency.';\n    throw new Error(message);\n  }\n};\nbitcore.versionGuard(global._bitcore);\nglobal._bitcore = bitcore.version;\n\n// crypto\nbitcore.crypto = {};\nbitcore.crypto.BN = require('./lib/crypto/bn');\nbitcore.crypto.ECDSA = require('./lib/crypto/ecdsa');\nbitcore.crypto.Schnorr = require('./lib/crypto/schnorr');\nbitcore.crypto.Hash = require('./lib/crypto/hash');\nbitcore.crypto.Random = require('./lib/crypto/random');\nbitcore.crypto.Point = require('./lib/crypto/point');\nbitcore.crypto.Signature = require('./lib/crypto/signature');\nbitcore.crypto.TaggedHash = require('./lib/crypto/taggedhash');\n\n// encoding\nbitcore.encoding = {};\nbitcore.encoding.Base58 = require('./lib/encoding/base58');\nbitcore.encoding.Base58Check = require('./lib/encoding/base58check');\nbitcore.encoding.BufferReader = require('./lib/encoding/bufferreader');\nbitcore.encoding.BufferWriter = require('./lib/encoding/bufferwriter');\nbitcore.encoding.Varint = require('./lib/encoding/varint');\n\n// utilities\nbitcore.util = {};\nbitcore.util.buffer = require('./lib/util/buffer');\nbitcore.util.js = require('./lib/util/js');\nbitcore.util.preconditions = require('./lib/util/preconditions');\n\n// errors thrown by the library\nbitcore.errors = require('./lib/errors');\n\n// main bitcoin library\nbitcore.Address = require('./lib/address');\nbitcore.Block = require('./lib/block');\nbitcore.MerkleBlock = require('./lib/block/merkleblock');\nbitcore.BlockHeader = require('./lib/block/blockheader');\nbitcore.HDPrivateKey = require('./lib/hdprivatekey.js');\nbitcore.HDPublicKey = require('./lib/hdpublickey.js');\nbitcore.Message = require('./lib/message');\nbitcore.Networks = require('./lib/networks');\nbitcore.Opcode = require('./lib/opcode');\nbitcore.PrivateKey = require('./lib/privatekey');\nbitcore.PublicKey = require('./lib/publickey');\nbitcore.Script = require('./lib/script');\nbitcore.Transaction = require('./lib/transaction');\nbitcore.URI = require('./lib/uri');\nbitcore.Unit = require('./lib/unit');\n\n// dependencies, subject to change\nbitcore.deps = {};\nbitcore.deps.bnjs = require('bn.js');\nbitcore.deps.bs58 = require('bs58');\nbitcore.deps.Buffer = Buffer;\nbitcore.deps.elliptic = require('elliptic');\nbitcore.deps._ = require('lodash');\n\n// Internal usage, exposed for testing/advanced tweaking\nbitcore.Transaction.sighash = require('./lib/transaction/sighash');\n","'use strict';\n\nvar _ = require('lodash');\nvar $ = require('./util/preconditions');\nvar errors = require('./errors');\nvar Base58Check = require('./encoding/base58check');\nvar Bech32 = require('./encoding/bech32');\nvar Networks = require('./networks');\nvar Hash = require('./crypto/hash');\nvar JSUtil = require('./util/js');\nvar PublicKey = require('./publickey');\n\n/**\n * Instantiate an address from an address String or Buffer, a public key or script hash Buffer,\n * or an instance of {@link PublicKey} or {@link Script}.\n *\n * This is an immutable class, and if the first parameter provided to this constructor is an\n * `Address` instance, the same argument will be returned.\n *\n * An address has two key properties: `network` and `type`. The type is one of\n * `Address.PayToPublicKeyHash` (value is the `'pubkeyhash'` string),\n * `Address.PayToScriptHash` (the string `'scripthash'`),\n * `Address.PayToWitnessPublicKeyHash` (the string `'witnesspubkeyhash'`),\n * or `Address.PayToWitnessScriptHash` (the string `'witnessscripthash'`).\n * The network is an instance of {@link Network}.\n * You can quickly check whether an address is of a given kind by using the methods\n * `isPayToPublicKeyHash`, `isPayToScriptHash`, `isPayToWitnessPublicKeyHash`,\n * and `isPayToWitnessScriptHash`.\n *\n * @example\n * ```javascript\n * // validate that an input field is valid\n * var error = Address.getValidationError(input, 'testnet');\n * if (!error) {\n *   var address = Address(input, 'testnet');\n * } else {\n *   // invalid network or checksum (typo?)\n *   var message = error.messsage;\n * }\n *\n * // get an address from a public key\n * var address = Address(publicKey, 'testnet').toString();\n * ```\n *\n * @param {*} data - The encoded data in various formats\n * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type of address: 'scripthash', 'pubkeyhash', witnessscripthash, 'witnesspubkeyhash', or 'taproot'\n * @param {string=} multisigType - The type of multisig: 'scripthash' or 'witnessscripthash'\n * @returns {Address} A new valid and frozen instance of an Address\n * @constructor\n */\nfunction Address(data, network, type, multisigType) {\n  /* jshint maxcomplexity: 12 */\n  /* jshint maxstatements: 20 */\n\n  if (!(this instanceof Address)) {\n    return new Address(data, network, type);\n  }\n\n  if (_.isArray(data) && _.isNumber(network)) {\n    return Address.createMultisig(data, network, type, false, multisigType);\n  }\n\n  if (data instanceof Address) {\n    // Immutable instance\n    return data;\n  }\n\n  $.checkArgument(data, 'First argument is required, please include address data.', 'guide/address.html');\n\n  if (network && !Networks.get(network)) {\n    throw new TypeError('Second argument must be \"livenet\" or \"testnet\".');\n  }\n\n  if (type && (\n    type !== Address.PayToPublicKeyHash\n    && type !== Address.PayToScriptHash\n    && type !== Address.PayToWitnessPublicKeyHash\n    && type !== Address.PayToWitnessScriptHash\n    && type !== Address.PayToTaproot)) {\n    throw new TypeError('Third argument must be \"pubkeyhash\", \"scripthash\", \"witnesspubkeyhash\", \"witnessscripthash\", or \"taproot\".');\n  }\n\n  var info = this._classifyArguments(data, network, type);\n\n  // set defaults if not set\n  info.network = info.network || Networks.get(network) || Networks.defaultNetwork;\n  info.type = info.type || type || Address.PayToPublicKeyHash;\n\n  JSUtil.defineImmutable(this, {\n    hashBuffer: info.hashBuffer,\n    network: info.network,\n    type: info.type\n  });\n\n  return this;\n}\n\n/**\n * Internal function used to split different kinds of arguments of the constructor\n * @param {*} data - The encoded data in various formats\n * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Object} An \"info\" object with \"type\", \"network\", and \"hashBuffer\"\n */\nAddress.prototype._classifyArguments = function(data, network, type) {\n  /* jshint maxcomplexity: 10 */\n  // transform and validate input data\n  if ((data instanceof Buffer || data instanceof Uint8Array) && (data.length === 20 || data.length === 32)) {\n    return Address._transformHash(data, network, type);\n  } else if ((data instanceof Buffer || data instanceof Uint8Array) && data.length >= 21) {\n    return Address._transformBuffer(data, network, type);\n  } else if (data instanceof PublicKey) {\n    return Address._transformPublicKey(data, network, type);\n  } else if (data instanceof Script) {\n    return Address._transformScript(data, network);\n  } else if (typeof(data) === 'string') {\n    return Address._transformString(data, network, type);\n  } else if (_.isObject(data)) {\n    return Address._transformObject(data);\n  } else {\n    throw new TypeError('First argument is an unrecognized data format.');\n  }\n};\n\n/** @static */\nAddress.PayToPublicKeyHash = 'pubkeyhash';\n/** @static */\nAddress.PayToScriptHash = 'scripthash';\n/** @static */\nAddress.PayToWitnessPublicKeyHash = 'witnesspubkeyhash';\n/** @static */\nAddress.PayToWitnessScriptHash = 'witnessscripthash';\n/** @static */\nAddress.PayToTaproot = 'taproot';\n\n/**\n * @param {Buffer} hash - An instance of a hash Buffer\n * @param {string} type - either 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\n * @param {Network=} network - the name of the network associated\n * @returns {Object} An object with keys: hashBuffer\n * @private\n */\nAddress._transformHash = function(hash, network, type) {\n  var info = {};\n  if (!(hash instanceof Buffer) && !(hash instanceof Uint8Array)) {\n    throw new TypeError('Address supplied is not a buffer.');\n  }\n  if (hash.length !== 20 && hash.length !== 32) {\n    throw new TypeError('Address hashbuffers must be either 20 or 32 bytes.');\n  }\n  info.hashBuffer = hash;\n  info.network = Networks.get(network) || Networks.defaultNetwork;\n  info.type = type;\n  return info;\n};\n\n/**\n * Deserializes an address serialized through `Address#toObject()`\n * @param {Object} data\n * @param {string} data.hash - the hash that this address encodes\n * @param {string} data.type - either 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\n * @param {Network=} data.network - the name of the network associated\n * @return {Address}\n */\nAddress._transformObject = function(data) {\n  $.checkArgument(data.hash || data.hashBuffer, 'Must provide a `hash` or `hashBuffer` property');\n  $.checkArgument(data.type, 'Must provide a `type` property');\n  return {\n    hashBuffer: data.hash ? Buffer.from(data.hash, 'hex') : data.hashBuffer,\n    network: Networks.get(data.network) || Networks.defaultNetwork,\n    type: data.type\n  };\n};\n\n/**\n * Internal function to discover the network and type based on the first data byte\n *\n * @param {Buffer} buffer - An instance of a hex encoded address Buffer\n * @returns {Object} An object with keys: network and type\n * @private\n */\nAddress._classifyFromVersion = function(buffer) {\n  var version = {};\n\n  if (buffer.length > 21) {\n    var info = Bech32.decode(buffer.toString('utf8'));\n    if (info.version !== 0 && info.version !== 1) { // v1 == taproot\n      throw new TypeError('Only witness v0 and v1 addresses are supported.');\n    }\n\n    if (info.version === 0) {\n      if (info.data.length === 20) {\n        version.type = Address.PayToWitnessPublicKeyHash;\n      } else if (info.data.length === 32) {\n        version.type = Address.PayToWitnessScriptHash;\n      } else {\n        throw new TypeError('Witness data must be either 20 or 32 bytes.')\n      }\n    } else if (info.version === 1) {\n      if (info.data.length === 32) {\n        version.type = Address.PayToTaproot;\n      } else {\n        throw new TypeError('Witness data must be 32 bytes for v1');\n      }\n    } else {\n    }\n    version.network = Networks.get(info.prefix, 'bech32prefix');\n  } else {\n\n    var pubkeyhashNetwork = Networks.get(buffer[0], 'pubkeyhash');\n    var scripthashNetwork = Networks.get(buffer[0], 'scripthash');\n\n    if (pubkeyhashNetwork) {\n      version.network = pubkeyhashNetwork;\n      version.type = Address.PayToPublicKeyHash;\n    } else if (scripthashNetwork) {\n      version.network = scripthashNetwork;\n      version.type = Address.PayToScriptHash;\n    }\n  }\n\n  return version;\n};\n\n/**\n * Internal function to transform a bitcoin address buffer\n *\n * @param {Buffer} buffer - An instance of a hex encoded address Buffer\n * @param {string=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\nAddress._transformBuffer = function(buffer, network, type) {\n  /* jshint maxcomplexity: 9 */\n  var info = {};\n  if (!(buffer instanceof Buffer) && !(buffer instanceof Uint8Array)) {\n    throw new TypeError('Address supplied is not a buffer.');\n  }\n\n  if (buffer.length < 21) {\n    throw new TypeError('Address buffer is incorrect length.');\n  }\n\n  var networkObj = Networks.get(network);\n  var bufferVersion = Address._classifyFromVersion(buffer);\n\n  if (network && !networkObj) {\n    throw new TypeError('Unknown network');\n  }\n\n  if (!bufferVersion.network || (networkObj && networkObj.xpubkey !== bufferVersion.network.xpubkey)) {\n    throw new TypeError('Address has mismatched network type.');\n  }\n\n  if (!bufferVersion.type || (type && type !== bufferVersion.type)) {\n    throw new TypeError('Address has mismatched type.');\n  }\n\n  if (buffer.length > 21) {\n    info.hashBuffer = Bech32.decode(buffer.toString('utf8')).data;\n  } else {\n    info.hashBuffer = buffer.slice(1);\n  }\n  info.network = networkObj || bufferVersion.network;\n  info.type = bufferVersion.type;\n  return info;\n};\n\n/**\n * Internal function to transform a {@link PublicKey}\n *\n * @param {PublicKey} pubkey - An instance of PublicKey\n * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', 'scripthash', or 'taproot'\n * @returns {Object} An object with keys: hashBuffer, type\n * @private\n */\nAddress._transformPublicKey = function(pubkey, network, type) {\n  var info = {};\n  if (!(pubkey instanceof PublicKey)) {\n    throw new TypeError('Address must be an instance of PublicKey.');\n  }\n  if (type && type !== Address.PayToScriptHash && type !== Address.PayToWitnessPublicKeyHash && type !== Address.PayToPublicKeyHash && type !== Address.PayToTaproot) {\n    throw new TypeError('Type must be either pubkeyhash, witnesspubkeyhash, scripthash, or taproot to transform public key.');\n  }\n  if (!pubkey.compressed && (type === Address.PayToScriptHash || type === Address.PayToWitnessPublicKeyHash)) {\n    throw new TypeError('Witness addresses must use compressed public keys.');\n  }\n  if (type === Address.PayToScriptHash) {\n    info.hashBuffer = Hash.sha256ripemd160(Script.buildWitnessV0Out(pubkey).toBuffer());\n  } else if (type === Address.PayToTaproot) {\n    info.hashBuffer = pubkey.createTapTweak().tweakedPubKey;\n  } else {\n    info.hashBuffer = Hash.sha256ripemd160(pubkey.toBuffer());\n  }\n  info.type = type || Address.PayToPublicKeyHash;\n  return info;\n};\n\n/**\n * Internal function to transform a {@link Script} into a `info` object.\n *\n * @param {Script} script - An instance of Script\n * @returns {Object} An object with keys: hashBuffer, type\n * @private\n */\nAddress._transformScript = function(script, network) {\n  $.checkArgument(script instanceof Script, 'script must be a Script instance');\n  var info = script.getAddressInfo(network);\n  if (!info) {\n    throw new errors.Script.CantDeriveAddress(script);\n  }\n  return info;\n};\n\n/**\n * Creates a P2SH address from a set of public keys and a threshold.\n *\n * The addresses will be sorted lexicographically, as that is the trend in bitcoin.\n * To create an address from unsorted public keys, use the {@link Script#buildMultisigOut}\n * interface.\n *\n * @param {Array} publicKeys - a set of public keys to create an address\n * @param {number} threshold - the number of signatures needed to release the funds\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {boolean=} nestedWitness - if the address uses a nested p2sh witness\n * @param {string} type - Either 'scripthash' or 'witnessscripthash'. If nestedWitness is set, then this is ignored\n * @return {Address}\n */\nAddress.createMultisig = function(publicKeys, threshold, network, nestedWitness, type) {\n  network = network || publicKeys[0].network || Networks.defaultNetwork;\n  if (type && type !== Address.PayToScriptHash && type !== Address.PayToWitnessScriptHash) {\n    throw new TypeError('Type must be either scripthash or witnessscripthash to create multisig.');\n  }\n  if (nestedWitness || type === Address.PayToWitnessScriptHash) {\n    publicKeys = _.map(publicKeys, PublicKey);\n    for (var i = 0; i < publicKeys.length; i++) {\n      if (!publicKeys[i].compressed) {\n        throw new TypeError('Witness addresses must use compressed public keys.');\n      }\n    }\n  }\n  var redeemScript = Script.buildMultisigOut(publicKeys, threshold);\n  if (nestedWitness) {\n    return Address.payingTo(Script.buildWitnessMultisigOutFromScript(redeemScript), network);\n  }\n  return Address.payingTo(redeemScript, network, type);\n};\n\n/**\n * Internal function to transform a bitcoin address string\n *\n * @param {string} data\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash', 'scripthash', 'witnesspubkeyhash', or 'witnessscripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\nAddress._transformString = function(data, network, type) {\n  if (typeof(data) !== 'string') {\n    throw new TypeError('data parameter supplied is not a string.');\n  }\n\n  if(data.length > 100) {\n    throw new TypeError('address string is too long');\n  }\n\n  if (network && !Networks.get(network)) {\n    throw new TypeError('Unknown network');\n  }\n\n  data = data.trim();\n\n  try {\n    var info = Address._transformBuffer(Buffer.from(data, 'utf8'), network, type);\n    return info;\n  } catch (e) {\n    if (type === Address.PayToWitnessPublicKeyHash || type === Address.PayToWitnessScriptHash || type === Address.PayToTaproot) {\n      throw e;\n    }\n  }\n\n  var addressBuffer = Base58Check.decode(data);\n  var info = Address._transformBuffer(addressBuffer, network, type);\n  return info;\n};\n\n/**\n * Instantiate an address from a PublicKey instance\n *\n * @param {PublicKey} data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', or 'scripthash'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromPublicKey = function(data, network, type) {\n  var info = Address._transformPublicKey(data, network, type);\n  network = network || Networks.defaultNetwork;\n  return new Address(info.hashBuffer, network, info.type);\n};\n\n/**\n * Instantiate an address from a ripemd160 public key hash\n *\n * @param {Buffer} hash - An instance of buffer of the hash\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromPublicKeyHash = function(hash, network) {\n  var info = Address._transformHash(hash);\n  return new Address(info.hashBuffer, network, Address.PayToPublicKeyHash);\n};\n\n/**\n * Instantiate an address from a ripemd160 script hash\n *\n * @param {Buffer} hash - An instance of buffer of the hash\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - Either 'scripthash' or 'witnessscripthash'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromScriptHash = function(hash, network, type) {\n  $.checkArgument(hash, 'hash parameter is required');\n  var info = Address._transformHash(hash);\n  if (type === Address.PayToWitnessScriptHash && hash.length !== 32) {\n      throw new TypeError('Address hashbuffer must be exactly 32 bytes for v0 witness script hash.');\n  }\n  var type = type || Address.PayToScriptHash;\n  return new Address(info.hashBuffer, network, type);\n};\n\n/**\n * Builds a p2sh address paying to script. This will hash the script and\n * use that to create the address.\n * If you want to extract an address associated with a script instead,\n * see {{Address#fromScript}}\n *\n * @param {Script} script - An instance of Script\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - Either 'scripthash' or 'witnessscripthash'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.payingTo = function(script, network, type) {\n  $.checkArgument(script, 'script is required');\n  $.checkArgument(script instanceof Script, 'script must be instance of Script');\n  var hash;\n  if (type === Address.PayToWitnessScriptHash) {\n    hash = Hash.sha256(script.toBuffer());\n  } else {\n    hash = Hash.sha256ripemd160(script.toBuffer());\n  }\n  var type = type || Address.PayToScriptHash;\n  return Address.fromScriptHash(hash, network, type);\n};\n\n/**\n * Extract address from a Script. The script must be of one\n * of the following types: p2pkh input, p2pkh output, p2sh input\n * or p2sh output.\n * This will analyze the script and extract address information from it.\n * If you want to transform any script to a p2sh Address paying\n * to that script's hash instead, use {{Address#payingTo}}\n *\n * @param {Script} script - An instance of Script\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromScript = function(script, network) {\n  $.checkArgument(script instanceof Script, 'script must be a Script instance');\n  var info = Address._transformScript(script, network);\n  return new Address(info.hashBuffer, network, info.type);\n};\n\n/**\n * Instantiate an address from a buffer of the address\n *\n * @param {Buffer} buffer - An instance of buffer of the address\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromBuffer = function(buffer, network, type) {\n  var info = Address._transformBuffer(buffer, network, type);\n  return new Address(info.hashBuffer, info.network, info.type);\n};\n\n/**\n * Instantiate an address from an address string\n *\n * @param {string} str - An string of the bitcoin address\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromString = function(str, network, type) {\n  var info = Address._transformString(str, network, type);\n  return new Address(info.hashBuffer, info.network, info.type);\n};\n\n/**\n * Instantiate an address from an Object\n *\n * @param {string} json - An JSON string or Object with keys: hash, network and type\n * @returns {Address} A new valid instance of an Address\n */\nAddress.fromObject = function fromObject(obj) {\n  $.checkState(\n    JSUtil.isHexa(obj.hash),\n    'Unexpected hash property, \"' + obj.hash + '\", expected to be hex.'\n  );\n  var hashBuffer = Buffer.from(obj.hash, 'hex');\n  return new Address(hashBuffer, obj.network, obj.type);\n};\n\n/**\n * Will return a validation error if exists\n *\n * @example\n * ```javascript\n * // a network mismatch error\n * var error = Address.getValidationError('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'testnet');\n * ```\n *\n * @param {string} data - The encoded data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - The type of address: 'script' or 'pubkey'\n * @returns {null|Error} The corresponding error message\n */\nAddress.getValidationError = function(data, network, type) {\n  var error;\n  try {\n    /* jshint nonew: false */\n    new Address(data, network, type);\n  } catch (e) {\n    error = e;\n  }\n  return error;\n};\n\n/**\n * Will return a boolean if an address is valid\n *\n * @example\n * ```javascript\n * assert(Address.isValid('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'livenet'));\n * ```\n *\n * @param {string} data - The encoded data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - The type of address: 'script' or 'pubkey'\n * @returns {boolean} The corresponding error message\n */\nAddress.isValid = function(data, network, type) {\n  return !Address.getValidationError(data, network, type);\n};\n\n/**\n * Returns true if an address is of pay to public key hash type\n * @return boolean\n */\nAddress.prototype.isPayToPublicKeyHash = function() {\n  return this.type === Address.PayToPublicKeyHash;\n};\n\n/**\n * Returns true if an address is of pay to script hash type\n * @return boolean\n */\nAddress.prototype.isPayToScriptHash = function() {\n  return this.type === Address.PayToScriptHash;\n};\n\n/**\n * Returns true if an address is of pay to witness public key hash type\n * @return boolean\n */\nAddress.prototype.isPayToWitnessPublicKeyHash = function() {\n  return this.type === Address.PayToWitnessPublicKeyHash;\n};\n\n/**\n * Returns true if an address is of pay to witness script hash type\n * @return boolean\n */\nAddress.prototype.isPayToWitnessScriptHash = function() {\n  return this.type === Address.PayToWitnessScriptHash;\n};\n\n/**\n * Returns true if an address is of pay to Taproot script hash type\n * @returns {boolean}\n */\nAddress.prototype.isPayToTaproot = function() {\n  return this.type === Address.PayToTaproot;\n}\n\n/**\n * Will return a buffer representation of the address\n *\n * @returns {Buffer} Bitcoin address buffer\n */\nAddress.prototype.toBuffer = function() {\n  if (this.isPayToWitnessPublicKeyHash() || this.isPayToWitnessScriptHash()) {\n    return Buffer.from(this.toString(), 'utf8')\n  }\n  var version = Buffer.from([this.network[this.type]]);\n  return Buffer.concat([version, this.hashBuffer]);\n};\n\n/**\n * @returns {Object} A plain object with the address information\n */\nAddress.prototype.toObject = Address.prototype.toJSON = function toObject() {\n  return {\n    hash: this.hashBuffer.toString('hex'),\n    type: this.type,\n    network: this.network.toString()\n  };\n};\n\n/**\n * Will return a the string representation of the address\n *\n * @returns {string} Bitcoin address\n */\nAddress.prototype.toString = function() {\n  if (this.isPayToWitnessPublicKeyHash() || this.isPayToWitnessScriptHash() || this.isPayToTaproot()) {\n    let prefix = this.network.bech32prefix;\n    let version = 0;\n    let encoding = Bech32.encodings.BECH32;\n    if (this.isPayToTaproot()) {\n      version = 1;\n      encoding = Bech32.encodings.BECH32M;\n    }\n    return Bech32.encode(prefix, version, this.hashBuffer, encoding);\n  }\n  return Base58Check.encode(this.toBuffer());\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Bitcoin address\n */\nAddress.prototype.inspect = function() {\n  return '<Address: ' + this.toString() + ', type: ' + this.type + ', network: ' + this.network + '>';\n};\n\nmodule.exports = Address;\n\nvar Script = require('./script');\n","'use strict';\n\nvar _ = require('lodash');\nvar BlockHeader = require('./blockheader');\nvar BN = require('../crypto/bn');\nvar BufferUtil = require('../util/buffer');\nvar BufferReader = require('../encoding/bufferreader');\nvar BufferWriter = require('../encoding/bufferwriter');\nvar Hash = require('../crypto/hash');\nvar Transaction = require('../transaction');\nvar $ = require('../util/preconditions');\n\n/**\n * Instantiate a Block from a Buffer, JSON object, or Object with\n * the properties of the Block\n *\n * @param {*} - A Buffer, JSON string, or Object\n * @returns {Block}\n * @constructor\n */\nfunction Block(arg) {\n  if (!(this instanceof Block)) {\n    return new Block(arg);\n  }\n  _.extend(this, Block._from(arg));\n  return this;\n}\n\n// https://github.com/bitcoin/bitcoin/blob/b5fa132329f0377d787a4a21c1686609c2bfaece/src/primitives/block.h#L14\nBlock.MAX_BLOCK_SIZE = 1000000;\n\n/**\n * @param {*} - A Buffer, JSON string or Object\n * @returns {Object} - An object representing block data\n * @throws {TypeError} - If the argument was not recognized\n * @private\n */\nBlock._from = function _from(arg) {\n  var info = {};\n  if (BufferUtil.isBuffer(arg)) {\n    info = Block._fromBufferReader(BufferReader(arg));\n  } else if (_.isObject(arg)) {\n    info = Block._fromObject(arg);\n  } else {\n    throw new TypeError('Unrecognized argument for Block');\n  }\n  return info;\n};\n\n/**\n * @param {Object} - A plain JavaScript object\n * @returns {Object} - An object representing block data\n * @private\n */\nBlock._fromObject = function _fromObject(data) {\n  var transactions = [];\n  data.transactions.forEach(function(tx) {\n    if (tx instanceof Transaction) {\n      transactions.push(tx);\n    } else {\n      transactions.push(Transaction().fromObject(tx));\n    }\n  });\n  var info = {\n    header: BlockHeader.fromObject(data.header),\n    transactions: transactions\n  };\n  return info;\n};\n\n/**\n * @param {Object} - A plain JavaScript object\n * @returns {Block} - An instance of block\n */\nBlock.fromObject = function fromObject(obj) {\n  var info = Block._fromObject(obj);\n  return new Block(info);\n};\n\n/**\n * @param {BufferReader} - Block data\n * @returns {Object} - An object representing the block data\n * @private\n */\nBlock._fromBufferReader = function _fromBufferReader(br) {\n  var info = {};\n  $.checkState(!br.finished(), 'No block data received');\n  info.header = BlockHeader.fromBufferReader(br);\n  var transactions = br.readVarintNum();\n  info.transactions = [];\n  for (var i = 0; i < transactions; i++) {\n    info.transactions.push(Transaction().fromBufferReader(br));\n  }\n  return info;\n};\n\n/**\n * @param {BufferReader} - A buffer reader of the block\n * @returns {Block} - An instance of block\n */\nBlock.fromBufferReader = function fromBufferReader(br) {\n  $.checkArgument(br, 'br is required');\n  var info = Block._fromBufferReader(br);\n  return new Block(info);\n};\n\n/**\n * @param {Buffer} - A buffer of the block\n * @returns {Block} - An instance of block\n */\nBlock.fromBuffer = function fromBuffer(buf) {\n  return Block.fromBufferReader(new BufferReader(buf));\n};\n\n/**\n * @param {string} - str - A hex encoded string of the block\n * @returns {Block} - A hex encoded string of the block\n */\nBlock.fromString = function fromString(str) {\n  var buf = Buffer.from(str, 'hex');\n  return Block.fromBuffer(buf);\n};\n\n/**\n * @param {Binary} - Raw block binary data or buffer\n * @returns {Block} - An instance of block\n */\nBlock.fromRawBlock = function fromRawBlock(data) {\n  if (!BufferUtil.isBuffer(data)) {\n    data = Buffer.from(data, 'binary');\n  }\n  var br = BufferReader(data);\n  br.pos = Block.Values.START_OF_BLOCK;\n  var info = Block._fromBufferReader(br);\n  return new Block(info);\n};\n\n/**\n * @returns {Object} - A plain object with the block properties\n */\nBlock.prototype.toObject = Block.prototype.toJSON = function toObject() {\n  var transactions = [];\n  this.transactions.forEach(function(tx) {\n    transactions.push(tx.toObject());\n  });\n  return {\n    header: this.header.toObject(),\n    transactions: transactions\n  };\n};\n\n/**\n * @returns {Buffer} - A buffer of the block\n */\nBlock.prototype.toBuffer = function toBuffer() {\n  return this.toBufferWriter().concat();\n};\n\n/**\n * @returns {string} - A hex encoded string of the block\n */\nBlock.prototype.toString = function toString() {\n  return this.toBuffer().toString('hex');\n};\n\n/**\n * @param {BufferWriter} - An existing instance of BufferWriter\n * @returns {BufferWriter} - An instance of BufferWriter representation of the Block\n */\nBlock.prototype.toBufferWriter = function toBufferWriter(bw) {\n  if (!bw) {\n    bw = new BufferWriter();\n  }\n  bw.write(this.header.toBuffer());\n  bw.writeVarintNum(this.transactions.length);\n  for (var i = 0; i < this.transactions.length; i++) {\n    this.transactions[i].toBufferWriter(bw);\n  }\n  return bw;\n};\n\n/**\n * Will iterate through each transaction and return an array of hashes\n * @returns {Array} - An array with transaction hashes\n */\nBlock.prototype.getTransactionHashes = function getTransactionHashes() {\n  var hashes = [];\n  if (this.transactions.length === 0) {\n    return [Block.Values.NULL_HASH];\n  }\n  for (var t = 0; t < this.transactions.length; t++) {\n    hashes.push(this.transactions[t]._getHash());\n  }\n  return hashes;\n};\n\n/**\n * Will build a merkle tree of all the transactions, ultimately arriving at\n * a single point, the merkle root.\n * @link https://en.bitcoin.it/wiki/Protocol_specification#Merkle_Trees\n * @returns {Array} - An array with each level of the tree after the other.\n */\nBlock.prototype.getMerkleTree = function getMerkleTree() {\n\n  var tree = this.getTransactionHashes();\n\n  var j = 0;\n  for (var size = this.transactions.length; size > 1; size = Math.floor((size + 1) / 2)) {\n    for (var i = 0; i < size; i += 2) {\n      var i2 = Math.min(i + 1, size - 1);\n      var buf = Buffer.concat([tree[j + i], tree[j + i2]]);\n      tree.push(Hash.sha256sha256(buf));\n    }\n    j += size;\n  }\n\n  return tree;\n};\n\n/**\n * Calculates the merkleRoot from the transactions.\n * @returns {Buffer} - A buffer of the merkle root hash\n */\nBlock.prototype.getMerkleRoot = function getMerkleRoot() {\n  var tree = this.getMerkleTree();\n  return tree[tree.length - 1];\n};\n\n/**\n * Verifies that the transactions in the block match the header merkle root\n * @returns {Boolean} - If the merkle roots match\n */\nBlock.prototype.validMerkleRoot = function validMerkleRoot() {\n\n  var h = new BN(this.header.merkleRoot.toString('hex'), 'hex');\n  var c = new BN(this.getMerkleRoot().toString('hex'), 'hex');\n\n  if (h.cmp(c) !== 0) {\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * @returns {Buffer} - The little endian hash buffer of the header\n */\nBlock.prototype._getHash = function() {\n  return this.header._getHash();\n};\n\nvar idProperty = {\n  configurable: false,\n  enumerable: true,\n  /**\n   * @returns {string} - The big endian hash buffer of the header\n   */\n  get: function() {\n    if (!this._id) {\n      this._id = this.header.id;\n    }\n    return this._id;\n  },\n  set: _.noop\n};\nObject.defineProperty(Block.prototype, 'id', idProperty);\nObject.defineProperty(Block.prototype, 'hash', idProperty);\n\n/**\n * @returns {string} - A string formatted for the console\n */\nBlock.prototype.inspect = function inspect() {\n  return '<Block ' + this.id + '>';\n};\n\nBlock.Values = {\n  START_OF_BLOCK: 8, // Start of block in raw block data\n  NULL_HASH: Buffer.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex')\n};\n\nmodule.exports = Block;\n","'use strict';\n\nvar _ = require('lodash');\nvar BN = require('../crypto/bn');\nvar BufferUtil = require('../util/buffer');\nvar BufferReader = require('../encoding/bufferreader');\nvar BufferWriter = require('../encoding/bufferwriter');\nvar Hash = require('../crypto/hash');\nvar JSUtil = require('../util/js');\nvar $ = require('../util/preconditions');\n\nvar GENESIS_BITS = 0x1d00ffff;\n\n/**\n * Instantiate a BlockHeader from a Buffer, JSON object, or Object with\n * the properties of the BlockHeader\n *\n * @param {*} - A Buffer, JSON string, or Object\n * @returns {BlockHeader} - An instance of block header\n * @constructor\n */\nvar BlockHeader = function BlockHeader(arg) {\n  if (!(this instanceof BlockHeader)) {\n    return new BlockHeader(arg);\n  }\n  var info = BlockHeader._from(arg);\n  this.version = info.version;\n  this.prevHash = info.prevHash;\n  this.merkleRoot = info.merkleRoot;\n  this.time = info.time;\n  this.timestamp = info.time;\n  this.bits = info.bits;\n  this.nonce = info.nonce;\n\n  if (info.hash) {\n    $.checkState(\n      this.hash === info.hash,\n      'Argument object hash property does not match block hash.'\n    );\n  }\n\n  return this;\n};\n\n/**\n * @param {*} - A Buffer, JSON string or Object\n * @returns {Object} - An object representing block header data\n * @throws {TypeError} - If the argument was not recognized\n * @private\n */\nBlockHeader._from = function _from(arg) {\n  var info = {};\n  if (BufferUtil.isBuffer(arg)) {\n    info = BlockHeader._fromBufferReader(BufferReader(arg));\n  } else if (_.isObject(arg)) {\n    info = BlockHeader._fromObject(arg);\n  } else {\n    throw new TypeError('Unrecognized argument for BlockHeader');\n  }\n  return info;\n};\n\n/**\n * @param {Object} - A JSON string\n * @returns {Object} - An object representing block header data\n * @private\n */\nBlockHeader._fromObject = function _fromObject(data) {\n  $.checkArgument(data, 'data is required');\n  var prevHash = data.prevHash;\n  var merkleRoot = data.merkleRoot;\n  if (_.isString(data.prevHash)) {\n    prevHash = BufferUtil.reverse(Buffer.from(data.prevHash, 'hex'));\n  }\n  if (_.isString(data.merkleRoot)) {\n    merkleRoot = BufferUtil.reverse(Buffer.from(data.merkleRoot, 'hex'));\n  }\n  var info = {\n    hash: data.hash,\n    version: data.version,\n    prevHash: prevHash,\n    merkleRoot: merkleRoot,\n    time: data.time,\n    timestamp: data.time,\n    bits: data.bits,\n    nonce: data.nonce\n  };\n  return info;\n};\n\n/**\n * @param {Object} - A plain JavaScript object\n * @returns {BlockHeader} - An instance of block header\n */\nBlockHeader.fromObject = function fromObject(obj) {\n  var info = BlockHeader._fromObject(obj);\n  return new BlockHeader(info);\n};\n\n/**\n * @param {Binary} - Raw block binary data or buffer\n * @returns {BlockHeader} - An instance of block header\n */\nBlockHeader.fromRawBlock = function fromRawBlock(data) {\n  if (!BufferUtil.isBuffer(data)) {\n    data = Buffer.from(data, 'binary');\n  }\n  var br = BufferReader(data);\n  br.pos = BlockHeader.Constants.START_OF_HEADER;\n  var info = BlockHeader._fromBufferReader(br);\n  return new BlockHeader(info);\n};\n\n/**\n * @param {Buffer} - A buffer of the block header\n * @returns {BlockHeader} - An instance of block header\n */\nBlockHeader.fromBuffer = function fromBuffer(buf) {\n  var info = BlockHeader._fromBufferReader(BufferReader(buf));\n  return new BlockHeader(info);\n};\n\n/**\n * @param {string} - A hex encoded buffer of the block header\n * @returns {BlockHeader} - An instance of block header\n */\nBlockHeader.fromString = function fromString(str) {\n  var buf = Buffer.from(str, 'hex');\n  return BlockHeader.fromBuffer(buf);\n};\n\n/**\n * @param {BufferReader} - A BufferReader of the block header\n * @returns {Object} - An object representing block header data\n * @private\n */\nBlockHeader._fromBufferReader = function _fromBufferReader(br) {\n  var info = {};\n  info.version = br.readInt32LE();\n  info.prevHash = br.read(32);\n  info.merkleRoot = br.read(32);\n  info.time = br.readUInt32LE();\n  info.bits = br.readUInt32LE();\n  info.nonce = br.readUInt32LE();\n  return info;\n};\n\n/**\n * @param {BufferReader} - A BufferReader of the block header\n * @returns {BlockHeader} - An instance of block header\n */\nBlockHeader.fromBufferReader = function fromBufferReader(br) {\n  var info = BlockHeader._fromBufferReader(br);\n  return new BlockHeader(info);\n};\n\n/**\n * @returns {Object} - A plain object of the BlockHeader\n */\nBlockHeader.prototype.toObject = BlockHeader.prototype.toJSON = function toObject() {\n  return {\n    hash: this.hash,\n    version: this.version,\n    prevHash: BufferUtil.reverse(this.prevHash).toString('hex'),\n    merkleRoot: BufferUtil.reverse(this.merkleRoot).toString('hex'),\n    time: this.time,\n    bits: this.bits,\n    nonce: this.nonce\n  };\n};\n\n/**\n * @returns {Buffer} - A Buffer of the BlockHeader\n */\nBlockHeader.prototype.toBuffer = function toBuffer() {\n  return this.toBufferWriter().concat();\n};\n\n/**\n * @returns {string} - A hex encoded string of the BlockHeader\n */\nBlockHeader.prototype.toString = function toString() {\n  return this.toBuffer().toString('hex');\n};\n\n/**\n * @param {BufferWriter} - An existing instance BufferWriter\n * @returns {BufferWriter} - An instance of BufferWriter representation of the BlockHeader\n */\nBlockHeader.prototype.toBufferWriter = function toBufferWriter(bw) {\n  if (!bw) {\n    bw = new BufferWriter();\n  }\n  bw.writeInt32LE(this.version);\n  bw.write(this.prevHash);\n  bw.write(this.merkleRoot);\n  bw.writeUInt32LE(this.time);\n  bw.writeUInt32LE(this.bits);\n  bw.writeUInt32LE(this.nonce);\n  return bw;\n};\n\n/**\n * Returns the target difficulty for this block\n * @param {Number} bits\n * @returns {BN} An instance of BN with the decoded difficulty bits\n */\nBlockHeader.prototype.getTargetDifficulty = function getTargetDifficulty(bits) {\n  bits = bits || this.bits;\n\n  var target = new BN(bits & 0xffffff);\n  var mov = 8 * ((bits >>> 24) - 3);\n  while (mov-- > 0) {\n    target = target.mul(new BN(2));\n  }\n  return target;\n};\n\n/**\n * @link https://en.bitcoin.it/wiki/Difficulty\n * @return {Number}\n */\nBlockHeader.prototype.getDifficulty = function getDifficulty() {\n  var difficulty1TargetBN = this.getTargetDifficulty(GENESIS_BITS).mul(new BN(Math.pow(10, 8)));\n  var currentTargetBN = this.getTargetDifficulty();\n\n  var difficultyString = difficulty1TargetBN.div(currentTargetBN).toString(10);\n  var decimalPos = difficultyString.length - 8;\n  difficultyString = difficultyString.slice(0, decimalPos) + '.' + difficultyString.slice(decimalPos);\n\n  return parseFloat(difficultyString);\n};\n\n/**\n * @returns {Buffer} - The little endian hash buffer of the header\n */\nBlockHeader.prototype._getHash = function hash() {\n  var buf = this.toBuffer();\n  return Hash.sha256sha256(buf);\n};\n\nvar idProperty = {\n  configurable: false,\n  enumerable: true,\n  /**\n   * @returns {string} - The big endian hash buffer of the header\n   */\n  get: function() {\n    if (!this._id) {\n      this._id = BufferReader(this._getHash()).readReverse().toString('hex');\n    }\n    return this._id;\n  },\n  set: _.noop\n};\nObject.defineProperty(BlockHeader.prototype, 'id', idProperty);\nObject.defineProperty(BlockHeader.prototype, 'hash', idProperty);\n\n/**\n * @returns {Boolean} - If timestamp is not too far in the future\n */\nBlockHeader.prototype.validTimestamp = function validTimestamp() {\n  var currentTime = Math.round(new Date().getTime() / 1000);\n  if (this.time > currentTime + BlockHeader.Constants.MAX_TIME_OFFSET) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * @returns {Boolean} - If the proof-of-work hash satisfies the target difficulty\n */\nBlockHeader.prototype.validProofOfWork = function validProofOfWork() {\n  var pow = new BN(this.id, 'hex');\n  var target = this.getTargetDifficulty();\n\n  if (pow.cmp(target) > 0) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * @returns {string} - A string formatted for the console\n */\nBlockHeader.prototype.inspect = function inspect() {\n  return '<BlockHeader ' + this.id + '>';\n};\n\nBlockHeader.Constants = {\n  START_OF_HEADER: 8, // Start buffer position in raw block data\n  MAX_TIME_OFFSET: 2 * 60 * 60, // The max a timestamp can be in the future\n  LARGEST_HASH: new BN('10000000000000000000000000000000000000000000000000000000000000000', 'hex')\n};\n\nmodule.exports = BlockHeader;\n","module.exports = require('./block');\n\nmodule.exports.BlockHeader = require('./blockheader');\nmodule.exports.MerkleBlock = require('./merkleblock');\n","'use strict';\n\nvar _ = require('lodash');\nvar BlockHeader = require('./blockheader');\nvar BufferUtil = require('../util/buffer');\nvar BufferReader = require('../encoding/bufferreader');\nvar BufferWriter = require('../encoding/bufferwriter');\nvar Hash = require('../crypto/hash');\nvar JSUtil = require('../util/js');\nvar Transaction = require('../transaction');\nvar errors = require('../errors');\nvar $ = require('../util/preconditions');\n\n/**\n * Instantiate a MerkleBlock from a Buffer, JSON object, or Object with\n * the properties of the Block\n *\n * @param {*} - A Buffer, JSON string, or Object representing a MerkleBlock\n * @returns {MerkleBlock}\n * @constructor\n */\nfunction MerkleBlock(arg) {\n  /* jshint maxstatements: 18 */\n\n  if (!(this instanceof MerkleBlock)) {\n    return new MerkleBlock(arg);\n  }\n\n  var info = {};\n  if (BufferUtil.isBuffer(arg)) {\n    info = MerkleBlock._fromBufferReader(BufferReader(arg));\n  } else if (_.isObject(arg)) {\n    var header;\n    if(arg.header instanceof BlockHeader) {\n      header = arg.header;\n    } else {\n      header = BlockHeader.fromObject(arg.header);\n    }\n    info = {\n      /**\n       * @name MerkleBlock#header\n       * @type {BlockHeader}\n       */\n      header: header,\n      /**\n       * @name MerkleBlock#numTransactions\n       * @type {Number}\n       */\n      numTransactions: arg.numTransactions,\n      /**\n       * @name MerkleBlock#hashes\n       * @type {String[]}\n       */\n      hashes: arg.hashes,\n      /**\n       * @name MerkleBlock#flags\n       * @type {Number[]}\n       */\n      flags: arg.flags\n    };\n  } else {\n    throw new TypeError('Unrecognized argument for MerkleBlock');\n  }\n  _.extend(this,info);\n  this._flagBitsUsed = 0;\n  this._hashesUsed = 0;\n\n  return this;\n}\n\n/**\n * @param {Buffer} - MerkleBlock data in a Buffer object\n * @returns {MerkleBlock} - A MerkleBlock object\n */\nMerkleBlock.fromBuffer = function fromBuffer(buf) {\n  return MerkleBlock.fromBufferReader(BufferReader(buf));\n};\n\n/**\n * @param {BufferReader} - MerkleBlock data in a BufferReader object\n * @returns {MerkleBlock} - A MerkleBlock object\n */\nMerkleBlock.fromBufferReader = function fromBufferReader(br) {\n  return new MerkleBlock(MerkleBlock._fromBufferReader(br));\n};\n\n/**\n * @returns {Buffer} - A buffer of the block\n */\nMerkleBlock.prototype.toBuffer = function toBuffer() {\n  return this.toBufferWriter().concat();\n};\n\n/**\n * @param {BufferWriter} - An existing instance of BufferWriter\n * @returns {BufferWriter} - An instance of BufferWriter representation of the MerkleBlock\n */\nMerkleBlock.prototype.toBufferWriter = function toBufferWriter(bw) {\n  if (!bw) {\n    bw = new BufferWriter();\n  }\n  bw.write(this.header.toBuffer());\n  bw.writeUInt32LE(this.numTransactions);\n  bw.writeVarintNum(this.hashes.length);\n  for (var i = 0; i < this.hashes.length; i++) {\n    bw.write(Buffer.from(this.hashes[i], 'hex'));\n  }\n  bw.writeVarintNum(this.flags.length);\n  for (i = 0; i < this.flags.length; i++) {\n    bw.writeUInt8(this.flags[i]);\n  }\n  return bw;\n};\n\n/**\n * @returns {Object} - A plain object with the MerkleBlock properties\n */\nMerkleBlock.prototype.toObject = MerkleBlock.prototype.toJSON = function toObject() {\n  return {\n    header: this.header.toObject(),\n    numTransactions: this.numTransactions,\n    hashes: this.hashes,\n    flags: this.flags\n  };\n};\n\n/**\n * Verify that the MerkleBlock is valid\n * @returns {Boolean} - True/False whether this MerkleBlock is Valid\n */\nMerkleBlock.prototype.validMerkleTree = function validMerkleTree() {\n  $.checkState(_.isArray(this.flags), 'MerkleBlock flags is not an array');\n  $.checkState(_.isArray(this.hashes), 'MerkleBlock hashes is not an array');\n\n  // Can't have more hashes than numTransactions\n  if(this.hashes.length > this.numTransactions) {\n    return false;\n  }\n\n  // Can't have more flag bits than num hashes\n  if(this.flags.length * 8 < this.hashes.length) {\n    return false;\n  }\n\n  var height = this._calcTreeHeight();\n  var opts = { hashesUsed: 0, flagBitsUsed: 0 };\n  var root = this._traverseMerkleTree(height, 0, opts);\n  if(opts.hashesUsed !== this.hashes.length) {\n    return false;\n  }\n  return BufferUtil.equals(root, this.header.merkleRoot);\n};\n\n/**\n * Return a list of all the txs hash that match the filter\n * @returns {Array} - txs hash that match the filter\n */\nMerkleBlock.prototype.filterdTxsHash = function filterdTxsHash() {\n  $.checkState(_.isArray(this.flags), 'MerkleBlock flags is not an array');\n  $.checkState(_.isArray(this.hashes), 'MerkleBlock hashes is not an array');\n\n  // Can't have more hashes than numTransactions\n  if(this.hashes.length > this.numTransactions) {\n    throw new errors.MerkleBlock.InvalidMerkleTree();\n  }\n\n  // Can't have more flag bits than num hashes\n  if(this.flags.length * 8 < this.hashes.length) {\n    throw new errors.MerkleBlock.InvalidMerkleTree();\n  }\n\n  // If there is only one hash the filter do not match any txs in the block\n  if(this.hashes.length === 1) {\n    return [];\n  };\n\n  var height = this._calcTreeHeight();\n  var opts = { hashesUsed: 0, flagBitsUsed: 0 };\n  var txs = this._traverseMerkleTree(height, 0, opts, true);\n  if(opts.hashesUsed !== this.hashes.length) {\n    throw new errors.MerkleBlock.InvalidMerkleTree();\n  }\n  return txs;\n};\n\n/**\n * Traverse a the tree in this MerkleBlock, validating it along the way\n * Modeled after Bitcoin Core merkleblock.cpp TraverseAndExtract()\n * @param {Number} - depth - Current height\n * @param {Number} - pos - Current position in the tree\n * @param {Object} - opts - Object with values that need to be mutated throughout the traversal\n * @param {Boolean} - checkForTxs - if true return opts.txs else return the Merkle Hash\n * @param {Number} - opts.flagBitsUsed - Number of flag bits used, should start at 0\n * @param {Number} - opts.hashesUsed - Number of hashes used, should start at 0\n * @param {Array} - opts.txs - Will finish populated by transactions found during traversal that match the filter\n * @returns {Buffer|null} - Buffer containing the Merkle Hash for that height\n * @returns {Array} - transactions found during traversal that match the filter\n * @private\n */\nMerkleBlock.prototype._traverseMerkleTree = function traverseMerkleTree(depth, pos, opts, checkForTxs) {\n  /* jshint maxcomplexity:  12*/\n  /* jshint maxstatements: 20 */\n\n  opts = opts || {};\n  opts.txs = opts.txs || [];\n  opts.flagBitsUsed = opts.flagBitsUsed || 0;\n  opts.hashesUsed = opts.hashesUsed || 0;\n  var checkForTxs = checkForTxs || false;\n\n  if(opts.flagBitsUsed > this.flags.length * 8) {\n    return null;\n  }\n  var isParentOfMatch = (this.flags[opts.flagBitsUsed >> 3] >>> (opts.flagBitsUsed++ & 7)) & 1;\n  if(depth === 0 || !isParentOfMatch) {\n    if(opts.hashesUsed >= this.hashes.length) {\n      return null;\n    }\n    var hash = this.hashes[opts.hashesUsed++];\n    if(depth === 0 && isParentOfMatch) {\n      opts.txs.push(hash);\n    }\n    return Buffer.from(hash, 'hex');\n  } else {\n    var left = this._traverseMerkleTree(depth-1, pos*2, opts);\n    var right = left;\n    if(pos*2+1 < this._calcTreeWidth(depth-1)) {\n      right = this._traverseMerkleTree(depth-1, pos*2+1, opts);\n    }\n    if (checkForTxs){\n      return opts.txs;\n    } else {\n      return Hash.sha256sha256(new Buffer.concat([left, right]));\n    };\n  }\n};\n\n/** Calculates the width of a merkle tree at a given height.\n *  Modeled after Bitcoin Core merkleblock.h CalcTreeWidth()\n * @param {Number} - Height at which we want the tree width\n * @returns {Number} - Width of the tree at a given height\n * @private\n */\nMerkleBlock.prototype._calcTreeWidth = function calcTreeWidth(height) {\n  return (this.numTransactions + (1 << height) - 1) >> height;\n};\n\n/** Calculates the height of the merkle tree in this MerkleBlock\n * @param {Number} - Height at which we want the tree width\n * @returns {Number} - Height of the merkle tree in this MerkleBlock\n * @private\n */\nMerkleBlock.prototype._calcTreeHeight = function calcTreeHeight() {\n  var height = 0;\n  while (this._calcTreeWidth(height) > 1) {\n    height++;\n  }\n  return height;\n};\n\n/**\n * @param {Transaction|String} - Transaction or Transaction ID Hash\n * @returns {Boolean} - return true/false if this MerkleBlock has the TX or not\n * @private\n */\nMerkleBlock.prototype.hasTransaction = function hasTransaction(tx) {\n  $.checkArgument(!_.isUndefined(tx), 'tx cannot be undefined');\n  $.checkArgument(tx instanceof Transaction || typeof tx === 'string',\n      'Invalid tx given, tx must be a \"string\" or \"Transaction\"');\n\n  var hash = tx;\n  if(tx instanceof Transaction) {\n    // We need to reverse the id hash for the lookup\n    hash = BufferUtil.reverse(Buffer.from(tx.id, 'hex')).toString('hex');\n  }\n\n  var txs = [];\n  var height = this._calcTreeHeight();\n  this._traverseMerkleTree(height, 0, { txs: txs });\n  return txs.indexOf(hash) !== -1;\n};\n\n/**\n * @param {Buffer} - MerkleBlock data\n * @returns {Object} - An Object representing merkleblock data\n * @private\n */\nMerkleBlock._fromBufferReader = function _fromBufferReader(br) {\n  $.checkState(!br.finished(), 'No merkleblock data received');\n  var info = {};\n  info.header = BlockHeader.fromBufferReader(br);\n  info.numTransactions = br.readUInt32LE();\n  var numHashes = br.readVarintNum();\n  info.hashes = [];\n  for (var i = 0; i < numHashes; i++) {\n    info.hashes.push(br.read(32).toString('hex'));\n  }\n  var numFlags = br.readVarintNum();\n  info.flags = [];\n  for (i = 0; i < numFlags; i++) {\n    info.flags.push(br.readUInt8());\n  }\n  return info;\n};\n\n/**\n * @param {Object} - A plain JavaScript object\n * @returns {Block} - An instance of block\n */\nMerkleBlock.fromObject = function fromObject(obj) {\n  return new MerkleBlock(obj);\n};\n\nmodule.exports = MerkleBlock;\n","'use strict';\n\nvar BN = require('bn.js');\nvar $ = require('../util/preconditions');\nvar _ = require('lodash');\nconst BufferUtil = require('../util/buffer');\n\nvar reversebuf = function(buf) {\n  var buf2 = Buffer.alloc(buf.length);\n  for (var i = 0; i < buf.length; i++) {\n    buf2[i] = buf[buf.length - 1 - i];\n  }\n  return buf2;\n};\n\nBN.Zero = new BN(0);\nBN.One = new BN(1);\nBN.Minus1 = new BN(-1);\n\nBN.fromNumber = function(n) {\n  $.checkArgument(_.isNumber(n));\n  return new BN(n);\n};\n\nBN.fromString = function(str, base) {\n  $.checkArgument(_.isString(str));\n  return new BN(str, base);\n};\n\nBN.fromBuffer = function(buf, opts) {\n  $.checkArgument(BufferUtil.isBuffer(buf), 'first argument should be a buffer');\n  buf = Buffer.from(buf); // ensure Uint8Array is converted to Buffer\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\n    buf = reversebuf(buf);\n  }\n  var hex = buf.toString('hex');\n  var bn = new BN(hex, 16);\n  return bn;\n};\n\n/**\n * Instantiate a BigNumber from a \"signed magnitude buffer\"\n * (a buffer where the most significant bit represents the sign (0 = positive, -1 = negative))\n */\nBN.fromSM = function(buf, opts) {\n  var ret;\n  if (buf.length === 0) {\n    return BN.fromBuffer(Buffer.from([0]));\n  }\n\n  var endian = 'big';\n  if (opts) {\n    endian = opts.endian;\n  }\n  if (endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  if (buf[0] & 0x80) {\n    buf[0] = buf[0] & 0x7f;\n    ret = BN.fromBuffer(buf);\n    ret.neg().copy(ret);\n  } else {\n    ret = BN.fromBuffer(buf);\n  }\n  return ret;\n};\n\n\nBN.prototype.toNumber = function() {\n  return parseInt(this.toString(10), 10);\n};\n\nBN.prototype.toBuffer = function(opts) {\n  var buf, hex;\n  if (opts && opts.size) {\n    hex = this.toString(16, 2);\n    var natlen = hex.length / 2;\n    buf = Buffer.from(hex, 'hex');\n\n    if (natlen === opts.size) {\n      buf = buf;\n    } else if (natlen > opts.size) {\n      buf = BN.trim(buf, natlen);\n    } else if (natlen < opts.size) {\n      buf = BN.pad(buf, natlen, opts.size);\n    }\n  } else {\n    hex = this.toString(16, 2);\n    buf = Buffer.from(hex, 'hex');\n  }\n\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  return buf;\n};\n\nBN.prototype.toSMBigEndian = function() {\n  var buf;\n  if (this.cmp(BN.Zero) === -1) {\n    buf = this.neg().toBuffer();\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([Buffer.from([0x80]), buf]);\n    } else {\n      buf[0] = buf[0] | 0x80;\n    }\n  } else {\n    buf = this.toBuffer();\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([Buffer.from([0x00]), buf]);\n    }\n  }\n\n  if (buf.length === 1 & buf[0] === 0) {\n    buf = Buffer.from([]);\n  }\n  return buf;\n};\n\nBN.prototype.toSM = function(opts) {\n  var endian = opts ? opts.endian : 'big';\n  var buf = this.toSMBigEndian();\n\n  if (endian === 'little') {\n    buf = reversebuf(buf);\n  }\n  return buf;\n};\n\n/**\n * Create a BN from a \"ScriptNum\":\n * This is analogous to the constructor for CScriptNum in bitcoind. Many ops in\n * bitcoind's script interpreter use CScriptNum, which is not really a proper\n * bignum. Instead, an error is thrown if trying to input a number bigger than\n * 4 bytes. We copy that behavior here. A third argument, `size`, is provided to\n * extend the hard limit of 4 bytes, as some usages require more than 4 bytes.\n */\nBN.fromScriptNumBuffer = function(buf, fRequireMinimal, size) {\n  var nMaxNumSize = size || 4;\n  $.checkArgument(buf.length <= nMaxNumSize, new Error('script number overflow'));\n  if (fRequireMinimal && buf.length > 0) {\n    // Check that the number is encoded with the minimum possible\n    // number of bytes.\n    //\n    // If the most-significant-byte - excluding the sign bit - is zero\n    // then we're not minimal. Note how this test also rejects the\n    // negative-zero encoding, 0x80.\n    if ((buf[buf.length - 1] & 0x7f) === 0) {\n      // One exception: if there's more than one byte and the most\n      // significant bit of the second-most-significant-byte is set\n      // it would conflict with the sign bit. An example of this case\n      // is +-255, which encode to 0xff00 and 0xff80 respectively.\n      // (big-endian).\n      if (buf.length <= 1 || (buf[buf.length - 2] & 0x80) === 0) {\n        throw new Error('non-minimally encoded script number');\n      }\n    }\n  }\n  return BN.fromSM(buf, {\n    endian: 'little'\n  });\n};\n\n/**\n * The corollary to the above, with the notable exception that we do not throw\n * an error if the output is larger than four bytes. (Which can happen if\n * performing a numerical operation that results in an overflow to more than 4\n * bytes).\n */\nBN.prototype.toScriptNumBuffer = function() {\n  return this.toSM({\n    endian: 'little'\n  });\n};\n\nBN.trim = function(buf, natlen) {\n  return buf.slice(natlen - buf.length, buf.length);\n};\n\nBN.pad = function(buf, natlen, size) {\n  var rbuf = Buffer.alloc(size);\n  for (var i = 0; i < buf.length; i++) {\n    rbuf[rbuf.length - 1 - i] = buf[buf.length - 1 - i];\n  }\n  for (i = 0; i < size - natlen; i++) {\n    rbuf[i] = 0;\n  }\n  return rbuf;\n};\n\nmodule.exports = BN;\n","'use strict';\n\nconst BN = require('./bn');\nconst Point = require('./point');\nconst Signature = require('./signature');\nconst PublicKey = require('../publickey');\nconst Random = require('./random');\nconst Hash = require('./hash');\nconst BufferUtil = require('../util/buffer');\nconst $ = require('../util/preconditions');\n\n\n/**\n * Attach the recovery factor i to an ECDSA signature.\n * @param {Buffer} hashbuf\n * @param {Signature} sig\n * @param {PulicKey} pubkey\n * @returns {Signature}\n */\nconst calci = function(hashbuf, sig, pubkey) {\n  for (var i = 0; i < 4; i++) {\n    var Qprime;\n    try {\n      Qprime = getPublicKey(hashbuf, sig, i);\n    } catch (e) {\n      console.error(e);\n      continue;\n    }\n\n    if (Qprime.point.eq(pubkey.point)) {\n      sig.i = i;\n      sig.compressed = pubkey.compressed;\n      return sig;\n    }\n  }\n\n  throw new Error('Unable to find valid recovery factor');\n};\n\n/**\n * Information about public key recovery:\n * https://bitcointalk.org/index.php?topic=6430.0\n * http://stackoverflow.com/questions/19665491/how-do-i-get-an-ecdsa-public-key-from-just-a-bitcoin-signature-sec1-4-1-6-k \n * @param {Buffer} hashbuf\n * @param {Signature} sig\n * @param {Number} i\n * @returns {PublicKey}\n */\nconst getPublicKey = function(hashbuf, sig, i) {\n  /* jshint maxstatements: 25 */\n  $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be equal to 0, 1, 2, or 3'));\n\n  var e = BN.fromBuffer(hashbuf);\n  var r = sig.r;\n  var s = sig.s;\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = i & 1;\n\n  // The more significant bit specifies whether we should use the\n  // first or second candidate key.\n  var isSecondKey = i >> 1;\n\n  var n = Point.getN();\n  var G = Point.getG();\n\n  // 1.1 Let x = r + jn\n  var x = isSecondKey ? r.add(n) : r;\n  var R = Point.fromX(isYOdd, x);\n\n  // 1.4 Check that nR is at infinity\n  var nR = R.mul(n);\n\n  if (!nR.isInfinity()) {\n    throw new Error('nR is not a valid curve point');\n  }\n\n  // Compute -e from e\n  var eNeg = e.neg().umod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR - eG)\n  // Q = r^-1 (sR + -eG)\n  var rInv = r.invm(n);\n\n  //var Q = R.multiplyTwo(s, G, eNeg).mul(rInv);\n  var Q = R.mul(s).add(G.mul(eNeg)).mul(rInv);\n\n  var pubkey = PublicKey.fromPoint(Q, sig.compressed);\n\n  return pubkey;\n};\n\n\n/**\n * Recover a public key from a signature.\n * @param {Buffer} hashbuf\n * @param {Signature} sig Signature with the recovery factor i.\n * @returns {PublicKey}\n */\nconst recoverPublicKey = function(hashbuf, sig) {\n  return getPublicKey(hashbuf, sig, sig.i);\n};\n\n\n/**\n * Generate a random k\n * @returns {BN}\n */\nconst getRandomK = function() {\n  var N = Point.getN();\n  var k;\n  do {\n    k = BN.fromBuffer(Random.getRandomBuffer(32));\n  } while (!(k.lt(N) && k.gt(BN.Zero)));\n  return k;\n};\n\n\n/**\n * Generate a deterministic k\n * REF: https://tools.ietf.org/html/rfc6979#section-3.2\n * @param {Buffer} hashbuf\n * @param {PrivateKey} privkey\n * @param {Number} badrs Increment until a valid k is found\n * @returns {BN}\n */\nconst getDeterministicK = function(hashbuf, privkey, badrs) {\n  /* jshint maxstatements: 25 */\n  // if r or s were invalid when this function was used in signing,\n  // we do not want to actually compute r, s here for efficiency, so,\n  // we can increment badrs. explained at end of RFC 6979 section 3.2\n  if (!badrs) {\n    badrs = 0;\n  }\n  var v = Buffer.alloc(32);\n  v.fill(0x01);\n  var k = Buffer.alloc(32);\n  k.fill(0x00);\n  var x = privkey.bn.toBuffer({\n    size: 32\n  });\n  k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x00]), x, hashbuf]), k);\n  v = Hash.sha256hmac(v, k);\n  k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x01]), x, hashbuf]), k);\n  // double hash v\n  v = Hash.sha256hmac(v, k);\n  v = Hash.sha256hmac(v, k);\n  var T = BN.fromBuffer(v);\n  var N = Point.getN();\n\n  // also explained in 3.2, we must ensure T is in the proper range (0, N)\n  for (var i = 0; i < badrs || !(T.lt(N) && T.gt(BN.Zero)); i++) {\n    k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0x00])]), k);\n    // double hash v\n    v = Hash.sha256hmac(v, k);\n    v = Hash.sha256hmac(v, k);\n    T = BN.fromBuffer(v);\n  }\n\n  return T;\n};\n\n\n/**\n * Convert s to a low s\n * see BIP 62, \"low S values in signatures\"\n * @param {BN} s\n * @returns {BN}\n */\nconst toLowS = function(s) {\n  if (s.gt(new BN('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex'))) {\n    s = Point.getN().sub(s);\n  }\n  return s;\n};\n\n\n/**\n * Sign a hash with a private key.\n * @param {Buffer|Uint8Array} hashbuf\n * @param {PrivateKey} privkey\n * @param {Object|undefined} opts An object of optional parameters\n * @param {String} opts.endian 'big' or 'little' (default: big)\n * @param {Boolean} opts.randomK Use a random value for k - produces a non-deterministic signature (default: false)\n * @returns {Signature}\n */\nconst sign = function(hashbuf, privkey, opts) {\n  const { endian = 'big', randomK = false } = opts || {};\n  $.checkState(BufferUtil.isBuffer(hashbuf) && hashbuf.length === 32, 'hashbuf must be a 32 byte buffer');\n  $.checkState(privkey && privkey.bn, 'privkey must be a PrivateKey');\n  \n  var d = privkey.bn;\n  hashbuf = Buffer.from(hashbuf);\n  if (endian === 'little') {\n    hashbuf.reverse();\n  }\n\n  var e = BN.fromBuffer(hashbuf);\n  var N = Point.getN();\n  var G = Point.getG();\n  // try different values of k until r, s are valid\n  var badrs = 0;\n  var k, Q, r, s;\n  do {\n    k = randomK ? getRandomK() : getDeterministicK(hashbuf, privkey, badrs);\n    badrs++;\n    Q = G.mul(k);\n    r = Q.x.umod(N);\n    s = k.invm(N).mul(e.add(d.mul(r))).umod(N);\n  } while (r.cmp(BN.Zero) <= 0 || s.cmp(BN.Zero) <= 0);\n\n  s = toLowS(s);\n\n  return new Signature({\n    s,\n    r,\n    compressed: privkey.publicKey.compressed\n  });\n};\n\n\n/**\n * Get signature verification error string\n * @param {Buffer} hashbuf\n * @param {Signature} sig\n * @param {PublicKey} pubkey\n * @param {Object|undefined} opts An object of optional parameters\n * @param {String} opts.endian 'big' or 'little' (default: big)\n * @returns {String|undefined} Returns an error string, or undefined if there is no error\n */\nconst verificationError = function(hashbuf, sig, pubkey, opts) {\n  const { endian = 'big' } = opts || {};\n\n  if (!BufferUtil.isBuffer(hashbuf) || hashbuf.length !== 32) {\n    return 'hashbuf must be a 32 byte buffer';\n  }\n\n  var r = sig.r;\n  var s = sig.s;\n  if (!(r.gt(BN.Zero) && r.lt(Point.getN())) || !(s.gt(BN.Zero) && s.lt(Point.getN()))) {\n    return 'r and s not in range';\n  }\n\n  var e = BN.fromBuffer(hashbuf, { endian });\n  var n = Point.getN();\n  var sinv = s.invm(n);\n  var u1 = sinv.mul(e).umod(n);\n  var u2 = sinv.mul(r).umod(n);\n\n  var p = Point.getG().mulAdd(u1, pubkey.point, u2);\n  if (p.isInfinity()) {\n    return 'p is infinity';\n  }\n\n  if (p.getX().umod(n).cmp(r) !== 0) {\n    return 'Invalid signature';\n  }\n\n  return; // no error\n};\n\n\n/**\n * Verify a signature\n * @param {Buffer} hashbuf\n * @param {Signature} sig\n * @param {PublicKey} pubkey\n * @param {Object|undefined} opts An object of optional parameters\n * @param {String} opts.endian 'big' or 'little' (default: big)\n * @returns {Boolean}\n */\nconst verify = function(hashbuf, sig, pubkey, opts) {\n  if (!pubkey) {\n    throw new Error('pubkey required for signature verification');\n  }\n  pubkey = new PublicKey(pubkey);\n  \n  if (!sig) {\n    throw new Error('signature required for verification');\n  }\n  sig = new Signature(sig);\n\n  return !verificationError(hashbuf, sig, pubkey, opts);\n};\n\nmodule.exports = {\n  sign,\n  verify,\n  verificationError,\n \n  // pubkey recovery methods\n  calci,\n  recoverPublicKey,\n};\n\nmodule.exports.__testing__ = {\n  getDeterministicK,\n  getPublicKey,\n  getRandomK,\n  toLowS,\n};\n\n","'use strict';\n\nvar crypto = require('crypto');\nvar BufferUtil = require('../util/buffer');\nvar $ = require('../util/preconditions');\n\nvar Hash = module.exports;\n\nHash.sha1 = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return crypto.createHash('sha1').update(buf).digest();\n};\n\nHash.sha1.blocksize = 512;\n\nHash.sha256 = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return crypto.createHash('sha256').update(buf).digest();\n};\n\nHash.sha256.blocksize = 512;\n\nHash.sha256sha256 = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return Hash.sha256(Hash.sha256(buf));\n};\n\nHash.ripemd160 = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return crypto.createHash('ripemd160').update(buf).digest();\n};\n\nHash.sha256ripemd160 = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return Hash.ripemd160(Hash.sha256(buf));\n};\n\nHash.sha512 = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return crypto.createHash('sha512').update(buf).digest();\n};\n\nHash.sha512.blocksize = 1024;\n\nHash.hmac = function(hashf, data, key) {\n  //http://en.wikipedia.org/wiki/Hash-based_message_authentication_code\n  //http://tools.ietf.org/html/rfc4868#section-2\n  $.checkArgument(BufferUtil.isBuffer(data));\n  $.checkArgument(BufferUtil.isBuffer(key));\n  $.checkArgument(hashf.blocksize);\n\n  var blocksize = hashf.blocksize / 8;\n\n  if (key.length > blocksize) {\n    key = hashf(key);\n  } else if (key < blocksize) {\n    var fill = Buffer.alloc(blocksize);\n    fill.fill(0);\n    key.copy(fill);\n    key = fill;\n  }\n\n  var o_key = Buffer.alloc(blocksize);\n  o_key.fill(0x5c);\n\n  var i_key = Buffer.alloc(blocksize);\n  i_key.fill(0x36);\n\n  var o_key_pad = Buffer.alloc(blocksize);\n  var i_key_pad = Buffer.alloc(blocksize);\n  for (var i = 0; i < blocksize; i++) {\n    o_key_pad[i] = o_key[i] ^ key[i];\n    i_key_pad[i] = i_key[i] ^ key[i];\n  }\n\n  return hashf(Buffer.concat([o_key_pad, hashf(Buffer.concat([i_key_pad, data]))]));\n};\n\nHash.sha256hmac = function(data, key) {\n  return Hash.hmac(Hash.sha256, data, key);\n};\n\nHash.sha512hmac = function(data, key) {\n  return Hash.hmac(Hash.sha512, data, key);\n};\n","'use strict';\n\nvar BN = require('./bn');\nvar BufferUtil = require('../util/buffer');\n\nvar EC = require('elliptic').ec;\nvar ec = new EC('secp256k1');\nvar ecPoint = ec.curve.point.bind(ec.curve);\nvar ecPointFromX = ec.curve.pointFromX.bind(ec.curve);\n\n/**\n *\n * Instantiate a valid secp256k1 Point from the X and Y coordinates.\n *\n * @param {BN|String} x - The X coordinate\n * @param {BN|String} y - The Y coordinate\n * @link https://github.com/indutny/elliptic\n * @augments elliptic.curve.point\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of Point\n * @constructor\n */\nvar Point = function Point(x, y, isRed) {\n  try {\n    var point = ecPoint(x, y, isRed);\n  } catch (e) {\n    throw new Error('Invalid Point');\n  }\n  point.validate();\n  return point;\n};\n\nPoint.prototype = Object.getPrototypeOf(ec.curve.point());\n\n/**\n *\n * Instantiate a valid secp256k1 Point from only the X coordinate\n *\n * @param {boolean} odd - If the Y coordinate is odd\n * @param {BN|String} x - The X coordinate\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of Point\n */\nPoint.fromX = function fromX(odd, x){\n  try {\n    var point = ecPointFromX(x, odd);\n  } catch (e) {\n    throw new Error('Invalid X');\n  }\n  point.validate();\n  return point;\n};\n\n/**\n *\n * Will return a secp256k1 ECDSA base point.\n *\n * @link https://en.bitcoin.it/wiki/Secp256k1\n * @returns {Point} An instance of the base point.\n */\nPoint.getG = function getG() {\n  return ec.curve.g;\n};\n\n/**\n *\n * Will return the max of range of valid private keys as governed by the secp256k1 ECDSA standard.\n * (A.K.A curve order)\n * @link https://en.bitcoin.it/wiki/Private_key#Range_of_valid_ECDSA_private_keys\n * @returns {BN} A BN instance of the number of points on the curve\n */\nPoint.getN = function getN() {\n  return new BN(ec.curve.n.toArray());\n};\n\n/**\n * Secp256k1 field size\n * @returns {BN} A BN instance of the field size\n */\nPoint.getP = function() {\n  return ec.curve.p.clone();\n};\n\nPoint.prototype._getX = Point.prototype.getX;\n\n/**\n *\n * Will return the X coordinate of the Point\n *\n * @returns {BN} A BN instance of the X coordinate\n */\nPoint.prototype.getX = function getX() {\n  return new BN(this._getX().toArray());\n};\n\nPoint.prototype._getY = Point.prototype.getY;\n\n/**\n *\n * Will return the Y coordinate of the Point\n *\n * @returns {BN} A BN instance of the Y coordinate\n */\nPoint.prototype.getY = function getY() {\n  return new BN(this._getY().toArray());\n};\n\n/**\n *\n * Will determine if the point is valid\n *\n * @link https://www.iacr.org/archive/pkc2003/25670211/25670211.pdf\n * @param {Point} An instance of Point\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of the same Point\n */\nPoint.prototype.validate = function validate() {\n\n  if (this.isInfinity()){\n    throw new Error('Point cannot be equal to Infinity');\n  }\n\n  var p2;\n  try {\n    p2 = ecPointFromX(this.getX(), this.getY().isOdd());\n  } catch (e) {\n    throw new Error('Point does not lie on the curve');\n  }\n\n  if (p2.y.cmp(this.y) !== 0) {\n    throw new Error('Invalid y value for curve.');\n  }\n\n\n  //todo: needs test case\n  if (!(this.mul(Point.getN()).isInfinity())) {\n    throw new Error('Point times N must be infinity');\n  }\n\n  return this;\n\n};\n\nPoint.pointToCompressed = function pointToCompressed(point) {\n  var xbuf = point.getX().toBuffer({size: 32});\n  var ybuf = point.getY().toBuffer({size: 32});\n\n  var prefix;\n  var odd = ybuf[ybuf.length - 1] % 2;\n  if (odd) {\n    prefix = Buffer.from([0x03]);\n  } else {\n    prefix = Buffer.from([0x02]);\n  }\n  return BufferUtil.concat([prefix, xbuf]);\n};\n\n\nPoint.prototype.liftX = function() {\n  const fieldSize = Point.getP();\n  const zero = new BN(0);\n  const one = new BN(1);\n  const two = new BN(2);\n  const three = new BN(3);\n  const four = new BN(4);\n  const seven = new BN(7);\n  const red = BN.red('k256');\n\n  const c = this.x.pow(three).add(seven).mod(fieldSize);\n  const y = c.toRed(red).redPow(fieldSize.add(one).div(four)).mod(fieldSize);\n  \n  if (!c.eq(y.pow(two).mod(fieldSize))) {\n    throw new Error('liftX failed');\n  }\n  \n  const pointX = this.x.red ? this.x.fromRed() : this.x;\n  const pointY = y.mod(two).eq(zero) ? y.fromRed() : fieldSize.sub(y)\n  return new Point(pointX, pointY, true);\n};\n\nmodule.exports = Point;\n","'use strict';\n\nfunction Random() {\n}\n\n/* secure random bytes that sometimes throws an error due to lack of entropy */\nRandom.getRandomBuffer = function(size) {\n  if (process.browser)\n    return Random.getRandomBufferBrowser(size);\n  else\n    return Random.getRandomBufferNode(size);\n};\n\nRandom.getRandomBufferNode = function(size) {\n  var crypto = require('crypto');\n  return crypto.randomBytes(size);\n};\n\nRandom.getRandomBufferBrowser = function(size) {\n  if (!window.crypto && !window.msCrypto)\n    throw new Error('window.crypto not available');\n\n  if (window.crypto && window.crypto.getRandomValues)\n    var crypto = window.crypto;\n  else if (window.msCrypto && window.msCrypto.getRandomValues) //internet explorer\n    var crypto = window.msCrypto;\n  else\n    throw new Error('window.crypto.getRandomValues not available');\n\n  var bbuf = new Uint8Array(size);\n  crypto.getRandomValues(bbuf);\n  var buf = Buffer.from(bbuf);\n\n  return buf;\n};\n\n/* insecure random bytes, but it never fails */\nRandom.getPseudoRandomBuffer = function(size) {\n  var b32 = 0x100000000;\n  var b = Buffer.alloc(size);\n  var r;\n\n  for (var i = 0; i <= size; i++) {\n    var j = Math.floor(i / 4);\n    var k = i - j * 4;\n    if (k === 0) {\n      r = Math.random() * b32;\n      b[i] = r & 0xff;\n    } else {\n      b[i] = (r = r >>> 8) & 0xff;\n    }\n  }\n\n  return b;\n};\n\nmodule.exports = Random;\n","const crypto = require('crypto');\nconst $ = require('../util/preconditions');\nconst JS = require('../util/js');\nconst BN = require('./bn');\nconst Point = require('./point');\nconst TaggedHash = require('./taggedhash');\n\nconst Schnorr = function Schnorr() {\n  if (!(this instanceof Schnorr)) {\n    return new Schnorr();\n  }\n  return this;\n};\n\nSchnorr.prototype.set = function() {};\n\n/**\n * Create a schnorr signature\n * @param {PrivateKey|Buffer|BN} privateKey\n * @param {String|Buffer} message Hex string or buffer\n * @param {String|Buffer} aux Hex string or buffer\n * @returns {Buffer}\n * @link https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#Default_Signing\n */\nSchnorr.sign = function(privateKey, message, aux) {\n  privateKey = Buffer.isBuffer(privateKey) ? privateKey : privateKey.toBuffer();\n  if (privateKey.length !== 32) {\n    throw new Error('Private key should be 32 bytes for schnorr signatures');\n  }\n\n  if (typeof message === 'string') {\n    $.checkArgument(JS.isHexaString(message), 'Schnorr message string is not hex');\n    message = Buffer.from(message, 'hex')\n  }\n  $.checkArgument($.isType(message, 'Buffer'), 'Schnorr message must be a hex string or buffer');\n\n  if (!aux) {\n    aux = crypto.randomBytes(32);\n  }\n  if (typeof aux === 'string') {\n    $.checkArgument(JS.isHexaString(aux), 'Schnorr aux string is not hex');\n    aux = Buffer.from(aux, 'hex')\n  }\n  $.checkArgument($.isType(aux, 'Buffer'), 'Schnorr aux must be a hex string or buffer');\n\n  const G = Point.getG();\n  const n = Point.getN();\n\n  const dPrime = new BN(privateKey);\n  if (dPrime.eqn(0) || dPrime.gte(n)) {\n    throw new Error('Invalid private key for schnorr signing');\n  }\n  const P = G.mul(dPrime);\n  const Pbuf = Buffer.from(P.encodeCompressed().slice(1)); // slice(1) removes the encoding prefix byte\n  const d = P.y.isEven() ? dPrime : n.sub(dPrime);\n  const t = d.xor(new BN(new TaggedHash('BIP0340/aux', aux).finalize()));\n  const rand = new TaggedHash('BIP0340/nonce', Buffer.concat([t.toBuffer(), Pbuf, message])).finalize();\n  const kPrime = new BN(rand).mod(n);\n  if (kPrime.eqn(0)) {\n    throw new Error('Error creating schnorr signature');\n  }\n  const R = G.mul(kPrime);\n  const Rbuf = Buffer.from(R.encodeCompressed().slice(1)); // slice(1) removes the encoding prefix byte\n  const k = R.y.isEven() ? kPrime : n.sub(kPrime);\n  const e = new BN(new TaggedHash('BIP0340/challenge', Buffer.concat([Rbuf, Pbuf, message])).finalize()).mod(n);\n  const sig = Buffer.concat([Rbuf, k.add(e.mul(d)).mod(n).toBuffer({ size: 32 })]);\n\n  if (!Schnorr.verify(Pbuf, message, sig)) {\n    throw new Error('Error creating schnorr signature. Verification failed');\n  }\n  return sig;\n};\n\n\n/**\n * Verify a schnorr signature\n * @param {PublicKey|Buffer} publicKey\n * @param {String|Buffer} message Hex string or buffer\n * @param {String|Signature|Buffer} signature Hex string, Signature instance, or buffer\n * @returns {Boolean}\n * @link https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#Verification\n */\nSchnorr.verify = function(publicKey, message, signature) {\n  if ($.isType(publicKey, 'PublicKey')) {\n    publicKey = publicKey.point.x.toBuffer();\n  }\n  if (publicKey.length !== 32) {\n    throw new Error('Public key should be 32 bytes for schnorr signatures');\n  }\n\n  if (typeof message === 'string') {\n    $.checkArgument(JS.isHexaString(message), 'Schnorr message string is not hex');\n    message = Buffer.from(message, 'hex');\n  }\n  if (message.length !== 32) {\n    throw new Error('Message should be a 32 byte buffer');\n  }\n\n  if (typeof signature === 'string') {\n    $.checkArgument(JS.isHexaString(signature), 'Schnorr signature string is not hex');\n    signature = Buffer.from(signature, 'hex');\n  }\n  if (typeof signature.toBuffer === 'function') {\n    signature = signature.toBuffer();\n    if (signature.length === 65) {\n      signature = signature.slice(0, 64); // remove the sighashType byte\n    }\n  }\n  if (signature.length !== 64) {\n    throw new Error('Signature should be a 64 byte buffer. Got ' + signature.length + ' bytes');\n  }\n\n  try {\n    const p = Point.getP();\n    const n = Point.getN();\n\n    const P = Point.fromX(false, publicKey).liftX();\n    const r = new BN(signature.slice(0, 32));\n    const s = new BN(signature.slice(32, 64));\n    if (r.gte(p) || s.gte(n)) {\n      return false;\n    }\n    const e = getE(r, P, message);\n    const G = Point.getG();\n    const R = G.mul(s).add(P.mul(e).neg());\n    if (R.inf || !R.y.isEven() || !R.x.eq(r)) {\n      return false;\n    }\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\n/* Utility function used in Verify() */\nconst getE = function(r, P, message) {\n  const n = Point.getN();\n  const hash = new TaggedHash('BIP0340/challenge', Buffer.concat([r.toBuffer({ size: 32 }), P.x.toBuffer({ size: 32 }), message])).finalize();\n  return new BN(hash).mod(n);\n};\n\nmodule.exports = Schnorr;\n","'use strict';\n\nvar BN = require('./bn');\nvar _ = require('lodash');\nvar $ = require('../util/preconditions');\nvar BufferUtil = require('../util/buffer');\nvar JSUtil = require('../util/js');\n\nvar Signature = function Signature(r, s, isSchnorr) {\n  if (!(this instanceof Signature)) {\n    return new Signature(r, s, isSchnorr);\n  }\n  if (r instanceof BN) {\n    this.set({\n      r: r,\n      s: s,\n      isSchnorr: isSchnorr\n    });\n  } else if (r) {\n    var obj = r;\n    this.set(obj);\n  }\n};\n\n/* jshint maxcomplexity: 7 */\nSignature.prototype.set = function(obj) {\n  this.r = obj.r || this.r || undefined;\n  this.s = obj.s || this.s || undefined;\n\n  // public key recovery parameter in range [0, 3]\n  this.i = typeof obj.i === 'undefined' ? this.i : obj.i;\n  // whether the recovered pubkey is compressed\n  this.compressed = typeof obj.compressed === 'undefined' ? this.compressed : obj.compressed;\n  this.isSchnorr = typeof obj.isSchnorr === 'undefined' ? this.isSchnorr : obj.isSchnorr;\n  this.nhashtype = obj.nhashtype || this.nhashtype || undefined;\n  return this;\n};\n\nSignature.fromCompact = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf), 'Argument is expected to be a Buffer');\n\n  var sig = new Signature();\n\n  var compressed = true;\n  var i = buf.slice(0, 1)[0] - 27 - 4;\n  if (i < 0) {\n    compressed = false;\n    i = i + 4;\n  }\n\n  var b2 = buf.slice(1, 33);\n  var b3 = buf.slice(33, 65);\n\n  $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be 0, 1, 2, or 3'));\n  $.checkArgument(b2.length === 32, new Error('r must be 32 bytes'));\n  $.checkArgument(b3.length === 32, new Error('s must be 32 bytes'));\n\n  sig.compressed = compressed;\n  sig.i = i;\n  sig.r = BN.fromBuffer(b2);\n  sig.s = BN.fromBuffer(b3);\n\n  return sig;\n};\n\nSignature.fromDER = Signature.fromBuffer = function(buf, strict) {\n  var sig = new Signature();\n\n  // Schnorr Signatures use 65 byte for in tx r [len] 32 , s [len] 32, nhashtype\n  // NOTE: this check is not very reliable. You should use .fromSchnorr directly if you know it's a schnorr sig.\n  if((buf.length === 64 || buf.length === 65) && buf[0] != 0x30) {\n    return Signature.fromSchnorr(buf);\n  }\n  \n  $.checkArgument(!(buf.length === 64 && buf[0] === 0x30), new Error('64 DER (ecdsa) signatures not allowed'));\n  \n  var obj = Signature.parseDER(buf, strict);\n\n  sig.r = obj.r;\n  sig.s = obj.s;\n\n  return sig;\n};\n\n// The format used in a tx\nSignature.fromTxFormat = function(buf) {\n  var nhashtype = buf.readUInt8(buf.length - 1);\n  var derbuf = buf.slice(0, buf.length - 1);\n  var sig = new Signature.fromDER(derbuf, false);\n  sig.nhashtype = nhashtype;\n  return sig;\n};\n\nSignature.fromString = function(str) {\n  var buf = Buffer.from(str, 'hex');\n  return Signature.fromDER(buf);\n};\n\n\n/**\n * In order to mimic the non-strict DER encoding of OpenSSL, set strict = false.\n */\nSignature.parseDER = function(buf, strict) {\n  $.checkArgument(BufferUtil.isBuffer(buf), new Error('DER formatted signature should be a buffer'));\n  if (_.isUndefined(strict)) {\n    strict = true;\n  }\n\n  var header = buf[0];\n  $.checkArgument(header === 0x30, new Error('Header byte should be 0x30'));\n\n  var length = buf[1];\n  var buflength = buf.slice(2).length;\n  $.checkArgument(!strict || length === buflength, new Error('Length byte should length of what follows'));\n\n  length = length < buflength ? length : buflength;\n\n  var rheader = buf[2 + 0];\n  $.checkArgument(rheader === 0x02, new Error('Integer byte for r should be 0x02'));\n\n  var rlength = buf[2 + 1];\n  var rbuf = buf.slice(2 + 2, 2 + 2 + rlength);\n  var r = BN.fromBuffer(rbuf);\n  var rneg = buf[2 + 1 + 1] === 0x00 ? true : false;\n  $.checkArgument(rlength === rbuf.length, new Error('Length of r incorrect'));\n\n  var sheader = buf[2 + 2 + rlength + 0];\n  $.checkArgument(sheader === 0x02, new Error('Integer byte for s should be 0x02'));\n\n  var slength = buf[2 + 2 + rlength + 1];\n  var sbuf = buf.slice(2 + 2 + rlength + 2, 2 + 2 + rlength + 2 + slength);\n  var s = BN.fromBuffer(sbuf);\n  var sneg = buf[2 + 2 + rlength + 2 + 2] === 0x00 ? true : false;\n  $.checkArgument(slength === sbuf.length, new Error('Length of s incorrect'));\n\n  var sumlength = 2 + 2 + rlength + 2 + slength;\n  $.checkArgument(length === sumlength - 2, new Error('Length of signature incorrect'));\n\n  var obj = {\n    header: header,\n    length: length,\n    rheader: rheader,\n    rlength: rlength,\n    rneg: rneg,\n    rbuf: rbuf,\n    r: r,\n    sheader: sheader,\n    slength: slength,\n    sneg: sneg,\n    sbuf: sbuf,\n    s: s\n  };\n\n  return obj;\n};\n\n\nSignature.prototype.toCompact = function(i, compressed) {\n  i = typeof i === 'number' ? i : this.i;\n  compressed = typeof compressed === 'boolean' ? compressed : this.compressed;\n\n  if (!(i === 0 || i === 1 || i === 2 || i === 3)) {\n    throw new Error('i must be equal to 0, 1, 2, or 3');\n  }\n\n  var val = i + 27 + 4;\n  if (compressed === false) {\n    val = val - 4;\n  }\n  var b1 = Buffer.from([val]);\n  var b2 = this.r.toBuffer({\n    size: 32\n  });\n  var b3 = this.s.toBuffer({\n    size: 32\n  });\n  return Buffer.concat([b1, b2, b3]);\n};\n\n/**\n * Returns either a DER encoded buffer or a Schnorr encoded buffer if isSchnor == true\n */\nSignature.prototype.toBuffer = Signature.prototype.toDER = function() {\n  if(this.isSchnorr) {\n    const hashTypeBuf = !this.nhashtype || this.nhashtype === Signature.SIGHASH_DEFAULT ? Buffer.alloc(0) : Buffer.from([this.nhashtype]);\n    return Buffer.concat([this.r.toBuffer({ size: 32 }), this.s.toBuffer({ size: 32 }), hashTypeBuf]);\n  }\n\n  var rnbuf = this.r.toBuffer();\n  var snbuf = this.s.toBuffer();\n\n  var rneg = rnbuf[0] & 0x80 ? true : false;\n  var sneg = snbuf[0] & 0x80 ? true : false;\n\n  var rbuf = rneg ? Buffer.concat([Buffer.from([0x00]), rnbuf]) : rnbuf;\n  var sbuf = sneg ? Buffer.concat([Buffer.from([0x00]), snbuf]) : snbuf;\n\n  var rlength = rbuf.length;\n  var slength = sbuf.length;\n  var length = 2 + rlength + 2 + slength;\n  var rheader = 0x02;\n  var sheader = 0x02;\n  var header = 0x30;\n\n  var der = Buffer.concat([Buffer.from([header, length, rheader, rlength]), rbuf, Buffer.from([sheader, slength]), sbuf]);\n  return der;\n};\n\nSignature.prototype.toString = function() {\n  var buf = this.toDER();\n  return buf.toString('hex');\n};\n\n/**\n * This function is translated from bitcoind's IsDERSignature and is used in\n * the script interpreter.  This \"DER\" format actually includes an extra byte,\n * the nhashtype, at the end. It is really the tx format, not DER format.\n *\n * A canonical signature exists of: [30] [total len] [02] [len R] [R] [02] [len S] [S] [hashtype]\n * Where R and S are not negative (their first byte has its highest bit not set), and not\n * excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,\n * in which case a single 0 byte is necessary and even required).\n *\n * See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623\n */\nSignature.isTxDER = function(buf) {\n  if (buf.length < 9) {\n    //  Non-canonical signature: too short\n    return false;\n  }\n  if (buf.length > 73) {\n    // Non-canonical signature: too long\n    return false;\n  }\n  if (buf[0] !== 0x30) {\n    //  Non-canonical signature: wrong type\n    return false;\n  }\n  if (buf[1] !== buf.length - 3) {\n    //  Non-canonical signature: wrong length marker\n    return false;\n  }\n  var nLenR = buf[3];\n  if (5 + nLenR >= buf.length) {\n    //  Non-canonical signature: S length misplaced\n    return false;\n  }\n  var nLenS = buf[5 + nLenR];\n  if ((nLenR + nLenS + 7) !== buf.length) {\n    //  Non-canonical signature: R+S length mismatch\n    return false;\n  }\n\n  var R = buf.slice(4);\n  if (buf[4 - 2] !== 0x02) {\n    //  Non-canonical signature: R value type mismatch\n    return false;\n  }\n  if (nLenR === 0) {\n    //  Non-canonical signature: R length is zero\n    return false;\n  }\n  if (R[0] & 0x80) {\n    //  Non-canonical signature: R value negative\n    return false;\n  }\n  if (nLenR > 1 && (R[0] === 0x00) && !(R[1] & 0x80)) {\n    //  Non-canonical signature: R value excessively padded\n    return false;\n  }\n\n  var S = buf.slice(6 + nLenR);\n  if (buf[6 + nLenR - 2] !== 0x02) {\n    //  Non-canonical signature: S value type mismatch\n    return false;\n  }\n  if (nLenS === 0) {\n    //  Non-canonical signature: S length is zero\n    return false;\n  }\n  if (S[0] & 0x80) {\n    //  Non-canonical signature: S value negative\n    return false;\n  }\n  if (nLenS > 1 && (S[0] === 0x00) && !(S[1] & 0x80)) {\n    //  Non-canonical signature: S value excessively padded\n    return false;\n  }\n  return true;\n};\n\n/**\n * Compares to bitcoind's IsLowDERSignature\n * See also ECDSA signature algorithm which enforces this.\n * See also BIP 62, \"low S values in signatures\"\n */\nSignature.prototype.hasLowS = function() {\n  if (this.s.lt(new BN(1)) ||\n    this.s.gt(new BN('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex'))) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * @returns true if the nhashtype is exactly equal to one of the standard options or combinations thereof.\n * Translated from bitcoind's IsDefinedHashtypeSignature\n */\nSignature.prototype.hasDefinedHashtype = function() {\n  if (!JSUtil.isNaturalNumber(this.nhashtype)) {\n    return false;\n  }\n  // accept with or without Signature.SIGHASH_ANYONECANPAY by ignoring the bit\n  var temp = this.nhashtype & ~Signature.SIGHASH_ANYONECANPAY;\n  if (temp < Signature.SIGHASH_ALL || temp > Signature.SIGHASH_SINGLE) {\n    return false;\n  }\n  return true;\n};\n\nSignature.prototype.toTxFormat = function() {\n  var derbuf = this.toDER();\n  var buf = Buffer.alloc(1);\n  buf.writeUInt8(this.nhashtype, 0);\n  return Buffer.concat([derbuf, buf]);\n};\n\n/**\n * Creates a Signature instance from a Schnorr sig\n * @param {Buffer} buf Schnorr signature buffer\n * @returns {Signature}\n */\nSignature.fromSchnorr = function(buf) {\n  $.checkArgument(Buffer.isBuffer(buf), 'Schnorr signature argument must be a buffer');\n  $.checkArgument(buf.length === 64 || buf.length === 65, 'Schnorr signatures must be 64 or 65 bytes');\n\n  const sig = new Signature();\n  let r = buf.slice(0,32);\n  let s = buf.slice(32, 64);\n  if (buf.length === 65) {\n    sig.nhashtype = buf[buf.length - 1];\n    $.checkState(sig.nhashtype !== Signature.SIGHASH_DEFAULT, new Error('invalid hashtype'));\n  } else {\n    sig.nhashtype = Signature.SIGHASH_DEFAULT;\n  }\n  sig.r = BN.fromBuffer(r);\n  sig.s = BN.fromBuffer(s);\n  sig.isSchnorr = true;\n  return sig;\n};\n\nSignature.SIGHASH_DEFAULT       = 0x00; //!< Taproot only; implied when sighash byte is missing, and equivalent to SIGHASH_ALL\nSignature.SIGHASH_ALL           = 0x01;\nSignature.SIGHASH_NONE          = 0x02;\nSignature.SIGHASH_SINGLE        = 0x03;\nSignature.SIGHASH_ANYONECANPAY  = 0x80;\n\nSignature.SIGHASH_OUTPUT_MASK = 3;\nSignature.SIGHASH_INPUT_MASK  = 128; // 0x80,\n\nSignature.Version = {};\nSignature.Version.BASE       = 0;\nSignature.Version.WITNESS_V0 = 1;\nSignature.Version.TAPROOT    = 2;\nSignature.Version.TAPSCRIPT  = 3;\n\nmodule.exports = Signature;\n","const Hash = require('./hash');\nconst BufferWriter = require('../encoding/bufferwriter');\nconst inherits = require('inherits');\n\n/**\n * Creates a tag hash to ensure uniqueness of a message between purposes.\n * For example, if there's a potential for a collision of messages between\n *   multiple purposes, a tag can be added to guard against such collisions.\n * @link https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#Design (see 'Tagged Hashes')\n * @param {String} tag The tag to prevent message collisions. Should uniquely reflect the purpose of the message.\n * @param {Buffer|String} message (optional)\n * @param {String} messageEncoding (default: 'hex') If `message` is a string, provide the encoding\n * @returns {TaggedHash} Instance of a BufferWriter with the written tag and `finalize` method\n */\nfunction TaggedHash(tag, message, messageEncoding = 'hex') {\n  if (!(this instanceof TaggedHash)) {\n    return new TaggedHash(tag, message, messageEncoding);\n  }\n  BufferWriter.apply(this);\n  tag = Buffer.from(tag);\n\n  const taghash = Hash.sha256(tag);\n  this.write(taghash);\n  this.write(taghash);\n  if (message) {\n    message = Buffer.isBuffer(message) ? message : Buffer.from(message, messageEncoding);\n    this.write(message);\n  }\n  return this;\n};\n\ninherits(TaggedHash, BufferWriter);\n\n/**\n * Returns a 32-byte SHA256 hash of the double tagged hashes concat'd with the message\n * as defined by BIP-340: SHA256(SHA256(tag), SHA256(tag), message)\n * @returns {Buffer}\n */\nTaggedHash.prototype.finalize = function() {\n  return Buffer.from(Hash.sha256(this.toBuffer()));\n};\n\n/**\n * Commonly used tags\n */\nObject.defineProperties(TaggedHash, {\n  TAPSIGHASH: { get: () => new TaggedHash('TapSighash') },\n  TAPLEAF:    { get: () => new TaggedHash('TapLeaf') },\n  TAPBRANCH:  { get: () => new TaggedHash('TapBranch') }\n});\n\nmodule.exports = TaggedHash;","'use strict';\n\nvar _ = require('lodash');\nvar bs58 = require('bs58');\nvar buffer = require('buffer');\n\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'.split('');\n\nvar Base58 = function Base58(obj) {\n  /* jshint maxcomplexity: 8 */\n  if (!(this instanceof Base58)) {\n    return new Base58(obj);\n  }\n  if (Buffer.isBuffer(obj)) {\n    var buf = obj;\n    this.fromBuffer(buf);\n  } else if (typeof obj === 'string') {\n    var str = obj;\n    this.fromString(str);\n  } else if (obj) {\n    this.set(obj);\n  }\n};\n\nBase58.validCharacters = function validCharacters(chars) {\n  if (buffer.Buffer.isBuffer(chars)) {\n    chars = chars.toString();\n  }\n  return _.every(_.map(chars, function(char) { return _.includes(ALPHABET, char); }));\n};\n\nBase58.prototype.set = function(obj) {\n  this.buf = obj.buf || this.buf || undefined;\n  return this;\n};\n\nBase58.encode = function(buf) {\n  if (!buffer.Buffer.isBuffer(buf)) {\n    throw new Error('Input should be a buffer');\n  }\n  return bs58.encode(buf);\n};\n\nBase58.decode = function(str) {\n  if (typeof str !== 'string') {\n    throw new Error('Input should be a string');\n  }\n  return Buffer.from(bs58.decode(str));\n};\n\nBase58.prototype.fromBuffer = function(buf) {\n  this.buf = buf;\n  return this;\n};\n\nBase58.prototype.fromString = function(str) {\n  var buf = Base58.decode(str);\n  this.buf = buf;\n  return this;\n};\n\nBase58.prototype.toBuffer = function() {\n  return this.buf;\n};\n\nBase58.prototype.toString = function() {\n  return Base58.encode(this.buf);\n};\n\nmodule.exports = Base58;\n","'use strict';\n\nvar _ = require('lodash');\nvar Base58 = require('./base58');\nvar buffer = require('buffer');\nvar sha256sha256 = require('../crypto/hash').sha256sha256;\n\nvar Base58Check = function Base58Check(obj) {\n  if (!(this instanceof Base58Check))\n    return new Base58Check(obj);\n  if (Buffer.isBuffer(obj)) {\n    var buf = obj;\n    this.fromBuffer(buf);\n  } else if (typeof obj === 'string') {\n    var str = obj;\n    this.fromString(str);\n  } else if (obj) {\n    this.set(obj);\n  }\n};\n\nBase58Check.prototype.set = function(obj) {\n  this.buf = obj.buf || this.buf || undefined;\n  return this;\n};\n\nBase58Check.validChecksum = function validChecksum(data, checksum) {\n  if (_.isString(data)) {\n    data = Buffer.from(Base58.decode(data));\n  }\n  if (_.isString(checksum)) {\n    checksum =  Buffer.from(Base58.decode(checksum));\n  }\n  if (!checksum) {\n    checksum = data.slice(-4);\n    data = data.slice(0, -4);\n  }\n  return Base58Check.checksum(data).toString('hex') === checksum.toString('hex');\n};\n\nBase58Check.decode = function(s) {\n  if (typeof s !== 'string')\n    throw new Error('Input must be a string');\n\n  var buf = Buffer.from(Base58.decode(s));\n\n  if (buf.length < 4)\n    throw new Error(\"Input string too short\");\n\n  var data = buf.slice(0, -4);\n  var csum = buf.slice(-4);\n\n  var hash = sha256sha256(data);\n  var hash4 = hash.slice(0, 4);\n\n  if (csum.toString('hex') !== hash4.toString('hex'))\n    throw new Error(\"Checksum mismatch\");\n\n  return data;\n};\n\nBase58Check.checksum = function(buffer) {\n  return sha256sha256(buffer).slice(0, 4);\n};\n\nBase58Check.encode = function(buf) {\n  if (!Buffer.isBuffer(buf))\n    throw new Error('Input must be a buffer');\n  var checkedBuf = Buffer.alloc(buf.length + 4);\n  var hash = Base58Check.checksum(buf);\n  buf.copy(checkedBuf);\n  hash.copy(checkedBuf, buf.length);\n  return Base58.encode(checkedBuf);\n};\n\nBase58Check.prototype.fromBuffer = function(buf) {\n  this.buf = buf;\n  return this;\n};\n\nBase58Check.prototype.fromString = function(str) {\n  var buf = Base58Check.decode(str);\n  this.buf = buf;\n  return this;\n};\n\nBase58Check.prototype.toBuffer = function() {\n  return this.buf;\n};\n\nBase58Check.prototype.toString = function() {\n  return Base58Check.encode(this.buf);\n};\n\nmodule.exports = Base58Check;\n","'use strict';\n\nvar bech32 = require('bech32');\n\n/**\n * Decode bech32/bech32m string\n * @param {String} str String to decode\n * @returns {Object} Decoded string info\n */\nvar decode = function(str) {\n  if (typeof str !== 'string') {\n    throw new Error('Input should be a string');\n  }\n\n  var decoded;\n  let fromWords = bech32.bech32.fromWords;\n  let encoding = encodings.BECH32;\n  try {\n    decoded = bech32.bech32.decode(str);\n  } catch (e) {\n    if (e.message.indexOf('Invalid checksum') > -1) {\n      decoded = bech32.bech32m.decode(str);\n      encoding = encodings.BECH32M;\n      fromWords = bech32.bech32m.fromWords;\n    } else {\n      throw e;\n    }\n  }\n\n  const version = decoded.words[0];\n  if (version >= 1 && encoding !== encodings.BECH32M) {\n    throw new Error('Version 1+ witness address must use Bech32m checksum');\n  }\n\n  return {\n    prefix: decoded.prefix,\n    data: Buffer.from(fromWords(decoded.words.slice(1))),\n    version\n  };\n};\n\n/**\n * Encode using BECH32 encoding\n * @param {String} prefix bech32 prefix\n * @param {Number} version\n * @param {String|Buffer} data \n * @param {String|Number} encoding (optional, default=bech32) Valid encodings are 'bech32', 'bech32m', 0, and 1.\n * @returns {String} encoded string\n */\nvar encode = function(prefix, version, data, encoding) {\n\tif (typeof prefix !== 'string') {\n\t\tthrow new Error('Prefix should be a string');\n\t}\n\tif (typeof version !== 'number') {\n\t\tthrow new Error('version should be a number');\n\t}\n  // convert string to number\n  if (encoding && typeof encoding == 'string') {\n    encoding = encodings[encoding.toUpperCase()] || -1; // fallback to -1 so it throws invalid encoding below\n  }\n  if (encoding && !(encoding == encodings.BECH32 || encoding == encodings.BECH32M)) {\n    throw new Error('Invalid encoding specified');\n  }\n  \n  let b32Variety = encoding == encodings.BECH32M ? bech32.bech32m : bech32.bech32;\n  let words = b32Variety.toWords(data);\n\n  words.unshift(version);\n\treturn b32Variety.encode(prefix, words);\n}\n\nconst encodings = {\n  BECH32: 1,\n  BECH32M: 2\n}\n\nmodule.exports = { decode: decode, encode: encode, encodings };\n","'use strict';\n\nvar _ = require('lodash');\nvar $ = require('../util/preconditions');\nvar BufferUtil = require('../util/buffer');\nvar BN = require('../crypto/bn');\n\nvar BufferReader = function BufferReader(buf) {\n  if (!(this instanceof BufferReader)) {\n    return new BufferReader(buf);\n  }\n  if (_.isUndefined(buf)) {\n    return;\n  }\n  if (Buffer.isBuffer(buf)) {\n    this.set({\n      buf: buf\n    });\n  } else if (_.isString(buf)) {\n    this.set({\n      buf: Buffer.from(buf, 'hex'),\n    });\n  } else if (_.isObject(buf)) {\n    var obj = buf;\n    this.set(obj);\n  } else {\n    throw new TypeError('Unrecognized argument for BufferReader');\n  }\n};\n\nBufferReader.prototype.set = function(obj) {\n  this.buf = obj.buf || this.buf || undefined;\n  this.pos = obj.pos || this.pos || 0;\n  return this;\n};\n\nBufferReader.prototype.eof = function() {\n  if(this.buf) {\n    return this.pos >= this.buf.length;\n  } else {\n    return true;\n  }\n};\n\nBufferReader.prototype.finished = BufferReader.prototype.eof;\n\nBufferReader.prototype.read = function(len) {\n  $.checkArgument(!_.isUndefined(len), 'Must specify a length');\n  var buf = this.buf.slice(this.pos, this.pos + len);\n  this.pos = this.pos + len;\n  return buf;\n};\n\nBufferReader.prototype.readAll = function() {\n  var buf = this.buf.slice(this.pos, this.buf.length);\n  this.pos = this.buf.length;\n  return buf;\n};\n\nBufferReader.prototype.readUInt8 = function() {\n  var val = this.buf.readUInt8(this.pos);\n  this.pos = this.pos + 1;\n  return val;\n};\n\nBufferReader.prototype.readUInt16BE = function() {\n  var val = this.buf.readUInt16BE(this.pos);\n  this.pos = this.pos + 2;\n  return val;\n};\n\nBufferReader.prototype.readUInt16LE = function() {\n  var val = this.buf.readUInt16LE(this.pos);\n  this.pos = this.pos + 2;\n  return val;\n};\n\nBufferReader.prototype.readUInt32BE = function() {\n  var val = this.buf.readUInt32BE(this.pos);\n  this.pos = this.pos + 4;\n  return val;\n};\n\nBufferReader.prototype.readUInt32LE = function() {\n  var val = this.buf.readUInt32LE(this.pos);\n  this.pos = this.pos + 4;\n  return val;\n};\n\nBufferReader.prototype.readInt32LE = function() {\n  var val = this.buf.readInt32LE(this.pos);\n  this.pos = this.pos + 4;\n  return val;\n};\n\nBufferReader.prototype.readUInt64BEBN = function() {\n  var buf = this.buf.slice(this.pos, this.pos + 8);\n  var bn = BN.fromBuffer(buf);\n  this.pos = this.pos + 8;\n  return bn;\n};\n\nBufferReader.prototype.readUInt64LEBN = function() {\n  var second = this.buf.readUInt32LE(this.pos);\n  var first = this.buf.readUInt32LE(this.pos + 4);\n  var combined = (first * 0x100000000) + second;\n  // Instantiating an instance of BN with a number is faster than with an\n  // array or string. However, the maximum safe number for a double precision\n  // floating point is 2 ^ 52 - 1 (0x1fffffffffffff), thus we can safely use\n  // non-floating point numbers less than this amount (52 bits). And in the case\n  // that the number is larger, we can instatiate an instance of BN by passing\n  // an array from the buffer (slower) and specifying the endianness.\n  var bn;\n  if (combined <= 0x1fffffffffffff) {\n    bn = new BN(combined);\n  } else {\n    var data = Array.prototype.slice.call(this.buf, this.pos, this.pos + 8);\n    bn = new BN(data, 10, 'le');\n  }\n  this.pos = this.pos + 8;\n  return bn;\n};\n\nBufferReader.prototype.readVarintNum = function() {\n  var first = this.readUInt8();\n  switch (first) {\n    case 0xFD:\n      return this.readUInt16LE();\n    case 0xFE:\n      return this.readUInt32LE();\n    case 0xFF:\n      var bn = this.readUInt64LEBN();\n      var n = bn.toNumber();\n      if (n <= Math.pow(2, 53)) {\n        return n;\n      } else {\n        throw new Error('number too large to retain precision - use readVarintBN');\n      }\n      break;\n    default:\n      return first;\n  }\n};\n\n/**\n * reads a length prepended buffer\n */\nBufferReader.prototype.readVarLengthBuffer = function() {\n  var len = this.readVarintNum();\n  var buf = this.read(len);\n  $.checkState(buf.length === len, 'Invalid length while reading varlength buffer. ' +\n    'Expected to read: ' + len + ' and read ' + buf.length);\n  return buf;\n};\n\nBufferReader.prototype.readVarintBuf = function() {\n  var first = this.buf.readUInt8(this.pos);\n  switch (first) {\n    case 0xFD:\n      return this.read(1 + 2);\n    case 0xFE:\n      return this.read(1 + 4);\n    case 0xFF:\n      return this.read(1 + 8);\n    default:\n      return this.read(1);\n  }\n};\n\nBufferReader.prototype.readVarintBN = function() {\n  var first = this.readUInt8();\n  switch (first) {\n    case 0xFD:\n      return new BN(this.readUInt16LE());\n    case 0xFE:\n      return new BN(this.readUInt32LE());\n    case 0xFF:\n      return this.readUInt64LEBN();\n    default:\n      return new BN(first);\n  }\n};\n\nBufferReader.prototype.reverse = function() {\n  var buf = Buffer.alloc(this.buf.length);\n  for (var i = 0; i < buf.length; i++) {\n    buf[i] = this.buf[this.buf.length - 1 - i];\n  }\n  this.buf = buf;\n  return this;\n};\n\nBufferReader.prototype.readReverse = function(len) {\n  if (_.isUndefined(len)) {\n    len = this.buf.length;\n  }\n  var buf = this.buf.slice(this.pos, this.pos + len);\n  this.pos = this.pos + len;\n  return BufferUtil.reverse(buf);\n};\n\nmodule.exports = BufferReader;\n","'use strict';\n\nvar bufferUtil = require('../util/buffer');\nvar assert = require('assert');\n\nvar BufferWriter = function BufferWriter(obj) {\n  if (!(this instanceof BufferWriter))\n    return new BufferWriter(obj);\n  this.bufLen = 0;\n  if (obj)\n    this.set(obj);\n  else\n    this.bufs = [];\n};\n\nBufferWriter.prototype.set = function(obj) {\n  this.bufs = obj.bufs || this.bufs || [];\n  this.bufLen = this.bufs.reduce(function(prev, buf){ return prev + buf.length; }, 0);\n  return this;\n};\n\nBufferWriter.prototype.toBuffer = function() {\n  return this.concat();\n};\n\nBufferWriter.prototype.concat = function() {\n  return Buffer.concat(this.bufs, this.bufLen);\n};\n\nBufferWriter.prototype.write = function(buf) {\n  assert(bufferUtil.isBuffer(buf));\n  this.bufs.push(buf);\n  this.bufLen += buf.length;\n  return this;\n};\n\nBufferWriter.prototype.writeReverse = function(buf) {\n  assert(bufferUtil.isBuffer(buf));\n  this.bufs.push(bufferUtil.reverse(buf));\n  this.bufLen += buf.length;\n  return this;\n};\n\nBufferWriter.prototype.writeUInt8 = function(n) {\n  if (n < 0) {\n    n = n >>> 0; // Convert signed int to unsigned int\n  }\n  var buf = Buffer.alloc(1);\n  buf.writeUInt8(n, 0);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeUInt16BE = function(n) {\n  if (n < 0) {\n    n = n >>> 0; // Convert signed int to unsigned int\n  }\n  var buf = Buffer.alloc(2);\n  buf.writeUInt16BE(n, 0);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeUInt16LE = function(n) {\n  if (n < 0) {\n    n = n >>> 0; // Convert signed int to unsigned int\n  }\n  var buf = Buffer.alloc(2);\n  buf.writeUInt16LE(n, 0);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeUInt32BE = function(n) {\n  if (n < 0) {\n    n = n >>> 0; // Convert signed int to unsigned int\n  }\n  var buf = Buffer.alloc(4);\n  buf.writeUInt32BE(n, 0);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeInt32LE = function(n) {\n  var buf = Buffer.alloc(4);\n  buf.writeInt32LE(n, 0);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeUInt32LE = function(n) {\n  if (n < 0) {\n    n = n >>> 0; // Convert signed int to unsigned int\n  }\n  var buf = Buffer.alloc(4);\n  buf.writeUInt32LE(n, 0);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeUInt64BEBN = function(bn) {\n  var buf = bn.toBuffer({size: 8});\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeUInt64LEBN = function(bn) {\n  var buf = bn.toBuffer({size: 8});\n  this.writeReverse(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeVarintNum = function(n) {\n  var buf = BufferWriter.varintBufNum(n);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.prototype.writeVarintBN = function(bn) {\n  var buf = BufferWriter.varintBufBN(bn);\n  this.write(buf);\n  return this;\n};\n\nBufferWriter.varintBufNum = function(n) {\n  var buf = undefined;\n  if (n < 253) {\n    buf = Buffer.alloc(1);\n    buf.writeUInt8(n, 0);\n  } else if (n < 0x10000) {\n    buf = Buffer.alloc(1 + 2);\n    buf.writeUInt8(253, 0);\n    buf.writeUInt16LE(n, 1);\n  } else if (n < 0x100000000) {\n    buf = Buffer.alloc(1 + 4);\n    buf.writeUInt8(254, 0);\n    buf.writeUInt32LE(n, 1);\n  } else {\n    buf = Buffer.alloc(1 + 8);\n    buf.writeUInt8(255, 0);\n    buf.writeInt32LE(n & -1, 1);\n    buf.writeUInt32LE(Math.floor(n / 0x100000000), 5);\n  }\n  return buf;\n};\n\nBufferWriter.varintBufBN = function(bn) {\n  var buf = undefined;\n  var n = bn.toNumber();\n  if (n < 253) {\n    buf = Buffer.alloc(1);\n    buf.writeUInt8(n, 0);\n  } else if (n < 0x10000) {\n    buf = Buffer.alloc(1 + 2);\n    buf.writeUInt8(253, 0);\n    buf.writeUInt16LE(n, 1);\n  } else if (n < 0x100000000) {\n    buf = Buffer.alloc(1 + 4);\n    buf.writeUInt8(254, 0);\n    buf.writeUInt32LE(n, 1);\n  } else {\n    var bw = new BufferWriter();\n    bw.writeUInt8(255);\n    bw.writeUInt64LEBN(bn);\n    var buf = bw.concat();\n  }\n  return buf;\n};\n\nmodule.exports = BufferWriter;\n","'use strict';\n\nvar BufferWriter = require('./bufferwriter');\nvar BufferReader = require('./bufferreader');\nvar BN = require('../crypto/bn');\n\nvar Varint = function Varint(buf) {\n  if (!(this instanceof Varint))\n    return new Varint(buf);\n  if (Buffer.isBuffer(buf)) {\n    this.buf = buf;\n  } else if (typeof buf === 'number') {\n    var num = buf;\n    this.fromNumber(num);\n  } else if (buf instanceof BN) {\n    var bn = buf;\n    this.fromBN(bn);\n  } else if (buf) {\n    var obj = buf;\n    this.set(obj);\n  }\n};\n\nVarint.prototype.set = function(obj) {\n  this.buf = obj.buf || this.buf;\n  return this;\n};\n\nVarint.prototype.fromString = function(str) {\n  this.set({\n    buf: Buffer.from(str, 'hex')\n  });\n  return this;\n};\n\nVarint.prototype.toString = function() {\n  return this.buf.toString('hex');\n};\n\nVarint.prototype.fromBuffer = function(buf) {\n  this.buf = buf;\n  return this;\n};\n\nVarint.prototype.fromBufferReader = function(br) {\n  this.buf = br.readVarintBuf();\n  return this;\n};\n\nVarint.prototype.fromBN = function(bn) {\n  this.buf = BufferWriter().writeVarintBN(bn).concat();\n  return this;\n};\n\nVarint.prototype.fromNumber = function(num) {\n  this.buf = BufferWriter().writeVarintNum(num).concat();\n  return this;\n};\n\nVarint.prototype.toBuffer = function() {\n  return this.buf;\n};\n\nVarint.prototype.toBN = function() {\n  return BufferReader(this.buf).readVarintBN();\n};\n\nVarint.prototype.toNumber = function() {\n  return BufferReader(this.buf).readVarintNum();\n};\n\nmodule.exports = Varint;\n","'use strict';\n\nvar _ = require('lodash');\n\nfunction format(message, args) {\n  return message\n    .replace('{0}', args[0])\n    .replace('{1}', args[1])\n    .replace('{2}', args[2]);\n}\nvar traverseNode = function(parent, errorDefinition) {\n  var NodeError = function() {\n    if (_.isString(errorDefinition.message)) {\n      this.message = format(errorDefinition.message, arguments);\n    } else if (_.isFunction(errorDefinition.message)) {\n      this.message = errorDefinition.message.apply(null, arguments);\n    } else {\n      throw new Error('Invalid error definition for ' + errorDefinition.name);\n    }\n    this.stack = this.message + '\\n' + (new Error()).stack;\n  };\n  NodeError.prototype = Object.create(parent.prototype);\n  NodeError.prototype.name = parent.prototype.name + errorDefinition.name;\n  parent[errorDefinition.name] = NodeError;\n  if (errorDefinition.errors) {\n    childDefinitions(NodeError, errorDefinition.errors);\n  }\n  return NodeError;\n};\n\n/* jshint latedef: false */\nvar childDefinitions = function(parent, childDefinitions) {\n  _.each(childDefinitions, function(childDefinition) {\n    traverseNode(parent, childDefinition);\n  });\n};\n/* jshint latedef: true */\n\nvar traverseRoot = function(parent, errorsDefinition) {\n  childDefinitions(parent, errorsDefinition);\n  return parent;\n};\n\n\nvar bitcore = {};\nbitcore.Error = function() {\n  this.message = 'Internal error';\n  this.stack = this.message + '\\n' + (new Error()).stack;\n};\nbitcore.Error.prototype = Object.create(Error.prototype);\nbitcore.Error.prototype.name = 'bitcore.Error';\n\n\nvar data = require('./spec');\ntraverseRoot(bitcore.Error, data);\n\nmodule.exports = bitcore.Error;\n\nmodule.exports.extend = function(spec) {\n  return traverseNode(bitcore.Error, spec);\n};\n","'use strict';\n\nvar docsURL = 'http://bitcore.io/';\n\nmodule.exports = [{\n  name: 'InvalidB58Char',\n  message: 'Invalid Base58 character: {0} in {1}'\n}, {\n  name: 'InvalidB58Checksum',\n  message: 'Invalid Base58 checksum for {0}'\n}, {\n  name: 'InvalidNetwork',\n  message: 'Invalid version for network: got {0}'\n}, {\n  name: 'InvalidState',\n  message: 'Invalid state: {0}'\n}, {\n  name: 'NotImplemented',\n  message: 'Function {0} was not implemented yet'\n}, {\n  name: 'InvalidNetworkArgument',\n  message: 'Invalid network: must be \"livenet\" or \"testnet\", got {0}'\n}, {\n  name: 'InvalidArgument',\n  message: function() {\n    return 'Invalid Argument' + (arguments[0] ? (': ' + arguments[0]) : '') +\n      (arguments[1] ? (' Documentation: ' + docsURL + arguments[1]) : '');\n  }\n}, {\n  name: 'AbstractMethodInvoked',\n  message: 'Abstract Method Invocation: {0}'\n}, {\n  name: 'InvalidArgumentType',\n  message: function() {\n    return 'Invalid Argument for ' + arguments[2] + ', expected ' + arguments[1] + ' but got ' + typeof arguments[0];\n  }\n}, {\n  name: 'Unit',\n  message: 'Internal Error on Unit {0}',\n  errors: [{\n    'name': 'UnknownCode',\n    'message': 'Unrecognized unit code: {0}'\n  }, {\n    'name': 'InvalidRate',\n    'message': 'Invalid exchange rate: {0}'\n  }]\n}, {\n  name: 'MerkleBlock',\n  message: 'Internal Error on MerkleBlock {0}',\n  errors: [{\n    'name': 'InvalidMerkleTree',\n    'message': 'This MerkleBlock contain an invalid Merkle Tree'\n  }]\n}, {\n  name: 'Transaction',\n  message: 'Internal Error on Transaction {0}',\n  errors: [{\n    name: 'Input',\n    message: 'Internal Error on Input {0}',\n    errors: [{\n      name: 'MissingScript',\n      message: 'Need a script to create an input'\n    }, {\n      name: 'UnsupportedScript',\n      message: 'Unsupported input script type: {0}'\n    }, {\n      name: 'MissingPreviousOutput',\n      message: 'No previous output information.'\n    }, {\n      name: 'BlockHeightOutOfRange',\n      message: 'Block Height can only be between 0 and 65535'\n    } , {\n      name: 'LockTimeRange',\n      message: 'Seconds needs to be more that 0 and less that 33553920'\n    }\n    ]\n  }, {\n    name: 'NeedMoreInfo',\n    message: '{0}'\n  }, {\n    name: 'InvalidSorting',\n    message: 'The sorting function provided did not return the change output as one of the array elements'\n  }, {\n    name: 'InvalidOutputAmountSum',\n    message: '{0}'\n  }, {\n    name: 'MissingSignatures',\n    message: 'Some inputs have not been fully signed'\n  }, {\n    name: 'InvalidIndex',\n    message: 'Invalid index: {0} is not between 0, {1}'\n  }, {\n    name: 'UnableToVerifySignature',\n    message: 'Unable to verify signature: {0}'\n  }, {\n    name: 'DustOutputs',\n    message: 'Dust amount detected in one output'\n  }, {\n    name: 'InvalidSatoshis',\n    message: 'Output satoshis are invalid',\n  }, {\n    name: 'FeeError',\n    message: 'Internal Error on Fee {0}',\n    errors: [{\n      name: 'TooSmall',\n      message: 'Fee is too small: {0}',\n    }, {\n      name: 'TooLarge',\n      message: 'Fee is too large: {0}',\n    }, {\n      name: 'Different',\n      message: 'Unspent value is different from specified fee: {0}',\n    }]\n  }, {\n    name: 'ChangeAddressMissing',\n    message: 'Change address is missing'\n  }, {\n    name: 'BlockHeightTooHigh',\n    message: 'Block Height can be at most 2^32 -1'\n  }, {\n    name: 'NLockTimeOutOfRange',\n    message: 'Block Height can only be between 0 and 499 999 999'\n  }, {\n    name: 'LockTimeTooEarly',\n    message: 'Lock Time can\\'t be earlier than UNIX date 500 000 000'\n  }]\n}, {\n  name: 'Script',\n  message: 'Internal Error on Script {0}',\n  errors: [{\n    name: 'UnrecognizedAddress',\n    message: 'Expected argument {0} to be an address'\n  }, {\n    name: 'CantDeriveAddress',\n    message: 'Can\\'t derive address associated with script {0}, needs to be p2pkh in, p2pkh out, p2sh in, or p2sh out.'\n  }, {\n    name: 'InvalidBuffer',\n    message: 'Invalid script buffer: can\\'t parse valid script from given buffer {0}'\n  }]\n}, {\n  name: 'HDPrivateKey',\n  message: 'Internal Error on HDPrivateKey {0}',\n  errors: [{\n    name: 'InvalidDerivationArgument',\n    message: 'Invalid derivation argument {0}, expected string, or number and boolean'\n  }, {\n    name: 'InvalidEntropyArgument',\n    message: 'Invalid entropy: must be an hexa string or binary buffer, got {0}',\n    errors: [{\n      name: 'TooMuchEntropy',\n      message: 'Invalid entropy: more than 512 bits is non standard, got \"{0}\"'\n    }, {\n      name: 'NotEnoughEntropy',\n      message: 'Invalid entropy: at least 128 bits needed, got \"{0}\"'\n    }]\n  }, {\n    name: 'InvalidLength',\n    message: 'Invalid length for xprivkey string in {0}'\n  }, {\n    name: 'InvalidPath',\n    message: 'Invalid derivation path: {0}'\n  }, {\n    name: 'UnrecognizedArgument',\n    message: 'Invalid argument: creating a HDPrivateKey requires a string, buffer, json or object, got \"{0}\"'\n  }]\n}, {\n  name: 'HDPublicKey',\n  message: 'Internal Error on HDPublicKey {0}',\n  errors: [{\n    name: 'ArgumentIsPrivateExtended',\n    message: 'Argument is an extended private key: {0}'\n  }, {\n    name: 'InvalidDerivationArgument',\n    message: 'Invalid derivation argument: got {0}'\n  }, {\n    name: 'InvalidLength',\n    message: 'Invalid length for xpubkey: got \"{0}\"'\n  }, {\n    name: 'InvalidPath',\n    message: 'Invalid derivation path, it should look like: \"m/1/100\", got \"{0}\"'\n  }, {\n    name: 'InvalidIndexCantDeriveHardened',\n    message: 'Invalid argument: creating a hardened path requires an HDPrivateKey'\n  }, {\n    name: 'MustSupplyArgument',\n    message: 'Must supply an argument to create a HDPublicKey'\n  }, {\n    name: 'UnrecognizedArgument',\n    message: 'Invalid argument for creation, must be string, json, buffer, or object'\n  }]\n}];\n","'use strict';\n\n\nvar assert = require('assert');\nvar buffer = require('buffer');\nvar _ = require('lodash');\nvar $ = require('./util/preconditions');\n\nvar BN = require('./crypto/bn');\nvar Base58 = require('./encoding/base58');\nvar Base58Check = require('./encoding/base58check');\nvar Hash = require('./crypto/hash');\nvar Network = require('./networks');\nvar Point = require('./crypto/point');\nvar PrivateKey = require('./privatekey');\nvar Random = require('./crypto/random');\n\nvar errors = require('./errors');\nvar hdErrors = errors.HDPrivateKey;\nvar BufferUtil = require('./util/buffer');\nvar JSUtil = require('./util/js');\n\nvar MINIMUM_ENTROPY_BITS = 128;\nvar BITS_TO_BYTES = 1 / 8;\nvar MAXIMUM_ENTROPY_BITS = 512;\n\n\n/**\n * Represents an instance of an hierarchically derived private key.\n *\n * More info on https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n *\n * @constructor\n * @param {string|Buffer|Object} arg\n */\nfunction HDPrivateKey(arg) {\n  /* jshint maxcomplexity: 10 */\n  if (arg instanceof HDPrivateKey) {\n    return arg;\n  }\n  if (!(this instanceof HDPrivateKey)) {\n    return new HDPrivateKey(arg);\n  }\n  if (!arg) {\n    return this._generateRandomly();\n  }\n\n  if (Network.get(arg)) {\n    return this._generateRandomly(arg);\n  } else if (_.isString(arg) || BufferUtil.isBuffer(arg)) {\n    if (HDPrivateKey.isValidSerialized(arg)) {\n      this._buildFromSerialized(arg);\n    } else if (JSUtil.isValidJSON(arg)) {\n      this._buildFromJSON(arg);\n    } else if (BufferUtil.isBuffer(arg) && HDPrivateKey.isValidSerialized(arg.toString())) {\n      this._buildFromSerialized(arg.toString());\n    } else {\n      throw HDPrivateKey.getSerializedError(arg);\n    }\n  } else if (_.isObject(arg)) {\n    this._buildFromObject(arg);\n  } else {\n    throw new hdErrors.UnrecognizedArgument(arg);\n  }\n}\n\n/**\n * Verifies that a given path is valid.\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n * @return {boolean}\n */\nHDPrivateKey.isValidPath = function(arg, hardened) {\n  if (_.isString(arg)) {\n    var indexes = HDPrivateKey._getDerivationIndexes(arg);\n    return indexes !== null && _.every(indexes, HDPrivateKey.isValidPath);\n  }\n\n  if (_.isNumber(arg)) {\n    if (arg < HDPrivateKey.Hardened && hardened === true) {\n      arg += HDPrivateKey.Hardened;\n    }\n    return arg >= 0 && arg < HDPrivateKey.MaxIndex;\n  }\n\n  return false;\n};\n\n/**\n * Internal function that splits a string path into a derivation index array.\n * It will return null if the string path is malformed.\n * It does not validate if indexes are in bounds.\n *\n * @param {string} path\n * @return {Array}\n */\nHDPrivateKey._getDerivationIndexes = function(path) {\n  var steps = path.split('/');\n\n  // Special cases:\n  if (_.includes(HDPrivateKey.RootElementAlias, path)) {\n    return [];\n  }\n\n  if (!_.includes(HDPrivateKey.RootElementAlias, steps[0])) {\n    return null;\n  }\n\n  var indexes = steps.slice(1).map(function(step) {\n    var isHardened = step.slice(-1) === '\\'';\n    if (isHardened) {\n      step = step.slice(0, -1);\n    }\n    if (!step || step[0] === '-') {\n      return NaN;\n    }\n    var index = +step; // cast to number\n    if (isHardened) {\n      index += HDPrivateKey.Hardened;\n    }\n\n    return index;\n  });\n\n  return _.some(indexes, isNaN) ? null : indexes;\n};\n\n/**\n * WARNING: This method is deprecated. Use deriveChild or deriveNonCompliantChild instead. This is not BIP32 compliant\n *\n *\n * Get a derived child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same private key), \"m/0/1/40/2'/1000\", where the ' quote means a hardened\n * derivation.\n *\n * If the first argument is a number, the child with that index will be\n * derived. If the second argument is truthy, the hardened version will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPrivateKey('xprv...');\n * var child_0_1_2h = parent.derive(0).derive(1).derive(2, true);\n * var copy_of_child_0_1_2h = parent.derive(\"m/0/1/2'\");\n * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);\n * ```\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\nHDPrivateKey.prototype.derive = function(arg, hardened) {\n  return this.deriveNonCompliantChild(arg, hardened);\n};\n\n/**\n * WARNING: This method will not be officially supported until v1.0.0.\n *\n *\n * Get a derived child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same private key), \"m/0/1/40/2'/1000\", where the ' quote means a hardened\n * derivation.\n *\n * If the first argument is a number, the child with that index will be\n * derived. If the second argument is truthy, the hardened version will be\n * derived. See the example usage for clarification.\n *\n * WARNING: The `nonCompliant` option should NOT be used, except for older implementation\n * that used a derivation strategy that used a non-zero padded private key.\n *\n * @example\n * ```javascript\n * var parent = new HDPrivateKey('xprv...');\n * var child_0_1_2h = parent.deriveChild(0).deriveChild(1).deriveChild(2, true);\n * var copy_of_child_0_1_2h = parent.deriveChild(\"m/0/1/2'\");\n * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);\n * ```\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\nHDPrivateKey.prototype.deriveChild = function(arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\n\n/**\n * WARNING: This method will not be officially supported until v1.0.0\n *\n *\n * WARNING: If this is a new implementation you should NOT use this method, you should be using\n * `derive` instead.\n *\n * This method is explicitly for use and compatibility with an implementation that\n * was not compliant with BIP32 regarding the derivation algorithm. The private key\n * must be 32 bytes hashing, and this implementation will use the non-zero padded\n * serialization of a private key, such that it's still possible to derive the privateKey\n * to recover those funds.\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\nHDPrivateKey.prototype.deriveNonCompliantChild = function(arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened, true);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg, true);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\n\nHDPrivateKey.prototype._deriveWithNumber = function(index, hardened, nonCompliant) {\n  /* jshint maxstatements: 20 */\n  /* jshint maxcomplexity: 10 */\n  if (!HDPrivateKey.isValidPath(index, hardened)) {\n    throw new hdErrors.InvalidPath(index);\n  }\n\n  hardened = index >= HDPrivateKey.Hardened ? true : hardened;\n  if (index < HDPrivateKey.Hardened && hardened === true) {\n    index += HDPrivateKey.Hardened;\n  }\n\n  var indexBuffer = BufferUtil.integerAsBuffer(index);\n  var data;\n  if (hardened && nonCompliant) {\n    // The private key serialization in this case will not be exactly 32 bytes and can be\n    // any value less, and the value is not zero-padded.\n    var nonZeroPadded = this.privateKey.bn.toBuffer();\n    data = BufferUtil.concat([Buffer.from([0]), nonZeroPadded, indexBuffer]);\n  } else if (hardened) {\n    // This will use a 32 byte zero padded serialization of the private key\n    var privateKeyBuffer = this.privateKey.bn.toBuffer({size: 32});\n    assert(privateKeyBuffer.length === 32, 'length of private key buffer is expected to be 32 bytes');\n    data = BufferUtil.concat([Buffer.from([0]), privateKeyBuffer, indexBuffer]);\n  } else {\n    data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);\n  }\n  var hash = Hash.sha512hmac(data, this._buffers.chainCode);\n  var leftPart = BN.fromBuffer(hash.slice(0, 32), {\n    size: 32\n  });\n  var chainCode = hash.slice(32, 64);\n\n  var privateKey = leftPart.add(this.privateKey.toBigNumber()).umod(Point.getN()).toBuffer({\n    size: 32\n  });\n\n  if (!PrivateKey.isValid(privateKey)) {\n    // Index at this point is already hardened, we can pass null as the hardened arg\n    return this._deriveWithNumber(index + 1, null, nonCompliant);\n  }\n\n  var derived = new HDPrivateKey({\n    network: this.network,\n    depth: this.depth + 1,\n    parentFingerPrint: this.fingerPrint,\n    childIndex: index,\n    chainCode: chainCode,\n    privateKey: privateKey\n  });\n\n  return derived;\n};\n\nHDPrivateKey.prototype._deriveFromString = function(path, nonCompliant) {\n  if (!HDPrivateKey.isValidPath(path)) {\n    throw new hdErrors.InvalidPath(path);\n  }\n\n  var indexes = HDPrivateKey._getDerivationIndexes(path);\n  var derived = indexes.reduce(function(prev, index) {\n    return prev._deriveWithNumber(index, null, nonCompliant);\n  }, this);\n\n  return derived;\n};\n\n/**\n * Verifies that a given serialized private key in base58 with checksum format\n * is valid.\n *\n * @param {string|Buffer} data - the serialized private key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {boolean}\n */\nHDPrivateKey.isValidSerialized = function(data, network) {\n  return !HDPrivateKey.getSerializedError(data, network);\n};\n\n/**\n * Checks what's the error that causes the validation of a serialized private key\n * in base58 with checksum to fail.\n *\n * @param {string|Buffer} data - the serialized private key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {errors.InvalidArgument|null}\n */\nHDPrivateKey.getSerializedError = function(data, network) {\n  /* jshint maxcomplexity: 10 */\n  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {\n    return new hdErrors.UnrecognizedArgument('Expected string or buffer');\n  }\n  if (!Base58.validCharacters(data)) {\n    return new errors.InvalidB58Char('(unknown)', data);\n  }\n  try {\n    data = Base58Check.decode(data);\n  } catch (e) {\n    return new errors.InvalidB58Checksum(data);\n  }\n  if (data.length !== HDPrivateKey.DataLength) {\n    return new hdErrors.InvalidLength(data);\n  }\n  if (!_.isUndefined(network)) {\n    var error = HDPrivateKey._validateNetwork(data, network);\n    if (error) {\n      return error;\n    }\n  }\n  return null;\n};\n\nHDPrivateKey._validateNetwork = function(data, networkArg) {\n  var network = Network.get(networkArg);\n  if (!network) {\n    return new errors.InvalidNetworkArgument(networkArg);\n  }\n  var version = data.slice(0, 4);\n  if (BufferUtil.integerFromBuffer(version) !== network.xprivkey) {\n    return new errors.InvalidNetwork(version);\n  }\n  return null;\n};\n\nHDPrivateKey.fromString = function(arg) {\n  $.checkArgument(_.isString(arg), 'No valid string was provided');\n  return new HDPrivateKey(arg);\n};\n\nHDPrivateKey.fromObject = function(arg) {\n  $.checkArgument(_.isObject(arg), 'No valid argument was provided');\n  return new HDPrivateKey(arg);\n};\n\nHDPrivateKey.prototype._buildFromJSON = function(arg) {\n  return this._buildFromObject(JSON.parse(arg));\n};\n\nHDPrivateKey.prototype._buildFromObject = function(arg) {\n  /* jshint maxcomplexity: 12 */\n  // TODO: Type validation\n  var buffers = {\n    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xprivkey) : arg.version,\n    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,\n    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,\n    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,\n    chainCode: _.isString(arg.chainCode) ? Buffer.from(arg.chainCode,'hex') : arg.chainCode,\n    privateKey: (_.isString(arg.privateKey) && JSUtil.isHexa(arg.privateKey)) ? Buffer.from(arg.privateKey,'hex') : arg.privateKey,\n    checksum: arg.checksum ? (arg.checksum.length ? arg.checksum : BufferUtil.integerAsBuffer(arg.checksum)) : undefined\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPrivateKey.prototype._buildFromSerialized = function(arg) {\n  var decoded = Base58Check.decode(arg);\n  var buffers = {\n    version: decoded.slice(HDPrivateKey.VersionStart, HDPrivateKey.VersionEnd),\n    depth: decoded.slice(HDPrivateKey.DepthStart, HDPrivateKey.DepthEnd),\n    parentFingerPrint: decoded.slice(HDPrivateKey.ParentFingerPrintStart,\n      HDPrivateKey.ParentFingerPrintEnd),\n    childIndex: decoded.slice(HDPrivateKey.ChildIndexStart, HDPrivateKey.ChildIndexEnd),\n    chainCode: decoded.slice(HDPrivateKey.ChainCodeStart, HDPrivateKey.ChainCodeEnd),\n    privateKey: decoded.slice(HDPrivateKey.PrivateKeyStart, HDPrivateKey.PrivateKeyEnd),\n    checksum: decoded.slice(HDPrivateKey.ChecksumStart, HDPrivateKey.ChecksumEnd),\n    xprivkey: arg\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPrivateKey.prototype._generateRandomly = function(network) {\n  return HDPrivateKey.fromSeed(Random.getRandomBuffer(64), network);\n};\n\n/**\n * Generate a private key from a seed, as described in BIP32\n *\n * @param {string|Buffer} hexa\n * @param {*} network\n * @return HDPrivateKey\n */\nHDPrivateKey.fromSeed = function(hexa, network) {\n  /* jshint maxcomplexity: 8 */\n  if (JSUtil.isHexaString(hexa)) {\n    hexa = Buffer.from(hexa, 'hex');\n  }\n  if (!Buffer.isBuffer(hexa)) {\n    throw new hdErrors.InvalidEntropyArgument(hexa);\n  }\n  if (hexa.length < MINIMUM_ENTROPY_BITS * BITS_TO_BYTES) {\n    throw new hdErrors.InvalidEntropyArgument.NotEnoughEntropy(hexa);\n  }\n  if (hexa.length > MAXIMUM_ENTROPY_BITS * BITS_TO_BYTES) {\n    throw new hdErrors.InvalidEntropyArgument.TooMuchEntropy(hexa);\n  }\n  var hash = Hash.sha512hmac(hexa, Buffer.from('Bitcoin seed'));\n\n  return new HDPrivateKey({\n    network: Network.get(network) || Network.defaultNetwork,\n    depth: 0,\n    parentFingerPrint: 0,\n    childIndex: 0,\n    privateKey: hash.slice(0, 32),\n    chainCode: hash.slice(32, 64)\n  });\n};\n\n\n\nHDPrivateKey.prototype._calcHDPublicKey = function() {\n  if (!this._hdPublicKey) {\n    var HDPublicKey = require('./hdpublickey');\n    this._hdPublicKey = new HDPublicKey(this);\n  }\n};\n\n/**\n * Receives a object with buffers in all the properties and populates the\n * internal structure\n *\n * @param {Object} arg\n * @param {buffer.Buffer} arg.version\n * @param {buffer.Buffer} arg.depth\n * @param {buffer.Buffer} arg.parentFingerPrint\n * @param {buffer.Buffer} arg.childIndex\n * @param {buffer.Buffer} arg.chainCode\n * @param {buffer.Buffer} arg.privateKey\n * @param {buffer.Buffer} arg.checksum\n * @param {string=} arg.xprivkey - if set, don't recalculate the base58\n *      representation\n * @return {HDPrivateKey} this\n */\nHDPrivateKey.prototype._buildFromBuffers = function(arg) {\n  /* jshint maxcomplexity: 8 */\n  /* jshint maxstatements: 20 */\n\n  HDPrivateKey._validateBufferArguments(arg);\n\n  JSUtil.defineImmutable(this, {\n    _buffers: arg\n  });\n\n  var sequence = [\n    arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode,\n    BufferUtil.emptyBuffer(1), arg.privateKey\n  ];\n  var concat = buffer.Buffer.concat(sequence);\n  if (!arg.checksum || !arg.checksum.length) {\n    arg.checksum = Base58Check.checksum(concat);\n  } else {\n    if (arg.checksum.toString() !== Base58Check.checksum(concat).toString()) {\n      throw new errors.InvalidB58Checksum(concat);\n    }\n  }\n\n  var network = Network.get(BufferUtil.integerFromBuffer(arg.version));\n  var xprivkey;\n  xprivkey = Base58Check.encode(buffer.Buffer.concat(sequence));\n  arg.xprivkey = Buffer.from(xprivkey);\n\n  var privateKey = new PrivateKey(BN.fromBuffer(arg.privateKey), network);\n  var publicKey = privateKey.toPublicKey();\n  var size = HDPrivateKey.ParentFingerPrintSize;\n  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);\n\n  JSUtil.defineImmutable(this, {\n    xprivkey: xprivkey,\n    network: network,\n    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),\n    privateKey: privateKey,\n    publicKey: publicKey,\n    fingerPrint: fingerPrint\n  });\n\n  this._hdPublicKey = null;\n\n  Object.defineProperty(this, 'hdPublicKey', {\n    configurable: false,\n    enumerable: true,\n    get: function() {\n      this._calcHDPublicKey();\n      return this._hdPublicKey;\n    }\n  });\n  Object.defineProperty(this, 'xpubkey', {\n    configurable: false,\n    enumerable: true,\n    get: function() {\n      this._calcHDPublicKey();\n      return this._hdPublicKey.xpubkey;\n    }\n  });\n  return this;\n};\n\nHDPrivateKey._validateBufferArguments = function(arg) {\n  var checkBuffer = function(name, size) {\n    var buff = arg[name];\n    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer');\n    assert(\n      buff.length === size,\n      name + ' has not the expected size: found ' + buff.length + ', expected ' + size\n    );\n  };\n  checkBuffer('version', HDPrivateKey.VersionSize);\n  checkBuffer('depth', HDPrivateKey.DepthSize);\n  checkBuffer('parentFingerPrint', HDPrivateKey.ParentFingerPrintSize);\n  checkBuffer('childIndex', HDPrivateKey.ChildIndexSize);\n  checkBuffer('chainCode', HDPrivateKey.ChainCodeSize);\n  checkBuffer('privateKey', HDPrivateKey.PrivateKeySize);\n  if (arg.checksum && arg.checksum.length) {\n    checkBuffer('checksum', HDPrivateKey.CheckSumSize);\n  }\n};\n\n/**\n * Returns the string representation of this private key (a string starting\n * with \"xprv...\"\n *\n * @return string\n */\nHDPrivateKey.prototype.toString = function() {\n  return this.xprivkey;\n};\n\n/**\n * Returns the console representation of this extended private key.\n * @return string\n */\nHDPrivateKey.prototype.inspect = function() {\n  return '<HDPrivateKey: ' + this.xprivkey + '>';\n};\n\n/**\n * Returns a plain object with a representation of this private key.\n *\n * Fields include:<ul>\n * <li> network: either 'livenet' or 'testnet'\n * <li> depth: a number ranging from 0 to 255\n * <li> fingerPrint: a number ranging from 0 to 2^32-1, taken from the hash of the\n * <li>     associated public key\n * <li> parentFingerPrint: a number ranging from 0 to 2^32-1, taken from the hash\n * <li>     of this parent's associated public key or zero.\n * <li> childIndex: the index from which this child was derived (or zero)\n * <li> chainCode: an hexa string representing a number used in the derivation\n * <li> privateKey: the private key associated, in hexa representation\n * <li> xprivkey: the representation of this extended private key in checksum\n * <li>     base58 format\n * <li> checksum: the base58 checksum of xprivkey\n * </ul>\n *  @return {Object}\n */\nHDPrivateKey.prototype.toObject = HDPrivateKey.prototype.toJSON = function toObject() {\n  return {\n    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version), 'xprivkey').name,\n    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),\n    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),\n    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),\n    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),\n    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),\n    privateKey: this.privateKey.toBuffer().toString('hex'),\n    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n    xprivkey: this.xprivkey\n  };\n};\n\n/**\n * Build a HDPrivateKey from a buffer\n *\n * @param {Buffer} arg\n * @return {HDPrivateKey}\n */\nHDPrivateKey.fromBuffer = function(arg) {\n  return new HDPrivateKey(arg.toString());\n};\n\n/**\n * Returns a buffer representation of the HDPrivateKey\n *\n * @return {string}\n */\nHDPrivateKey.prototype.toBuffer = function() {\n  return BufferUtil.copy(this._buffers.xprivkey);\n};\n\nHDPrivateKey.DefaultDepth = 0;\nHDPrivateKey.DefaultFingerprint = 0;\nHDPrivateKey.DefaultChildIndex = 0;\nHDPrivateKey.Hardened = 0x80000000;\nHDPrivateKey.MaxIndex = 2 * HDPrivateKey.Hardened;\n\nHDPrivateKey.RootElementAlias = ['m', 'M', 'm\\'', 'M\\''];\n\nHDPrivateKey.VersionSize = 4;\nHDPrivateKey.DepthSize = 1;\nHDPrivateKey.ParentFingerPrintSize = 4;\nHDPrivateKey.ChildIndexSize = 4;\nHDPrivateKey.ChainCodeSize = 32;\nHDPrivateKey.PrivateKeySize = 32;\nHDPrivateKey.CheckSumSize = 4;\n\nHDPrivateKey.DataLength = 78;\nHDPrivateKey.SerializedByteSize = 82;\n\nHDPrivateKey.VersionStart = 0;\nHDPrivateKey.VersionEnd = HDPrivateKey.VersionStart + HDPrivateKey.VersionSize;\nHDPrivateKey.DepthStart = HDPrivateKey.VersionEnd;\nHDPrivateKey.DepthEnd = HDPrivateKey.DepthStart + HDPrivateKey.DepthSize;\nHDPrivateKey.ParentFingerPrintStart = HDPrivateKey.DepthEnd;\nHDPrivateKey.ParentFingerPrintEnd = HDPrivateKey.ParentFingerPrintStart + HDPrivateKey.ParentFingerPrintSize;\nHDPrivateKey.ChildIndexStart = HDPrivateKey.ParentFingerPrintEnd;\nHDPrivateKey.ChildIndexEnd = HDPrivateKey.ChildIndexStart + HDPrivateKey.ChildIndexSize;\nHDPrivateKey.ChainCodeStart = HDPrivateKey.ChildIndexEnd;\nHDPrivateKey.ChainCodeEnd = HDPrivateKey.ChainCodeStart + HDPrivateKey.ChainCodeSize;\nHDPrivateKey.PrivateKeyStart = HDPrivateKey.ChainCodeEnd + 1;\nHDPrivateKey.PrivateKeyEnd = HDPrivateKey.PrivateKeyStart + HDPrivateKey.PrivateKeySize;\nHDPrivateKey.ChecksumStart = HDPrivateKey.PrivateKeyEnd;\nHDPrivateKey.ChecksumEnd = HDPrivateKey.ChecksumStart + HDPrivateKey.CheckSumSize;\n\nassert(HDPrivateKey.ChecksumEnd === HDPrivateKey.SerializedByteSize);\n\nmodule.exports = HDPrivateKey;\n","'use strict';\n\nvar _ = require('lodash');\nvar $ = require('./util/preconditions');\n\nvar BN = require('./crypto/bn');\nvar Base58 = require('./encoding/base58');\nvar Base58Check = require('./encoding/base58check');\nvar Hash = require('./crypto/hash');\nvar HDPrivateKey = require('./hdprivatekey');\nvar Network = require('./networks');\nvar Point = require('./crypto/point');\nvar PublicKey = require('./publickey');\n\nvar bitcoreErrors = require('./errors');\nvar errors = bitcoreErrors;\nvar hdErrors = bitcoreErrors.HDPublicKey;\nvar assert = require('assert');\n\nvar JSUtil = require('./util/js');\nvar BufferUtil = require('./util/buffer');\n\n/**\n * The representation of an hierarchically derived public key.\n *\n * See https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n *\n * @constructor\n * @param {Object|string|Buffer} arg\n */\nfunction HDPublicKey(arg) {\n  /* jshint maxcomplexity: 12 */\n  /* jshint maxstatements: 20 */\n  if (arg instanceof HDPublicKey) {\n    return arg;\n  }\n  if (!(this instanceof HDPublicKey)) {\n    return new HDPublicKey(arg);\n  }\n  if (arg) {\n    if (_.isString(arg) || BufferUtil.isBuffer(arg)) {\n      var error = HDPublicKey.getSerializedError(arg);\n      if (!error) {\n        return this._buildFromSerialized(arg);\n      } else if (BufferUtil.isBuffer(arg) && !HDPublicKey.getSerializedError(arg.toString())) {\n        return this._buildFromSerialized(arg.toString());\n      } else {\n        if (error instanceof hdErrors.ArgumentIsPrivateExtended) {\n          return new HDPrivateKey(arg).hdPublicKey;\n        }\n        throw error;\n      }\n    } else {\n      if (_.isObject(arg)) {\n        if (arg instanceof HDPrivateKey) {\n          return this._buildFromPrivate(arg);\n        } else {\n          return this._buildFromObject(arg);\n        }\n      } else {\n        throw new hdErrors.UnrecognizedArgument(arg);\n      }\n    }\n  } else {\n    throw new hdErrors.MustSupplyArgument();\n  }\n}\n\n/**\n * Verifies that a given path is valid.\n *\n * @param {string|number} arg\n * @return {boolean}\n */\nHDPublicKey.isValidPath = function(arg) {\n  if (_.isString(arg)) {\n    var indexes = HDPrivateKey._getDerivationIndexes(arg);\n    return indexes !== null && _.every(indexes, HDPublicKey.isValidPath);\n  }\n\n  if (_.isNumber(arg)) {\n    return arg >= 0 && arg < HDPublicKey.Hardened;\n  }\n\n  return false;\n};\n\n/**\n * WARNING: This method is deprecated. Use deriveChild instead.\n *\n *\n * Get a derivated child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same public key), \"m/0/1/40/2/1000\".\n *\n * Note that hardened keys can't be derived from a public extended key.\n *\n * If the first argument is a number, the child with that index will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPublicKey('xpub...');\n * var child_0_1_2 = parent.derive(0).derive(1).derive(2);\n * var copy_of_child_0_1_2 = parent.derive(\"m/0/1/2\");\n * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);\n * ```\n *\n * @param {string|number} arg\n */\nHDPublicKey.prototype.derive = function(arg, hardened) {\n  return this.deriveChild(arg, hardened);\n};\n\n/**\n * WARNING: This method will not be officially supported until v1.0.0.\n *\n *\n * Get a derivated child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same public key), \"m/0/1/40/2/1000\".\n *\n * Note that hardened keys can't be derived from a public extended key.\n *\n * If the first argument is a number, the child with that index will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPublicKey('xpub...');\n * var child_0_1_2 = parent.deriveChild(0).deriveChild(1).deriveChild(2);\n * var copy_of_child_0_1_2 = parent.deriveChild(\"m/0/1/2\");\n * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);\n * ```\n *\n * @param {string|number} arg\n */\nHDPublicKey.prototype.deriveChild = function(arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\n\nHDPublicKey.prototype._deriveWithNumber = function(index, hardened) {\n  if (index >= HDPublicKey.Hardened || hardened) {\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\n  }\n  if (index < 0) {\n    throw new hdErrors.InvalidPath(index);\n  }\n\n  var indexBuffer = BufferUtil.integerAsBuffer(index);\n  var data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);\n  var hash = Hash.sha512hmac(data, this._buffers.chainCode);\n  var leftPart = BN.fromBuffer(hash.slice(0, 32), {size: 32});\n  var chainCode = hash.slice(32, 64);\n\n  var publicKey;\n  try {\n    publicKey = PublicKey.fromPoint(Point.getG().mul(leftPart).add(this.publicKey.point));\n  } catch (e) {\n    return this._deriveWithNumber(index + 1);\n  }\n\n  var derived = new HDPublicKey({\n    network: this.network,\n    depth: this.depth + 1,\n    parentFingerPrint: this.fingerPrint,\n    childIndex: index,\n    chainCode: chainCode,\n    publicKey: publicKey\n  });\n\n  return derived;\n};\n\nHDPublicKey.prototype._deriveFromString = function(path) {\n  /* jshint maxcomplexity: 8 */\n  if (_.includes(path, \"'\")) {\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\n  } else if (!HDPublicKey.isValidPath(path)) {\n    throw new hdErrors.InvalidPath(path);\n  }\n\n  var indexes = HDPrivateKey._getDerivationIndexes(path);\n  var derived = indexes.reduce(function(prev, index) {\n    return prev._deriveWithNumber(index);\n  }, this);\n\n  return derived;\n};\n\n/**\n * Verifies that a given serialized public key in base58 with checksum format\n * is valid.\n *\n * @param {string|Buffer} data - the serialized public key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {boolean}\n */\nHDPublicKey.isValidSerialized = function(data, network) {\n  return _.isNull(HDPublicKey.getSerializedError(data, network));\n};\n\n/**\n * Checks what's the error that causes the validation of a serialized public key\n * in base58 with checksum to fail.\n *\n * @param {string|Buffer} data - the serialized public key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {errors|null}\n */\nHDPublicKey.getSerializedError = function(data, network) {\n  /* jshint maxcomplexity: 10 */\n  /* jshint maxstatements: 20 */\n  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {\n    return new hdErrors.UnrecognizedArgument('expected buffer or string');\n  }\n  if (!Base58.validCharacters(data)) {\n    return new errors.InvalidB58Char('(unknown)', data);\n  }\n  try {\n    data = Base58Check.decode(data);\n  } catch (e) {\n    return new errors.InvalidB58Checksum(data);\n  }\n  if (data.length !== HDPublicKey.DataSize) {\n    return new hdErrors.InvalidLength(data);\n  }\n  if (!_.isUndefined(network)) {\n    var error = HDPublicKey._validateNetwork(data, network);\n    if (error) {\n      return error;\n    }\n  }\n  var version = BufferUtil.integerFromBuffer(data.slice(0, 4));\n  if (version === Network.livenet.xprivkey || version === Network.testnet.xprivkey ) {\n    return new hdErrors.ArgumentIsPrivateExtended();\n  }\n  return null;\n};\n\nHDPublicKey._validateNetwork = function(data, networkArg) {\n  var network = Network.get(networkArg);\n  if (!network) {\n    return new errors.InvalidNetworkArgument(networkArg);\n  }\n  var version = data.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd);\n  if (BufferUtil.integerFromBuffer(version) !== network.xpubkey) {\n    return new errors.InvalidNetwork(version);\n  }\n  return null;\n};\n\nHDPublicKey.prototype._buildFromPrivate = function (arg) {\n  var args = _.clone(arg._buffers);\n  var point = Point.getG().mul(BN.fromBuffer(args.privateKey));\n  args.publicKey = Point.pointToCompressed(point);\n  args.version = BufferUtil.integerAsBuffer(Network.get(BufferUtil.integerFromBuffer(args.version)).xpubkey);\n  args.privateKey = undefined;\n  args.checksum = undefined;\n  args.xprivkey = undefined;\n  return this._buildFromBuffers(args);\n};\n\nHDPublicKey.prototype._buildFromObject = function(arg) {\n  /* jshint maxcomplexity: 10 */\n  // TODO: Type validation\n  var buffers = {\n    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xpubkey) : arg.version,\n    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,\n    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,\n    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,\n    chainCode: _.isString(arg.chainCode) ? Buffer.from(arg.chainCode,'hex') : arg.chainCode,\n    publicKey: _.isString(arg.publicKey) ? Buffer.from(arg.publicKey,'hex') :\n      BufferUtil.isBuffer(arg.publicKey) ? arg.publicKey : arg.publicKey.toBuffer(),\n    checksum: _.isNumber(arg.checksum) ? BufferUtil.integerAsBuffer(arg.checksum) : arg.checksum\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPublicKey.prototype._buildFromSerialized = function(arg) {\n  var decoded = Base58Check.decode(arg);\n  var buffers = {\n    version: decoded.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd),\n    depth: decoded.slice(HDPublicKey.DepthStart, HDPublicKey.DepthEnd),\n    parentFingerPrint: decoded.slice(HDPublicKey.ParentFingerPrintStart,\n                                     HDPublicKey.ParentFingerPrintEnd),\n    childIndex: decoded.slice(HDPublicKey.ChildIndexStart, HDPublicKey.ChildIndexEnd),\n    chainCode: decoded.slice(HDPublicKey.ChainCodeStart, HDPublicKey.ChainCodeEnd),\n    publicKey: decoded.slice(HDPublicKey.PublicKeyStart, HDPublicKey.PublicKeyEnd),\n    checksum: decoded.slice(HDPublicKey.ChecksumStart, HDPublicKey.ChecksumEnd),\n    xpubkey: arg\n  };\n  return this._buildFromBuffers(buffers);\n};\n\n/**\n * Receives a object with buffers in all the properties and populates the\n * internal structure\n *\n * @param {Object} arg\n * @param {buffer.Buffer} arg.version\n * @param {buffer.Buffer} arg.depth\n * @param {buffer.Buffer} arg.parentFingerPrint\n * @param {buffer.Buffer} arg.childIndex\n * @param {buffer.Buffer} arg.chainCode\n * @param {buffer.Buffer} arg.publicKey\n * @param {buffer.Buffer} arg.checksum\n * @param {string=} arg.xpubkey - if set, don't recalculate the base58\n *      representation\n * @return {HDPublicKey} this\n */\nHDPublicKey.prototype._buildFromBuffers = function(arg) {\n  /* jshint maxcomplexity: 8 */\n  /* jshint maxstatements: 20 */\n\n  HDPublicKey._validateBufferArguments(arg);\n\n  JSUtil.defineImmutable(this, {\n    _buffers: arg\n  });\n\n  var sequence = [\n    arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode,\n    arg.publicKey\n  ];\n  var concat = BufferUtil.concat(sequence);\n  var checksum = Base58Check.checksum(concat);\n  if (!arg.checksum || !arg.checksum.length) {\n    arg.checksum = checksum;\n  } else {\n    if (arg.checksum.toString('hex') !== checksum.toString('hex')) {\n      throw new errors.InvalidB58Checksum(concat, checksum);\n    }\n  }\n  var network = Network.get(BufferUtil.integerFromBuffer(arg.version));\n\n  var xpubkey;\n  xpubkey = Base58Check.encode(BufferUtil.concat(sequence));\n  arg.xpubkey = Buffer.from(xpubkey);\n\n  var publicKey = new PublicKey(arg.publicKey, {network: network});\n  var size = HDPublicKey.ParentFingerPrintSize;\n  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);\n\n  JSUtil.defineImmutable(this, {\n    xpubkey: xpubkey,\n    network: network,\n    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),\n    publicKey: publicKey,\n    fingerPrint: fingerPrint\n  });\n\n  return this;\n};\n\nHDPublicKey._validateBufferArguments = function(arg) {\n  var checkBuffer = function(name, size) {\n    var buff = arg[name];\n    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer, it\\'s ' + typeof buff);\n    assert(\n      buff.length === size,\n      name + ' has not the expected size: found ' + buff.length + ', expected ' + size\n    );\n  };\n  checkBuffer('version', HDPublicKey.VersionSize);\n  checkBuffer('depth', HDPublicKey.DepthSize);\n  checkBuffer('parentFingerPrint', HDPublicKey.ParentFingerPrintSize);\n  checkBuffer('childIndex', HDPublicKey.ChildIndexSize);\n  checkBuffer('chainCode', HDPublicKey.ChainCodeSize);\n  checkBuffer('publicKey', HDPublicKey.PublicKeySize);\n  if (arg.checksum && arg.checksum.length) {\n    checkBuffer('checksum', HDPublicKey.CheckSumSize);\n  }\n};\n\nHDPublicKey.fromString = function(arg) {\n  $.checkArgument(_.isString(arg), 'No valid string was provided');\n  return new HDPublicKey(arg);\n};\n\nHDPublicKey.fromObject = function(arg) {\n  $.checkArgument(_.isObject(arg), 'No valid argument was provided');\n  return new HDPublicKey(arg);\n};\n\n/**\n * Returns the base58 checked representation of the public key\n * @return {string} a string starting with \"xpub...\" in livenet\n */\nHDPublicKey.prototype.toString = function() {\n  return this.xpubkey;\n};\n\n/**\n * Returns the console representation of this extended public key.\n * @return string\n */\nHDPublicKey.prototype.inspect = function() {\n  return '<HDPublicKey: ' + this.xpubkey + '>';\n};\n\n/**\n * Returns a plain JavaScript object with information to reconstruct a key.\n *\n * Fields are: <ul>\n *  <li> network: 'livenet' or 'testnet'\n *  <li> depth: a number from 0 to 255, the depth to the master extended key\n *  <li> fingerPrint: a number of 32 bits taken from the hash of the public key\n *  <li> fingerPrint: a number of 32 bits taken from the hash of this key's\n *  <li>     parent's public key\n *  <li> childIndex: index with which this key was derived\n *  <li> chainCode: string in hexa encoding used for derivation\n *  <li> publicKey: string, hexa encoded, in compressed key format\n *  <li> checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n *  <li> xpubkey: the string with the base58 representation of this extended key\n *  <li> checksum: the base58 checksum of xpubkey\n * </ul>\n */\nHDPublicKey.prototype.toObject = HDPublicKey.prototype.toJSON = function toObject() {\n  return {\n    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version)).name,\n    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),\n    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),\n    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),\n    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),\n    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),\n    publicKey: this.publicKey.toString(),\n    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n    xpubkey: this.xpubkey\n  };\n};\n\n/**\n * Create a HDPublicKey from a buffer argument\n *\n * @param {Buffer} arg\n * @return {HDPublicKey}\n */\nHDPublicKey.fromBuffer = function(arg) {\n  return new HDPublicKey(arg);\n};\n\n/**\n * Return a buffer representation of the xpubkey\n *\n * @return {Buffer}\n */\nHDPublicKey.prototype.toBuffer = function() {\n  return BufferUtil.copy(this._buffers.xpubkey);\n};\n\nHDPublicKey.Hardened = 0x80000000;\nHDPublicKey.RootElementAlias = ['m', 'M'];\n\nHDPublicKey.VersionSize = 4;\nHDPublicKey.DepthSize = 1;\nHDPublicKey.ParentFingerPrintSize = 4;\nHDPublicKey.ChildIndexSize = 4;\nHDPublicKey.ChainCodeSize = 32;\nHDPublicKey.PublicKeySize = 33;\nHDPublicKey.CheckSumSize = 4;\n\nHDPublicKey.DataSize = 78;\nHDPublicKey.SerializedByteSize = 82;\n\nHDPublicKey.VersionStart           = 0;\nHDPublicKey.VersionEnd             = HDPublicKey.VersionStart + HDPublicKey.VersionSize;\nHDPublicKey.DepthStart             = HDPublicKey.VersionEnd;\nHDPublicKey.DepthEnd               = HDPublicKey.DepthStart + HDPublicKey.DepthSize;\nHDPublicKey.ParentFingerPrintStart = HDPublicKey.DepthEnd;\nHDPublicKey.ParentFingerPrintEnd   = HDPublicKey.ParentFingerPrintStart + HDPublicKey.ParentFingerPrintSize;\nHDPublicKey.ChildIndexStart        = HDPublicKey.ParentFingerPrintEnd;\nHDPublicKey.ChildIndexEnd          = HDPublicKey.ChildIndexStart + HDPublicKey.ChildIndexSize;\nHDPublicKey.ChainCodeStart         = HDPublicKey.ChildIndexEnd;\nHDPublicKey.ChainCodeEnd           = HDPublicKey.ChainCodeStart + HDPublicKey.ChainCodeSize;\nHDPublicKey.PublicKeyStart         = HDPublicKey.ChainCodeEnd;\nHDPublicKey.PublicKeyEnd           = HDPublicKey.PublicKeyStart + HDPublicKey.PublicKeySize;\nHDPublicKey.ChecksumStart          = HDPublicKey.PublicKeyEnd;\nHDPublicKey.ChecksumEnd            = HDPublicKey.ChecksumStart + HDPublicKey.CheckSumSize;\n\nassert(HDPublicKey.PublicKeyEnd === HDPublicKey.DataSize);\nassert(HDPublicKey.ChecksumEnd === HDPublicKey.SerializedByteSize);\n\nmodule.exports = HDPublicKey;\n","'use strict';\n\nvar _ = require('lodash');\nvar PrivateKey = require('./privatekey');\nvar PublicKey = require('./publickey');\nvar Address = require('./address');\nvar BufferWriter = require('./encoding/bufferwriter');\nvar ECDSA = require('./crypto/ecdsa');\nvar Signature = require('./crypto/signature');\nvar sha256sha256 = require('./crypto/hash').sha256sha256;\nvar JSUtil = require('./util/js');\nvar $ = require('./util/preconditions');\n\nfunction Message(message) {\n  if (!(this instanceof Message)) {\n    return new Message(message);\n  }\n  $.checkArgument(_.isString(message), 'First argument should be a string');\n  this.message = message;\n\n  return this;\n}\n\nMessage.MAGIC_BYTES = Buffer.from('Bitcoin Signed Message:\\n');\n\nMessage.prototype.magicHash = function magicHash() {\n  var prefix1 = BufferWriter.varintBufNum(Message.MAGIC_BYTES.length);\n  var messageBuffer = Buffer.from(this.message);\n  var prefix2 = BufferWriter.varintBufNum(messageBuffer.length);\n  var buf = Buffer.concat([prefix1, Message.MAGIC_BYTES, prefix2, messageBuffer]);\n  var hash = sha256sha256(buf);\n  return hash;\n};\n\nMessage.prototype._sign = function _sign(privateKey) {\n  $.checkArgument(privateKey instanceof PrivateKey, 'First argument should be an instance of PrivateKey');\n  const hash = this.magicHash();\n  const sig = ECDSA.sign(hash, privateKey, { randomK: true });\n  ECDSA.calci(hash, sig, privateKey.toPublicKey());\n  return sig;\n};\n\n/**\n * Will sign a message with a given bitcoin private key.\n *\n * @param {PrivateKey} privateKey - An instance of PrivateKey\n * @returns {String} A base64 encoded compact signature\n */\nMessage.prototype.sign = function sign(privateKey) {\n  var signature = this._sign(privateKey);\n  return signature.toCompact().toString('base64');\n};\n\nMessage.prototype._verify = function _verify(publicKey, signature) {\n  $.checkArgument(publicKey instanceof PublicKey, 'First argument should be an instance of PublicKey');\n  $.checkArgument(signature instanceof Signature, 'Second argument should be an instance of Signature');\n  var hash = this.magicHash();\n  var verified = ECDSA.verify(hash, signature, publicKey);\n  if (!verified) {\n    this.error = 'The signature was invalid';\n  }\n  return verified;\n};\n\n/**\n * Will return a boolean of the signature is valid for a given bitcoin address.\n * If it isn't the specific reason is accessible via the \"error\" member.\n *\n * @param {Address|String} bitcoinAddress - A bitcoin address\n * @param {String} signatureString - A base64 encoded compact signature\n * @returns {Boolean}\n */\nMessage.prototype.verify = function verify(bitcoinAddress, signatureString) {\n  $.checkArgument(bitcoinAddress);\n  $.checkArgument(signatureString && _.isString(signatureString));\n\n  if (_.isString(bitcoinAddress)) {\n    bitcoinAddress = Address.fromString(bitcoinAddress);\n  }\n  var signature = Signature.fromCompact(Buffer.from(signatureString, 'base64'));\n\n  // recover the public key\n  const hashbuf = this.magicHash();\n  var publicKey = ECDSA.recoverPublicKey(hashbuf, signature);\n\n  var signatureAddress = Address.fromPublicKey(publicKey, bitcoinAddress.network);\n\n  // check that the recovered address and specified address match\n  if (bitcoinAddress.toString() !== signatureAddress.toString()) {\n    this.error = 'The signature did not match the message digest';\n    return false;\n  }\n\n  return this._verify(publicKey, signature);\n};\n\n/**\n * Will return a public key string if the provided signature and the message digest is correct\n * If it isn't the specific reason is accessible via the \"error\" member.\n *\n * @param {Address|String} bitcoinAddress - A bitcoin address\n * @param {String} signatureString - A base64 encoded compact signature\n * @returns {String}\n */\nMessage.prototype.recoverPublicKey = function recoverPublicKey(bitcoinAddress, signatureString) {\n  $.checkArgument(bitcoinAddress);\n  $.checkArgument(signatureString && _.isString(signatureString));\n\n  if (_.isString(bitcoinAddress)) {\n    bitcoinAddress = Address.fromString(bitcoinAddress);\n  }\n  var signature = Signature.fromCompact(Buffer.from(signatureString, 'base64'));\n\n  // recover the public key\n  const hashbuf = this.magicHash();\n  var publicKey = ECDSA.recoverPublicKey(hashbuf, signature);\n\n  var signatureAddress = Address.fromPublicKey(publicKey, bitcoinAddress.network);\n\n  // check that the recovered address and specified address match\n  if (bitcoinAddress.toString() !== signatureAddress.toString()) {\n    this.error = 'The signature did not match the message digest';\n  }\n\n  return publicKey.toString();\n};\n\n/**\n * Instantiate a message from a message string\n *\n * @param {String} str - A string of the message\n * @returns {Message} A new instance of a Message\n */\nMessage.fromString = function(str) {\n  return new Message(str);\n};\n\n/**\n * Instantiate a message from JSON\n *\n * @param {String} json - An JSON string or Object with keys: message\n * @returns {Message} A new instance of a Message\n */\nMessage.fromJSON = function fromJSON(json) {\n  if (JSUtil.isValidJSON(json)) {\n    json = JSON.parse(json);\n  }\n  return new Message(json.message);\n};\n\n/**\n * @returns {Object} A plain object with the message information\n */\nMessage.prototype.toObject = function toObject() {\n  return {\n    message: this.message\n  };\n};\n\n/**\n * @returns {String} A JSON representation of the message information\n */\nMessage.prototype.toJSON = function toJSON() {\n  return JSON.stringify(this.toObject());\n};\n\n/**\n * Will return a the string representation of the message\n *\n * @returns {String} Message\n */\nMessage.prototype.toString = function() {\n  return this.message;\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {String} Message\n */\nMessage.prototype.inspect = function() {\n  return '<Message: ' + this.toString() + '>';\n};\n\nmodule.exports = Message;\n\nvar Script = require('./script');\n","'use strict';\nvar BufferUtil = require('./util/buffer');\nvar JSUtil = require('./util/js');\nvar networks = [];\nvar networkMaps = {};\n\n/**\n * A network is merely a map containing values that correspond to version\n * numbers for each bitcoin network. Currently only supporting \"livenet\"\n * (a.k.a. \"mainnet\") and \"testnet\".\n * @constructor\n */\nfunction Network() {}\n\nNetwork.prototype.toString = function toString() {\n  return this.name;\n};\n\n/**\n * @function\n * @member Networks#get\n * Retrieves the network associated with a magic number or string.\n * @param {string|number|Network} arg\n * @param {string|Array} keys - if set, only check if the magic number associated with this name matches\n * @return Network\n */\nfunction get(arg, keys) {\n  if (~networks.indexOf(arg)) {\n    return arg;\n  }\n  if (keys) {\n    if (!Array.isArray(keys)) {\n      keys = [keys];\n    }\n    for (const index in networks) {\n      if (keys.some(key => networks[index][key] === arg)) {\n        return networks[index];\n      }\n    }\n    return undefined;\n  }\n  if (networkMaps[arg] && networkMaps[arg].length >= 1) {\n    return networkMaps[arg][0];\n  } else {\n    return networkMaps[arg];\n  }\n}\n\n/**\n * @function\n * @member Networks#is\n * Returns true if the string is the network name or alias\n * @param {string} str - A string to check\n * @return boolean\n */\nfunction is(str) {\n  return this.name == str || this.alias == str;\n}\n\n/**\n * @function\n * @member Networks#add\n * Will add a custom Network\n * @param {Object} data\n * @param {string} data.name - The name of the network\n * @param {string} data.alias - The aliased name of the network\n * @param {Number} data.pubkeyhash - The publickey hash prefix\n * @param {Number} data.privatekey - The privatekey prefix\n * @param {Number} data.scripthash - The scripthash prefix\n * @param {string} data.bech32prefix - The native segwit prefix\n * @param {Number} data.xpubkey - The extended public key magic\n * @param {Number} data.xprivkey - The extended private key magic\n * @param {Array}  data.variants - An array of variants\n * @param {string} data.variants.name - The name of the variant\n * @param {Number} data.variants.networkMagic - The network magic number\n * @param {Number} data.variants.port - The network port\n * @param {Array}  data.variants.dnsSeeds - An array of dns seeds\n * @return Network\n */\nfunction addNetwork(data) {\n  var network = new Network();\n\n  JSUtil.defineImmutable(network, {\n    name: data.name,\n    alias: data.alias,\n    is: data.is,\n    pubkeyhash: data.pubkeyhash,\n    privatekey: data.privatekey,\n    scripthash: data.scripthash,\n    bech32prefix: data.bech32prefix,\n    xpubkey: data.xpubkey,\n    xprivkey: data.xprivkey\n  });\n\n  if (data.networkMagic) {\n    JSUtil.defineImmutable(network, {\n      networkMagic: BufferUtil.integerAsBuffer(data.networkMagic)\n    });\n  }\n\n  if (data.port) {\n    JSUtil.defineImmutable(network, {\n      port: data.port\n    });\n  }\n\n  if (data.dnsSeeds) {\n    JSUtil.defineImmutable(network, {\n      dnsSeeds: data.dnsSeeds\n    });\n  }\n\n  for (const value of Object.values(network)) {\n    if (value != null && typeof value !== 'object') {\n      if (!networkMaps[value]) {\n        networkMaps[value] = [];\n      }\n      networkMaps[value].push(network);\n    }\n  };\n\n  networks.push(network);\n\n  for (const variant of data.variants || []) {\n    addNetwork({\n      ...data,\n      variants: undefined,\n      ...variant,\n    });\n  }\n\n  return network;\n}\n\n/**\n * @function\n * @member Networks#remove\n * Will remove a custom network\n * @param {Network} network\n */\nfunction removeNetwork(network) {\n  if (typeof network !== 'object') {\n    network = get(network);\n  }\n  for (var i = 0; i < networks.length; i++) {\n    if (networks[i] === network) {\n      networks.splice(i, 1);\n    }\n  }\n  for (var key in networkMaps) {\n    if (networkMaps[key].length) {\n      const index = networkMaps[key].indexOf(network);\n      if (index >= 0) {\n        networkMaps[key].splice(index, 1);\n      }\n      if (networkMaps[key].length === 0) {\n        delete networkMaps[key];\n      }\n    } else if (networkMaps[key] === network) {\n      delete networkMaps[key];\n    }\n  }\n}\n\naddNetwork({\n  name: 'livenet',\n  alias: 'mainnet',\n  is,\n  pubkeyhash: 0x00,\n  privatekey: 0x80,\n  scripthash: 0x05,\n  bech32prefix: 'bc',\n  xpubkey: 0x0488b21e,\n  xprivkey: 0x0488ade4,\n  networkMagic: 0xf9beb4d9,\n  port: 8333,\n  dnsSeeds: [\n    'seed.bitcoin.sipa.be',\n    'dnsseed.bluematt.me',\n    'dnsseed.bitcoin.dashjr.org',\n    'seed.bitcoinstats.com',\n    'seed.bitnodes.io',\n    'bitseed.xf2.org'\n  ]\n});\n\n/**\n * @instance\n * @member Networks#livenet\n */\nvar livenet = get('livenet');\n\naddNetwork({\n  name: 'testnet',\n  alias: 'testnet',\n  is,\n  pubkeyhash: 0x6f,\n  privatekey: 0xef,\n  scripthash: 0xc4,\n  bech32prefix: 'tb',\n  xpubkey: 0x043587cf,\n  xprivkey: 0x04358394,\n  variants: [{\n    name: 'testnet3',\n    networkMagic: 0x0b110907,\n    port: 18333,\n    dnsSeeds: [\n      'testnet-seed.bitcoin.petertodd.org',\n      'testnet-seed.bluematt.me',\n      'testnet-seed.alexykot.me',\n      'testnet-seed.bitcoin.schildbach.de'\n    ]\n  }, {\n    name: 'signet',\n    networkMagic: 0x0a03cf40,\n    port: 38333,\n    dnsSeeds: [\n      '178.128.221.177',\n      '103.16.128.63',\n      '153.126.143.201',\n      '192.241.163.142'\n    ]\n  }, {\n    name: 'testnet4',\n    networkMagic: 0x1c163f28,\n    port: 48333,\n    dnsSeeds: [\n      '18.189.156.102',\n      '18.201.207.55',\n      '51.158.248.8',\n      '57.128.176.163',\n      '82.67.102.15',\n      '88.99.248.50',\n      '95.217.73.162',\n      '103.99.171.212',\n      '103.165.192.210',\n    ]\n  }]\n});\n\n/**\n * @instance\n * @member Networks#testnet\n */\nvar testnet = get('testnet');\nvar testnet3 = get('testnet3');\nvar signet = get('signet');\n\naddNetwork({\n  name: 'regtest',\n  alias: 'dev',\n  is,\n  pubkeyhash: 0x6f,\n  privatekey: 0xef,\n  scripthash: 0xc4,\n  bech32prefix: 'bcrt',\n  xpubkey: 0x043587cf,\n  xprivkey: 0x04358394,\n  networkMagic: 0xfabfb5da,\n  port: 18444,\n  dnsSeeds: []\n});\n\n/**\n * @instance\n * @member Networks#regtest\n */\nvar regtest = get('regtest');\n\n/**\n * @function\n * @deprecated\n * @member Networks#enableRegtest\n * Will enable regtest features for testnet\n */\nfunction enableRegtest() {\n  testnet.regtestEnabled = true;\n}\n\n/**\n * @function\n * @deprecated\n * @member Networks#disableRegtest\n * Will disable regtest features for testnet\n */\nfunction disableRegtest() {\n  testnet.regtestEnabled = false;\n}\n\n/**\n * @namespace Networks\n */\nmodule.exports = {\n  add: addNetwork,\n  remove: removeNetwork,\n  defaultNetwork: livenet,\n  livenet: livenet,\n  mainnet: livenet,\n  testnet: testnet,\n  testnet3: testnet3,\n  signet: signet,\n  regtest: regtest,\n  get: get,\n  enableRegtest: enableRegtest,\n  disableRegtest: disableRegtest\n};\n","'use strict';\n\nvar _ = require('lodash');\nvar $ = require('./util/preconditions');\nvar BufferUtil = require('./util/buffer');\nvar JSUtil = require('./util/js');\n\nfunction Opcode(num) {\n  if (!(this instanceof Opcode)) {\n    return new Opcode(num);\n  }\n\n  var value;\n\n  if (_.isNumber(num)) {\n    value = num;\n  } else if (_.isString(num)) {\n    value = Opcode.map[num];\n  } else {\n    throw new TypeError('Unrecognized num type: \"' + typeof(num) + '\" for Opcode');\n  }\n\n  JSUtil.defineImmutable(this, {\n    num: value\n  });\n\n  return this;\n}\n\nOpcode.fromBuffer = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf));\n  return new Opcode(Number('0x' + buf.toString('hex')));\n};\n\nOpcode.fromNumber = function(num) {\n  $.checkArgument(_.isNumber(num));\n  return new Opcode(num);\n};\n\nOpcode.fromString = function(str) {\n  $.checkArgument(_.isString(str));\n  var value = Opcode.map[str];\n  if (typeof value === 'undefined') {\n    throw new TypeError('Invalid opcodestr');\n  }\n  return new Opcode(value);\n};\n\nOpcode.prototype.toHex = function() {\n  return this.num.toString(16);\n};\n\nOpcode.prototype.toBuffer = function() {\n  return Buffer.from(this.toHex(), 'hex');\n};\n\nOpcode.prototype.toNumber = function() {\n  return this.num;\n};\n\nOpcode.prototype.toString = function() {\n  var str = Opcode.reverseMap[this.num];\n  if (typeof str === 'undefined') {\n    throw new Error('Opcode does not have a string representation');\n  }\n  return str;\n};\n\nOpcode.smallInt = function(n) {\n  $.checkArgument(_.isNumber(n), 'Invalid Argument: n should be number');\n  $.checkArgument(n >= 0 && n <= 16, 'Invalid Argument: n must be between 0 and 16');\n  if (n === 0) {\n    return Opcode('OP_0');\n  }\n  return new Opcode(Opcode.map.OP_1 + n - 1);\n};\n\n/**\n * Converts OP_0 - OP_16 to an int\n * @param {Number} opcode Opcode\n * @returns {Number}\n */\nOpcode.decodeOpN = function(opcode) {\n  if (opcode === Opcode.OP_0) {\n    return 0;\n  }\n  $.checkArgument(opcode >= Opcode.OP_1 && opcode <= Opcode.OP_16, new Error('Invalid opcode: ' + JSON.stringify(opcode)));\n  return opcode - (Opcode.OP_1 - 1);\n};\n\n/**\n * Returns true if given opcode is classified as a \"success\".\n * This was taken from commit https://github.com/bitcoin/bitcoin/commit/72422ce396b8eba7b1a72c171c2f07dae691d1b5\n * @param {Number|String} opcode \n * @returns {Boolean}\n */\nOpcode.isOpSuccess = function(opcode) {\n  if (typeof opcode === 'string' && !parseInt(opcode)) {\n    opcode = Opcode[opcode];\n  }\n  return opcode == 80 || opcode == 98 || (opcode >= 126 && opcode <= 129) ||\n        (opcode >= 131 && opcode <= 134) || (opcode >= 137 && opcode <= 138) ||\n        (opcode >= 141 && opcode <= 142) || (opcode >= 149 && opcode <= 153) ||\n        (opcode >= 187 && opcode <= 254);\n};\n\n\nOpcode.map = {\n  // push value\n  OP_FALSE: 0,\n  OP_0: 0,\n  OP_PUSHDATA1: 76,\n  OP_PUSHDATA2: 77,\n  OP_PUSHDATA4: 78,\n  OP_1NEGATE: 79,\n  OP_RESERVED: 80,\n  OP_TRUE: 81,\n  OP_1: 81,\n  OP_2: 82,\n  OP_3: 83,\n  OP_4: 84,\n  OP_5: 85,\n  OP_6: 86,\n  OP_7: 87,\n  OP_8: 88,\n  OP_9: 89,\n  OP_10: 90,\n  OP_11: 91,\n  OP_12: 92,\n  OP_13: 93,\n  OP_14: 94,\n  OP_15: 95,\n  OP_16: 96,\n\n  // control\n  OP_NOP: 97,\n  OP_VER: 98,\n  OP_IF: 99,\n  OP_NOTIF: 100,\n  OP_VERIF: 101,\n  OP_VERNOTIF: 102,\n  OP_ELSE: 103,\n  OP_ENDIF: 104,\n  OP_VERIFY: 105,\n  OP_RETURN: 106,\n\n  // stack ops\n  OP_TOALTSTACK: 107,\n  OP_FROMALTSTACK: 108,\n  OP_2DROP: 109,\n  OP_2DUP: 110,\n  OP_3DUP: 111,\n  OP_2OVER: 112,\n  OP_2ROT: 113,\n  OP_2SWAP: 114,\n  OP_IFDUP: 115,\n  OP_DEPTH: 116,\n  OP_DROP: 117,\n  OP_DUP: 118,\n  OP_NIP: 119,\n  OP_OVER: 120,\n  OP_PICK: 121,\n  OP_ROLL: 122,\n  OP_ROT: 123,\n  OP_SWAP: 124,\n  OP_TUCK: 125,\n\n  // splice ops\n  OP_CAT: 126,\n  OP_SUBSTR: 127,\n  OP_LEFT: 128,\n  OP_RIGHT: 129,\n  OP_SIZE: 130,\n\n  // bit logic\n  OP_INVERT: 131,\n  OP_AND: 132,\n  OP_OR: 133,\n  OP_XOR: 134,\n  OP_EQUAL: 135,\n  OP_EQUALVERIFY: 136,\n  OP_RESERVED1: 137,\n  OP_RESERVED2: 138,\n\n  // numeric\n  OP_1ADD: 139,\n  OP_1SUB: 140,\n  OP_2MUL: 141,\n  OP_2DIV: 142,\n  OP_NEGATE: 143,\n  OP_ABS: 144,\n  OP_NOT: 145,\n  OP_0NOTEQUAL: 146,\n\n  OP_ADD: 147,\n  OP_SUB: 148,\n  OP_MUL: 149,\n  OP_DIV: 150,\n  OP_MOD: 151,\n  OP_LSHIFT: 152,\n  OP_RSHIFT: 153,\n\n  OP_BOOLAND: 154,\n  OP_BOOLOR: 155,\n  OP_NUMEQUAL: 156,\n  OP_NUMEQUALVERIFY: 157,\n  OP_NUMNOTEQUAL: 158,\n  OP_LESSTHAN: 159,\n  OP_GREATERTHAN: 160,\n  OP_LESSTHANOREQUAL: 161,\n  OP_GREATERTHANOREQUAL: 162,\n  OP_MIN: 163,\n  OP_MAX: 164,\n\n  OP_WITHIN: 165,\n\n  // crypto\n  OP_RIPEMD160: 166,\n  OP_SHA1: 167,\n  OP_SHA256: 168,\n  OP_HASH160: 169,\n  OP_HASH256: 170,\n  OP_CODESEPARATOR: 171,\n  OP_CHECKSIG: 172,\n  OP_CHECKSIGVERIFY: 173,\n  OP_CHECKMULTISIG: 174,\n  OP_CHECKMULTISIGVERIFY: 175,\n\n  OP_CHECKLOCKTIMEVERIFY: 177,\n  OP_CHECKSEQUENCEVERIFY: 178,\n\n  // expansion\n  OP_NOP1: 176,\n  OP_NOP2: 177,\n  OP_NOP3: 178,\n  OP_NOP4: 179,\n  OP_NOP5: 180,\n  OP_NOP6: 181,\n  OP_NOP7: 182,\n  OP_NOP8: 183,\n  OP_NOP9: 184,\n  OP_NOP10: 185,\n\n  // Opcode added by BIP 342 (Tapscript)\n  OP_CHECKSIGADD: 186, // 0xba\n\n  // template matching params\n  OP_PUBKEYHASH: 253,\n  OP_PUBKEY: 254,\n  OP_INVALIDOPCODE: 255\n};\n\nOpcode.reverseMap = [];\n\nfor (var k in Opcode.map) {\n  Opcode.reverseMap[Opcode.map[k]] = k;\n}\n\n// Easier access to opcodes\n_.extend(Opcode, Opcode.map);\n\n/**\n * @returns true if opcode is one of OP_0, OP_1, ..., OP_16\n */\nOpcode.isSmallIntOp = function(opcode) {\n  if (opcode instanceof Opcode) {\n    opcode = opcode.toNumber();\n  }\n  return ((opcode === Opcode.map.OP_0) ||\n    ((opcode >= Opcode.map.OP_1) && (opcode <= Opcode.map.OP_16)));\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Script opcode\n */\nOpcode.prototype.inspect = function() {\n  return '<Opcode: ' + this.toString() + ', hex: '+this.toHex()+', decimal: '+this.num+'>';\n};\n\nmodule.exports = Opcode;\n","'use strict';\n\nvar _ = require('lodash');\nvar Address = require('./address');\nvar Base58Check = require('./encoding/base58check');\nvar BN = require('./crypto/bn');\nvar JSUtil = require('./util/js');\nvar Networks = require('./networks');\nvar Point = require('./crypto/point');\nvar PublicKey = require('./publickey');\nvar Random = require('./crypto/random');\nvar $ = require('./util/preconditions');\nconst TaggedHash = require('./crypto/taggedhash');\n\n/**\n * Instantiate a PrivateKey from a BN, Buffer and WIF.\n *\n * @example\n * ```javascript\n * // generate a new random key\n * var key = PrivateKey();\n *\n * // get the associated address\n * var address = key.toAddress();\n *\n * // encode into wallet export format\n * var exported = key.toWIF();\n *\n * // instantiate from the exported (and saved) private key\n * var imported = PrivateKey.fromWIF(exported);\n * ```\n *\n * @param {string} data - The encoded data in various formats\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {PrivateKey} A new valid instance of an PrivateKey\n * @constructor\n */\nfunction PrivateKey(data, network) {\n  /* jshint maxstatements: 20 */\n  /* jshint maxcomplexity: 8 */\n\n  if (!(this instanceof PrivateKey)) {\n    return new PrivateKey(data, network);\n  }\n  if (data instanceof PrivateKey) {\n    return data;\n  }\n\n  var info = this._classifyArguments(data, network);\n\n  // validation\n  if (!info.bn || info.bn.cmp(new BN(0)) === 0){\n    throw new TypeError('Number can not be equal to zero, undefined, null or false');\n  }\n  if (!info.bn.lt(Point.getN())) {\n    throw new TypeError('Number must be less than N');\n  }\n  if (typeof(info.network) === 'undefined') {\n    throw new TypeError('Must specify the network (\"livenet\" or \"testnet\")');\n  }\n\n  JSUtil.defineImmutable(this, {\n    bn: info.bn,\n    compressed: info.compressed,\n    network: info.network\n  });\n\n  Object.defineProperty(this, 'publicKey', {\n    configurable: false,\n    enumerable: true,\n    get: this.toPublicKey.bind(this)\n  });\n\n  return this;\n\n};\n\n/**\n * Internal helper to instantiate PrivateKey internal `info` object from\n * different kinds of arguments passed to the constructor.\n *\n * @param {*} data\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @return {Object}\n */\nPrivateKey.prototype._classifyArguments = function(data, network) {\n  /* jshint maxcomplexity: 10 */\n  var info = {\n    compressed: true,\n    network: network ? Networks.get(network) : Networks.defaultNetwork\n  };\n\n  // detect type of data\n  if (_.isUndefined(data) || _.isNull(data)){\n    info.bn = PrivateKey._getRandomBN();\n  } else if (data instanceof BN) {\n    info.bn = data;\n  } else if (data instanceof Buffer || data instanceof Uint8Array) {\n    info = PrivateKey._transformBuffer(data, network);\n  } else if (data.bn && data.network){\n    info = PrivateKey._transformObject(data);\n  } else if (!network && Networks.get(data)) {\n    info.bn = PrivateKey._getRandomBN();\n    info.network = Networks.get(data);\n  } else if (typeof(data) === 'string'){\n    if (JSUtil.isHexa(data)) {\n      info.bn = new BN(Buffer.from(data, 'hex'));\n    } else {\n      info = PrivateKey._transformWIF(data, network);\n    }\n  } else {\n    throw new TypeError('First argument is an unrecognized data type.');\n  }\n  return info;\n};\n\n/**\n * Internal function to get a random Big Number (BN)\n *\n * @returns {BN} A new randomly generated BN\n * @private\n */\nPrivateKey._getRandomBN = function(){\n  var condition;\n  var bn;\n  do {\n    var privbuf = Random.getRandomBuffer(32);\n    bn = BN.fromBuffer(privbuf);\n    condition = bn.lt(Point.getN());\n  } while (!condition);\n  return bn;\n};\n\n/**\n * Internal function to transform a WIF Buffer into a private key\n *\n * @param {Buffer} buf - An WIF string\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\nPrivateKey._transformBuffer = function(buf, network) {\n\n  var info = {};\n\n  if (buf.length === 32) {\n    return PrivateKey._transformBNBuffer(buf, network);\n  }\n\n  info.network = Networks.get(buf[0], 'privatekey');\n\n  if (!info.network) {\n    throw new Error('Invalid network');\n  }\n\n  if (network && info.network !== Networks.get(network)) {\n    throw new TypeError('Private key network mismatch');\n  }\n\n  if (buf.length === 1 + 32 + 1 && buf[1 + 32 + 1 - 1] === 1) {\n    info.compressed = true;\n  } else if (buf.length === 1 + 32) {\n    info.compressed = false;\n  } else {\n    throw new Error('Length of buffer must be 33 (uncompressed) or 34 (compressed)');\n  }\n\n  info.bn = BN.fromBuffer(buf.slice(1, 32 + 1));\n\n  return info;\n};\n\n/**\n * Internal function to transform a BN buffer into a private key\n *\n * @param {Buffer} buf\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {object} an Object with keys: bn, network, and compressed\n * @private\n */\nPrivateKey._transformBNBuffer = function(buf, network) {\n  var info = {};\n  info.network = Networks.get(network) || Networks.defaultNetwork;\n  info.bn = BN.fromBuffer(buf);\n  info.compressed = false;\n  return info;\n};\n\n/**\n * Internal function to transform a WIF string into a private key\n *\n * @param {string} buf - An WIF string\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\nPrivateKey._transformWIF = function(str, network) {\n  return PrivateKey._transformBuffer(Base58Check.decode(str), network);\n};\n\n/**\n * Instantiate a PrivateKey from a Buffer with the DER or WIF representation\n *\n * @param {Buffer} arg\n * @param {Network} network\n * @return {PrivateKey}\n */\nPrivateKey.fromBuffer = function(arg, network) {\n  return new PrivateKey(arg, network);\n};\n\n/**\n * Internal function to transform a JSON string on plain object into a private key\n * return this.\n *\n * @param {string} json - A JSON string or plain object\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\nPrivateKey._transformObject = function(json) {\n  var bn = new BN(json.bn, 'hex');\n  var network = Networks.get(json.network);\n  return {\n    bn: bn,\n    network: network,\n    compressed: json.compressed\n  };\n};\n\n/**\n * Instantiate a PrivateKey from a WIF string\n *\n * @param {string} str - The WIF encoded private key string\n * @returns {PrivateKey} A new valid instance of PrivateKey\n */\nPrivateKey.fromString = PrivateKey.fromWIF = function(str) {\n  $.checkArgument(_.isString(str), 'First argument is expected to be a string.');\n  return new PrivateKey(str);\n};\n\n/**\n * Instantiate a PrivateKey from a plain JavaScript object\n *\n * @param {Object} obj - The output from privateKey.toObject()\n */\nPrivateKey.fromObject = function(obj) {\n  $.checkArgument(_.isObject(obj), 'First argument is expected to be an object.');\n  return new PrivateKey(obj);\n};\n\n/**\n * Instantiate a PrivateKey from random bytes\n *\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {PrivateKey} A new valid instance of PrivateKey\n */\nPrivateKey.fromRandom = function(network) {\n  var bn = PrivateKey._getRandomBN();\n  return new PrivateKey(bn, network);\n};\n\n/**\n * Check if there would be any errors when initializing a PrivateKey\n *\n * @param {string} data - The encoded data in various formats\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {null|Error} An error if exists\n */\nPrivateKey.getValidationError = function(data, network) {\n  var error;\n  try {\n    /* jshint nonew: false */\n    new PrivateKey(data, network);\n  } catch (e) {\n    error = e;\n  }\n  return error;\n};\n\n/**\n * Check if the parameters are valid\n *\n * @param {string} data - The encoded data in various formats\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {Boolean} If the private key is would be valid\n */\nPrivateKey.isValid = function(data, network){\n  if (!data) {\n    return false;\n  }\n  return !PrivateKey.getValidationError(data, network);\n};\n\n/**\n * Will output the PrivateKey encoded as hex string\n *\n * @returns {string}\n */\nPrivateKey.prototype.toString = function() {\n  return this.toBuffer().toString('hex');\n};\n\n/**\n * Will output the PrivateKey to a WIF string\n *\n * @returns {string} A WIP representation of the private key\n */\nPrivateKey.prototype.toWIF = function() {\n  var network = this.network;\n  var compressed = this.compressed;\n\n  var buf;\n  if (compressed) {\n    buf = Buffer.concat([Buffer.from([network.privatekey]),\n                         this.bn.toBuffer({size: 32}),\n                         Buffer.from([0x01])]);\n  } else {\n    buf = Buffer.concat([Buffer.from([network.privatekey]),\n                         this.bn.toBuffer({size: 32})]);\n  }\n\n  return Base58Check.encode(buf);\n};\n\n/**\n * Will return the private key as a BN instance\n *\n * @returns {BN} A BN instance of the private key\n */\nPrivateKey.prototype.toBigNumber = function(){\n  return this.bn;\n};\n\n/**\n * Will return the private key as a BN buffer\n *\n * @returns {Buffer} A buffer of the private key\n */\nPrivateKey.prototype.toBuffer = function(){\n  return this.bn.toBuffer({size: 32});\n};\n\n/**\n * WARNING: This method will not be officially supported until v1.0.0.\n *\n *\n * Will return the private key as a BN buffer without leading zero padding\n *\n * @returns {Buffer} A buffer of the private key\n */\nPrivateKey.prototype.toBufferNoPadding = function() {\n  return this.bn.toBuffer();\n};\n\n/**\n * Will return the corresponding public key\n *\n * @returns {PublicKey} A public key generated from the private key\n */\nPrivateKey.prototype.toPublicKey = function(){\n  if (!this._pubkey) {\n    this._pubkey = PublicKey.fromPrivateKey(this);\n  }\n  return this._pubkey;\n};\n\n/**\n * Will return an address for the private key\n * @param {Network=} network - optional parameter specifying\n * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', or 'scripthash'\n * the desired network for the address\n *\n * @returns {Address} An address generated from the private key\n */\nPrivateKey.prototype.toAddress = function(network, type) {\n  var pubkey = this.toPublicKey();\n  return Address.fromPublicKey(pubkey, network || this.network, type);\n};\n\n/**\n * @returns {Object} A plain object representation\n */\nPrivateKey.prototype.toObject = PrivateKey.prototype.toJSON = function toObject() {\n  return {\n    bn: this.bn.toString('hex'),\n    compressed: this.compressed,\n    network: this.network.toString()\n  };\n};\n\n/**\n * Create a tweaked version of this private key\n * @param {Buffer} merkleRoot (optional)\n * @returns {{ tweakedPrivKey: Buffer }}\n */\nPrivateKey.prototype.createTapTweak = function(merkleRoot) {\n  const order = Point.getN();\n  const P = Point.getG().mul(this.bn);\n  const secKey = P.y.isEven() ? this.bn : order.sub(this.bn);\n  const taggedWriter = new TaggedHash('TapTweak');\n  taggedWriter.write(P.x.toBuffer({ size: 32 }));\n\n  if (merkleRoot) {\n    $.checkArgument(Buffer.isBuffer(merkleRoot) && merkleRoot.length === 32, 'merkleRoot must be 32 byte buffer');\n    taggedWriter.write(merkleRoot);\n  }\n  const tweakHash = taggedWriter.finalize();\n\n  $.checkState(BN.fromBuffer(tweakHash).lt(order), 'TapTweak hash failed secp256k1 order check');\n  return {\n    tweakedPrivKey: secKey.add(new BN(tweakHash)).mod(order).toBuffer({ size: 32 })\n  };\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Private key\n */\nPrivateKey.prototype.inspect = function() {\n  var uncompressed = !this.compressed ? ', uncompressed' : '';\n  return '<PrivateKey: ' + this.toString() + ', network: ' + this.network + uncompressed + '>';\n};\n\nmodule.exports = PrivateKey;\n","'use strict';\n\nvar BN = require('./crypto/bn');\nvar Point = require('./crypto/point');\nvar Hash = require('./crypto/hash');\nvar JSUtil = require('./util/js');\nvar Network = require('./networks');\nvar _ = require('lodash');\nvar $ = require('./util/preconditions');\nconst TaggedHash = require('./crypto/taggedhash');\n\n/**\n * Instantiate a PublicKey from a {@link PrivateKey}, {@link Point}, `string`, or `Buffer`.\n *\n * There are two internal properties, `network` and `compressed`, that deal with importing\n * a PublicKey from a PrivateKey in WIF format. More details described on {@link PrivateKey}\n *\n * @example\n * ```javascript\n * // instantiate from a private key\n * var key = PublicKey(privateKey, true);\n *\n * // export to as a DER hex encoded string\n * var exported = key.toString();\n *\n * // import the public key\n * var imported = PublicKey.fromString(exported);\n * ```\n *\n * @param {string} data - The encoded data in various formats\n * @param {Object} extra - additional options\n * @param {Network=} extra.network - Which network should the address for this public key be for\n * @param {String=} extra.compressed - If the public key is compressed\n * @returns {PublicKey} A new valid instance of an PublicKey\n * @constructor\n */\nfunction PublicKey(data, extra) {\n\n  if (!(this instanceof PublicKey)) {\n    return new PublicKey(data, extra);\n  }\n\n  $.checkArgument(data, 'First argument is required, please include public key data.');\n\n  if (data instanceof PublicKey) {\n    // Return copy, but as it's an immutable object, return same argument\n    return data;\n  }\n  extra = extra || {};\n\n  var info = this._classifyArgs(data, extra);\n\n  // validation\n  info.point.validate();\n\n  JSUtil.defineImmutable(this, {\n    point: info.point,\n    compressed: info.compressed,\n    network: info.network || Network.defaultNetwork\n  });\n\n  return this;\n};\n\n/**\n * Internal function to differentiate between arguments passed to the constructor\n * @param {*} data\n * @param {Object} extra\n */\nPublicKey.prototype._classifyArgs = function(data, extra) {\n  /* jshint maxcomplexity: 10 */\n  var info = {\n    compressed: _.isUndefined(extra.compressed) || extra.compressed\n  };\n\n  // detect type of data\n  if (data instanceof Point) {\n    info.point = data;\n  } else if (data.x && data.y) {\n    info = PublicKey._transformObject(data);\n  } else if (typeof(data) === 'string') {\n    info = PublicKey._transformDER(Buffer.from(data, 'hex'));\n  } else if (PublicKey._isBuffer(data)) {\n    info = PublicKey._transformDER(data);\n  } else if (PublicKey._isPrivateKey(data)) {\n    info = PublicKey._transformPrivateKey(data);\n  } else {\n    throw new TypeError('First argument is an unrecognized data format.');\n  }\n  if (!info.network) {\n    info.network = _.isUndefined(extra.network) ? undefined : Network.get(extra.network);\n  }\n  return info;\n};\n\n/**\n * Internal function to detect if an object is a {@link PrivateKey}\n *\n * @param {*} param - object to test\n * @returns {boolean}\n * @private\n */\nPublicKey._isPrivateKey = function(param) {\n  var PrivateKey = require('./privatekey');\n  return param instanceof PrivateKey;\n};\n\n/**\n * Internal function to detect if an object is a Buffer\n *\n * @param {*} param - object to test\n * @returns {boolean}\n * @private\n */\nPublicKey._isBuffer = function(param) {\n  return (param instanceof Buffer) || (param instanceof Uint8Array);\n};\n\n/**\n * Internal function to transform a private key into a public key point\n *\n * @param {PrivateKey} privkey - An instance of PrivateKey\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformPrivateKey = function(privkey) {\n  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');\n  var info = {};\n  info.point = Point.getG().mul(privkey.bn);\n  info.compressed = privkey.compressed;\n  info.network = privkey.network;\n  return info;\n};\n\n/**\n * Internal function to transform DER into a public key point\n *\n * @param {Buffer} buf - An hex encoded buffer\n * @param {bool=} strict - if set to false, will loosen some conditions\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformDER = function(buf, strict) {\n  /* jshint maxstatements: 30 */\n  /* jshint maxcomplexity: 12 */\n  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');\n  var info = {};\n\n  strict = _.isUndefined(strict) ? true : strict;\n\n  var x;\n  var y;\n  var xbuf;\n  var ybuf;\n\n  if (buf[0] === 0x04 || (!strict && (buf[0] === 0x06 || buf[0] === 0x07))) {\n    xbuf = buf.slice(1, 33);\n    ybuf = buf.slice(33, 65);\n    if (xbuf.length !== 32 || ybuf.length !== 32 || buf.length !== 65) {\n      throw new TypeError('Length of x and y must be 32 bytes');\n    }\n    x = new BN(xbuf);\n    y = new BN(ybuf);\n    info.point = new Point(x, y);\n    info.compressed = false;\n  } else if (buf[0] === 0x03) {\n    xbuf = buf.slice(1);\n    x = new BN(xbuf);\n    info = PublicKey._transformX(true, x);\n    info.compressed = true;\n  } else if (buf[0] === 0x02) {\n    xbuf = buf.slice(1);\n    x = new BN(xbuf);\n    info = PublicKey._transformX(false, x);\n    info.compressed = true;\n  } else {\n    throw new TypeError('Invalid DER format public key');\n  }\n  return info;\n};\n\n/**\n * Internal function to transform X into a public key point\n *\n * @param {Boolean} odd - If the point is above or below the x axis\n * @param {Point} x - The x point\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformX = function(odd, x) {\n  $.checkArgument(typeof odd === 'boolean', 'Must specify whether y is odd or not (true or false)');\n  var info = {};\n  info.point = Point.fromX(odd, x);\n  return info;\n};\n\n/**\n * Internal function to transform a JSON into a public key point\n *\n * @param {String|Object} json - a JSON string or plain object\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformObject = function(json) {\n  var x = new BN(json.x, 'hex');\n  var y = new BN(json.y, 'hex');\n  var point = new Point(x, y);\n  return new PublicKey(point, {\n    compressed: json.compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from a PrivateKey\n *\n * @param {PrivateKey} privkey - An instance of PrivateKey\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromPrivateKey = function(privkey) {\n  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');\n  var info = PublicKey._transformPrivateKey(privkey);\n  return new PublicKey(info.point, {\n    compressed: info.compressed,\n    network: info.network\n  });\n};\n\n/**\n * Instantiate a PublicKey from a Buffer\n * @param {Buffer} buf A DER buffer (33+ bytes) or a 32 byte X-only coordinate (taproot only)\n * @param {Boolean} strict (optional; Only applies to DER format) If set to false, will loosen some conditions\n * @returns {PublicKey}\n */\nPublicKey.fromBuffer = function(buf, strict) {\n  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key or 32 byte X coordinate (taproot)');\n  if (buf.length === 32) {\n    return PublicKey.fromX(false, buf);\n  }\n  return PublicKey.fromDER(buf, strict);\n}\n\n/**\n * Instantiate a PublicKey from a DER buffer\n * @param {Buffer} buf - A DER hex buffer\n * @param {bool=} strict - if set to false, will loosen some conditions\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromDER = function(buf, strict) {\n  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');\n  var info = PublicKey._transformDER(buf, strict);\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from a Point\n *\n * @param {Point} point - A Point instance\n * @param {boolean=} compressed - whether to store this public key as compressed format\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromPoint = function(point, compressed) {\n  $.checkArgument(point instanceof Point, 'First argument must be an instance of Point.');\n  return new PublicKey(point, {\n    compressed: compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from a DER hex encoded string\n *\n * @param {string} str - A DER hex string\n * @param {String=} encoding - The type of string encoding\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromString = function(str, encoding) {\n  var buf = Buffer.from(str, encoding || 'hex');\n  var info = PublicKey._transformDER(buf);\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from an X Point\n *\n * @param {Boolean} odd - If the point is above or below the x axis\n * @param {Point} x - The x point\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromX = function(odd, x) {\n  var info = PublicKey._transformX(odd, x);\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n\n/**\n * PublicKey instance from a Taproot (32-byte) public key\n * @param {String|Buffer} hexBuf \n * @returns {PublicKey}\n */\nPublicKey.fromTaproot = function(hexBuf) {\n  if (typeof hexBuf === 'string' && JSUtil.isHexaString(hexBuf)) {\n    hexBuf = Buffer.from(hexBuf, 'hex');\n  }\n  $.checkArgument(Buffer.isBuffer(hexBuf), 'hexBuf must be a hex string or buffer');\n  $.checkArgument(hexBuf.length === 32, 'Taproot public keys must be 32 bytes');\n  return new PublicKey.fromX(false, hexBuf);\n}\n\n/**\n * Verifies if the input is a valid Taproot public key\n * @param {String|Buffer} hexBuf \n * @returns {Boolean}\n */\nPublicKey.isValidTaproot = function(hexBuf) {\n  try {\n    return !!PublicKey.fromTaproot(hexBuf);\n  } catch (e) {\n    return false;\n  }\n};\n\n\n/**\n * Get the TapTweak tagged hash of this pub key and the merkleRoot\n * @param {Buffer} merkleRoot (optional)\n * @returns {Buffer}\n */\nPublicKey.prototype.computeTapTweakHash = function(merkleRoot) {\n  const taggedWriter = new TaggedHash('TapTweak');\n  taggedWriter.write(this.point.x.toBuffer({ size: 32 }));\n\n  //  If !merkleRoot, then we have no scripts. The actual tweak does not matter, but \n  //  follow BIP341 here to allow for reproducible tweaking.\n\n  if (merkleRoot) {\n    $.checkArgument(Buffer.isBuffer(merkleRoot) && merkleRoot.length === 32, 'merkleRoot must be 32 byte buffer');\n    taggedWriter.write(merkleRoot);\n  }\n  const tweakHash = taggedWriter.finalize();\n  \n  const order = Point.getN();\n  $.checkState(BN.fromBuffer(tweakHash).lt(order), 'TapTweak hash failed secp256k1 order check');\n  return tweakHash;\n};\n\n\n/**\n * Verify a tweaked public key against this key\n * @param {PublicKey|Buffer} p Tweaked pub key\n * @param {Buffer} merkleRoot (optional)\n * @param {Buffer} control \n * @returns {Boolean}\n */\nPublicKey.prototype.checkTapTweak = function(p, merkleRoot, control) {\n  if (Buffer.isBuffer(p)) {\n    p = PublicKey.fromTaproot(p);\n  }\n  const tweak = p.computeTapTweakHash(merkleRoot);\n\n  const P = p.point.liftX();\n  const Q = P.add(this.point.curve.g.mul(BN.fromBuffer(tweak)));\n  \n  return this.point.x.eq(Q.x) && Q.y.mod(new BN(2)).eq(new BN(control[0] & 1));\n};\n\n\n/**\n * Create a tweaked version of this pub key\n * @param {Buffer} merkleRoot (optional)\n * @returns {{ parity: Number, tweakedPubKey: Buffer }}\n */\nPublicKey.prototype.createTapTweak = function(merkleRoot) {\n  $.checkArgument(merkleRoot == null || (Buffer.isBuffer(merkleRoot) && merkleRoot.length === 32), 'merkleRoot must be a 32 byte buffer');\n\n  let t = this.computeTapTweakHash(merkleRoot);\n  t = new BN(t);\n  const Q = this.point.liftX().add(Point.getG().mul(t));\n  const parity = Q.y.isEven() ? 0 : 1;\n  return {\n    parity,\n    tweakedPubKey: Q.x.toBuffer()\n  };\n};\n\n/**\n * Check if there would be any errors when initializing a PublicKey\n *\n * @param {string} data - The encoded data in various formats\n * @returns {null|Error} An error if exists\n */\nPublicKey.getValidationError = function(data) {\n  var error;\n  try {\n    /* jshint nonew: false */\n    new PublicKey(data);\n  } catch (e) {\n    error = e;\n  }\n  return error;\n};\n\n/**\n * Check if the parameters are valid\n *\n * @param {string} data - The encoded data in various formats\n * @returns {Boolean} If the public key would be valid\n */\nPublicKey.isValid = function(data) {\n  return !PublicKey.getValidationError(data);\n};\n\n/**\n * @returns {Object} A plain object of the PublicKey\n */\nPublicKey.prototype.toObject = PublicKey.prototype.toJSON = function toObject() {\n  return {\n    x: this.point.getX().toString('hex', 2),\n    y: this.point.getY().toString('hex', 2),\n    compressed: this.compressed\n  };\n};\n\n/**\n * Will output the PublicKey to a DER Buffer\n *\n * @returns {Buffer} A DER hex encoded buffer\n */\nPublicKey.prototype.toBuffer = PublicKey.prototype.toDER = function() {\n  var x = this.point.getX();\n  var y = this.point.getY();\n\n  var xbuf = x.toBuffer({\n    size: 32\n  });\n  var ybuf = y.toBuffer({\n    size: 32\n  });\n\n  var prefix;\n  if (!this.compressed) {\n    prefix = Buffer.from([0x04]);\n    return Buffer.concat([prefix, xbuf, ybuf]);\n  } else {\n    var odd = ybuf[ybuf.length - 1] % 2;\n    if (odd) {\n      prefix = Buffer.from([0x03]);\n    } else {\n      prefix = Buffer.from([0x02]);\n    }\n    return Buffer.concat([prefix, xbuf]);\n  }\n};\n\n/**\n * Will return a sha256 + ripemd160 hash of the serialized public key\n * @see https://github.com/bitcoin/bitcoin/blob/master/src/pubkey.h#L141\n * @returns {Buffer}\n */\nPublicKey.prototype._getID = function _getID() {\n  return Hash.sha256ripemd160(this.toBuffer());\n};\n\n/**\n * Will return an address for the public key\n *\n * @param {String|Network=} network - Which network should the address be for\n * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', or 'scripthash'\n * @returns {Address} An address generated from the public key\n */\nPublicKey.prototype.toAddress = function(network, type) {\n  var Address = require('./address');\n  return Address.fromPublicKey(this, network || this.network, type);\n};\n\n/**\n * Will output the PublicKey to a DER encoded hex string\n *\n * @returns {string} A DER hex encoded string\n */\nPublicKey.prototype.toString = function() {\n  return this.toDER().toString('hex');\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Public key\n */\nPublicKey.prototype.inspect = function() {\n  return '<PublicKey: ' + this.toString() +\n    (this.compressed ? '' : ', uncompressed') + '>';\n};\n\n\nmodule.exports = PublicKey;\n","module.exports = require('./script');\n\nmodule.exports.Interpreter = require('./interpreter');\n","'use strict';\n\nconst _ = require('lodash');\n\nconst Script = require('./script');\nconst Opcode = require('../opcode');\nconst BN = require('../crypto/bn');\nconst Hash = require('../crypto/hash');\nconst Signature = require('../crypto/signature');\nconst PublicKey = require('../publickey');\nconst $ = require('../util/preconditions');\nconst SighashWitness = require('../transaction/sighashwitness');\nconst SighashSchnorr = require('../transaction/sighashschnorr');\nconst BufferWriter = require('../encoding/bufferwriter');\nconst TaggedHash = require('../crypto/taggedhash');\n\n/**\n * Bitcoin transactions contain scripts. Each input has a script called the\n * scriptSig, and each output has a script called the scriptPubkey. To validate\n * an input, the input's script is concatenated with the referenced output script,\n * and the result is executed. If at the end of execution the stack contains a\n * \"true\" value, then the transaction is valid.\n *\n * The primary way to use this class is via the verify function.\n * e.g., Interpreter().verify( ... );\n */\nvar Interpreter = function Interpreter(obj) {\n  if (!(this instanceof Interpreter)) {\n    return new Interpreter(obj);\n  }\n  if (obj) {\n    this.initialize();\n    this.set(obj);\n  } else {\n    this.initialize();\n  }\n};\n\n\nInterpreter.prototype.verifyWitnessProgram = function(version, program, witness, satoshis, flags, isP2SH) {\n\n  var scriptPubKey = new Script();\n  var stack = [];\n\n  if (version === 0) {\n    if (program.length === Interpreter.WITNESS_V0_SCRIPTHASH_SIZE) {\n      if (witness.length === 0) {\n        this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY';\n        return false;\n      }\n\n      var scriptPubKeyBuffer = witness[witness.length - 1];\n      scriptPubKey = new Script(scriptPubKeyBuffer);\n      var hash = Hash.sha256(scriptPubKeyBuffer);\n      if (hash.toString('hex') !== program.toString('hex')) {\n        this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH';\n        return false;\n      }\n\n      stack = witness.slice(0, -1);\n      return this.executeWitnessScript(scriptPubKey, stack, Signature.Version.WITNESS_V0, satoshis, flags);\n    } else if (program.length === Interpreter.WITNESS_V0_KEYHASH_SIZE) {\n      if (witness.length !== 2) {\n        this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH';\n        return false;\n      }\n\n      scriptPubKey.add(Opcode.OP_DUP);\n      scriptPubKey.add(Opcode.OP_HASH160);\n      scriptPubKey.add(program);\n      scriptPubKey.add(Opcode.OP_EQUALVERIFY);\n      scriptPubKey.add(Opcode.OP_CHECKSIG);\n\n      stack = witness;\n      return this.executeWitnessScript(scriptPubKey, stack, Signature.Version.WITNESS_V0, satoshis, flags);\n    } else {\n      this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH';\n      return false;\n    }\n  } else if (version === 1 && program.length == Interpreter.WITNESS_V1_TAPROOT_SIZE && !isP2SH) {\n    const execdata = { annexPresent: false };\n    // BIP341 Taproot: 32-byte non-P2SH witness v1 program (which encodes a P2C-tweaked pubkey)\n    if (!(flags & Interpreter.SCRIPT_VERIFY_TAPROOT)) {\n      return true;\n    }\n    stack = Array.from(witness);\n    if (stack.length == 0) {\n      this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY';\n      return false;\n    }\n    if (stack.length >= 2 && stack[stack.length - 1].length && stack[stack.length - 1][0] === Script.ANNEX_TAG) {\n      // Drop annex (this is non-standard; see IsWitnessStandard)\n      const annex = stack.pop();\n      const annexWriter = new BufferWriter();\n      annexWriter.writeVarintNum(annex.length);\n      annexWriter.write(annex);\n      execdata.annexHash = Hash.sha256(annexWriter.toBuffer());\n      execdata.annexPresent = true;\n    }\n    execdata.annexInit = true;\n    if (stack.length === 1) {\n      // Key path spending (stack size is 1 after removing optional annex)\n      return this.checkSchnorrSignature(stack[0], program, Signature.Version.TAPROOT, execdata);\n    } else {\n      // Script path spending (stack size is >1 after removing optional annex)\n      const control = stack.pop();\n      const scriptPubKeyBuf = stack.pop();\n\n      if (\n        control.length < Interpreter.TAPROOT_CONTROL_BASE_SIZE  ||\n        control.length > Interpreter.TAPROOT_CONTROL_MAX_SIZE   ||\n        ((control.length - Interpreter.TAPROOT_CONTROL_BASE_SIZE) % Interpreter.TAPROOT_CONTROL_NODE_SIZE) != 0\n      ) {\n        this.errstr = 'SCRIPT_ERR_TAPROOT_WRONG_CONTROL_SIZE';\n        return false;\n      }\n      execdata.tapleafHash = Interpreter.computeTapleafHash(control[0] & Interpreter.TAPROOT_LEAF_MASK, scriptPubKeyBuf);\n      if (!Interpreter.verifyTaprootCommitment(control, program, execdata.tapleafHash)) {\n        this.errstr = 'SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH';\n        return false;\n      }\n      execdata.tapleafHashInit = true;\n      if ((control[0] & Interpreter.TAPROOT_LEAF_MASK) === Interpreter.TAPROOT_LEAF_TAPSCRIPT) {\n        // Tapscript (leaf version 0xc0)\n        let witnessSize;\n        {\n          const bw = new BufferWriter();\n          bw.writeVarintNum(witness.length);\n          for (let element of witness) {\n            bw.writeVarintNum(element.length);\n            bw.write(element);\n          }\n          witnessSize = bw.toBuffer().length;\n        }\n\n        try {\n          scriptPubKey = new Script(scriptPubKeyBuf);\n        } catch (err) {\n          // Note how this condition would not be reached if an unknown OP_SUCCESSx was found\n          this.errstr = 'SCRIPT_ERR_BAD_OPCODE';\n          return false;\n        }\n\n        execdata.validationWeightLeft = witnessSize + Script.VALIDATION_WEIGHT_OFFSET;\n        execdata.validationWeightLeftInit = true;\n        return this.executeWitnessScript(scriptPubKey, stack, Signature.Version.TAPSCRIPT, satoshis, flags, execdata);\n      }\n      // If none of the above conditions are met then this must be an upgraded taproot version.\n      if (flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION) {\n        this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION';\n        return false;\n      }\n      // Future softfork compatibility\n      return true;\n    }\n  } else if ((flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM)) {\n    this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM';\n    return false;\n  }\n  // Other version/size/p2sh combinations return true for future softfork compatibility\n  return true;\n};\n\n\nInterpreter.prototype.executeWitnessScript = function(scriptPubKey, stack, sigversion, satoshis, flags, execdata) {\n  if (sigversion === Signature.Version.TAPSCRIPT) {\n    for (let chunk of scriptPubKey.chunks) {\n      // New opcodes will be listed here. May use a different sigversion to modify existing opcodes.\n      if (Opcode.isOpSuccess(chunk.opcodenum)) {\n        if (flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS) {\n          this.errstr = 'SCRIPT_ERR_DISCOURAGE_OP_SUCCESS';\n          return false;\n        }\n        return true;\n      }\n    }\n\n    // Tapscript enforces initial stack size limits (altstack is empty here)\n    if (stack.length > Interpreter.MAX_STACK_SIZE) {\n      this.errstr = 'SCRIPT_ERR_STACK_SIZE';\n      return false;\n    }\n  }\n\n  // Disallow stack item size > MAX_SCRIPT_ELEMENT_SIZE in witness stack\n  if (stack.length && stack.some(elem => elem.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE)) {\n    this.errstr = 'SCRIPT_ERR_PUSH_SIZE';\n    return false;\n  }\n\n  this.initialize();\n\n  this.set({\n    script: scriptPubKey,\n    stack: stack,\n    sigversion: sigversion,\n    satoshis: satoshis,\n    flags: flags,\n    execdata: execdata\n  });\n\n  if (!this.evaluate()) {\n    return false;\n  }\n\n  if (this.stack.length !== 1) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE';\n    return false;\n  }\n\n  var buf = this.stack[this.stack.length - 1];\n  if (!Interpreter.castToBool(buf)) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_STACK';\n    return false;\n  }\n\n  return true;\n};\n\n\n\n/**\n * Verifies a Script by executing it and returns true if it is valid.\n * This function needs to be provided with the scriptSig and the scriptPubkey\n * separately.\n * @param {Script} scriptSig - the script's first part (corresponding to the tx input)\n * @param {Script} scriptPubkey - the script's last part (corresponding to the tx output)\n * @param {Transaction=} tx - the Transaction containing the scriptSig in one input (used\n *    to check signature validity for some opcodes like OP_CHECKSIG)\n * @param {number} nin - index of the transaction input containing the scriptSig verified.\n * @param {number} flags - evaluation flags. See Interpreter.SCRIPT_* constants\n * @param {number} witness - array of witness data\n * @param {number} satoshis - number of satoshis created by this output\n *\n * Translated from bitcoind's VerifyScript\n */\nInterpreter.prototype.verify = function(scriptSig, scriptPubkey, tx, nin, flags, witness, satoshis) {\n\n  var Transaction = require('../transaction');\n  if (_.isUndefined(tx)) {\n    tx = new Transaction();\n  }\n  if (_.isUndefined(nin)) {\n    nin = 0;\n  }\n  if (_.isUndefined(flags)) {\n    flags = 0;\n  }\n  if (_.isUndefined(witness)) {\n    witness = null;\n  }\n  if (_.isUndefined(satoshis)) {\n    satoshis = 0;\n  }\n\n  this.set({\n    script: scriptSig,\n    tx: tx,\n    nin: nin,\n    sigversion: Signature.Version.BASE,\n    satoshis: 0,\n    flags: flags\n  });\n  var stackCopy;\n\n  if ((flags & Interpreter.SCRIPT_VERIFY_SIGPUSHONLY) !== 0 && !scriptSig.isPushOnly()) {\n    this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';\n    return false;\n  }\n\n  // evaluate scriptSig\n  if (!this.evaluate()) {\n    return false;\n  }\n\n  if (flags & Interpreter.SCRIPT_VERIFY_P2SH) {\n    stackCopy = this.stack.slice();\n  }\n\n  var stack = this.stack;\n  this.initialize();\n  this.set({\n    script: scriptPubkey,\n    stack: stack,\n    tx: tx,\n    nin: nin,\n    flags: flags\n  });\n\n  // evaluate scriptPubkey\n  if (!this.evaluate()) {\n    return false;\n  }\n\n  if (this.stack.length === 0) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_RESULT';\n    return false;\n  }\n\n  var buf = this.stack[this.stack.length - 1];\n  if (!Interpreter.castToBool(buf)) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_STACK';\n    return false;\n  }\n\n  var hadWitness = false;\n  if ((flags & Interpreter.SCRIPT_VERIFY_WITNESS)) {\n    var witnessValues = {};\n    if (scriptPubkey.isWitnessProgram(witnessValues)) {\n      hadWitness = true;\n      if (scriptSig.toBuffer().length !== 0) {\n        this.errstr = 'SCRIPT_ERR_WITNESS_MALLEATED';\n        return false;\n      }\n      if (!this.verifyWitnessProgram(witnessValues.version, witnessValues.program, witness, satoshis, this.flags, /* isP2SH */ false)) {\n        return false;\n      }\n    }\n  }\n\n  // Additional validation for spend-to-script-hash transactions:\n  if ((flags & Interpreter.SCRIPT_VERIFY_P2SH) && scriptPubkey.isScriptHashOut()) {\n    // scriptSig must be literals-only or validation fails\n    if (!scriptSig.isPushOnly()) {\n      this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';\n      return false;\n    }\n\n    // stackCopy cannot be empty here, because if it was the\n    // P2SH  HASH <> EQUAL  scriptPubKey would be evaluated with\n    // an empty stack and the EvalScript above would return false.\n    if (stackCopy.length === 0) {\n      throw new Error('internal error - stack copy empty');\n    }\n\n    var redeemScriptSerialized = stackCopy[stackCopy.length - 1];\n    var redeemScript = Script.fromBuffer(redeemScriptSerialized);\n    stackCopy.pop();\n\n    this.initialize();\n    this.set({\n      script: redeemScript,\n      stack: stackCopy,\n      tx: tx,\n      nin: nin,\n      flags: flags\n    });\n\n    // evaluate redeemScript\n    if (!this.evaluate()) {\n      return false;\n    }\n\n    if (stackCopy.length === 0) {\n      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_P2SH_STACK';\n      return false;\n    }\n\n    if (!Interpreter.castToBool(stackCopy[stackCopy.length - 1])) {\n      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_P2SH_STACK';\n      return false;\n    }\n    if ((flags & Interpreter.SCRIPT_VERIFY_WITNESS)) {\n      var p2shWitnessValues = {};\n      if (redeemScript.isWitnessProgram(p2shWitnessValues)) {\n        hadWitness = true;\n        var redeemScriptPush = new Script();\n        redeemScriptPush.add(redeemScript.toBuffer());\n        if (scriptSig.toHex() !== redeemScriptPush.toHex()) {\n          this.errstr = 'SCRIPT_ERR_WITNESS_MALLEATED_P2SH';\n          return false;\n        }\n\n        if (!this.verifyWitnessProgram(p2shWitnessValues.version, p2shWitnessValues.program, witness, satoshis, this.flags, /* isP2SH */ true)) {\n          return false;\n        }\n        // Bypass the cleanstack check at the end. The actual stack is obviously not clean\n        // for witness programs.\n        stack = [stack[0]];\n      }\n    }\n  }\n\n  // The CLEANSTACK check is only performed after potential P2SH evaluation,\n  // as the non-P2SH evaluation of a P2SH script will obviously not result in\n  // a clean stack (the P2SH inputs remain). The same holds for witness\n  // evaluation.\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_CLEANSTACK) != 0) {\n      // Disallow CLEANSTACK without P2SH, as otherwise a switch\n      // CLEANSTACK->P2SH+CLEANSTACK would be possible, which is not a\n      // softfork (and P2SH should be one).\n      if (\n        (this.flags & Interpreter.SCRIPT_VERIFY_P2SH)    == 0 ||\n        (this.flags & Interpreter.SCRIPT_VERIFY_WITNESS) == 0\n      ) {\n        throw 'flags & SCRIPT_VERIFY_P2SH';\n      }\n\n      if (stackCopy.length != 1) {\n        this.errstr = 'SCRIPT_ERR_CLEANSTACK';\n        return false;\n      }\n  }\n\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_WITNESS)) {\n    if (!hadWitness && witness.length > 0) {\n      this.errstr = 'SCRIPT_ERR_WITNESS_UNEXPECTED';\n      return false;\n    }\n  }\n\n  return true;\n};\n\nmodule.exports = Interpreter;\n\nInterpreter.prototype.initialize = function(obj) {\n  this.stack = [];\n  this.altstack = [];\n  this.pc = 0;\n  this.satoshis = 0;\n  this.sigversion = Signature.Version.BASE;\n  this.pbegincodehash = 0;\n  this.nOpCount = 0;\n  this.vfExec = [];\n  this.errstr = '';\n  this.flags = 0;\n  this.execdata = {};\n};\n\nInterpreter.prototype.set = function(obj) {\n  this.script = obj.script || this.script;\n  this.tx = obj.tx || this.tx;\n  this.nin = typeof obj.nin === 'undefined' ? this.nin : parseInt(obj.nin);\n  this.stack = obj.stack || this.stack;\n  this.altstack = obj.altstack || this.altstack;\n  this.pc = typeof obj.pc === 'undefined' ? this.pc : obj.pc;\n  this.pbegincodehash = typeof obj.pbegincodehash === 'undefined' ? this.pbegincodehash : obj.pbegincodehash;\n  this.sigversion = typeof obj.sigversion === 'undefined' ? this.sigversion : obj.sigversion;\n  this.satoshis = typeof obj.satoshis === 'undefined' ? this.satoshis : obj.satoshis;\n  this.nOpCount = typeof obj.nOpCount === 'undefined' ? this.nOpCount : obj.nOpCount;\n  this.vfExec = obj.vfExec || this.vfExec;\n  this.errstr = obj.errstr || this.errstr;\n  this.flags = typeof obj.flags === 'undefined' ? this.flags : obj.flags;\n  this.execdata = typeof obj.execdata === 'undefined' ? this.execdata : (obj.execdata || {});\n};\n\nInterpreter.true = Buffer.from([1]);\nInterpreter.false = Buffer.from([]);\n\nInterpreter.MAX_SCRIPT_SIZE = 10000;\nInterpreter.MAX_STACK_SIZE = 1000;\nInterpreter.MAX_SCRIPT_ELEMENT_SIZE = 520;\n\nInterpreter.LOCKTIME_THRESHOLD = 500000000;\nInterpreter.LOCKTIME_THRESHOLD_BN = new BN(Interpreter.LOCKTIME_THRESHOLD);\n\n// flags taken from bitcoind\n// bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\nInterpreter.SCRIPT_VERIFY_NONE = 0;\n\n// Evaluate P2SH subscripts (softfork safe, BIP16).\nInterpreter.SCRIPT_VERIFY_P2SH = (1 << 0);\n\n// Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.\n// Passing a pubkey that is not (0x04 + 64 bytes) or (0x02 or 0x03 + 32 bytes) to checksig causes that pubkey to be\n// skipped (not softfork safe: this flag can widen the validity of OP_CHECKSIG OP_NOT).\nInterpreter.SCRIPT_VERIFY_STRICTENC = (1 << 1);\n\n// Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP62 rule 1)\nInterpreter.SCRIPT_VERIFY_DERSIG = (1 << 2);\n\n// Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script failure\n// (softfork safe, BIP62 rule 5).\nInterpreter.SCRIPT_VERIFY_LOW_S = (1 << 3);\n\n// verify dummy stack item consumed by CHECKMULTISIG is of zero-length (softfork safe, BIP62 rule 7).\nInterpreter.SCRIPT_VERIFY_NULLDUMMY = (1 << 4);\n\n// Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).\nInterpreter.SCRIPT_VERIFY_SIGPUSHONLY = (1 << 5);\n\n// Require minimal encodings for all push operations (OP_0... OP_16, OP_1NEGATE where possible, direct\n// pushes up to 75 bytes, OP_PUSHDATA up to 255 bytes, OP_PUSHDATA2 for anything larger). Evaluating\n// any other push causes the script to fail (BIP62 rule 3).\n// In addition, whenever a stack element is interpreted as a number, it must be of minimal length (BIP62 rule 4).\n// (softfork safe)\nInterpreter.SCRIPT_VERIFY_MINIMALDATA = (1 << 6);\n\n// Discourage use of NOPs reserved for upgrades (NOP1-10)\n//\n// Provided so that nodes can avoid accepting or mining transactions\n// containing executed NOP's whose meaning may change after a soft-fork,\n// thus rendering the script invalid; with this flag set executing\n// discouraged NOPs fails the script. This verification flag will never be\n// a mandatory flag applied to scripts in a block. NOPs that are not\n// executed, e.g.  within an unexecuted IF ENDIF block, are *not* rejected.\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = (1 << 7);\n\n\n// Require that only a single stack element remains after evaluation. This\n// changes the success criterion from \"At least one stack element must\n// remain, and when interpreted as a boolean, it must be true\" to \"Exactly\n// one stack element must remain, and when interpreted as a boolean, it must\n// be true\".\n// (softfork safe, BIP62 rule 6)\n// Note: CLEANSTACK should never be used without P2SH or WITNESS.\nInterpreter.SCRIPT_VERIFY_CLEANSTACK = (1 << 8),\n\n// Verify CHECKLOCKTIMEVERIFY\n//\n// See BIP65 for details.\nInterpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY = (1 << 9);\n\n// support CHECKSEQUENCEVERIFY opcode\n//\n// See BIP112 for details\nInterpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY = (1 << 10);\n\n// Support segregated witness\n//\nInterpreter.SCRIPT_VERIFY_WITNESS = (1 << 11);\n\n// Making v1-v16 witness program non-standard\n//\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM = (1 << 12);\n\n\n//\n// Segwit script only: Require the argument of OP_IF/NOTIF to be exactly\n// 0x01 or empty vector\n//\nInterpreter.SCRIPT_VERIFY_MINIMALIF = (1 << 13);\n\n\n// Signature(s) must be empty vector if an CHECK(MULTI)SIG operation failed\n//\nInterpreter.SCRIPT_VERIFY_NULLFAIL = (1 << 14);\n\n// Public keys in scripts must be compressed\n//\nInterpreter.SCRIPT_VERIFY_WITNESS_PUBKEYTYPE = (1 << 15);\n\n// Do we accept signature using SIGHASH_FORKID\n//\nInterpreter.SCRIPT_ENABLE_SIGHASH_FORKID = (1 << 16);\n\n// Do we accept activate replay protection using a different fork id.\n//\nInterpreter.SCRIPT_ENABLE_REPLAY_PROTECTION = (1 << 17);\n\n// Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n//\nInterpreter.SCRIPT_VERIFY_CONST_SCRIPTCODE = (1 << 16);\n\n// Verify taproot script\n//\nInterpreter.SCRIPT_VERIFY_TAPROOT = (1 << 17);\n\n// Making unknown Taproot leaf versions non-standard\n//\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1 << 18);\n\n// Making unknown OP_SUCCESS non-standard\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1 << 19);\n\n// Making unknown public key versions (in BIP 342 scripts) non-standard\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1 << 20);\n\n\n\n/* Below flags apply in the context of BIP 68*/\n/**\n * If this flag set, CTxIn::nSequence is NOT interpreted as a relative\n * lock-time.\n */\nInterpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG = (1 << 31);\n\n/**\n * If CTxIn::nSequence encodes a relative lock-time and this flag is set,\n * the relative lock-time has units of 512 seconds, otherwise it specifies\n * blocks with a granularity of 1.\n */\nInterpreter.SEQUENCE_LOCKTIME_TYPE_FLAG = (1 << 22);\n\n/**\n * If CTxIn::nSequence encodes a relative lock-time, this mask is applied to\n * extract that lock-time from the sequence field.\n */\nInterpreter.SEQUENCE_LOCKTIME_MASK = 0x0000ffff;\n\n/** Signature hash sizes */\nInterpreter.WITNESS_V0_SCRIPTHASH_SIZE = 32;\nInterpreter.WITNESS_V0_KEYHASH_SIZE = 20;\nInterpreter.WITNESS_V1_TAPROOT_SIZE = 32;\n\nInterpreter.TAPROOT_LEAF_MASK = 0xfe;\nInterpreter.TAPROOT_LEAF_TAPSCRIPT = 0xc0;\nInterpreter.TAPROOT_CONTROL_BASE_SIZE = 33;\nInterpreter.TAPROOT_CONTROL_NODE_SIZE = 32;\nInterpreter.TAPROOT_CONTROL_MAX_NODE_COUNT = 128;\nInterpreter.TAPROOT_CONTROL_MAX_SIZE = Interpreter.TAPROOT_CONTROL_BASE_SIZE + Interpreter.TAPROOT_CONTROL_NODE_SIZE * Interpreter.TAPROOT_CONTROL_MAX_NODE_COUNT;\n\n// Conceptually, this doesn't really belong with the Interpreter, but I haven't found a better place for it.\nInterpreter.PROTOCOL_VERSION = 70016;\n\nInterpreter.castToBool = function(buf) {\n  for (var i = 0; i < buf.length; i++) {\n    if (buf[i] !== 0) {\n      // can be negative zero\n      if (i === buf.length - 1 && buf[i] === 0x80) {\n        return false;\n      }\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Translated from bitcoind's CheckSignatureEncoding\n */\nInterpreter.prototype.checkSignatureEncoding = function(buf) {\n  var sig;\n\n    // Empty signature. Not strictly DER encoded, but allowed to provide a\n    // compact way to provide an invalid signature for use with CHECK(MULTI)SIG\n    if (buf.length == 0) {\n        return true;\n    }\n\n  if ((this.flags & (Interpreter.SCRIPT_VERIFY_DERSIG | Interpreter.SCRIPT_VERIFY_LOW_S | Interpreter.SCRIPT_VERIFY_STRICTENC)) !== 0 && !Signature.isTxDER(buf)) {\n    this.errstr = 'SCRIPT_ERR_SIG_DER_INVALID_FORMAT';\n    return false;\n  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_LOW_S) !== 0) {\n    sig = Signature.fromTxFormat(buf);\n    if (!sig.hasLowS()) {\n      this.errstr = 'SCRIPT_ERR_SIG_DER_HIGH_S';\n      return false;\n    }\n  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0) {\n    sig = Signature.fromTxFormat(buf);\n    if (!sig.hasDefinedHashtype()) {\n      this.errstr = 'SCRIPT_ERR_SIG_HASHTYPE';\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Translated from bitcoind's CheckPubKeyEncoding\n */\nInterpreter.prototype.checkPubkeyEncoding = function(buf) {\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0 && !PublicKey.isValid(buf)) {\n    this.errstr = 'SCRIPT_ERR_PUBKEYTYPE';\n    return false;\n  }\n\n  // Only compressed keys are accepted in segwit\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_WITNESS_PUBKEYTYPE) != 0 && this.sigversion == Signature.Version.WITNESS_V0 && !PublicKey.fromBuffer(buf).compressed) {\n    this.errstr = 'SCRIPT_ERR_WITNESS_PUBKEYTYPE';\n    return false;\n  }\n\n  return true;\n};\n\n\n/**\n * Verifies ECDSA signature\n * @param {Signature} sig\n * @param {PublicKey} pubkey\n * @param {Number} nin\n * @param {Script} subscript\n * @param {Number} satoshis\n * @returns {Boolean}\n */\nInterpreter.prototype.checkEcdsaSignature = function(sig, pubkey, nin, subscript, satoshis) {\n  var subscriptBuffer = subscript.toBuffer();\n  var scriptCodeWriter = new BufferWriter();\n  scriptCodeWriter.writeVarintNum(subscriptBuffer.length);\n  scriptCodeWriter.write(subscriptBuffer);\n\n  $.checkState(JSUtil.isNaturalNumber(satoshis));\n  var satoshisBuffer = new BufferWriter().writeUInt64LEBN(new BN(satoshis)).toBuffer();\n\n  var verified = SighashWitness.verify(\n    this,\n    sig,\n    pubkey,\n    nin,\n    scriptCodeWriter.toBuffer(),\n    satoshisBuffer\n  );\n  return verified;\n};\n\n\n/**\n * Verifies Schnorr signature\n * @param {Signature|Buffer} sig\n * @param {PublicKey|Buffer} pubkey\n * @param {Number} sigversion\n * @param {Object} execdata\n * @returns {Boolean}\n */\nInterpreter.prototype.checkSchnorrSignature = function(sig, pubkey, sigversion, execdata) {\n  $.checkArgument(sig && Buffer.isBuffer(sig), 'Missing sig');\n  $.checkArgument(pubkey && Buffer.isBuffer(pubkey), 'Missing pubkey');\n  $.checkArgument(sigversion, 'Missing sigversion');\n  $.checkArgument(execdata, 'Missing execdata');\n\n  $.checkArgument(pubkey.length === 32, 'Schnorr signatures have 32-byte public keys. The caller is responsible for enforcing this.');\n  // Note that in Tapscript evaluation, empty signatures are treated specially (invalid signature that does not\n  // abort script execution). This is implemented in EvalChecksigTapscript, which won't invoke\n  // CheckSchnorrSignature in that case. In other contexts, they are invalid like every other signature with\n  // size different from 64 or 65.\n  if (!(sig.length === 64 || sig.length === 65)) {\n    this.errstr = 'SCRIPT_ERR_SCHNORR_SIG_SIZE';\n    return false;\n  }\n\n  if (sig.length === 65 && sig[sig.length - 1] === Signature.SIGHASH_DEFAULT) {\n    this.errstr = 'SCRIPT_ERR_SCHNORR_SIG_HASHTYPE';\n    return false;\n  }\n  sig = Signature.fromSchnorr(sig);\n  const verified = SighashSchnorr.verify(\n    this.tx,\n    sig,\n    pubkey,\n    sigversion,\n    this.nin,\n    execdata\n  );\n  return verified;\n};\n\n\n/**\n * Based on bitcoind's EvalChecksigPreTapscript function\n * bitcoind commit: a0988140b71485ad12c3c3a4a9573f7c21b1eff8\n */\nInterpreter.prototype._evalChecksigPreTapscript = function(bufSig, bufPubkey) {\n  $.checkArgument(\n    this.sigversion === Signature.Version.BASE || this.sigversion === Signature.Version.WITNESS_V0,\n    'sigversion must be base or witness_v0'\n  );\n\n  // Success signifies if the signature is valid.\n  // Result signifies the result of this funciton, which also takes flags into account.\n  const retVal = { success: false, result: false };\n\n  const subscript = new Script().set({\n    chunks: this.script.chunks.slice(this.pbegincodehash)\n  });\n\n  // Drop the signature in pre-segwit scripts but not segwit scripts\n  if (this.sigversion === Signature.Version.BASE) {\n    // Drop the signature, since there's no way for a signature to sign itself\n    const tmpScript = new Script().add(bufSig);\n    let found = subscript.chunks.length;\n    subscript.findAndDelete(tmpScript);\n\n    found = found == subscript.chunks.length + 1; // found if a chunk was removed\n    if (found && (this.flags & Interpreter.SCRIPT_VERIFY_CONST_SCRIPTCODE)) {\n      this.errstr = 'SCRIPT_ERR_SIG_FINDANDDELETE';\n      return retVal;\n    }\n  }\n\n  if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\n    return retVal;\n  }\n\n  try {\n    const sig = Signature.fromTxFormat(bufSig);\n    const pubkey = PublicKey.fromBuffer(bufPubkey, false);\n    retVal.success = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.sigversion, this.satoshis);\n  } catch (e) {\n    //invalid sig or pubkey\n    retVal.success = false;\n  }\n\n  if (!retVal.success && (this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL) && bufSig.length) {\n    this.errstr = 'SCRIPT_ERR_SIG_NULLFAIL';\n    return retVal;\n  }\n\n  // If it reaches here, then true\n  retVal.result = true;\n  return retVal;\n};\n\n\n/**\n * Based on bitcoind's EvalChecksigTapscript function\n * bitcoind commit: a0988140b71485ad12c3c3a4a9573f7c21b1eff8\n */\nInterpreter.prototype._evalChecksigTapscript = function(bufSig, bufPubkey) {\n  $.checkArgument(this.sigversion == Signature.Version.TAPSCRIPT, 'this.sigversion must by TAPSCRIPT');\n\n  /*\n    *  The following validation sequence is consensus critical. Please note how --\n    *    upgradable public key versions precede other rules;\n    *    the script execution fails when using empty signature with invalid public key;\n    *    the script execution fails when using non-empty invalid signature.\n    */\n\n  // Success signifies if the signature is valid.\n  // Result signifies the result of this funciton, which also takes flags into account.\n  const retVal = {\n    success: bufSig.length > 0,\n    result: false\n  }\n  if (retVal.success) {\n    // Implement the sigops/witnesssize ratio test.\n    // Passing with an upgradable public key version is also counted.\n    $.checkState(this.execdata.validationWeightLeftInit, 'validationWeightLeftInit is false');\n    this.execdata.validationWeightLeft -= Script.VALIDATION_WEIGHT_PER_SIGOP_PASSED;\n    if (this.execdata.validationWeightLeft < 0) {\n      this.errstr = 'SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT';\n      return retVal;\n    }\n  }\n  if (bufPubkey.length === 0) {\n    this.errstr = 'SCRIPT_ERR_PUBKEYTYPE';\n    return retVal;\n  } else if (bufPubkey.length == 32) {\n    if (retVal.success && !this.tx.checkSchnorrSignature(bufSig, bufPubkey, this.nin, this.sigversion, this.execdata)) {\n      this.errstr = 'SCRIPT_ERR_SCHNORR_SIG';\n      return retVal;\n    }\n  } else {\n    /*\n      *  New public key version softforks should be defined before this `else` block.\n      *  Generally, the new code should not do anything but failing the script execution. To avoid\n      *  consensus bugs, it should not modify any existing values (including `success`).\n      */\n    if ((this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE) != 0) {\n      this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE';\n      return retVal;\n    }\n  }\n\n  // If it reaches here, then true\n  retVal.result = true;\n  return retVal;\n}\n\n/**\n * Based on bitcoind's EvalChecksig function\n * bitcoind commit: a0988140b71485ad12c3c3a4a9573f7c21b1eff8\n * @returns {{ success: Boolean, verified: Boolean }}\n */\nInterpreter.prototype._evalCheckSig = function(bufSig, bufPubkey) {\n  switch(this.sigversion) {\n    case Signature.Version.BASE:\n    case Signature.Version.WITNESS_V0:\n      // const verified = this._evalChecksigPreTapscript(bufSig, bufPubkey);\n      // return { success: verified, verified }; // This is to keep the same return format as _evalCheckSigTapscript\n      return this._evalChecksigPreTapscript(bufSig, bufPubkey);\n    case Signature.Version.TAPSCRIPT:\n      return this._evalChecksigTapscript(bufSig, bufPubkey);\n    case Signature.Version.TAPROOT:\n      // Key path spending in Taproot has no script, so this is unreachable.\n      throw new Error('Called evalCheckSig with a TAPROOT sigversion. Check your implementation');\n  }\n};\n\n/**\n * Based on bitcoind's EvalScript function, with the inner loop moved to\n * Interpreter.prototype.step()\n * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n */\nInterpreter.prototype.evaluate = function() {\n  // sigversion cannot be TAPROOT here, as it admits no script execution.\n  $.checkArgument(this.sigversion == Signature.Version.BASE || this.sigversion == Signature.Version.WITNESS_V0 || this.sigversion == Signature.Version.TAPSCRIPT, 'invalid sigversion');\n\n  if (\n    (this.sigversion == Signature.Version.BASE || this.sigversion == Signature.Version.WITNESS_V0) &&\n    this.script.toBuffer().length > Interpreter.MAX_SCRIPT_SIZE\n  ) {\n    this.errstr = 'SCRIPT_ERR_SCRIPT_SIZE';\n    return false;\n  }\n\n  try {\n    while (this.pc < this.script.chunks.length) {\n      var fSuccess = this.step();\n      if (!fSuccess) {\n        return false;\n      }\n    }\n  } catch (e) {\n    this.errstr = 'SCRIPT_ERR_UNKNOWN_ERROR: ' + e;\n    return false;\n  }\n\n  if (this.vfExec.length > 0) {\n    this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Checks a locktime parameter with the transaction's locktime.\n * There are two times of nLockTime: lock-by-blockheight and lock-by-blocktime,\n * distinguished by whether nLockTime < LOCKTIME_THRESHOLD = 500000000\n *\n * See the corresponding code on bitcoin core:\n * https://github.com/bitcoin/bitcoin/blob/ffd75adce01a78b3461b3ff05bcc2b530a9ce994/src/script/interpreter.cpp#L1129\n *\n * @param {BN} nLockTime the locktime read from the script\n * @return {boolean} true if the transaction's locktime is less than or equal to\n *                   the transaction's locktime\n */\nInterpreter.prototype.checkLockTime = function(nLockTime) {\n\n  // We want to compare apples to apples, so fail the script\n  // unless the type of nLockTime being tested is the same as\n  // the nLockTime in the transaction.\n  if (!(\n    (this.tx.nLockTime <  Interpreter.LOCKTIME_THRESHOLD && nLockTime.lt(Interpreter.LOCKTIME_THRESHOLD_BN)) ||\n    (this.tx.nLockTime >= Interpreter.LOCKTIME_THRESHOLD && nLockTime.gte(Interpreter.LOCKTIME_THRESHOLD_BN))\n  )) {\n    return false;\n  }\n\n  // Now that we know we're comparing apples-to-apples, the\n  // comparison is a simple numeric one.\n  if (nLockTime.gt(new BN(this.tx.nLockTime))) {\n    return false;\n  }\n\n  // Finally the nLockTime feature can be disabled and thus\n  // CHECKLOCKTIMEVERIFY bypassed if every txin has been\n  // finalized by setting nSequence to maxint. The\n  // transaction would be allowed into the blockchain, making\n  // the opcode ineffective.\n  //\n  // Testing if this vin is not final is sufficient to\n  // prevent this condition. Alternatively we could test all\n  // inputs, but testing just this input minimizes the data\n  // required to prove correct CHECKLOCKTIMEVERIFY execution.\n  if (!this.tx.inputs[this.nin].isFinal()) {\n    return false;\n  }\n\n  return true;\n}\n\n\n/**\n * Checks a sequence parameter with the transaction's sequence.\n * @param {BN} nSequence the sequence read from the script\n * @return {boolean} true if the transaction's sequence is less than or equal to\n *                   the transaction's sequence\n */\nInterpreter.prototype.checkSequence = function(nSequence) {\n\n  // Relative lock times are supported by comparing the passed in operand to\n  // the sequence number of the input.\n  var txToSequence = this.tx.inputs[this.nin].sequenceNumber;\n\n  // Fail if the transaction's version number is not set high enough to\n  // trigger BIP 68 rules.\n  if (this.tx.version < 2) {\n    return false;\n  }\n\n  // Sequence numbers with their most significant bit set are not consensus\n  // constrained. Testing that the transaction's sequence number do not have\n  // this bit set prevents using this property to get around a\n  // CHECKSEQUENCEVERIFY check.\n  if (txToSequence & Interpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG) {\n    return false;\n  }\n\n  // Mask off any bits that do not have consensus-enforced meaning before\n  // doing the integer comparisons\n  var nLockTimeMask =\n      Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG | Interpreter.SEQUENCE_LOCKTIME_MASK;\n  var txToSequenceMasked = new BN(txToSequence & nLockTimeMask);\n  var nSequenceMasked = nSequence.and(new BN(nLockTimeMask));\n\n  // There are two kinds of nSequence: lock-by-blockheight and\n  // lock-by-blocktime, distinguished by whether nSequenceMasked <\n  // CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG.\n  //\n  // We want to compare apples to apples, so fail the script unless the type\n  // of nSequenceMasked being tested is the same as the nSequenceMasked in the\n  // transaction.\n  var SEQUENCE_LOCKTIME_TYPE_FLAG_BN = new BN(Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG);\n\n  if (!((txToSequenceMasked.lt(SEQUENCE_LOCKTIME_TYPE_FLAG_BN)  &&\n          nSequenceMasked.lt(SEQUENCE_LOCKTIME_TYPE_FLAG_BN)) ||\n        (txToSequenceMasked.gte(SEQUENCE_LOCKTIME_TYPE_FLAG_BN) &&\n          nSequenceMasked.gte(SEQUENCE_LOCKTIME_TYPE_FLAG_BN)))) {\n    return false;\n  }\n\n  // Now that we know we're comparing apples-to-apples, the comparison is a\n  // simple numeric one.\n  return nSequenceMasked.lte(txToSequenceMasked)\n}\n\n\nInterpreter.computeTapleafHash = function(leafVersion, scriptBuf) {\n  const tagWriter = TaggedHash.TAPLEAF;\n  tagWriter.writeUInt8(leafVersion);\n  tagWriter.writeVarintNum(scriptBuf.length);\n  tagWriter.write(scriptBuf);\n  return tagWriter.finalize();\n};\n\n\nInterpreter.computeTaprootMerkleRoot = function(control, tapleafHash) {\n  const pathLen = (control.length - Interpreter.TAPROOT_CONTROL_BASE_SIZE) / Interpreter.TAPROOT_CONTROL_NODE_SIZE;\n  let k = tapleafHash;\n  for (let i = 0; i < pathLen; ++i) {\n    const tagWriter = TaggedHash.TAPBRANCH;\n    const start = Interpreter.TAPROOT_CONTROL_BASE_SIZE + Interpreter.TAPROOT_CONTROL_NODE_SIZE * i;\n    const node = control.slice(start, start + Interpreter.TAPROOT_CONTROL_NODE_SIZE);\n    if (Buffer.compare(k, node) === -1) {\n      tagWriter.write(k);\n      tagWriter.write(node);\n    } else {\n      tagWriter.write(node);\n      tagWriter.write(k);\n    }\n    k = tagWriter.finalize();\n  }\n  return k;\n};\n\n\nInterpreter.verifyTaprootCommitment = function(control, program, tapleafHash) {\n  $.checkArgument(control.length >= Interpreter.TAPROOT_CONTROL_BASE_SIZE, 'control too short');\n  $.checkArgument(program.length >= 32, 'program is too short');\n\n  try {\n    //! The internal pubkey (x-only, so no Y coordinate parity).\n    const p = PublicKey.fromX(false, control.slice(1, Interpreter.TAPROOT_CONTROL_BASE_SIZE));\n    //! The output pubkey (taken from the scriptPubKey).\n    const q = PublicKey.fromX(false, program);\n    // Compute the Merkle root from the leaf and the provided path.\n    const merkleRoot = Interpreter.computeTaprootMerkleRoot(control, tapleafHash);\n    // Verify that the output pubkey matches the tweaked internal pubkey, after correcting for parity.\n    return q.checkTapTweak(p, merkleRoot, control);\n  } catch (err) {\n    return false;\n  }\n};\n\n\n/**\n * Based on the inner loop of bitcoind's EvalScript function\n * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n */\nInterpreter.prototype.step = function() {\n  var fRequireMinimal = (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALDATA) !== 0;\n\n  //bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n  var fExec = (this.vfExec.indexOf(false) === -1);\n  var buf, buf1, buf2, spliced, n, x1, x2, bn, bn1, bn2, bufSig, bufPubkey, subscript;\n  var sig, pubkey;\n  var fValue, fSuccess;\n  this.execdata = this.execdata || {};\n  if (!this.execdata.codeseparatorPosInit) {\n    this.execdata.codeseparatorPos = new BN(0xFFFFFFFF);\n    this.execdata.codeseparatorPosInit = true;\n  }\n\n  // Read instruction\n  var chunk = this.script.chunks[this.pc];\n  this.pc++;\n  var opcodenum = chunk.opcodenum;\n  if (_.isUndefined(opcodenum)) {\n    this.errstr = 'SCRIPT_ERR_UNDEFINED_OPCODE';\n    return false;\n  }\n  if (chunk.buf && chunk.buf.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {\n    this.errstr = 'SCRIPT_ERR_PUSH_SIZE';\n    return false;\n  }\n\n  if (this.sigversion === Signature.Version.BASE || this.sigversion === Signature.Version.WITNESS_V0) {\n    // Note how Opcode.OP_RESERVED does not count towards the opcode limit.\n    if (opcodenum > Opcode.OP_16 && ++(this.nOpCount) > 201) {\n      this.errstr = 'SCRIPT_ERR_OP_COUNT';\n      return false;\n    }\n  }\n\n\n  if (opcodenum === Opcode.OP_CAT ||\n    opcodenum === Opcode.OP_SUBSTR ||\n    opcodenum === Opcode.OP_LEFT ||\n    opcodenum === Opcode.OP_RIGHT ||\n    opcodenum === Opcode.OP_INVERT ||\n    opcodenum === Opcode.OP_AND ||\n    opcodenum === Opcode.OP_OR ||\n    opcodenum === Opcode.OP_XOR ||\n    opcodenum === Opcode.OP_2MUL ||\n    opcodenum === Opcode.OP_2DIV ||\n    opcodenum === Opcode.OP_MUL ||\n    opcodenum === Opcode.OP_DIV ||\n    opcodenum === Opcode.OP_MOD ||\n    opcodenum === Opcode.OP_LSHIFT ||\n    opcodenum === Opcode.OP_RSHIFT) {\n    this.errstr = 'SCRIPT_ERR_DISABLED_OPCODE';\n    return false;\n  }\n\n  // With SCRIPT_VERIFY_CONST_SCRIPTCODE, OP_CODESEPARATOR in non-segwit script is rejected even in an unexecuted branch\n  if (opcodenum == Opcode.OP_CODESEPARATOR && this.sigversion === Signature.Version.BASE && (this.flags & Interpreter.SCRIPT_VERIFY_CONST_SCRIPTCODE)) {\n    this.errstr = 'SCRIPT_ERR_OP_CODESEPARATOR';\n    return false;\n  }\n\n  if (fExec && 0 <= opcodenum && opcodenum <= Opcode.OP_PUSHDATA4) {\n    if (fRequireMinimal && !this.script.checkMinimalPush(this.pc - 1)) {\n      this.errstr = 'SCRIPT_ERR_MINIMALDATA';\n      return false;\n    }\n    if (!chunk.buf) {\n      this.stack.push(Interpreter.false);\n    } else if (chunk.len !== chunk.buf.length) {\n      throw new Error('Length of push value not equal to length of data');\n    } else {\n      this.stack.push(chunk.buf);\n    }\n  } else if (fExec || (Opcode.OP_IF <= opcodenum && opcodenum <= Opcode.OP_ENDIF)) {\n    switch (opcodenum) {\n      // Push value\n      case Opcode.OP_1NEGATE:\n      case Opcode.OP_1:\n      case Opcode.OP_2:\n      case Opcode.OP_3:\n      case Opcode.OP_4:\n      case Opcode.OP_5:\n      case Opcode.OP_6:\n      case Opcode.OP_7:\n      case Opcode.OP_8:\n      case Opcode.OP_9:\n      case Opcode.OP_10:\n      case Opcode.OP_11:\n      case Opcode.OP_12:\n      case Opcode.OP_13:\n      case Opcode.OP_14:\n      case Opcode.OP_15:\n      case Opcode.OP_16:\n        {\n          // ( -- value)\n          // ScriptNum bn((int)opcode - (int)(Opcode.OP_1 - 1));\n          n = opcodenum - (Opcode.OP_1 - 1);\n          buf = new BN(n).toScriptNumBuffer();\n          this.stack.push(buf);\n          // The result of these opcodes should always be the minimal way to push the data\n          // they push, so no need for a CheckMinimalPush here.\n        }\n        break;\n\n\n        //\n        // Control\n        //\n      case Opcode.OP_NOP:\n        break;\n\n      case Opcode.OP_NOP2:\n      case Opcode.OP_CHECKLOCKTIMEVERIFY:\n\n        if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)) {\n          // not enabled; treat as a NOP2\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n          break;\n        }\n\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        // Note that elsewhere numeric opcodes are limited to\n        // operands in the range -2**31+1 to 2**31-1, however it is\n        // legal for opcodes to produce results exceeding that\n        // range. This limitation is implemented by CScriptNum's\n        // default 4-byte limit.\n        //\n        // If we kept to that limit we'd have a year 2038 problem,\n        // even though the nLockTime field in transactions\n        // themselves is uint32 which only becomes meaningless\n        // after the year 2106.\n        //\n        // Thus as a special case we tell CScriptNum to accept up\n        // to 5-byte bignums, which are good until 2**39-1, well\n        // beyond the 2**32-1 limit of the nLockTime field itself.\n        var nLockTime = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal, 5);\n\n        // In the rare event that the argument may be < 0 due to\n        // some arithmetic being done first, you can always use\n        // 0 MAX CHECKLOCKTIMEVERIFY.\n        if (nLockTime.lt(new BN(0))) {\n          this.errstr = 'SCRIPT_ERR_NEGATIVE_LOCKTIME';\n          return false;\n        }\n\n        // Actually compare the specified lock time with the transaction.\n        if (!this.checkLockTime(nLockTime)) {\n          this.errstr = 'SCRIPT_ERR_UNSATISFIED_LOCKTIME';\n          return false;\n        }\n        break;\n\n      case Opcode.OP_NOP3:\n      case Opcode.OP_CHECKSEQUENCEVERIFY:\n\n        if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)) {\n          // not enabled; treat as a NOP3\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n          break;\n        }\n\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n\n        // nSequence, like nLockTime, is a 32-bit unsigned\n        // integer field. See the comment in CHECKLOCKTIMEVERIFY\n        // regarding 5-byte numeric operands.\n\n        var nSequence = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal, 5);\n\n\n        // In the rare event that the argument may be < 0 due to\n        // some arithmetic being done first, you can always use\n        // 0 MAX CHECKSEQUENCEVERIFY.\n        if (nSequence.lt(new BN(0))) {\n          this.errstr = 'SCRIPT_ERR_NEGATIVE_LOCKTIME';\n          return false;\n        }\n\n        // To provide for future soft-fork extensibility, if the\n        // operand has the disabled lock-time flag set,\n        // CHECKSEQUENCEVERIFY behaves as a NOP.\n        if ((nSequence &\n          Interpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG) != 0) {\n          break;\n        }\n\n        // Actually compare the specified lock time with the transaction.\n        if (!this.checkSequence(nSequence)) {\n          this.errstr = 'SCRIPT_ERR_UNSATISFIED_LOCKTIME';\n          return false;\n        }\n        break;\n\n\n\n      case Opcode.OP_NOP1:\n      case Opcode.OP_NOP4:\n      case Opcode.OP_NOP5:\n      case Opcode.OP_NOP6:\n      case Opcode.OP_NOP7:\n      case Opcode.OP_NOP8:\n      case Opcode.OP_NOP9:\n      case Opcode.OP_NOP10:\n        {\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n        }\n        break;\n\n      case Opcode.OP_IF:\n      case Opcode.OP_NOTIF:\n        {\n          // <expression> if [statements] [else [statements]] endif\n          // bool fValue = false;\n          fValue = false;\n          if (fExec) {\n            if (this.stack.length < 1) {\n              this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n              return false;\n            }\n\n            buf = this.stack[this.stack.length - 1];\n\n            // Tapscript requires minimal IF/NOTIF inputs as a consensus rule.\n            if (this.sigversion === Signature.Version.TAPSCRIPT) {\n              // The input argument to the OP_IF and OP_NOTIF opcodes must be either\n              // exactly 0 (the empty vector) or exactly 1 (the one-byte vector with value 1).\n              if (buf.length > 1 || (buf.length === 1 && buf[0] !== 1)) {\n                this.errstr = 'SCRIPT_ERR_TAPSCRIPT_MINIMALIF';\n                return false;\n              }\n            }\n            // Under witness v0 rules it is only a policy rule, enabled through SCRIPT_VERIFY_MINIMALIF.\n            if (this.sigversion === Signature.Version.WITNESS_V0 && (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALIF)) {\n              buf = this.stack[this.stack.length - 1];\n              if (buf.length > 1) {\n                this.errstr = 'SCRIPT_ERR_MINIMALIF';\n                return false;\n              }\n              if (buf.length == 1 && buf[0]!=1) {\n                this.errstr = 'SCRIPT_ERR_MINIMALIF';\n                return false;\n              }\n            }\n            fValue = Interpreter.castToBool(buf);\n            if (opcodenum === Opcode.OP_NOTIF) {\n              fValue = !fValue;\n            }\n            this.stack.pop();\n          }\n          this.vfExec.push(fValue);\n        }\n        break;\n\n      case Opcode.OP_ELSE:\n        {\n          if (this.vfExec.length === 0) {\n            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n            return false;\n          }\n          this.vfExec[this.vfExec.length - 1] = !this.vfExec[this.vfExec.length - 1];\n        }\n        break;\n\n      case Opcode.OP_ENDIF:\n        {\n          if (this.vfExec.length === 0) {\n            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n            return false;\n          }\n          this.vfExec.pop();\n        }\n        break;\n\n      case Opcode.OP_VERIFY:\n        {\n          // (true -- ) or\n          // (false -- false) and return\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          fValue = Interpreter.castToBool(buf);\n          if (fValue) {\n            this.stack.pop();\n          } else {\n            this.errstr = 'SCRIPT_ERR_VERIFY';\n            return false;\n          }\n        }\n        break;\n\n      case Opcode.OP_RETURN:\n        {\n          this.errstr = 'SCRIPT_ERR_OP_RETURN';\n          return false;\n        }\n        break;\n\n\n        //\n        // Stack ops\n        //\n      case Opcode.OP_TOALTSTACK:\n        {\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.altstack.push(this.stack.pop());\n        }\n        break;\n\n      case Opcode.OP_FROMALTSTACK:\n        {\n          if (this.altstack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_ALTSTACK_OPERATION';\n            return false;\n          }\n          this.stack.push(this.altstack.pop());\n        }\n        break;\n\n      case Opcode.OP_2DROP:\n        {\n          // (x1 x2 -- )\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.pop();\n          this.stack.pop();\n        }\n        break;\n\n      case Opcode.OP_2DUP:\n        {\n          // (x1 x2 -- x1 x2 x1 x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = this.stack[this.stack.length - 2];\n          buf2 = this.stack[this.stack.length - 1];\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n        }\n        break;\n\n      case Opcode.OP_3DUP:\n        {\n          // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = this.stack[this.stack.length - 3];\n          buf2 = this.stack[this.stack.length - 2];\n          var buf3 = this.stack[this.stack.length - 1];\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n          this.stack.push(buf3);\n        }\n        break;\n\n      case Opcode.OP_2OVER:\n        {\n          // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n          if (this.stack.length < 4) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = this.stack[this.stack.length - 4];\n          buf2 = this.stack[this.stack.length - 3];\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n        }\n        break;\n\n      case Opcode.OP_2ROT:\n        {\n          // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n          if (this.stack.length < 6) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          spliced = this.stack.splice(this.stack.length - 6, 2);\n          this.stack.push(spliced[0]);\n          this.stack.push(spliced[1]);\n        }\n        break;\n\n      case Opcode.OP_2SWAP:\n        {\n          // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n          if (this.stack.length < 4) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          spliced = this.stack.splice(this.stack.length - 4, 2);\n          this.stack.push(spliced[0]);\n          this.stack.push(spliced[1]);\n        }\n        break;\n\n      case Opcode.OP_IFDUP:\n        {\n          // (x - 0 | x x)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          fValue = Interpreter.castToBool(buf);\n          if (fValue) {\n            this.stack.push(buf);\n          }\n        }\n        break;\n\n      case Opcode.OP_DEPTH:\n        {\n          // -- stacksize\n          buf = new BN(this.stack.length).toScriptNumBuffer();\n          this.stack.push(buf);\n        }\n        break;\n\n      case Opcode.OP_DROP:\n        {\n          // (x -- )\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.pop();\n        }\n        break;\n\n      case Opcode.OP_DUP:\n        {\n          // (x -- x x)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.push(this.stack[this.stack.length - 1]);\n        }\n        break;\n\n      case Opcode.OP_NIP:\n        {\n          // (x1 x2 -- x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.splice(this.stack.length - 2, 1);\n        }\n        break;\n\n      case Opcode.OP_OVER:\n        {\n          // (x1 x2 -- x1 x2 x1)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.push(this.stack[this.stack.length - 2]);\n        }\n        break;\n\n      case Opcode.OP_PICK:\n      case Opcode.OP_ROLL:\n        {\n          // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n          // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);\n          n = bn.toNumber();\n          this.stack.pop();\n          if (n < 0 || n >= this.stack.length) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - n - 1];\n          if (opcodenum === Opcode.OP_ROLL) {\n            this.stack.splice(this.stack.length - n - 1, 1);\n          }\n          this.stack.push(buf);\n        }\n        break;\n\n      case Opcode.OP_ROT:\n        {\n          // (x1 x2 x3 -- x2 x3 x1)\n          //  x2 x1 x3  after first swap\n          //  x2 x3 x1  after second swap\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          x1 = this.stack[this.stack.length - 3];\n          x2 = this.stack[this.stack.length - 2];\n          var x3 = this.stack[this.stack.length - 1];\n          this.stack[this.stack.length - 3] = x2;\n          this.stack[this.stack.length - 2] = x3;\n          this.stack[this.stack.length - 1] = x1;\n        }\n        break;\n\n      case Opcode.OP_SWAP:\n        {\n          // (x1 x2 -- x2 x1)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          x1 = this.stack[this.stack.length - 2];\n          x2 = this.stack[this.stack.length - 1];\n          this.stack[this.stack.length - 2] = x2;\n          this.stack[this.stack.length - 1] = x1;\n        }\n        break;\n\n      case Opcode.OP_TUCK:\n        {\n          // (x1 x2 -- x2 x1 x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.splice(this.stack.length - 2, 0, this.stack[this.stack.length - 1]);\n        }\n        break;\n\n\n      case Opcode.OP_SIZE:\n        {\n          // (in -- in size)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          bn = new BN(this.stack[this.stack.length - 1].length);\n          this.stack.push(bn.toScriptNumBuffer());\n        }\n        break;\n\n\n        //\n        // Bitwise logic\n        //\n      case Opcode.OP_EQUAL:\n      case Opcode.OP_EQUALVERIFY:\n        //case Opcode.OP_NOTEQUAL: // use Opcode.OP_NUMNOTEQUAL\n        {\n          // (x1 x2 - bool)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = this.stack[this.stack.length - 2];\n          buf2 = this.stack[this.stack.length - 1];\n          var fEqual = buf1.toString('hex') === buf2.toString('hex');\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(fEqual ? Interpreter.true : Interpreter.false);\n          if (opcodenum === Opcode.OP_EQUALVERIFY) {\n            if (fEqual) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_EQUALVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n\n        //\n        // Numeric\n        //\n      case Opcode.OP_1ADD:\n      case Opcode.OP_1SUB:\n      case Opcode.OP_NEGATE:\n      case Opcode.OP_ABS:\n      case Opcode.OP_NOT:\n      case Opcode.OP_0NOTEQUAL:\n        {\n          // (in -- out)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);\n          switch (opcodenum) {\n            case Opcode.OP_1ADD:\n              bn = bn.add(BN.One);\n              break;\n            case Opcode.OP_1SUB:\n              bn = bn.sub(BN.One);\n              break;\n            case Opcode.OP_NEGATE:\n              bn = bn.neg();\n              break;\n            case Opcode.OP_ABS:\n              if (bn.cmp(BN.Zero) < 0) {\n                bn = bn.neg();\n              }\n              break;\n            case Opcode.OP_NOT:\n              bn = new BN((bn.cmp(BN.Zero) === 0) + 0);\n              break;\n            case Opcode.OP_0NOTEQUAL:\n              bn = new BN((bn.cmp(BN.Zero) !== 0) + 0);\n              break;\n              //default:      assert(!'invalid opcode'); break; // TODO: does this ever occur?\n          }\n          this.stack.pop();\n          this.stack.push(bn.toScriptNumBuffer());\n        }\n        break;\n\n      case Opcode.OP_ADD:\n      case Opcode.OP_SUB:\n      case Opcode.OP_BOOLAND:\n      case Opcode.OP_BOOLOR:\n      case Opcode.OP_NUMEQUAL:\n      case Opcode.OP_NUMEQUALVERIFY:\n      case Opcode.OP_NUMNOTEQUAL:\n      case Opcode.OP_LESSTHAN:\n      case Opcode.OP_GREATERTHAN:\n      case Opcode.OP_LESSTHANOREQUAL:\n      case Opcode.OP_GREATERTHANOREQUAL:\n      case Opcode.OP_MIN:\n      case Opcode.OP_MAX:\n        {\n          // (x1 x2 -- out)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);\n          bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);\n          bn = new BN(0);\n\n          switch (opcodenum) {\n            case Opcode.OP_ADD:\n              bn = bn1.add(bn2);\n              break;\n\n            case Opcode.OP_SUB:\n              bn = bn1.sub(bn2);\n              break;\n\n              // case Opcode.OP_BOOLAND:       bn = (bn1 != bnZero && bn2 != bnZero); break;\n            case Opcode.OP_BOOLAND:\n              bn = new BN(((bn1.cmp(BN.Zero) !== 0) && (bn2.cmp(BN.Zero) !== 0)) + 0);\n              break;\n              // case Opcode.OP_BOOLOR:        bn = (bn1 != bnZero || bn2 != bnZero); break;\n            case Opcode.OP_BOOLOR:\n              bn = new BN(((bn1.cmp(BN.Zero) !== 0) || (bn2.cmp(BN.Zero) !== 0)) + 0);\n              break;\n              // case Opcode.OP_NUMEQUAL:      bn = (bn1 == bn2); break;\n            case Opcode.OP_NUMEQUAL:\n              bn = new BN((bn1.cmp(bn2) === 0) + 0);\n              break;\n              // case Opcode.OP_NUMEQUALVERIFY:    bn = (bn1 == bn2); break;\n            case Opcode.OP_NUMEQUALVERIFY:\n              bn = new BN((bn1.cmp(bn2) === 0) + 0);\n              break;\n              // case Opcode.OP_NUMNOTEQUAL:     bn = (bn1 != bn2); break;\n            case Opcode.OP_NUMNOTEQUAL:\n              bn = new BN((bn1.cmp(bn2) !== 0) + 0);\n              break;\n              // case Opcode.OP_LESSTHAN:      bn = (bn1 < bn2); break;\n            case Opcode.OP_LESSTHAN:\n              bn = new BN((bn1.cmp(bn2) < 0) + 0);\n              break;\n              // case Opcode.OP_GREATERTHAN:     bn = (bn1 > bn2); break;\n            case Opcode.OP_GREATERTHAN:\n              bn = new BN((bn1.cmp(bn2) > 0) + 0);\n              break;\n              // case Opcode.OP_LESSTHANOREQUAL:   bn = (bn1 <= bn2); break;\n            case Opcode.OP_LESSTHANOREQUAL:\n              bn = new BN((bn1.cmp(bn2) <= 0) + 0);\n              break;\n              // case Opcode.OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\n            case Opcode.OP_GREATERTHANOREQUAL:\n              bn = new BN((bn1.cmp(bn2) >= 0) + 0);\n              break;\n            case Opcode.OP_MIN:\n              bn = (bn1.cmp(bn2) < 0 ? bn1 : bn2);\n              break;\n            case Opcode.OP_MAX:\n              bn = (bn1.cmp(bn2) > 0 ? bn1 : bn2);\n              break;\n              // default:           assert(!'invalid opcode'); break; //TODO: does this ever occur?\n          }\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(bn.toScriptNumBuffer());\n\n          if (opcodenum === Opcode.OP_NUMEQUALVERIFY) {\n            // if (CastToBool(stacktop(-1)))\n            if (Interpreter.castToBool(this.stack[this.stack.length - 1])) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_NUMEQUALVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      case Opcode.OP_WITHIN:\n        {\n          // (x min max -- out)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 3], fRequireMinimal);\n          bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);\n          var bn3 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);\n          //bool fValue = (bn2 <= bn1 && bn1 < bn3);\n          fValue = (bn2.cmp(bn1) <= 0) && (bn1.cmp(bn3) < 0);\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(fValue ? Interpreter.true : Interpreter.false);\n        }\n        break;\n\n\n        //\n        // Crypto\n        //\n      case Opcode.OP_RIPEMD160:\n      case Opcode.OP_SHA1:\n      case Opcode.OP_SHA256:\n      case Opcode.OP_HASH160:\n      case Opcode.OP_HASH256:\n        {\n          // (in -- hash)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          //valtype vchHash((opcode == Opcode.OP_RIPEMD160 ||\n          //                 opcode == Opcode.OP_SHA1 || opcode == Opcode.OP_HASH160) ? 20 : 32);\n          var bufHash;\n          if (opcodenum === Opcode.OP_RIPEMD160) {\n            bufHash = Hash.ripemd160(buf);\n          } else if (opcodenum === Opcode.OP_SHA1) {\n            bufHash = Hash.sha1(buf);\n          } else if (opcodenum === Opcode.OP_SHA256) {\n            bufHash = Hash.sha256(buf);\n          } else if (opcodenum === Opcode.OP_HASH160) {\n            bufHash = Hash.sha256ripemd160(buf);\n          } else if (opcodenum === Opcode.OP_HASH256) {\n            bufHash = Hash.sha256sha256(buf);\n          }\n          this.stack.pop();\n          this.stack.push(bufHash);\n        }\n        break;\n\n      case Opcode.OP_CODESEPARATOR:\n        {\n          // Hash starts after the code separator\n          this.pbegincodehash = this.pc;\n          this.execdata.codeseparatorPos = this.pc - 1;\n        }\n        break;\n\n      case Opcode.OP_CHECKSIG:\n      case Opcode.OP_CHECKSIGVERIFY:\n        {\n          // (sig pubkey -- bool)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          bufSig = this.stack[this.stack.length - 2];\n          bufPubkey = this.stack[this.stack.length - 1];\n\n          const { success: fSuccess, result } = this._evalCheckSig(bufSig, bufPubkey);\n          if (!result) {\n            return false;\n          }\n\n          this.stack.pop();\n          this.stack.pop();\n\n          // stack.push_back(fSuccess ? vchTrue : vchFalse);\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\n          if (opcodenum === Opcode.OP_CHECKSIGVERIFY) {\n            if (fSuccess) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_CHECKSIGVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n      case Opcode.OP_CHECKSIGADD:\n        {\n          // OP_CHECKSIGADD is only available in Tapscript\n          if (this.sigversion == Signature.Version.BASE || this.sigversion == Signature.Version.WITNESS_V0) {\n            this.errstr = 'SCRIPT_ERR_BAD_OPCODE';\n            return false;\n          }\n\n          // (sig num pubkey -- num)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          let sig = this.stack[this.stack.length - 3];\n          let num = this.stack[this.stack.length - 2];\n          let pubkey = this.stack[this.stack.length - 1];\n\n          num = BN.fromScriptNumBuffer(num, fRequireMinimal);\n\n          const { success, result } = this._evalCheckSig(sig, pubkey);\n          if (!result) {\n            return false;\n          }\n\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(num.addn(success ? 1 : 0).toScriptNumBuffer());\n        }\n        break;\n      case Opcode.OP_CHECKMULTISIG:\n      case Opcode.OP_CHECKMULTISIGVERIFY:\n        {\n          // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n\n          var i = 1;\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          var nKeysCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();\n          if (nKeysCount < 0 || nKeysCount > 20) {\n            this.errstr = 'SCRIPT_ERR_PUBKEY_COUNT';\n            return false;\n          }\n          this.nOpCount += nKeysCount;\n          if (this.nOpCount > 201) {\n            this.errstr = 'SCRIPT_ERR_OP_COUNT';\n            return false;\n          }\n          // int ikey = ++i;\n          var ikey = ++i;\n          i += nKeysCount;\n\n          // ikey2 is the position of last non-signature item in\n          // the stack. Top stack item = 1. With\n          // SCRIPT_VERIFY_NULLFAIL, this is used for cleanup if\n          // operation fails.\n          var ikey2 = nKeysCount + 2;\n\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          var nSigsCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();\n          if (nSigsCount < 0 || nSigsCount > nKeysCount) {\n            this.errstr = 'SCRIPT_ERR_SIG_COUNT';\n            return false;\n          }\n          // int isig = ++i;\n          var isig = ++i;\n          i += nSigsCount;\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          // Subset of script starting at the most recent codeseparator\n          subscript = new Script().set({\n            chunks: this.script.chunks.slice(this.pbegincodehash)\n          });\n\n          // Drop the signatures, since there's no way for a signature to sign itself\n          for (var k = 0; k < nSigsCount; k++) {\n            bufSig = this.stack[this.stack.length - isig - k];\n            subscript.findAndDelete(new Script().add(bufSig));\n          }\n\n          fSuccess = true;\n          while (fSuccess && nSigsCount > 0) {\n            // valtype& vchSig  = stacktop(-isig);\n            bufSig = this.stack[this.stack.length - isig];\n            // valtype& vchPubKey = stacktop(-ikey);\n            bufPubkey = this.stack[this.stack.length - ikey];\n\n            if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\n              return false;\n            }\n\n            var fOk;\n            try {\n              sig = Signature.fromTxFormat(bufSig);\n              pubkey = PublicKey.fromBuffer(bufPubkey, false);\n              fOk = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.sigversion, this.satoshis, this.execdata);\n            } catch (e) {\n              //invalid sig or pubkey\n              fOk = false;\n            }\n\n            if (fOk) {\n              isig++;\n              nSigsCount--;\n            }\n            ikey++;\n            nKeysCount--;\n\n            // If there are more signatures left than keys left,\n            // then too many signatures have failed\n            if (nSigsCount > nKeysCount) {\n              fSuccess = false;\n            }\n          }\n\n\n          // Clean up stack of actual arguments\n          while (i-- > 1) {\n            if (!fSuccess && (this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL) &&\n              !ikey2 && this.stack[this.stack.length - 1].length) {\n\n              this.errstr = 'SCRIPT_ERR_NULLFAIL';\n              return false;\n            }\n\n            if (ikey2 > 0) {\n              ikey2--;\n            }\n\n            this.stack.pop();\n          }\n\n          // A bug causes CHECKMULTISIG to consume one extra argument\n          // whose contents were not checked in any way.\n          //\n          // Unfortunately this is a potential source of mutability,\n          // so optionally verify it is exactly equal to zero prior\n          // to removing it from the stack.\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          if ((this.flags & Interpreter.SCRIPT_VERIFY_NULLDUMMY) && this.stack[this.stack.length - 1].length) {\n            this.errstr = 'SCRIPT_ERR_SIG_NULLDUMMY';\n            return false;\n          }\n          this.stack.pop();\n\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\n\n          if (opcodenum === Opcode.OP_CHECKMULTISIGVERIFY) {\n            if (fSuccess) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_CHECKMULTISIGVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      default:\n        this.errstr = 'SCRIPT_ERR_BAD_OPCODE';\n        return false;\n    }\n  }\n\n  // Size limits\n  if (this.stack.length + this.altstack.length > Interpreter.MAX_STACK_SIZE) {\n    this.errstr = 'SCRIPT_ERR_STACK_SIZE';\n    return false;\n  }\n\n  return true;\n};\n\n","'use strict';\n\nvar Address = require('../address');\nvar BufferReader = require('../encoding/bufferreader');\nvar BufferWriter = require('../encoding/bufferwriter');\nvar Hash = require('../crypto/hash');\nvar Opcode = require('../opcode');\nvar PublicKey = require('../publickey');\nvar Signature = require('../crypto/signature');\nvar Networks = require('../networks');\nvar $ = require('../util/preconditions');\nvar _ = require('lodash');\nvar errors = require('../errors');\nvar BufferUtil = require('../util/buffer');\nvar JSUtil = require('../util/js');\nconst TaggedHash = require('../crypto/taggedhash');\n\n/**\n * A bitcoin transaction script. Each transaction's inputs and outputs\n * has a script that is evaluated to validate it's spending.\n *\n * See https://en.bitcoin.it/wiki/Script\n *\n * @constructor\n * @param {Object|string|Buffer=} from optional data to populate script\n */\nvar Script = function Script(from) {\n  if (!(this instanceof Script)) {\n    return new Script(from);\n  }\n  this.chunks = [];\n\n  if (BufferUtil.isBuffer(from)) {\n    return Script.fromBuffer(from);\n  } else if (from instanceof Address) {\n    return Script.fromAddress(from);\n  } else if (from instanceof Script) {\n    return Script.fromBuffer(from.toBuffer());\n  } else if (typeof from === 'string') {\n    return Script.fromString(from);\n  } else if (_.isObject(from) && Array.isArray(from.chunks)) {\n    this.set(from);\n  }\n};\n\n\nScript.prototype.set = function(obj) {\n  $.checkArgument(_.isObject(obj));\n  $.checkArgument(Array.isArray(obj.chunks));\n  this.chunks = obj.chunks;\n  return this;\n};\n\nScript.fromBuffer = function(buffer) {\n  var script = new Script();\n  script.chunks = [];\n\n  var br = new BufferReader(buffer);\n  while (!br.finished()) {\n    try {\n      var opcodenum = br.readUInt8();\n\n      var len, buf;\n      if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {\n        len = opcodenum;\n        script.chunks.push({\n          buf: br.read(len),\n          len: len,\n          opcodenum: opcodenum\n        });\n      } else if (opcodenum === Opcode.OP_PUSHDATA1) {\n        len = br.readUInt8();\n        buf = br.read(len);\n        script.chunks.push({\n          buf: buf,\n          len: len,\n          opcodenum: opcodenum\n        });\n      } else if (opcodenum === Opcode.OP_PUSHDATA2) {\n        len = br.readUInt16LE();\n        buf = br.read(len);\n        script.chunks.push({\n          buf: buf,\n          len: len,\n          opcodenum: opcodenum\n        });\n      } else if (opcodenum === Opcode.OP_PUSHDATA4) {\n        len = br.readUInt32LE();\n        buf = br.read(len);\n        script.chunks.push({\n          buf: buf,\n          len: len,\n          opcodenum: opcodenum\n        });\n      } else if (Opcode.isOpSuccess(opcodenum)) {\n        // OP_SUCCESSx processing overrides everything, including stack element size limits\n        buf = br.readAll();\n        len = buf.length;\n        script.chunks.push({\n          buf: buf,\n          len: len,\n          opcodenum: opcodenum\n        });\n      } else {\n        script.chunks.push({\n          opcodenum: opcodenum\n        });\n      }\n    } catch (e) {\n      if (e instanceof RangeError) {\n        throw new errors.Script.InvalidBuffer(buffer.toString('hex'));\n      }\n      throw e;\n    }\n  }\n\n  return script;\n};\n\nScript.prototype.toBuffer = function() {\n  var bw = new BufferWriter();\n\n  for (var i = 0; i < this.chunks.length; i++) {\n    var chunk = this.chunks[i];\n    var opcodenum = chunk.opcodenum;\n    bw.writeUInt8(chunk.opcodenum);\n    if (chunk.buf) {\n      if (opcodenum < Opcode.OP_PUSHDATA1) {\n        bw.write(chunk.buf);\n      } else if (opcodenum === Opcode.OP_PUSHDATA1) {\n        bw.writeUInt8(chunk.len);\n        bw.write(chunk.buf);\n      } else if (opcodenum === Opcode.OP_PUSHDATA2) {\n        bw.writeUInt16LE(chunk.len);\n        bw.write(chunk.buf);\n      } else if (opcodenum === Opcode.OP_PUSHDATA4) {\n        bw.writeUInt32LE(chunk.len);\n        bw.write(chunk.buf);\n      } else {\n        // Could reach here if opcodenum is OP_SUCCESSx (see comment in .fromBuffer)\n        bw.write(chunk.buf);\n      }\n    }\n  }\n\n  return bw.concat();\n};\n\nScript.fromASM = function(str) {\n  var script = new Script();\n  script.chunks = [];\n\n  var tokens = str.split(' ');\n  var i = 0;\n  while (i < tokens.length) {\n    var token = tokens[i];\n    var opcode = Opcode(token);\n    var opcodenum = opcode.toNumber();\n\n    if (opcodenum == null) {\n      var buf = Buffer.from(tokens[i], 'hex');\n      script.chunks.push({\n        buf: buf,\n        len: buf.length,\n        opcodenum: buf.length\n      });\n      i = i + 1;\n    } else if (opcodenum === Opcode.OP_PUSHDATA1 ||\n      opcodenum === Opcode.OP_PUSHDATA2 ||\n      opcodenum === Opcode.OP_PUSHDATA4) {\n      script.chunks.push({\n        buf: Buffer.from(tokens[i + 2], 'hex'),\n        len: parseInt(tokens[i + 1]),\n        opcodenum: opcodenum\n      });\n      i = i + 3;\n    } else {\n      script.chunks.push({\n        opcodenum: opcodenum\n      });\n      i = i + 1;\n    }\n  }\n  return script;\n};\n\nScript.fromHex = function(str) {\n  return new Script(Buffer.from(str, 'hex'));\n};\n\nScript.fromString = function(str) {\n  if (JSUtil.isHexa(str) || str.length === 0) {\n    return new Script(Buffer.from(str, 'hex'));\n  }\n  var script = new Script();\n  script.chunks = [];\n\n  var tokens = str.split(' ');\n  var i = 0;\n  while (i < tokens.length) {\n    var token = tokens[i];\n    var opcode = Opcode(token);\n    var opcodenum = opcode.toNumber();\n\n    if (opcodenum == null) {\n      opcodenum = parseInt(token);\n      if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {\n        script.chunks.push({\n          buf: Buffer.from(tokens[i + 1].slice(2), 'hex'),\n          len: opcodenum,\n          opcodenum: opcodenum\n        });\n        i = i + 2;\n      } else {\n        throw new Error('Invalid script: ' + JSON.stringify(str));\n      }\n    } else if (opcodenum === Opcode.OP_PUSHDATA1 ||\n      opcodenum === Opcode.OP_PUSHDATA2 ||\n      opcodenum === Opcode.OP_PUSHDATA4) {\n      if (tokens[i + 2].slice(0, 2) !== '0x') {\n        throw new Error('Pushdata data must start with 0x');\n      }\n      script.chunks.push({\n        buf: Buffer.from(tokens[i + 2].slice(2), 'hex'),\n        len: parseInt(tokens[i + 1]),\n        opcodenum: opcodenum\n      });\n      i = i + 3;\n    } else {\n      script.chunks.push({\n        opcodenum: opcodenum\n      });\n      i = i + 1;\n    }\n  }\n  return script;\n};\n\nScript.prototype._chunkToString = function(chunk, type) {\n  var opcodenum = chunk.opcodenum;\n  var asm = (type === 'asm');\n  var str = '';\n  if (!chunk.buf) {\n    // no data chunk\n    if (typeof Opcode.reverseMap[opcodenum] !== 'undefined') {\n      if (asm) {\n        // A few cases where the opcode name differs from reverseMap\n        // aside from 1 to 16 data pushes.\n        if (opcodenum === 0) {\n          // OP_0 -> 0\n          str = str + ' 0';\n        } else if(opcodenum === 79) {\n          // OP_1NEGATE -> 1\n          str = str + ' -1';\n        } else {\n          str = str + ' ' + Opcode(opcodenum).toString();\n        }\n      } else {\n        str = str + ' ' + Opcode(opcodenum).toString();\n      }\n    } else {\n      var numstr = opcodenum.toString(16);\n      if (numstr.length % 2 !== 0) {\n        numstr = '0' + numstr;\n      }\n      if (asm) {\n        str = str + ' ' + numstr;\n      } else {\n        str = str + ' ' + '0x' + numstr;\n      }\n    }\n  } else {\n    // data chunk\n    if (!asm && opcodenum === Opcode.OP_PUSHDATA1 ||\n      opcodenum === Opcode.OP_PUSHDATA2 ||\n      opcodenum === Opcode.OP_PUSHDATA4) {\n      str = str + ' ' + Opcode(opcodenum).toString();\n    }\n    if (chunk.len > 0) {\n      if (asm) {\n        str = str + ' ' + chunk.buf.toString('hex');\n      } else {\n        str = str + ' ' + chunk.len + ' ' + '0x' + chunk.buf.toString('hex');\n      }\n    }\n  }\n  return str;\n};\n\nScript.prototype.toASM = function() {\n  var str = '';\n  for (var i = 0; i < this.chunks.length; i++) {\n    var chunk = this.chunks[i];\n    str += this._chunkToString(chunk, 'asm');\n  }\n\n  return str.substr(1);\n};\n\nScript.prototype.toString = function() {\n  var str = '';\n  for (var i = 0; i < this.chunks.length; i++) {\n    var chunk = this.chunks[i];\n    str += this._chunkToString(chunk);\n  }\n\n  return str.substr(1);\n};\n\nScript.prototype.toHex = function() {\n  return this.toBuffer().toString('hex');\n};\n\nScript.prototype.inspect = function() {\n  return '<Script: ' + this.toString() + '>';\n};\n\n// script classification methods\n\n/**\n * @returns {boolean} if this is a pay to pubkey hash output script\n */\nScript.prototype.isPublicKeyHashOut = function() {\n  return !!(this.chunks.length === 5 &&\n    this.chunks[0].opcodenum === Opcode.OP_DUP &&\n    this.chunks[1].opcodenum === Opcode.OP_HASH160 &&\n    this.chunks[2].buf &&\n    this.chunks[2].buf.length === 20 &&\n    this.chunks[3].opcodenum === Opcode.OP_EQUALVERIFY &&\n    this.chunks[4].opcodenum === Opcode.OP_CHECKSIG);\n};\n\n/**\n * @returns {boolean} if this is a pay to public key hash input script\n */\nScript.prototype.isPublicKeyHashIn = function() {\n  if (this.chunks.length === 2) {\n    var signatureBuf = this.chunks[0].buf;\n    var pubkeyBuf = this.chunks[1].buf;\n    if (signatureBuf &&\n        signatureBuf.length &&\n        signatureBuf[0] === 0x30 &&\n        pubkeyBuf &&\n        pubkeyBuf.length\n       ) {\n      var version = pubkeyBuf[0];\n      if ((version === 0x04 ||\n           version === 0x06 ||\n           version === 0x07) && pubkeyBuf.length === 65) {\n        return true;\n      } else if ((version === 0x03 || version === 0x02) && pubkeyBuf.length === 33) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\nScript.prototype.getPublicKey = function() {\n  $.checkState(this.isPublicKeyOut(), 'Can\\'t retrieve PublicKey from a non-PK output');\n  return this.chunks[0].buf;\n};\n\nScript.prototype.getPublicKeyHash = function() {\n  if (this.isPublicKeyHashOut()) {\n    return this.chunks[2].buf;\n  } else if (this.isWitnessPublicKeyHashOut()) {\n    return this.chunks[1].buf;\n  } else if (this.isTaproot()) {\n    return this.chunks[1].buf;\n  } else {\n    throw new Error('Can\\'t retrieve PublicKeyHash from a non-PKH output');\n  }\n};\n\n/**\n * @returns {boolean} if this is a public key output script\n */\nScript.prototype.isPublicKeyOut = function() {\n  if (this.chunks.length === 2 &&\n      this.chunks[0].buf &&\n      this.chunks[0].buf.length &&\n      this.chunks[1].opcodenum === Opcode.OP_CHECKSIG) {\n    var pubkeyBuf = this.chunks[0].buf;\n    var version = pubkeyBuf[0];\n    var isVersion = false;\n    if ((version === 0x04 ||\n         version === 0x06 ||\n         version === 0x07) && pubkeyBuf.length === 65) {\n      isVersion = true;\n    } else if ((version === 0x03 || version === 0x02) && pubkeyBuf.length === 33) {\n      isVersion = true;\n    }\n    if (isVersion) {\n      return PublicKey.isValid(pubkeyBuf);\n    }\n  }\n  return false;\n};\n\n/**\n * @returns {boolean} if this is a pay to public key input script\n */\nScript.prototype.isPublicKeyIn = function() {\n  if (this.chunks.length === 1) {\n    var signatureBuf = this.chunks[0].buf;\n    if (signatureBuf &&\n        signatureBuf.length &&\n        signatureBuf[0] === 0x30) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * @returns {boolean} if this is a p2sh output script\n */\nScript.prototype.isScriptHashOut = function() {\n  var buf = this.toBuffer();\n  return (buf.length === 23 &&\n    buf[0] === Opcode.OP_HASH160 &&\n    buf[1] === 0x14 &&\n    buf[buf.length - 1] === Opcode.OP_EQUAL);\n};\n\n/**\n * @returns {boolean} if this is a p2wsh output script\n */\nScript.prototype.isWitnessScriptHashOut = function() {\n  var buf = this.toBuffer();\n  return (buf.length === 34 && buf[0] === Opcode.OP_0 && buf[1] === 32);\n};\n\n/**\n * @returns {boolean} if this is a p2wpkh output script\n */\nScript.prototype.isWitnessPublicKeyHashOut = function() {\n  var buf = this.toBuffer();\n  return (buf.length === 22 && buf[0] === Opcode.OP_0 && buf[1] === 20);\n};\n\n/**\n * @returns {boolean} if this is a p2tr output script\n */\nScript.prototype.isTaproot = function() {\n  var buf = this.toBuffer();\n  return (buf.length === 34 && buf[0] === Opcode.OP_1 && buf[1] === 32);\n}\n\n/**\n * @param {Object=} values - The return values\n * @param {Number} values.version - Set with the witness version\n * @param {Buffer} values.program - Set with the witness program\n * @returns {boolean} if this is a p2wpkh output script\n */\nScript.prototype.isWitnessProgram = function(values) {\n  if (!values) {\n    values = {};\n  }\n  var buf = this.toBuffer();\n  if (buf.length < 4 || buf.length > 42) {\n    return false;\n  }\n  if (buf[0] !== Opcode.OP_0 && !(buf[0] >= Opcode.OP_1 && buf[0] <= Opcode.OP_16)) {\n    return false;\n  }\n\n  if (buf.length === buf[1] + 2) {\n    values.version = Opcode.decodeOpN(buf[0]);\n    values.program = buf.slice(2, buf.length);\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * @returns {boolean} if this is a p2sh input script\n * Note that these are frequently indistinguishable from pubkeyhashin\n */\nScript.prototype.isScriptHashIn = function() {\n  if (this.chunks.length <= 1) {\n    return false;\n  }\n  var redeemChunk = this.chunks[this.chunks.length - 1];\n  var redeemBuf = redeemChunk.buf;\n  if (!redeemBuf) {\n    return false;\n  }\n\n  var redeemScript;\n  try {\n    redeemScript = Script.fromBuffer(redeemBuf);\n  } catch (e) {\n    if (e instanceof errors.Script.InvalidBuffer) {\n      return false;\n    }\n    throw e;\n  }\n  var type = redeemScript.classify();\n  return type !== Script.types.UNKNOWN;\n};\n\n/**\n * @returns {boolean} if this is a mutlsig output script\n */\nScript.prototype.isMultisigOut = function() {\n  return (this.chunks.length > 3 &&\n    Opcode.isSmallIntOp(this.chunks[0].opcodenum) &&\n    this.chunks.slice(1, this.chunks.length - 2).every(function(obj) {\n      return obj.buf && BufferUtil.isBuffer(obj.buf);\n    }) &&\n    Opcode.isSmallIntOp(this.chunks[this.chunks.length - 2].opcodenum) &&\n    this.chunks[this.chunks.length - 1].opcodenum === Opcode.OP_CHECKMULTISIG);\n};\n\n\n/**\n * @returns {boolean} if this is a multisig input script\n */\nScript.prototype.isMultisigIn = function() {\n  return this.chunks.length >= 2 &&\n    this.chunks[0].opcodenum === 0 &&\n    this.chunks.slice(1, this.chunks.length).every(function(obj) {\n      return obj.buf &&\n        BufferUtil.isBuffer(obj.buf) &&\n        Signature.isTxDER(obj.buf);\n    });\n};\n\n/**\n * @returns {boolean} true if this is a valid standard OP_RETURN output\n */\nScript.prototype.isDataOut = function() {\n  return this.chunks.length >= 1 &&\n    this.chunks[0].opcodenum === Opcode.OP_RETURN &&\n    (this.chunks.length === 1 ||\n      (this.chunks.length === 2 &&\n        this.chunks[1].buf &&\n        this.chunks[1].buf.length <= Script.OP_RETURN_STANDARD_SIZE &&\n        this.chunks[1].length === this.chunks.len));\n};\n\n/**\n * Retrieve the associated data for this script.\n * In the case of a pay to public key hash, P2SH, P2WSH, or P2WPKH, return the hash.\n * In the case of a standard OP_RETURN, return the data\n * @returns {Buffer}\n */\nScript.prototype.getData = function() {\n  if (this.isDataOut() || this.isScriptHashOut() || this.isWitnessScriptHashOut() || this.isWitnessPublicKeyHashOut() || this.isTaproot()) {\n    if (this.chunks[1] == null) {\n      return Buffer.alloc(0);\n    } else {\n      return Buffer.from(this.chunks[1].buf);\n    }\n  }\n  if (this.isPublicKeyHashOut()) {\n    return Buffer.from(this.chunks[2].buf);\n  }\n  throw new Error('Unrecognized script type to get data from');\n};\n\n/**\n * @returns {boolean} if the script is only composed of data pushing\n * opcodes or small int opcodes (OP_0, OP_1, ..., OP_16)\n */\nScript.prototype.isPushOnly = function() {\n  return this.chunks.every(function(chunk) {\n    return chunk.opcodenum <= Opcode.OP_16;\n  });\n};\n\n\nScript.types = {};\nScript.types.UNKNOWN = 'Unknown';\nScript.types.PUBKEY_OUT = 'Pay to public key';\nScript.types.PUBKEY_IN = 'Spend from public key';\nScript.types.PUBKEYHASH_OUT = 'Pay to public key hash';\nScript.types.PUBKEYHASH_IN = 'Spend from public key hash';\nScript.types.SCRIPTHASH_OUT = 'Pay to script hash';\nScript.types.SCRIPTHASH_IN = 'Spend from script hash';\nScript.types.MULTISIG_OUT = 'Pay to multisig';\nScript.types.MULTISIG_IN = 'Spend from multisig';\nScript.types.DATA_OUT = 'Data push';\n\nScript.OP_RETURN_STANDARD_SIZE = 80;\n\n// Tag for input annex. If there are at least two witness elements for a transaction input,\n// and the first byte of the last element is 0x50, this last element is called annex, and\n// has meanings independent of the script\nScript.ANNEX_TAG = 0x50;\n\n// Validation weight per passing signature (Tapscript only, see BIP 342).\nScript.VALIDATION_WEIGHT_PER_SIGOP_PASSED = 50;\n\n// How much weight budget is added to the witness size (Tapscript only, see BIP 342).\nScript.VALIDATION_WEIGHT_OFFSET = 50;\n\n\n/**\n * @returns {object} The Script type if it is a known form,\n * or Script.UNKNOWN if it isn't\n */\nScript.prototype.classify = function() {\n  if (this._isInput) {\n    return this.classifyInput();\n  } else if (this._isOutput) {\n    return this.classifyOutput();\n  } else {\n    var outputType = this.classifyOutput();\n    return outputType != Script.types.UNKNOWN ? outputType : this.classifyInput();\n  }\n};\n\nScript.outputIdentifiers = {};\nScript.outputIdentifiers.PUBKEY_OUT = Script.prototype.isPublicKeyOut;\nScript.outputIdentifiers.PUBKEYHASH_OUT = Script.prototype.isPublicKeyHashOut;\nScript.outputIdentifiers.MULTISIG_OUT = Script.prototype.isMultisigOut;\nScript.outputIdentifiers.SCRIPTHASH_OUT = Script.prototype.isScriptHashOut;\nScript.outputIdentifiers.DATA_OUT = Script.prototype.isDataOut;\n\n/**\n * @returns {object} The Script type if it is a known form,\n * or Script.UNKNOWN if it isn't\n */\nScript.prototype.classifyOutput = function() {\n  for (var type in Script.outputIdentifiers) {\n    if (Script.outputIdentifiers[type].bind(this)()) {\n      return Script.types[type];\n    }\n  }\n  return Script.types.UNKNOWN;\n};\n\nScript.inputIdentifiers = {};\nScript.inputIdentifiers.PUBKEY_IN = Script.prototype.isPublicKeyIn;\nScript.inputIdentifiers.PUBKEYHASH_IN = Script.prototype.isPublicKeyHashIn;\nScript.inputIdentifiers.MULTISIG_IN = Script.prototype.isMultisigIn;\nScript.inputIdentifiers.SCRIPTHASH_IN = Script.prototype.isScriptHashIn;\n\n/**\n * @returns {object} The Script type if it is a known form,\n * or Script.UNKNOWN if it isn't\n */\nScript.prototype.classifyInput = function() {\n  for (var type in Script.inputIdentifiers) {\n    if (Script.inputIdentifiers[type].bind(this)()) {\n      return Script.types[type];\n    }\n  }\n  return Script.types.UNKNOWN;\n};\n\n\n/**\n * @returns {boolean} if script is one of the known types\n */\nScript.prototype.isStandard = function() {\n  // TODO: Add BIP62 compliance\n  return this.classify() !== Script.types.UNKNOWN;\n};\n\n\n// Script construction methods\n\n/**\n * Adds a script element at the start of the script.\n * @param {*} obj a string, number, Opcode, Buffer, or object to add\n * @returns {Script} this script instance\n */\nScript.prototype.prepend = function(obj) {\n  this._addByType(obj, true);\n  return this;\n};\n\n/**\n * Compares a script with another script\n */\nScript.prototype.equals = function(script) {\n  $.checkState(script instanceof Script, 'Must provide another script');\n  if (this.chunks.length !== script.chunks.length) {\n    return false;\n  }\n  var i;\n  for (i = 0; i < this.chunks.length; i++) {\n    if (BufferUtil.isBuffer(this.chunks[i].buf) && !BufferUtil.isBuffer(script.chunks[i].buf)) {\n      return false;\n    }\n    if (BufferUtil.isBuffer(this.chunks[i].buf) && !BufferUtil.equals(this.chunks[i].buf, script.chunks[i].buf)) {\n      return false;\n    } else if (this.chunks[i].opcodenum !== script.chunks[i].opcodenum) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Adds a script element to the end of the script.\n *\n * @param {*} obj a string, number, Opcode, Buffer, or object to add\n * @returns {Script} this script instance\n *\n */\nScript.prototype.add = function(obj) {\n  this._addByType(obj, false);\n  return this;\n};\n\nScript.prototype._addByType = function(obj, prepend) {\n  if (typeof obj === 'string') {\n    this._addOpcode(obj, prepend);\n  } else if (typeof obj === 'number') {\n    this._addOpcode(obj, prepend);\n  } else if (obj instanceof Opcode) {\n    this._addOpcode(obj, prepend);\n  } else if (BufferUtil.isBuffer(obj)) {\n    this._addBuffer(obj, prepend);\n  } else if (obj instanceof Script) {\n    this.chunks = this.chunks.concat(obj.chunks);\n  } else if (typeof obj === 'object') {\n    this._insertAtPosition(obj, prepend);\n  } else {\n    throw new Error('Invalid script chunk');\n  }\n};\n\nScript.prototype._insertAtPosition = function(op, prepend) {\n  if (prepend) {\n    this.chunks.unshift(op);\n  } else {\n    this.chunks.push(op);\n  }\n};\n\nScript.prototype._addOpcode = function(opcode, prepend) {\n  var op;\n  if (typeof opcode === 'number') {\n    op = opcode;\n  } else if (opcode instanceof Opcode) {\n    op = opcode.toNumber();\n  } else {\n    op = Opcode(opcode).toNumber();\n  }\n  this._insertAtPosition({\n    opcodenum: op\n  }, prepend);\n  return this;\n};\n\nScript.prototype._addBuffer = function(buf, prepend) {\n  var opcodenum;\n  var len = buf.length;\n  if (len >= 0 && len < Opcode.OP_PUSHDATA1) {\n    opcodenum = len;\n  } else if (len < Math.pow(2, 8)) {\n    opcodenum = Opcode.OP_PUSHDATA1;\n  } else if (len < Math.pow(2, 16)) {\n    opcodenum = Opcode.OP_PUSHDATA2;\n  } else if (len < Math.pow(2, 32)) {\n    opcodenum = Opcode.OP_PUSHDATA4;\n  } else {\n    throw new Error('You can\\'t push that much data');\n  }\n  this._insertAtPosition({\n    buf: buf,\n    len: len,\n    opcodenum: opcodenum\n  }, prepend);\n  return this;\n};\n\nScript.prototype.hasCodeseparators = function() {\n  for (var i = 0; i < this.chunks.length; i++) {\n    if (this.chunks[i].opcodenum === Opcode.OP_CODESEPARATOR) {\n      return true;\n    }\n  }\n  return false;\n};\n\nScript.prototype.removeCodeseparators = function() {\n  var chunks = [];\n  for (var i = 0; i < this.chunks.length; i++) {\n    if (this.chunks[i].opcodenum !== Opcode.OP_CODESEPARATOR) {\n      chunks.push(this.chunks[i]);\n    }\n  }\n  this.chunks = chunks;\n  return this;\n};\n\n// high level script builder methods\n\n/**\n * @returns {Script} a new Multisig output script for given public keys,\n * requiring m of those public keys to spend\n * @param {PublicKey[]} publicKeys - list of all public keys controlling the output\n * @param {number} threshold - amount of required signatures to spend the output\n * @param {Object=} opts - Several options:\n *        - noSorting: defaults to false, if true, don't sort the given\n *                      public keys before creating the script\n */\nScript.buildMultisigOut = function(publicKeys, threshold, opts) {\n  $.checkArgument(threshold <= publicKeys.length,\n    'Number of required signatures must be less than or equal to the number of public keys');\n  opts = opts || {};\n  var script = new Script();\n  script.add(Opcode.smallInt(threshold));\n  publicKeys = publicKeys.map(PublicKey);\n  var sorted = publicKeys;\n  if (!opts.noSorting) {\n    sorted = _.sortBy(publicKeys, function(publicKey) {\n      return publicKey.toString('hex');\n    });\n  }\n  for (var i = 0; i < sorted.length; i++) {\n    var publicKey = sorted[i];\n    script.add(publicKey.toBuffer());\n  }\n  script.add(Opcode.smallInt(publicKeys.length));\n  script.add(Opcode.OP_CHECKMULTISIG);\n  return script;\n};\n\nScript.buildWitnessMultisigOutFromScript = function(script) {\n  if (script instanceof Script) {\n    var s = new Script();\n    s.add(Opcode.OP_0);\n    s.add(Hash.sha256(script.toBuffer()));\n    return s;\n  } else {\n    throw new TypeError('First argument is expected to be a p2sh script');\n  }\n};\n\n/**\n * A new Multisig input script for the given public keys, requiring m of those public keys to spend\n *\n * @param {PublicKey[]} pubkeys list of all public keys controlling the output\n * @param {number} threshold amount of required signatures to spend the output\n * @param {Array} signatures and array of signature buffers to append to the script\n * @param {Object=} opts\n * @param {boolean=} opts.noSorting don't sort the given public keys before creating the script (false by default)\n * @param {Script=} opts.cachedMultisig don't recalculate the redeemScript\n *\n * @returns {Script}\n */\nScript.buildMultisigIn = function(pubkeys, threshold, signatures, opts) {\n  $.checkArgument(Array.isArray(pubkeys));\n  $.checkArgument(!isNaN(threshold));\n  $.checkArgument(Array.isArray(signatures));\n  opts = opts || {};\n  var s = new Script();\n  s.add(Opcode.OP_0);\n  for (const signature of signatures) {\n    $.checkArgument(BufferUtil.isBuffer(signature), 'Signatures must be an array of Buffers');\n    // TODO: allow signatures to be an array of Signature objects\n    s.add(signature);\n  }\n  return s;\n};\n\n/**\n * A new P2SH Multisig input script for the given public keys, requiring m of those public keys to spend\n *\n * @param {PublicKey[]} pubkeys list of all public keys controlling the output\n * @param {number} threshold amount of required signatures to spend the output\n * @param {Array} signatures and array of signature buffers to append to the script\n * @param {Object=} opts\n * @param {boolean=} opts.noSorting don't sort the given public keys before creating the script (false by default)\n * @param {Script=} opts.cachedMultisig don't recalculate the redeemScript\n *\n * @returns {Script}\n */\nScript.buildP2SHMultisigIn = function(pubkeys, threshold, signatures, opts) {\n  $.checkArgument(Array.isArray(pubkeys));\n  $.checkArgument(!isNaN(threshold));\n  $.checkArgument(Array.isArray(signatures));\n  opts = opts || {};\n  var s = new Script();\n  s.add(Opcode.OP_0);\n  for (const signature of signatures) {\n    $.checkArgument(BufferUtil.isBuffer(signature), 'Signatures must be an array of Buffers');\n    // TODO: allow signatures to be an array of Signature objects\n    s.add(signature);\n  }\n  s.add((opts.cachedMultisig || Script.buildMultisigOut(pubkeys, threshold, opts)).toBuffer());\n  return s;\n};\n\n/**\n * @returns {Script} a new pay to public key hash output for the given\n * address or public key\n * @param {(Address|PublicKey)} to - destination address or public key\n */\nScript.buildPublicKeyHashOut = function(to) {\n  $.checkArgument(to != null);\n  $.checkArgument(to instanceof PublicKey || to instanceof Address || typeof to === 'string');\n  if (to instanceof PublicKey) {\n    to = to.toAddress();\n  } else if (typeof to === 'string') {\n    to = new Address(to);\n  }\n  var s = new Script();\n  s.add(Opcode.OP_DUP)\n    .add(Opcode.OP_HASH160)\n    .add(to.hashBuffer)\n    .add(Opcode.OP_EQUALVERIFY)\n    .add(Opcode.OP_CHECKSIG);\n  s._network = to.network;\n  return s;\n};\n\n/**\n * @returns {Script} a new pay to witness v0 output for the given\n * address\n * @param {(Address|PublicKey)} to - destination address\n */\nScript.buildWitnessV0Out = function(to) {\n  $.checkArgument(to != null);\n  $.checkArgument(to instanceof PublicKey || to instanceof Address || typeof to === 'string');\n  if (to instanceof PublicKey) {\n    to = to.toAddress(null, Address.PayToWitnessPublicKeyHash);\n  } else if (typeof to === 'string') {\n    to = new Address(to);\n  }\n  var s = new Script();\n  s.add(Opcode.OP_0)\n    .add(to.hashBuffer);\n  s._network = to.network;\n  return s;\n};\n\n\n/**\n * Build Taproot script output\n * @param {PublicKey|Address} to recipient's pubKey or address\n * @param {Array|Object} scriptTree single leaf object OR array of leaves. leaf: { script: String, leafVersion: Integer }\n * @returns {Script}\n */\nScript.buildWitnessV1Out = function(to, scriptTree) {\n  $.checkArgument(to instanceof PublicKey || to instanceof Address || typeof to === 'string');\n  $.checkArgument(!scriptTree || Array.isArray(scriptTree) || !!scriptTree.script);\n\n  if (typeof to === 'string') {\n    try {\n      to = PublicKey.fromTaproot(to);\n    } catch {\n      to = Address.fromString(to);\n    }\n  }\n  \n  function buildTree(tree) {\n    if (Array.isArray(tree)) {\n      const [left, leftH] = buildTree(tree[0]);\n      const [right, rightH] = buildTree(tree[1]);\n      const ret = [[[left[0], left[1]], rightH], [[right[0], right[1]], leftH]];\n      const hWriter = TaggedHash.TAPBRANCH;\n      if (leftH.compare(rightH) === 1) {\n        hWriter.write(rightH);\n        hWriter.write(leftH);\n      } else {\n        hWriter.write(leftH);\n        hWriter.write(rightH);\n      }\n      return [ret, hWriter.finalize()];\n    } else {\n      const { leafVersion, script } = tree;\n      const scriptBuf = new Script(script).toBuffer();\n      const leafWriter = TaggedHash.TAPLEAF;\n      leafWriter.writeUInt8(leafVersion);\n      leafWriter.writeUInt8(scriptBuf.length);\n      leafWriter.write(scriptBuf);\n      const h = leafWriter.finalize();\n      return [[Buffer.from([leafVersion]), scriptBuf], h];\n    }\n  }\n\n  let taggedHash = null;\n  if (scriptTree) { \n    const [_, h] = buildTree(scriptTree);\n    taggedHash = h;\n  }\n  \n  let tweakedPubKey;\n  if (to instanceof PublicKey) {\n    tweakedPubKey = to.createTapTweak(taggedHash).tweakedPubKey;\n  } else { // Address\n    tweakedPubKey = to.hashBuffer;\n  }\n  const s = new Script();\n  s.add(Opcode.OP_1);\n  s.add(tweakedPubKey);\n  return s;\n};\n\n\n/**\n * @returns {Script} a new pay to public key output for the given\n *  public key\n */\nScript.buildPublicKeyOut = function(pubkey) {\n  $.checkArgument(pubkey instanceof PublicKey);\n  var s = new Script();\n  s.add(pubkey.toBuffer())\n    .add(Opcode.OP_CHECKSIG);\n  return s;\n};\n\n/**\n * @returns {Script} a new OP_RETURN script with data\n * @param {(string|Buffer)} data - the data to embed in the output\n * @param {(string)} encoding - the type of encoding of the string\n */\nScript.buildDataOut = function(data, encoding) {\n  $.checkArgument(data == null || typeof data === 'string' || BufferUtil.isBuffer(data));\n  if (typeof data === 'string') {\n    data = Buffer.from(data, encoding);\n  }\n  var s = new Script();\n  s.add(Opcode.OP_RETURN);\n  if (data != null) {\n    s.add(data);\n  }\n  return s;\n};\n\n/**\n * @param {Script|Address} script - the redeemScript for the new p2sh output.\n *    It can also be a p2sh address\n * @returns {Script} new pay to script hash script for given script\n */\nScript.buildScriptHashOut = function(script) {\n  $.checkArgument(script instanceof Script ||\n    (script instanceof Address && script.isPayToScriptHash()));\n  var s = new Script();\n  s.add(Opcode.OP_HASH160)\n    .add(script instanceof Address ? script.hashBuffer : Hash.sha256ripemd160(script.toBuffer()))\n    .add(Opcode.OP_EQUAL);\n\n  s._network = script._network || script.network;\n  return s;\n};\n\n/**\n * Builds a scriptSig (a script for an input) that signs a public key output script.\n *\n * @param {Signature|Buffer} signature - a Signature object, or the signature in DER canonical encoding\n * @param {number=} sigtype - the type of the signature (defaults to SIGHASH_ALL)\n */\nScript.buildPublicKeyIn = function(signature, sigtype) {\n  $.checkArgument(signature instanceof Signature || BufferUtil.isBuffer(signature));\n  $.checkArgument(sigtype == null || !isNaN(sigtype));\n  if (signature instanceof Signature) {\n    signature = signature.toBuffer();\n  }\n  var script = new Script();\n  script.add(BufferUtil.concat([\n    signature,\n    BufferUtil.integerAsSingleByteBuffer(sigtype || Signature.SIGHASH_ALL)\n  ]));\n  return script;\n};\n\n/**\n * Builds a scriptSig (a script for an input) that signs a public key hash\n * output script.\n *\n * @param {Buffer|string|PublicKey} publicKey\n * @param {Signature|Buffer} signature - a Signature object, or the signature in DER canonical encoding\n * @param {number=} sigtype - the type of the signature (defaults to SIGHASH_ALL)\n */\nScript.buildPublicKeyHashIn = function(publicKey, signature, sigtype) {\n  $.checkArgument(signature instanceof Signature || BufferUtil.isBuffer(signature));\n  $.checkArgument(sigtype == null || !isNaN(sigtype));\n  if (signature instanceof Signature) {\n    signature = signature.toBuffer();\n  }\n  var script = new Script()\n    .add(BufferUtil.concat([\n      signature,\n      BufferUtil.integerAsSingleByteBuffer(sigtype || Signature.SIGHASH_ALL)\n    ]))\n    .add(new PublicKey(publicKey).toBuffer());\n  return script;\n};\n\n/**\n * @returns {Script} an empty script\n */\nScript.empty = function() {\n  return new Script();\n};\n\n/**\n * @returns {Script} a new pay to script hash script that pays to this script\n */\nScript.prototype.toScriptHashOut = function() {\n  return Script.buildScriptHashOut(this);\n};\n\n/**\n * @return {Script} an output script built from the address\n */\nScript.fromAddress = function(address) {\n  address = Address(address);\n  if (address.isPayToScriptHash()) {\n    return Script.buildScriptHashOut(address);\n  } else if (address.isPayToPublicKeyHash()) {\n    return Script.buildPublicKeyHashOut(address);\n  } else if (address.isPayToWitnessPublicKeyHash()) {\n    return Script.buildWitnessV0Out(address);\n  } else if (address.isPayToWitnessScriptHash()) {\n    return Script.buildWitnessV0Out(address);\n  } else if (address.isPayToTaproot()) {\n    return Script.buildWitnessV1Out(address);\n  }\n  throw new errors.Script.UnrecognizedAddress(address);\n};\n\n/**\n * Will return the associated address information object\n * @return {Address|boolean}\n */\nScript.prototype.getAddressInfo = function(opts) {\n  if (this._isInput) {\n    return this._getInputAddressInfo();\n  } else if (this._isOutput) {\n    return this._getOutputAddressInfo();\n  } else {\n    var info = this._getOutputAddressInfo();\n    if (!info) {\n      return this._getInputAddressInfo();\n    }\n    return info;\n  }\n};\n\n/**\n * Will return the associated output scriptPubKey address information object\n * @return {Address|boolean}\n * @private\n */\nScript.prototype._getOutputAddressInfo = function() {\n  var info = {};\n  if (this.isScriptHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToScriptHash;\n  } else if (this.isPublicKeyHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToPublicKeyHash;\n  } else if (this.isWitnessScriptHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToWitnessScriptHash;\n  } else if (this.isWitnessPublicKeyHashOut()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToWitnessPublicKeyHash;\n  } else if (this.isTaproot()) {\n    info.hashBuffer = this.getData();\n    info.type = Address.PayToTaproot;\n  } else {\n    return false;\n  }\n  return info;\n};\n\n/**\n * Will return the associated input scriptSig address information object\n * @return {Address|boolean}\n * @private\n */\nScript.prototype._getInputAddressInfo = function() {\n  var info = {};\n  if (this.isPublicKeyHashIn()) {\n    // hash the publickey found in the scriptSig\n    info.hashBuffer = Hash.sha256ripemd160(this.chunks[1].buf);\n    info.type = Address.PayToPublicKeyHash;\n  } else if (this.isScriptHashIn()) {\n    // hash the redeemscript found at the end of the scriptSig\n    info.hashBuffer = Hash.sha256ripemd160(this.chunks[this.chunks.length - 1].buf);\n    info.type = Address.PayToScriptHash;\n  } else {\n    return false;\n  }\n  return info;\n};\n\n/**\n * @param {Network=} network\n * @return {Address|boolean} the associated address for this script if possible, or false\n */\nScript.prototype.toAddress = function(network) {\n  var info = this.getAddressInfo();\n  if (!info) {\n    return false;\n  }\n  info.network = Networks.get(network) || this._network || Networks.defaultNetwork;\n  return new Address(info);\n};\n\n/**\n * Analogous to bitcoind's FindAndDelete. Find and delete equivalent chunks,\n * typically used with push data chunks.  Note that this will find and delete\n * not just the same data, but the same data with the same push data op as\n * produced by default. i.e., if a pushdata in a tx does not use the minimal\n * pushdata op, then when you try to remove the data it is pushing, it will not\n * be removed, because they do not use the same pushdata op.\n */\nScript.prototype.findAndDelete = function(script) {\n  var buf = script.toBuffer();\n  var hex = buf.toString('hex');\n  for (var i = 0; i < this.chunks.length; i++) {\n    var script2 = Script({\n      chunks: [this.chunks[i]]\n    });\n    var buf2 = script2.toBuffer();\n    var hex2 = buf2.toString('hex');\n    if (hex === hex2) {\n      this.chunks.splice(i, 1);\n    }\n  }\n  return this;\n};\n\n/**\n * Comes from bitcoind's script interpreter CheckMinimalPush function\n * @returns {boolean} if the chunk {i} is the smallest way to push that particular data.\n */\nScript.prototype.checkMinimalPush = function(i) {\n  var chunk = this.chunks[i];\n  var buf = chunk.buf;\n  var opcodenum = chunk.opcodenum;\n  if (!buf) {\n    return true;\n  }\n  if (buf.length === 0) {\n    // Could have used OP_0.\n    return opcodenum === Opcode.OP_0;\n  } else if (buf.length === 1 && buf[0] >= 1 && buf[0] <= 16) {\n    // Could have used OP_1 .. OP_16.\n    return opcodenum === Opcode.OP_1 + (buf[0] - 1);\n  } else if (buf.length === 1 && buf[0] === 0x81) {\n    // Could have used OP_1NEGATE\n    return opcodenum === Opcode.OP_1NEGATE;\n  } else if (buf.length <= 75) {\n    // Could have used a direct push (opcode indicating number of bytes pushed + those bytes).\n    return opcodenum === buf.length;\n  } else if (buf.length <= 255) {\n    // Could have used OP_PUSHDATA.\n    return opcodenum === Opcode.OP_PUSHDATA1;\n  } else if (buf.length <= 65535) {\n    // Could have used OP_PUSHDATA2.\n    return opcodenum === Opcode.OP_PUSHDATA2;\n  }\n  return true;\n};\n\n\n/**\n * Comes from bitcoind's script GetSigOpCount(boolean) function\n * @param {boolean} use current (true) or pre-version-0.6 (false) logic\n * @returns {number} number of signature operations required by this script\n */\nScript.prototype.getSignatureOperationsCount = function(accurate) {\n  accurate = (accurate == null ? true : accurate);\n  var n = 0;\n  var lastOpcode = Opcode.OP_INVALIDOPCODE;\n  for (const chunk of this.chunks) {\n    var opcode = chunk.opcodenum;\n    if (opcode == Opcode.OP_CHECKSIG || opcode == Opcode.OP_CHECKSIGVERIFY) {\n      n++;\n    } else if (opcode == Opcode.OP_CHECKMULTISIG || opcode == Opcode.OP_CHECKMULTISIGVERIFY) {\n      if (accurate && lastOpcode >= Opcode.OP_1 && lastOpcode <= Opcode.OP_16) {\n        n += Opcode.decodeOpN(lastOpcode);\n      } else {\n        n += 20;\n      }\n    }\n    lastOpcode = opcode;\n  }\n  return n;\n};\n\nmodule.exports = Script;\n","module.exports = require('./transaction');\n\nmodule.exports.Input = require('./input');\nmodule.exports.Output = require('./output');\nmodule.exports.UnspentOutput = require('./unspentoutput');\nmodule.exports.Signature = require('./signature');\nmodule.exports.Sighash = require('./sighash');\nmodule.exports.SighashWitness = require('./sighashwitness');\n","module.exports = require('./input');\n\nmodule.exports.PublicKey = require('./publickey');\nmodule.exports.PublicKeyHash = require('./publickeyhash');\nmodule.exports.MultiSig = require('./multisig');\nmodule.exports.MultiSigScriptHash = require('./multisigscripthash');\nmodule.exports.Taproot = require('./taproot');\n","'use strict';\n\nvar _ = require('lodash');\nvar $ = require('../../util/preconditions');\nconst errors = require('../../errors');\nvar BufferWriter = require('../../encoding/bufferwriter');\nvar buffer = require('buffer');\nvar BufferUtil = require('../../util/buffer');\nvar JSUtil = require('../../util/js');\nvar Script = require('../../script');\nvar Sighash = require('../sighash');\nvar Output = require('../output');\n\nvar MAXINT = 0xffffffff; // Math.pow(2, 32) - 1;\nvar DEFAULT_SEQNUMBER = MAXINT;\nvar DEFAULT_LOCKTIME_SEQNUMBER = MAXINT - 1;\nvar DEFAULT_RBF_SEQNUMBER = MAXINT - 2;\nconst SEQUENCE_LOCKTIME_DISABLE_FLAG =  Math.pow(2,31); // (1 << 31);\nconst SEQUENCE_LOCKTIME_TYPE_FLAG = Math.pow(2,22); // (1 << 22);\nconst SEQUENCE_LOCKTIME_MASK = 0xffff;\nconst SEQUENCE_LOCKTIME_GRANULARITY = 512; // 512 seconds\nconst SEQUENCE_BLOCKDIFF_LIMIT = Math.pow(2,16)-1; // 16 bits \n\n\nfunction Input(params) {\n  if (!(this instanceof Input)) {\n    return new Input(params);\n  }\n  if (params) {\n    return this._fromObject(params);\n  }\n}\n\nInput.MAXINT = MAXINT;\nInput.DEFAULT_SEQNUMBER = DEFAULT_SEQNUMBER;\nInput.DEFAULT_LOCKTIME_SEQNUMBER = DEFAULT_LOCKTIME_SEQNUMBER;\nInput.DEFAULT_RBF_SEQNUMBER = DEFAULT_RBF_SEQNUMBER;\nInput.SEQUENCE_LOCKTIME_TYPE_FLAG = SEQUENCE_LOCKTIME_TYPE_FLAG;\n\nObject.defineProperty(Input.prototype, 'script', {\n  configurable: false,\n  enumerable: true,\n  get: function() {\n    if (this.isNull()) {\n      return null;\n    }\n    if (!this._script) {\n      this._script = new Script(this._scriptBuffer);\n      this._script._isInput = true;\n    }\n    return this._script;\n  }\n});\n\nInput.fromObject = function(obj) {\n  $.checkArgument(_.isObject(obj));\n  var input = new Input();\n  return input._fromObject(obj);\n};\n\nInput.prototype._fromObject = function(params) {\n  var prevTxId;\n  if (typeof params.prevTxId === 'string' && JSUtil.isHexa(params.prevTxId)) {\n    prevTxId = Buffer.from(params.prevTxId, 'hex');\n  } else {\n    prevTxId = params.prevTxId;\n  }\n  this.witnesses = [];\n  this.output = params.output ?\n    (params.output instanceof Output ? params.output : new Output(params.output)) : undefined;\n  this.prevTxId = prevTxId || params.txidbuf;\n  this.outputIndex = params.outputIndex == null ? params.txoutnum : params.outputIndex;\n  this.sequenceNumber = params.sequenceNumber == null ?\n    (params.seqnum == null ? DEFAULT_SEQNUMBER : params.seqnum) : params.sequenceNumber;\n  // null script is allowed in setScript()\n  if (params.script === undefined && params.scriptBuffer === undefined) {\n    throw new errors.Transaction.Input.MissingScript();\n  }\n  this.setScript(params.scriptBuffer || params.script);\n  return this;\n};\n\nInput.prototype.toObject = Input.prototype.toJSON = function toObject() {\n  var obj = {\n    prevTxId: this.prevTxId.toString('hex'),\n    outputIndex: this.outputIndex,\n    sequenceNumber: this.sequenceNumber,\n    script: this._scriptBuffer.toString('hex'),\n  };\n  // add human readable form if input contains valid script\n  if (this.script) {\n    obj.scriptString = this.script.toString();\n  }\n  if (this.output) {\n    obj.output = this.output.toObject();\n  }\n  return obj;\n};\n\nInput.fromBufferReader = function(br) {\n  var input = new Input();\n  input.prevTxId = br.readReverse(32);\n  input.outputIndex = br.readUInt32LE();\n  input._scriptBuffer = br.readVarLengthBuffer();\n  input.sequenceNumber = br.readUInt32LE();\n  // TODO: return different classes according to which input it is\n  // e.g: CoinbaseInput, PublicKeyHashInput, MultiSigScriptHashInput, etc.\n  return input;\n};\n\nInput.prototype.toBufferWriter = function(writer) {\n  if (!writer) {\n    writer = new BufferWriter();\n  }\n  writer.writeReverse(this.prevTxId);\n  writer.writeUInt32LE(this.outputIndex);\n  var script = this._scriptBuffer;\n  writer.writeVarintNum(script.length);\n  writer.write(script);\n  writer.writeUInt32LE(this.sequenceNumber);\n  return writer;\n};\n\nInput.prototype.setScript = function(script) {\n  this._script = null;\n  if (script instanceof Script) {\n    this._script = script;\n    this._script._isInput = true;\n    this._scriptBuffer = script.toBuffer();\n  } else if (JSUtil.isHexa(script)) {\n    // hex string script\n    this._scriptBuffer = Buffer.from(script, 'hex');\n  } else if (_.isString(script)) {\n    // human readable string script\n    this._script = new Script(script);\n    this._script._isInput = true;\n    this._scriptBuffer = this._script.toBuffer();\n  } else if (BufferUtil.isBuffer(script)) {\n    // buffer script\n    this._scriptBuffer = Buffer.from(script);\n  } else {\n    throw new TypeError('Invalid argument type: script');\n  }\n  return this;\n};\n\n/**\n * Retrieve signatures for the provided PrivateKey.\n *\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key to use when signing\n * @param {number} inputIndex - the index of this input in the provided transaction\n * @param {number} sigType - defaults to Signature.SIGHASH_ALL\n * @param {Buffer} addressHash - if provided, don't calculate the hash of the\n *     public key associated with the private key provided\n * @abstract\n */\nInput.prototype.getSignatures = function() {\n  throw new errors.AbstractMethodInvoked(\n    'Trying to sign unsupported output type (only P2PKH and P2SH multisig inputs are supported)' +\n    ' for input: ' + JSON.stringify(this)\n  );\n};\n\nInput.prototype.getSatoshisBuffer = function() {\n  $.checkState(this.output instanceof Output);\n  $.checkState(this.output._satoshisBN);\n  return new BufferWriter().writeUInt64LEBN(this.output._satoshisBN).toBuffer();\n};\n\n\nInput.prototype.isFullySigned = function() {\n  throw new errors.AbstractMethodInvoked('Input#isFullySigned');\n};\n\nInput.prototype.isFinal = function() {\n  return this.sequenceNumber !== Input.MAXINT;\n};\n\nInput.prototype.addSignature = function() {\n  throw new errors.AbstractMethodInvoked('Input#addSignature');\n};\n\nInput.prototype.clearSignatures = function() {\n  throw new errors.AbstractMethodInvoked('Input#clearSignatures');\n};\n\nInput.prototype.hasWitnesses = function() {\n  if (this.witnesses && this.witnesses.length > 0) {\n    return true;\n  }\n  return false;\n};\n\nInput.prototype.getWitnesses = function() {\n  return this.witnesses;\n};\n\nInput.prototype.setWitnesses = function(witnesses) {\n  this.witnesses = witnesses;\n};\n\nInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\n  // FIXME: Refactor signature so this is not necessary\n  signature.signature.nhashtype = signature.sigtype;\n  return Sighash.verify(\n    transaction,\n    signature.signature,\n    signature.publicKey,\n    signature.inputIndex,\n    this.output.script\n  );\n};\n\n/**\n * @returns true if this is a coinbase input (represents no input)\n */\nInput.prototype.isNull = function() {\n  return this.prevTxId.toString('hex') === '0000000000000000000000000000000000000000000000000000000000000000' &&\n    this.outputIndex === 0xffffffff;\n};\n\nInput.prototype._estimateSize = function() {\n  return this.toBufferWriter().toBuffer().length;\n};\n\nInput.prototype._getBaseSize = function() {\n  return 32 + 4 + 4; // outpoint (32 + 4) + sequence (4)\n};\n\n\n/**\n * Sets sequence number so that transaction is not valid until the desired seconds\n *  since the transaction is mined\n *\n * @param {Number} time in seconds\n * @return {Transaction} this\n */\nInput.prototype.lockForSeconds = function(seconds) {\n  $.checkArgument(_.isNumber(seconds));\n  if (seconds < 0 ||  seconds >= SEQUENCE_LOCKTIME_GRANULARITY * SEQUENCE_LOCKTIME_MASK) {\n    throw new errors.Transaction.Input.LockTimeRange();\n  }\n  seconds = parseInt(Math.floor(seconds / SEQUENCE_LOCKTIME_GRANULARITY));\n\n  // SEQUENCE_LOCKTIME_DISABLE_FLAG = 1 \n  this.sequenceNumber = seconds | SEQUENCE_LOCKTIME_TYPE_FLAG ;\n  return this;\n};\n\n/**\n * Sets sequence number so that transaction is not valid until the desired block height differnece since the tx is mined\n *\n * @param {Number} height\n * @return {Transaction} this\n */\nInput.prototype.lockUntilBlockHeight = function(heightDiff) {\n  $.checkArgument(_.isNumber(heightDiff));\n  if (heightDiff < 0 || heightDiff >= SEQUENCE_BLOCKDIFF_LIMIT) {\n    throw new errors.Transaction.Input.BlockHeightOutOfRange();\n  }\n  // SEQUENCE_LOCKTIME_TYPE_FLAG = 0\n  // SEQUENCE_LOCKTIME_DISABLE_FLAG = 0\n  this.sequenceNumber = heightDiff ;\n  return this;\n};\n\n\n/**\n *  Returns a semantic version of the input's sequence nLockTime.\n *  @return {Number|Date}\n *  If sequence lock is disabled  it returns null,\n *  if is set to block height lock, returns a block height (number)\n *  else it returns a Date object.\n */\nInput.prototype.getLockTime = function() {\n  if (this.sequenceNumber & SEQUENCE_LOCKTIME_DISABLE_FLAG) {\n    return null;\n  }\n\n  if (this.sequenceNumber & SEQUENCE_LOCKTIME_TYPE_FLAG) {\n    var seconds = SEQUENCE_LOCKTIME_GRANULARITY * (this.sequenceNumber & SEQUENCE_LOCKTIME_MASK);\n    return seconds;\n  } else {\n    var blockHeight = this.sequenceNumber & SEQUENCE_LOCKTIME_MASK;\n    return blockHeight;\n  }\n};\n\n\n\n\nmodule.exports = Input;\n","'use strict';\n\nvar _ = require('lodash');\nvar inherits = require('inherits');\nvar Transaction = require('../transaction');\nvar Input = require('./input');\nvar Output = require('../output');\nvar $ = require('../../util/preconditions');\n\nvar Script = require('../../script');\nvar Signature = require('../../crypto/signature');\nvar Sighash = require('../sighash');\nvar PublicKey = require('../../publickey');\nvar BufferUtil = require('../../util/buffer');\nvar TransactionSignature = require('../signature');\n\n/**\n * @constructor\n */\nfunction MultiSigInput(input, pubkeys, threshold, signatures, opts) {\n  opts = opts || {};\n  Input.apply(this, arguments);\n  var self = this;\n  pubkeys = pubkeys || input.publicKeys;\n  threshold = threshold || input.threshold;\n  signatures = signatures || input.signatures;\n  if (opts.noSorting) {\n    this.publicKeys = pubkeys\n  } else  {\n    this.publicKeys = _.sortBy(pubkeys, function(publicKey) { return publicKey.toString('hex'); });\n  }\n  $.checkState(Script.buildMultisigOut(this.publicKeys, threshold).equals(this.output.script),\n    'Provided public keys don\\'t match to the provided output script');\n  this.publicKeyIndex = {};\n  _.each(this.publicKeys, function(publicKey, index) {\n    self.publicKeyIndex[publicKey.toString()] = index;\n  });\n  this.threshold = threshold;\n  // Empty array of signatures\n  this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);\n}\ninherits(MultiSigInput, Input);\n\nMultiSigInput.prototype.toObject = function() {\n  var obj = Input.prototype.toObject.apply(this, arguments);\n  obj.threshold = this.threshold;\n  obj.publicKeys = _.map(this.publicKeys, function(publicKey) { return publicKey.toString(); });\n  obj.signatures = this._serializeSignatures();\n  return obj;\n};\n\nMultiSigInput.prototype._deserializeSignatures = function(signatures) {\n  return _.map(signatures, function(signature) {\n    if (!signature) {\n      return undefined;\n    }\n    return new TransactionSignature(signature);\n  });\n};\n\nMultiSigInput.prototype._serializeSignatures = function() {\n  return _.map(this.signatures, function(signature) {\n    if (!signature) {\n      return undefined;\n    }\n    return signature.toObject();\n  });\n};\n\n/**\n * Get signatures for this input\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\n * @param {number} index - the index of the input in the transaction input vector\n * @param {number} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\n * @param {Buffer} hashData - unused for this input type\n * @param {String} signingMethod DEPRECATED - method used to sign - 'ecdsa' or 'schnorr'\n * @param {Buffer} merkleRoot - unused for this input type\n * @return {Array<TransactionSignature>}\n */\nMultiSigInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod, merkleRoot) {\n  $.checkState(this.output instanceof Output);\n  sigtype = sigtype || Signature.SIGHASH_ALL;\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\n\n  const results = [];\n  for (const publicKey of this.publicKeys || []) {\n    if (publicKey.toString() === privateKey.publicKey.toString()) {\n      results.push(new TransactionSignature({\n        publicKey: privateKey.publicKey,\n        prevTxId: this.prevTxId,\n        outputIndex: this.outputIndex,\n        inputIndex: index,\n        signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script),\n        sigtype: sigtype\n      }));\n    }\n  }\n\n  return results;\n};\n\nMultiSigInput.prototype.addSignature = function(transaction, signature, signingMethod) {\n  $.checkState(!this.isFullySigned(), 'All needed signatures have already been added');\n  $.checkArgument(!_.isUndefined(this.publicKeyIndex[signature.publicKey.toString()], \"Signature Undefined\"),\n    'Signature has no matching public key');\n  $.checkState(this.isValidSignature(transaction, signature, signingMethod), \"Invalid Signature\");\n  this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;\n  this._updateScript();\n  return this;\n};\n\nMultiSigInput.prototype._updateScript = function() {\n  this.setScript(Script.buildMultisigIn(\n    this.publicKeys,\n    this.threshold,\n    this._createSignatures()\n  ));\n  return this;\n};\n\nMultiSigInput.prototype._createSignatures = function() {\n  return _.map(\n    _.filter(this.signatures, function(signature) { return !_.isUndefined(signature); }),\n    // Future signature types may need refactor of toDER\n    function(signature) {\n      return BufferUtil.concat([\n        signature.signature.toDER(),\n        BufferUtil.integerAsSingleByteBuffer(signature.sigtype)\n      ]);\n    }\n  );\n};\n\nMultiSigInput.prototype.clearSignatures = function() {\n  this.signatures = new Array(this.publicKeys.length);\n  this._updateScript();\n};\n\nMultiSigInput.prototype.isFullySigned = function() {\n  return this.countSignatures() === this.threshold;\n};\n\nMultiSigInput.prototype.countMissingSignatures = function() {\n  return this.threshold - this.countSignatures();\n};\n\nMultiSigInput.prototype.countSignatures = function() {\n  return _.reduce(this.signatures, function(sum, signature) {\n    return sum + (!!signature);\n  }, 0);\n};\n\nMultiSigInput.prototype.publicKeysWithoutSignature = function() {\n  var self = this;\n  return _.filter(this.publicKeys, function(publicKey) {\n    return !(self.signatures[self.publicKeyIndex[publicKey.toString()]]);\n  });\n};\n\nMultiSigInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\n  // FIXME: Refactor signature so this is not necessary\n  signature.signature.nhashtype = signature.sigtype;\n  return Sighash.verify(\n    transaction,\n    signature.signature,\n    signature.publicKey,\n    signature.inputIndex,\n    this.output.script\n  );\n};\n\n/**\n *\n * @param {Buffer[]} signatures\n * @param {PublicKey[]} publicKeys\n * @param {Transaction} transaction\n * @param {Integer} inputIndex\n * @param {Input} input\n * @param {String} signingMethod DEPRECATED - method used to sign - 'ecdsa' or 'schnorr' (future signing method)\n * @returns {TransactionSignature[]}\n */\nMultiSigInput.normalizeSignatures = function(transaction, input, inputIndex, signatures, publicKeys, signingMethod) {\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\n\n  return publicKeys.map(function (pubKey) {\n    var signatureMatch = null;\n    signatures = signatures.filter(function (signatureBuffer) {\n      if (signatureMatch) {\n        return true;\n      }\n\n      var signature = new TransactionSignature({\n        signature: Signature.fromTxFormat(signatureBuffer),\n        publicKey: pubKey,\n        prevTxId: input.prevTxId,\n        outputIndex: input.outputIndex,\n        inputIndex: inputIndex,\n        sigtype: Signature.SIGHASH_ALL\n      });\n\n      signature.signature.nhashtype = signature.sigtype;\n      var isMatch = Sighash.verify(\n          transaction,\n          signature.signature,\n          signature.publicKey,\n          signature.inputIndex,\n          input.output.script\n      );\n\n      if (isMatch) {\n        signatureMatch = signature;\n        return false;\n      }\n\n      return true;\n    });\n\n    return signatureMatch ? signatureMatch : null;\n  });\n};\n\nMultiSigInput.OPCODES_SIZE = 1; // 0\nMultiSigInput.SIGNATURE_SIZE = 73; // size (1) + DER (<=72)\n\nMultiSigInput.prototype._estimateSize = function() {\n  return this._getBaseSize() + MultiSigInput.OPCODES_SIZE +\n    this.threshold * MultiSigInput.SIGNATURE_SIZE;\n};\n\nmodule.exports = MultiSigInput;\n","'use strict';\n\n/* jshint maxparams:5 */\n\nvar _ = require('lodash');\nvar inherits = require('inherits');\nvar Input = require('./input');\nvar Output = require('../output');\nvar $ = require('../../util/preconditions');\n\nvar Address = require('../../address');\nvar Script = require('../../script');\nvar Signature = require('../../crypto/signature');\nvar Sighash = require('../sighash');\nvar SighashWitness = require('../sighashwitness');\nvar BufferWriter = require('../../encoding/bufferwriter');\nvar BufferUtil = require('../../util/buffer');\nvar TransactionSignature = require('../signature');\n\n/**\n * @constructor\n */\nfunction MultiSigScriptHashInput(input, pubkeys, threshold, signatures, opts) {\n  /* jshint maxstatements:20 */\n  opts = opts || {};\n  Input.apply(this, arguments);\n  pubkeys = pubkeys || input.publicKeys;\n  threshold = threshold || input.threshold;\n  signatures = signatures || input.signatures;\n  if (opts.noSorting) {\n    this.publicKeys = pubkeys;\n  } else  {\n    this.publicKeys = _.sortBy(pubkeys, function(publicKey) { return publicKey.toString('hex'); });\n  }\n  this.redeemScript = Script.buildMultisigOut(this.publicKeys, threshold, opts);\n  var nested = Script.buildWitnessMultisigOutFromScript(this.redeemScript);\n  if (nested.equals(this.output.script)) {\n    this.nestedWitness = false;\n    this.type = Address.PayToWitnessScriptHash;\n  } else if (Script.buildScriptHashOut(nested).equals(this.output.script)) {\n    this.nestedWitness = true;\n    this.type = Address.PayToScriptHash;\n  } else if (Script.buildScriptHashOut(this.redeemScript).equals(this.output.script)) {\n    this.nestedWitness = false;\n    this.type = Address.PayToScriptHash;\n  } else {\n    throw new Error('Provided public keys don\\'t hash to the provided output');\n  }\n\n  if (this.nestedWitness) {\n    var scriptSig = new Script();\n    scriptSig.add(nested.toBuffer());\n    this.setScript(scriptSig);\n  }\n\n  this.publicKeyIndex = {};\n  for (let index = 0; index < this.publicKeys.length; index++) {\n    const publicKey = this.publicKeys[index];\n    this.publicKeyIndex[publicKey.toString()] = index;\n  }\n  this.threshold = threshold;\n  // Empty array of signatures\n  this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);\n}\ninherits(MultiSigScriptHashInput, Input);\n\nMultiSigScriptHashInput.prototype.toObject = function() {\n  var obj = Input.prototype.toObject.apply(this, arguments);\n  obj.threshold = this.threshold;\n  obj.publicKeys = this.publicKeys.map(function(publicKey) { return publicKey.toString(); });\n  obj.signatures = this._serializeSignatures();\n  return obj;\n};\n\nMultiSigScriptHashInput.prototype._deserializeSignatures = function(signatures) {\n  return signatures.map(function(signature) {\n    if (!signature) {\n      return undefined;\n    }\n    return new TransactionSignature(signature);\n  });\n};\n\nMultiSigScriptHashInput.prototype._serializeSignatures = function() {\n  return this.signatures.map(function(signature) {\n    if (!signature) {\n      return undefined;\n    }\n    return signature.toObject();\n  });\n};\n\nMultiSigScriptHashInput.prototype.getScriptCode = function() {\n  var writer = new BufferWriter();\n  if (!this.redeemScript.hasCodeseparators()) {\n    var redeemScriptBuffer = this.redeemScript.toBuffer();\n    writer.writeVarintNum(redeemScriptBuffer.length);\n    writer.write(redeemScriptBuffer);\n  } else {\n    throw new Error('@TODO');\n  }\n  return writer.toBuffer();\n};\n\nMultiSigScriptHashInput.prototype.getSighash = function(transaction, privateKey, index, sigtype) {\n  var hash;\n  if (this.nestedWitness || this.type === Address.PayToWitnessScriptHash) {\n    var scriptCode = this.getScriptCode();\n    var satoshisBuffer = this.getSatoshisBuffer();\n    hash = SighashWitness.sighash(transaction, sigtype, index, scriptCode, satoshisBuffer);\n  } else  {\n    hash = Sighash.sighash(transaction, sigtype, index, this.redeemScript);\n  }\n  return hash;\n};\n\n/**\n * Get signatures for this input\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\n * @param {number} index - the index of the input in the transaction input vector\n * @param {number} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\n * @param {Buffer} hashData - unused for this input type\n * @param {String} signingMethod DEPRECATED - method used to sign - 'ecdsa' or 'schnorr'\n * @param {Buffer} merkleRoot - unused for this input type\n * @return {Array<TransactionSignature>}\n */\nMultiSigScriptHashInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod, merkleRoot) {\n  $.checkState(this.output instanceof Output);\n  sigtype = sigtype || Signature.SIGHASH_ALL;\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\n\n  const results = [];\n  for (const publicKey of this.publicKeys) {\n    if (publicKey.toString() === privateKey.publicKey.toString()) {\n      var signature;\n      if (this.nestedWitness || this.type === Address.PayToWitnessScriptHash) {\n        var scriptCode = this.getScriptCode();\n        var satoshisBuffer = this.getSatoshisBuffer();\n        signature = SighashWitness.sign(transaction, privateKey, sigtype, index, scriptCode, satoshisBuffer);\n      } else  {\n        signature = Sighash.sign(transaction, privateKey, sigtype, index, this.redeemScript);\n      }\n      results.push(new TransactionSignature({\n        publicKey: privateKey.publicKey,\n        prevTxId: this.prevTxId,\n        outputIndex: this.outputIndex,\n        inputIndex: index,\n        signature: signature,\n        sigtype: sigtype\n      }));\n    }\n  }\n  return results;\n};\n\nMultiSigScriptHashInput.prototype.addSignature = function(transaction, signature, signingMethod) {\n  $.checkState(!this.isFullySigned(), 'All needed signatures have already been added');\n  $.checkArgument(this.publicKeyIndex[signature.publicKey.toString()] != null,\n                  'Signature has no matching public key');\n  $.checkState(this.isValidSignature(transaction, signature, signingMethod), 'Invalid Signature!');\n  this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;\n  this._updateScript();\n  return this;\n};\n\nMultiSigScriptHashInput.prototype._updateScript = function() {\n  if (this.nestedWitness || this.type === Address.PayToWitnessScriptHash) {\n    var stack = [\n      Buffer.alloc(0),\n    ];\n    var signatures = this._createSignatures();\n    for (var i = 0; i < signatures.length; i++) {\n      stack.push(signatures[i]);\n    }\n    stack.push(this.redeemScript.toBuffer());\n    this.setWitnesses(stack);\n  } else {\n    var scriptSig = Script.buildP2SHMultisigIn(\n      this.publicKeys,\n      this.threshold,\n      this._createSignatures(),\n      { cachedMultisig: this.redeemScript }\n    );\n    this.setScript(scriptSig);\n  }\n  return this;\n};\n\nMultiSigScriptHashInput.prototype._createSignatures = function() {\n  return this.signatures\n    .filter(function(signature) { return signature != null; })\n    .map(function(signature) {\n      return BufferUtil.concat([\n        signature.signature.toDER(),\n        BufferUtil.integerAsSingleByteBuffer(signature.sigtype)\n      ]);\n    });\n};\n\nMultiSigScriptHashInput.prototype.clearSignatures = function() {\n  this.signatures = new Array(this.publicKeys.length);\n  this._updateScript();\n};\n\nMultiSigScriptHashInput.prototype.isFullySigned = function() {\n  return this.countSignatures() === this.threshold;\n};\n\nMultiSigScriptHashInput.prototype.countMissingSignatures = function() {\n  return this.threshold - this.countSignatures();\n};\n\nMultiSigScriptHashInput.prototype.countSignatures = function() {\n  return this.signatures.reduce(function(sum, signature) {\n    return sum + (!!signature);\n  }, 0);\n};\n\nMultiSigScriptHashInput.prototype.publicKeysWithoutSignature = function() {\n  return this.publicKeys.filter((publicKey) => {\n    return !(this.signatures[this.publicKeyIndex[publicKey.toString()]]);\n  });\n};\n\nMultiSigScriptHashInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\n  if (this.nestedWitness || this.type === Address.PayToWitnessScriptHash) {\n    signature.signature.nhashtype = signature.sigtype;\n    var scriptCode = this.getScriptCode();\n    var satoshisBuffer = this.getSatoshisBuffer();\n    return SighashWitness.verify(\n      transaction,\n      signature.signature,\n      signature.publicKey,\n      signature.inputIndex,\n      scriptCode,\n      satoshisBuffer\n    );\n  } else {\n    // FIXME: Refactor signature so this is not necessary\n    signature.signature.nhashtype = signature.sigtype;\n    return Sighash.verify(\n      transaction,\n      signature.signature,\n      signature.publicKey,\n      signature.inputIndex,\n      this.redeemScript\n    );\n  }\n};\n\nMultiSigScriptHashInput.MAX_OPCODES_SIZE = 8; // serialized size (<=3) + 0 .. OP_PUSHDATAx N .. M OP_CHECKMULTISIG\nMultiSigScriptHashInput.MAX_SIGNATURE_SIZE = 74; // size (1) + DER (<=72) + sighash (1)\nMultiSigScriptHashInput.MAX_PUBKEY_SIZE = 34; // size (1) + DER (<=33)\nMultiSigScriptHashInput.REDEEM_SCRIPT_SIZE = 34; // OP_0 (1) + scriptHash (1 + 32)\n\nMultiSigScriptHashInput.prototype._estimateSize = function() {\n  let result = this._getBaseSize();\n  const WITNESS_DISCOUNT = 4;\n  const witnessSize = MultiSigScriptHashInput.MAX_OPCODES_SIZE +\n    this.threshold * MultiSigScriptHashInput.MAX_SIGNATURE_SIZE +\n    this.publicKeys.length * MultiSigScriptHashInput.MAX_PUBKEY_SIZE;\n  if (this.type === Address.PayToWitnessScriptHash) {\n    result += witnessSize / WITNESS_DISCOUNT;\n  } else if (this.nestedWitness) {\n    result += witnessSize / WITNESS_DISCOUNT + MultiSigScriptHashInput.REDEEM_SCRIPT_SIZE;\n  } else {\n    result += witnessSize;\n  }\n  return result;\n};\n\nmodule.exports = MultiSigScriptHashInput;\n","'use strict';\n\nvar inherits = require('inherits');\n\nvar $ = require('../../util/preconditions');\nvar BufferUtil = require('../../util/buffer');\n\nvar Input = require('./input');\nvar Output = require('../output');\nvar Sighash = require('../sighash');\nvar Script = require('../../script');\nvar Signature = require('../../crypto/signature');\nvar TransactionSignature = require('../signature');\n\n/**\n * Represents a special kind of input of PayToPublicKey kind.\n * @constructor\n */\nfunction PublicKeyInput() {\n  Input.apply(this, arguments);\n}\ninherits(PublicKeyInput, Input);\n\n/**\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\n * @param {number} index - the index of the input in the transaction input vector\n * @param {number} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\n * @param {Buffer} hashData - unused for this input type \n * @param {String} signingMethod DEPRECATED - method used to sign input - 'ecdsa' or 'schnorr'\n * @return {Array} of objects that can be\n */\nPublicKeyInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod) {\n  $.checkState(this.output instanceof Output);\n  sigtype = sigtype || Signature.SIGHASH_ALL;\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\n  var publicKey = privateKey.toPublicKey();\n  if (publicKey.toString() === this.output.script.getPublicKey().toString('hex')) {\n    return [new TransactionSignature({\n      publicKey: publicKey,\n      prevTxId: this.prevTxId,\n      outputIndex: this.outputIndex,\n      inputIndex: index,\n      signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script),\n      sigtype: sigtype\n    })];\n  }\n  return [];\n};\n\n/**\n * Add the provided signature\n *\n * @param {Object} signature\n * @param {PublicKey} signature.publicKey\n * @param {Signature} signature.signature\n * @param {number=} signature.sigtype\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)\n * @return {PublicKeyInput} this, for chaining\n */\nPublicKeyInput.prototype.addSignature = function(transaction, signature, signingMethod) {\n  $.checkState(this.isValidSignature(transaction, signature, signingMethod), 'Signature is invalid');\n  this.setScript(Script.buildPublicKeyIn(\n    signature.signature.toDER(),\n    signature.sigtype\n  ));\n  return this;\n};\n\n/**\n * Clear the input's signature\n * @return {PublicKeyHashInput} this, for chaining\n */\nPublicKeyInput.prototype.clearSignatures = function() {\n  this.setScript(Script.empty());\n  return this;\n};\n\n/**\n * Query whether the input is signed\n * @return {boolean}\n */\nPublicKeyInput.prototype.isFullySigned = function() {\n  return this.script.isPublicKeyIn();\n};\n\nPublicKeyInput.SCRIPT_MAX_SIZE = 73; // sigsize (1 + 72)\n\nPublicKeyInput.prototype._estimateSize = function() {\n  return this._getBaseSize() + PublicKeyInput.SCRIPT_MAX_SIZE;\n};\n\nmodule.exports = PublicKeyInput;\n","'use strict';\n\nvar inherits = require('inherits');\n\nvar $ = require('../../util/preconditions');\nvar BufferUtil = require('../../util/buffer');\n\nvar Address = require('../../address');\nvar Hash = require('../../crypto/hash');\nvar Input = require('./input');\nvar Output = require('../output');\nvar Sighash = require('../sighash');\nvar SighashWitness = require('../sighashwitness');\nvar BufferWriter = require('../../encoding/bufferwriter');\nvar BufferUtil = require('../../util/buffer');\nvar Script = require('../../script');\nvar Signature = require('../../crypto/signature');\nvar TransactionSignature = require('../signature');\n\n/**\n * Represents a special kind of input of PayToPublicKeyHash kind.\n * @constructor\n */\nfunction PublicKeyHashInput() {\n  Input.apply(this, arguments);\n}\ninherits(PublicKeyHashInput, Input);\n\nPublicKeyHashInput.prototype.getRedeemScript = function(publicKey) {\n  if (!this.redeemScript) {\n    var redeemScript = Script.buildWitnessV0Out(publicKey);\n    if (Script.buildScriptHashOut(redeemScript).equals(this.output.script)) {\n      var scriptSig = new Script();\n      scriptSig.add(redeemScript.toBuffer());\n      this.setScript(scriptSig);\n      this.redeemScript = redeemScript;\n    }\n  }\n  return this.redeemScript;\n};\n\nPublicKeyHashInput.prototype.getScriptCode = function(publicKey) {\n  var writer = new BufferWriter();\n  var script;\n  if (this.output.script.isScriptHashOut()) {\n    script = this.getRedeemScript(publicKey);\n  } else {\n    script = this.output.script;\n  }\n  var scriptBuffer = Script.buildPublicKeyHashOut(script.toAddress()).toBuffer();\n  writer.writeVarintNum(scriptBuffer.length);\n  writer.write(scriptBuffer);\n  return writer.toBuffer();\n};\n\nPublicKeyHashInput.prototype.getSighash = function(transaction, privateKey, index, sigtype) {\n  var scriptCode = this.getScriptCode(privateKey);\n  var satoshisBuffer = this.getSatoshisBuffer();\n  return SighashWitness.sighash(transaction, sigtype, index, scriptCode, satoshisBuffer);\n};\n\n/**\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\n * @param {number} index - the index of the input in the transaction input vector\n * @param {number} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\n * @param {Buffer} hashData - the precalculated hash of the public key associated with the privateKey provided\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr'\n * @param {Buffer} merkleRoot - unused for this input type\n * @return {Array<TransactionSignature>}\n */\nPublicKeyHashInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod, merkleRoot) {\n  $.checkState(this.output instanceof Output);\n  hashData = hashData || Hash.sha256ripemd160(privateKey.publicKey.toBuffer());\n  sigtype = sigtype || Signature.SIGHASH_ALL;\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\n\n  var script;\n  if (this.output.script.isScriptHashOut()) {\n    script = this.getRedeemScript(privateKey.publicKey);\n  } else {\n    script = this.output.script;\n  }\n\n  if (script && BufferUtil.equals(hashData, script.getPublicKeyHash())) {\n    var signature;\n    if (script.isWitnessPublicKeyHashOut()) {\n      var satoshisBuffer = this.getSatoshisBuffer();\n      var scriptCode = this.getScriptCode(privateKey.publicKey);\n      signature = SighashWitness.sign(transaction, privateKey, sigtype, index, scriptCode, satoshisBuffer);\n    } else {\n      signature = Sighash.sign(transaction, privateKey, sigtype, index, this.output.script);\n    }\n\n    return [new TransactionSignature({\n      publicKey: privateKey.publicKey,\n      prevTxId: this.prevTxId,\n      outputIndex: this.outputIndex,\n      inputIndex: index,\n      signature: signature,\n      sigtype: sigtype\n    })];\n  }\n  return [];\n};\n/* jshint maxparams: 3 */\n\n/**\n * Add the provided signature\n *\n * @param {Transaction} transaction\n * @param {Object} signature\n * @param {PublicKey} signature.publicKey\n * @param {Signature} signature.signature\n * @param {number=} signature.sigtype\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr' (future signing method)\n * @return {PublicKeyHashInput} this, for chaining\n */\nPublicKeyHashInput.prototype.addSignature = function(transaction, signature, signingMethod) {\n  $.checkState(this.isValidSignature(transaction, signature, signingMethod), 'Signature is invalid');\n\n  if (this.output.script.isWitnessPublicKeyHashOut() || this.output.script.isScriptHashOut()) {\n    this.setWitnesses([\n      BufferUtil.concat([\n        signature.signature.toDER(),\n        BufferUtil.integerAsSingleByteBuffer(signature.sigtype)\n      ]),\n      signature.publicKey.toBuffer()\n    ]);\n  } else {\n    this.setScript(Script.buildPublicKeyHashIn(\n      signature.publicKey,\n      signature.signature.toDER(),\n      signature.sigtype\n    ));\n  }\n  return this;\n};\n\n/**\n * Clear the input's signature\n * @return {PublicKeyHashInput} this, for chaining\n */\nPublicKeyHashInput.prototype.clearSignatures = function() {\n  this.setScript(Script.empty());\n  this.setWitnesses([]);\n  return this;\n};\n\n/**\n * Query whether the input is signed\n * @return {boolean}\n */\nPublicKeyHashInput.prototype.isFullySigned = function() {\n  return this.script.isPublicKeyHashIn() || this.hasWitnesses();\n};\n\nPublicKeyHashInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {\n  signingMethod = signingMethod || 'ecdsa'; // unused. Keeping for consistency with other libs\n  // FIXME: Refactor signature so this is not necessary\n  signature.signature.nhashtype = signature.sigtype;\n  if (this.output.script.isWitnessPublicKeyHashOut() || this.output.script.isScriptHashOut()) {\n    var scriptCode = this.getScriptCode();\n    var satoshisBuffer = this.getSatoshisBuffer();\n    return SighashWitness.verify(\n      transaction,\n      signature.signature,\n      signature.publicKey,\n      signature.inputIndex,\n      scriptCode,\n      satoshisBuffer\n    );\n  } else {\n    return Sighash.verify(\n      transaction,\n      signature.signature,\n      signature.publicKey,\n      signature.inputIndex,\n      this.output.script\n    );\n  }\n};\n\n\nPublicKeyHashInput.SCRIPT_MAX_SIZE = 73 + 34; // sigsize (1 + 72) + pubkey (1 + 33)\nPublicKeyHashInput.REDEEM_SCRIPT_SIZE = 1 + 22; // len (1) OP_0 (1) pubkeyhash (1 + 20)\n\nPublicKeyHashInput.prototype._estimateSize = function() {\n  let result = this._getBaseSize();\n  result += 1; // script size\n  const WITNESS_DISCOUNT = 4;\n  const witnessSize = PublicKeyHashInput.SCRIPT_MAX_SIZE / WITNESS_DISCOUNT;\n  if (this.output.script.isWitnessPublicKeyHashOut()) {\n    result += witnessSize;\n  } else if (this.output.script.isScriptHashOut()) {\n    result += witnessSize + PublicKeyHashInput.REDEEM_SCRIPT_SIZE;\n  } else {\n    result += PublicKeyHashInput.SCRIPT_MAX_SIZE;\n  }\n  return result;\n};\n\nmodule.exports = PublicKeyHashInput;\n","const inherits = require('inherits');\nconst $ = require('../../util/preconditions');\nconst PubKeyHashInput = require('./publickeyhash');\nconst SighashSchnorr = require('../sighashschnorr');\nconst Signature = require('../../crypto/signature');\nconst TransactionSignature = require('../signature');\nconst Output = require('../output');\nconst PrivateKey = require('../../privatekey');\n\nfunction TaprootInput() {\n  PubKeyHashInput.apply(this, arguments);\n}\ninherits(TaprootInput, PubKeyHashInput);\n\n/**\n * Get signatures for this input\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\n * @param {number} index - the index of the input in the transaction input vector\n * @param {number} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\n * @param {Buffer} hashData - unused for this input type\n * @param {String} signingMethod - always schnorr for taproot\n * @param {Buffer} merkleRoot - the merkle root of the taproot tree\n * @return {Array<TransactionSignature>}\n */\nTaprootInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod, merkleRoot) {\n  $.checkState(this.output instanceof Output);\n  sigtype = sigtype || Signature.SIGHASH_DEFAULT;\n  \n  const inputIndex = transaction.inputs.indexOf(this);\n  const tweakedPk = privateKey.createTapTweak(merkleRoot).tweakedPrivKey;\n  const signature = SighashSchnorr.sign(\n    transaction,\n    tweakedPk,\n    sigtype,\n    inputIndex,\n    Signature.Version.TAPROOT,\n    null\n  );\n  if (!signature) {\n    return [];\n  }\n  const txSig = new TransactionSignature({\n    publicKey: privateKey.publicKey,\n    prevTxId: this.prevTxId,\n    outputIndex: this.outputIndex,\n    inputIndex,\n    signature: Signature.fromSchnorr(signature),\n    sigtype: sigtype\n  });\n  return this.isValidSignature(transaction, txSig) ? [txSig] : [];\n};\n\n\nTaprootInput.prototype.isValidSignature = function(transaction, signature) {\n  $.checkState(transaction.inputs.indexOf(this) >= 0, 'Signature has no matching input');\n  $.checkState(this.output instanceof Output, 'output is not instance of Output');\n  \n  if (!this.output.script.isTaproot()) {\n    return false;\n  }\n\n  return SighashSchnorr.verify(\n    transaction,\n    signature.signature,\n    this.output.script.chunks[1].buf,\n    Signature.Version.TAPROOT,\n    transaction.inputs.indexOf(this),\n    null\n  );\n};\n\n/**\n * Query whether the input is signed\n * @return {boolean}\n */\nTaprootInput.prototype.isFullySigned = function() {\n  return this.output.script.isTaproot() && this.hasWitnesses();\n};\n\n/**\n * Add the provided signature\n *\n * @param {Transaction} transaction\n * @param {Object} signature\n * @param {PublicKey} signature.publicKey\n * @param {Signature} signature.signature\n * @param {number} signature.sigtype\n * @return {TaprootInput} this, for chaining\n */\nTaprootInput.prototype.addSignature = function(transaction, signature) {\n  if (this.isValidSignature(transaction, signature)) {\n    this.setWitnesses([\n      signature.signature.toBuffer(),\n    ]);\n  }\n  // else... do nothing?\n  // When tx.sign(keys) is called, the given keys are used to try to sign all\n  // inputs. Invalid sigs may be created, in which case we should not add them here.\n  // The flow is kind of weird since this fn name is saying to add the signature.\n  // Maybe the validation check should be upstream to keep the code lexically obedient?\n\n  return this;\n};\n\n\n// TODO verify that this is the correct MAX size.\nTaprootInput.SCRIPT_MAX_SIZE = 66; // numwitnesses (1) + sigsize (1 + 64)\n\nTaprootInput.prototype._estimateSize = function() {\n  let result = this._getBaseSize();\n  result += 1; // script size\n  const WITNESS_DISCOUNT = 4;\n  const witnessSize = TaprootInput.SCRIPT_MAX_SIZE / WITNESS_DISCOUNT;\n  result += witnessSize;\n  return result;\n};\n\n\nmodule.exports = TaprootInput;\n","'use strict';\n\nvar _ = require('lodash');\nvar BN = require('../crypto/bn');\nvar bufferUtil = require('../util/buffer');\nvar JSUtil = require('../util/js');\nvar BufferWriter = require('../encoding/bufferwriter');\nvar Script = require('../script');\nvar $ = require('../util/preconditions');\nvar errors = require('../errors');\nconst Interpreter = require('../script/interpreter');\nconst TaggedHash = require('../crypto/taggedhash');\n\nvar MAX_SAFE_INTEGER = 0x1fffffffffffff;\n\nfunction Output(args) {\n  if (!(this instanceof Output)) {\n    return new Output(args);\n  }\n  if (_.isObject(args)) {\n    this.satoshis = args.satoshis;\n    if (bufferUtil.isBuffer(args.script)) {\n      this.setScriptFromBuffer(args.script);\n    } else {\n      var script;\n      if (_.isString(args.script) && JSUtil.isHexa(args.script)) {\n        script = Buffer.from(args.script, 'hex');\n      } else {\n        script = args.script;\n      }\n      this.setScript(script);\n    }\n\n    if (args.type === 'taproot') {\n      this.branch = [];\n      Object.defineProperty(this, 'isValid', {\n        configurable: false,\n        enumerable: false,\n        get: function() {\n          this._isValid || this._branch.length === 0;\n        },\n        set: function(isValid) {\n          this._isValid = isValid;\n        }\n      });\n      Object.defineProperty(this, 'isComplete', {\n        configurable: false,\n        enumerable: false,\n        get: function() {\n          return this.isValid && (this._branch.length === 0 || (this._branch.length === 1 && !!this._branch[0]));\n        }\n      });\n    }\n  } else {\n    throw new TypeError('Unrecognized argument for Output');\n  }\n}\n\nObject.defineProperty(Output.prototype, 'script', {\n  configurable: false,\n  enumerable: true,\n  get: function() {\n    if (this._script) {\n      return this._script;\n    } else {\n      this.setScriptFromBuffer(this._scriptBuffer);\n      return this._script;\n    }\n\n  }\n});\n\nObject.defineProperty(Output.prototype, 'satoshis', {\n  configurable: false,\n  enumerable: true,\n  get: function() {\n    return this._satoshis;\n  },\n  set: function(num) {\n    if (num instanceof BN) {\n      this._satoshisBN = num;\n      this._satoshis = num.toNumber();\n    } else if (_.isString(num)) {\n      this._satoshis = parseInt(num);\n      this._satoshisBN = BN.fromNumber(this._satoshis);\n    } else {\n      $.checkArgument(\n        JSUtil.isNaturalNumber(num),\n        'Output satoshis is not a natural number'\n      );\n      this._satoshisBN = BN.fromNumber(num);\n      this._satoshis = num;\n    }\n    $.checkState(\n      JSUtil.isNaturalNumber(this._satoshis),\n      'Output satoshis is not a natural number'\n    );\n  }\n});\n\nOutput.prototype.invalidSatoshis = function() {\n  if (this._satoshis > MAX_SAFE_INTEGER) {\n    return 'transaction txout satoshis greater than max safe integer';\n  }\n  if (this._satoshis !== this._satoshisBN.toNumber()) {\n    return 'transaction txout satoshis has corrupted value';\n  }\n  if (this._satoshis < 0) {\n    return 'transaction txout negative';\n  }\n  return false;\n};\n\nOutput.prototype.toObject = Output.prototype.toJSON = function toObject() {\n  var obj = {\n    satoshis: this.satoshis\n  };\n  obj.script = this._scriptBuffer.toString('hex');\n  return obj;\n};\n\nOutput.fromObject = function(data) {\n  return new Output(data);\n};\n\nOutput.prototype.setScriptFromBuffer = function(buffer) {\n  this._scriptBuffer = buffer;\n  try {\n    this._script = Script.fromBuffer(this._scriptBuffer);\n    this._script._isOutput = true;\n  } catch(e) {\n    if (e instanceof errors.Script.InvalidBuffer) {\n      this._script = null;\n    } else {\n      throw e;\n    }\n  }\n};\n\nOutput.prototype.setScript = function(script) {\n  if (script instanceof Script) {\n    this._scriptBuffer = script.toBuffer();\n    this._script = script;\n    this._script._isOutput = true;\n  } else if (_.isString(script)) {\n    this._script = Script.fromString(script);\n    this._scriptBuffer = this._script.toBuffer();\n    this._script._isOutput = true;\n  } else if (bufferUtil.isBuffer(script)) {\n    this.setScriptFromBuffer(script);\n  } else {\n    throw new TypeError('Invalid argument type: script');\n  }\n  return this;\n};\n\nOutput.prototype.inspect = function() {\n  var scriptStr;\n  if (this.script) {\n    scriptStr = this.script.inspect();\n  } else {\n    scriptStr = this._scriptBuffer.toString('hex');\n  }\n  return '<Output (' + this.satoshis + ' sats) ' + scriptStr + '>';\n};\n\nOutput.fromBufferReader = function(br) {\n  var obj = {};\n  obj.satoshis = br.readUInt64LEBN();\n  var size = br.readVarintNum();\n  if (size !== 0) {\n    obj.script = br.read(size);\n  } else {\n    obj.script = Buffer.from([]);\n  }\n  return new Output(obj);\n};\n\nOutput.prototype.toBufferWriter = function(writer) {\n  if (!writer) {\n    writer = new BufferWriter();\n  }\n  writer.writeUInt64LEBN(this._satoshisBN);\n  var script = this._scriptBuffer;\n  writer.writeVarintNum(script.length);\n  writer.write(script);\n  return writer;\n};\n\nOutput.prototype.calculateSize = function() {\n  let result = 8; // satoshis\n  result += BufferWriter.varintBufNum(this._scriptBuffer.length).length;\n  result += this._scriptBuffer.length;\n  return result;\n};\n\n/**\n * Taproot only\n * Add a new script at a certain depth in the tree. Add() operations must be called\n *  in depth-first traversal order of binary tree. If track is true, it will be included in\n *  the GetSpendData() output.\n * @param {Number} depth Tree depth at which to insert the node (depth is 0-based)\n * @param {Script} script \n * @param {Number} leafVersion \n * @param {Boolean} track If true, the leaf will be included in GetSpendData() output\n */\nOutput.prototype.add = function(depth, script, leafVersion, track = true) {\n  $.checkArgument((leafVersion & ~Interpreter.TAPROOT_LEAF_MASK) === 0, 'invalid leafVersion');\n  if (!this.isValid) {\n    return;\n  }\n\n  const node = {\n    hash: TaggedHash.TAPLEAF.writeUInt8(leafVersion).write(script.toBuffer()).finalize(),\n    leaves: []\n  };\n  if (track) {\n    const leafInfo = {\n      script,\n      leafVersion,\n      merkleBranch: []\n    };\n    node.leaves.push(leafInfo);\n  }\n  this._insertNode(node, depth);\n  return this;\n};\n\n\nOutput.prototype._insertNode = function(node, depth) {\n  $.checkArgument(depth >= 0 && depth <= Interpreter.TAPROOT_CONTROL_MAX_NODE_COUNT, 'invalid depth');\n  /* We cannot insert a leaf at a lower depth while a deeper branch is unfinished. Doing\n   * so would mean the Add() invocations do not correspond to a DFS traversal of a\n   * binary tree. */\n  if (depth + 1 < this._branch.length) {\n    this.isValid = false;\n    return;\n  }\n  /* As long as an entry in the branch exists at the specified depth, combine it and propagate up.\n   * The 'node' variable is overwritten here with the newly combined node. */\n  while (this.isValid && this._branch.length > depth && this._branch[depth]) {\n    node = this._combineNodes(node, this._branch[depth]);\n    this._branch = this._branch.slice(0, this._branch.length - 2);\n    if (depth == 0) {\n      this.isValid = false; /* Can't propagate further up than the root */\n    }\n    depth--;\n  }\n  if (this.isValid) {\n    /* Make sure the branch is big enough to place the new node. */\n    if (this._branch.length <= depth) {\n      this._branch = this._branch.slice(0, depth + 1);\n    }\n    $.checkState(!this._nodes[depth]);\n    m_branch[depth] = node;\n  }\n};\n\nOutput.prototype._combineNodes = function(a, b) {\n  const ret = {\n    hash: null,\n    leaves: []\n  };\n  /* Iterate over all tracked leaves in a, add b's hash to their Merkle branch, and move them to ret. */\n  for (let leaf of a.leaves) {\n    leaf.merkleBranch.push(b.hash);\n    ret.leaves.push(leaf);\n  }\n  /* Iterate over all tracked leaves in b, add a's hash to their Merkle branch, and move them to ret. */\n  for (let leaf of b.leaves) {\n    leaf.merkleBranch.push(a.hash);\n    ret.leaves.push(leaf);\n  }\n  /* Lexicographically sort a and b's hash, and compute parent hash. */\n  if (a.hash.compare(b.hash) === -1) {\n    ret.hash = TaggedHash.TAPBRANCH.write(a.hash).write(b.hash).finalize();\n  } else {\n    ret.hash = TaggedHash.TAPBRANCH.write(b.hash).write(a.hash).finalize();\n  }\n  return ret;\n};\n\n\n/**\n * Finalize the construction. Can only be called when IsComplete() is true.\n *  internal_key.IsFullyValid() must be true.\n * @param {PublicKey} pubKey \n */\nOutput.prototype.finalize = function(pubKey) {\n  $.checkState(this.isComplete === true, 'finalize can only be called when isComplete is true');\n  const ret = pubKey.createTapTweak(this._branch.length === 0 ? null : this._branch[0].hash);\n\n};\n\nmodule.exports = Output;\n","'use strict';\n\nvar Signature = require('../crypto/signature');\nvar Script = require('../script');\nvar Output = require('./output');\nvar BufferReader = require('../encoding/bufferreader');\nvar BufferWriter = require('../encoding/bufferwriter');\nvar BN = require('../crypto/bn');\nvar Hash = require('../crypto/hash');\nvar ECDSA = require('../crypto/ecdsa');\nvar $ = require('../util/preconditions');\nvar _ = require('lodash');\n\nvar SIGHASH_SINGLE_BUG = '0000000000000000000000000000000000000000000000000000000000000001';\nvar BITS_64_ON = 'ffffffffffffffff';\n\n/**\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\n * for OP_CHECKSIG.\n *\n * @name Signing.sighash\n * @param {Transaction} transaction the transaction to sign\n * @param {number} sighashType the type of the hash\n * @param {number} inputNumber the input index for the signature\n * @param {Script} subscript the script that will be signed\n */\nvar sighash = function sighash(transaction, sighashType, inputNumber, subscript) {\n  var Transaction = require('./transaction');\n  var Input = require('./input');\n\n  // Convert a string to a number\n  inputNumber = parseInt(inputNumber);\n\n  var i;\n  // Copy transaction\n  var txcopy = Transaction.shallowCopy(transaction);\n\n  // Copy script\n  subscript = new Script(subscript);\n  subscript.removeCodeseparators();\n\n  for (i = 0; i < txcopy.inputs.length; i++) {\n    // Blank signatures for other inputs\n    txcopy.inputs[i] = new Input(txcopy.inputs[i]).setScript(Script.empty());\n  }\n\n  txcopy.inputs[inputNumber] = new Input(txcopy.inputs[inputNumber]).setScript(subscript);\n\n  if ((sighashType & 31) === Signature.SIGHASH_NONE ||\n    (sighashType & 31) === Signature.SIGHASH_SINGLE) {\n\n    // clear all sequenceNumbers\n    for (i = 0; i < txcopy.inputs.length; i++) {\n      if (i !== inputNumber) {\n        txcopy.inputs[i].sequenceNumber = 0;\n      }\n    }\n  }\n\n  if ((sighashType & 31) === Signature.SIGHASH_NONE) {\n    txcopy.outputs = [];\n\n  } else if ((sighashType & 31) === Signature.SIGHASH_SINGLE) {\n    // The SIGHASH_SINGLE bug.\n    // https://bitcointalk.org/index.php?topic=260595.0\n    if (inputNumber >= txcopy.outputs.length) {\n      return Buffer.from(SIGHASH_SINGLE_BUG, 'hex');\n    }\n\n    txcopy.outputs.length = inputNumber + 1;\n\n    for (i = 0; i < inputNumber; i++) {\n      txcopy.outputs[i] = new Output({\n        satoshis: BN.fromBuffer(Buffer.from(BITS_64_ON, 'hex')),\n        script: Script.empty()\n      });\n    }\n  }\n\n  if (sighashType & Signature.SIGHASH_ANYONECANPAY) {\n    txcopy.inputs = [txcopy.inputs[inputNumber]];\n  }\n\n  var buf = new BufferWriter()\n    .write(txcopy.toBuffer())\n    .writeInt32LE(sighashType)\n    .toBuffer();\n  var ret = Hash.sha256sha256(buf);\n  ret = new BufferReader(ret).readReverse();\n  return ret;\n};\n\n/**\n * Create a signature\n *\n * @name Signing.sign\n * @param {Transaction} transaction\n * @param {PrivateKey} privateKey\n * @param {number} sighash\n * @param {number} inputIndex\n * @param {Script} subscript\n * @return {Signature}\n */\nfunction sign(transaction, privateKey, sighashType, inputIndex, subscript) {\n  let hashbuf = sighash(transaction, sighashType, inputIndex, subscript);\n  const sig = ECDSA.sign(hashbuf, privateKey, { endian: 'little' });\n  sig.nhashtype = sighashType;\n  return sig;\n};\n\n/**\n * Verify a signature\n *\n * @name Signing.verify\n * @param {Transaction} transaction\n * @param {Signature} signature\n * @param {PublicKey} publicKey\n * @param {number} inputIndex\n * @param {Script} subscript\n * @return {boolean}\n */\nfunction verify(transaction, signature, publicKey, inputIndex, subscript) {\n  $.checkArgument(!_.isUndefined(transaction), \"Transaction Undefined\");\n  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype), \"Signature Undefined\");\n\n  let hashbuf = sighash(transaction, signature.nhashtype, inputIndex, subscript);\n  return ECDSA.verify(hashbuf, signature, publicKey, { endian: 'little' });\n};\n\n/**\n * @namespace Signing\n */\nmodule.exports = {\n  sighash: sighash,\n  sign: sign,\n  verify: verify\n};\n","'use strict';\n\n/* jshint maxparams:5 */\n\nconst Signature = require('../crypto/signature');\nconst BufferWriter = require('../encoding/bufferwriter');\nconst Hash = require('../crypto/hash');\nconst Schnorr = require('../crypto/schnorr');\nconst $ = require('../util/preconditions');\nconst TaggedHash = require('../crypto/taggedhash');\nconst PrivateKey = require('../privatekey');\n\n/**\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\n * for witness v1 programs as defined by:\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n *\n * @name Signing.sighash\n * @param {Transaction} transaction the transaction to sign\n * @param {Number} sighashType the type of the hash\n * @param {Number} inputNumber the input index for the signature\n * @param {Number} sigversion Taproot or Tapscript version number\n * @param {Object} execdata Object with directives and data for creating the signature hash\n */\nfunction _signatureHash(transaction, sighashType, inputNumber, sigversion, execdata) {\n  let extFlag, keyVersion;\n\n  switch (sigversion) {\n    case Signature.Version.TAPROOT:\n      extFlag = 0;\n      // keyVersion is not used and left uninitialized.\n      break;\n    case Signature.Version.TAPSCRIPT:\n      extFlag = 1;\n      // keyVersion must be 0 for now, representing the current version of\n      // 32-byte public keys in the tapscript signature opcode execution.\n      // An upgradable public key version (with a size not 32-byte) may\n      // request a different keyVersion with a new sigversion.\n      keyVersion = 0;\n      break;\n    default:\n      return false;\n  }\n  $.checkArgument(inputNumber < transaction.inputs.length, 'inputNumber is greater than number of inputs');\n\n  const ss = TaggedHash.TAPSIGHASH;\n\n  // Epoch\n  ss.writeUInt8(0);\n\n  // Hash type\n  const outputType = (sighashType == Signature.SIGHASH_DEFAULT) ? Signature.SIGHASH_ALL : (sighashType & Signature.SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n  const inputType = sighashType & Signature.SIGHASH_INPUT_MASK;\n  if (!(sighashType <= 0x03 || (sighashType >= 0x81 && sighashType <= 0x83))) { // Check valid sighashtype (Signature.SIGHASH_*)\n    return false;\n  }\n  ss.writeUInt8(sighashType);\n\n  // Transaction level data\n  ss.writeInt32LE(transaction.version);\n  ss.writeUInt32LE(transaction.nLockTime);\n  if (inputType !== Signature.SIGHASH_ANYONECANPAY) {\n    const prevoutsBW = new BufferWriter();\n    const spentAmountsBW = new BufferWriter();\n    const spentScriptsBW = new BufferWriter();\n    const sequencesBW = new BufferWriter();\n\n    for(let vin of transaction.inputs) {\n      prevoutsBW.writeReverse(vin.prevTxId);\n      prevoutsBW.writeInt32LE(vin.outputIndex);\n\n      spentAmountsBW.writeUInt64LEBN(vin.output._satoshisBN);\n\n      const scriptBuf = vin.output.script.toBuffer();\n      spentScriptsBW.writeUInt8(scriptBuf.length);\n      spentScriptsBW.write(scriptBuf);\n\n      sequencesBW.writeUInt32LE(vin.sequenceNumber);\n    }\n\n    // ss << cache.m_prevouts_single_hash;\n    const prevoutsSingleHash = Hash.sha256(prevoutsBW.toBuffer());\n    ss.write(prevoutsSingleHash);\n\n    // ss << cache.m_spent_amounts_single_hash;\n    const spentAmountsSingleHash = Hash.sha256(spentAmountsBW.toBuffer());\n    ss.write(spentAmountsSingleHash);\n\n    // ss << cache.m_spent_scripts_single_hash;\n    const spentScriptsSingleHash = Hash.sha256(spentScriptsBW.toBuffer());\n    ss.write(spentScriptsSingleHash);\n\n    // ss << cache.m_sequences_single_hash;\n    const sequencesSingleHash = Hash.sha256(sequencesBW.toBuffer());\n    ss.write(sequencesSingleHash);\n  }\n  if (outputType === Signature.SIGHASH_ALL) {\n    const outputsBW = new BufferWriter();\n    for (let vout of transaction.outputs) {\n      outputsBW.write(vout.toBufferWriter().toBuffer());\n    }\n    // ss << cache.m_outputs_single_hash;\n    const outputsSingleHash = Hash.sha256(outputsBW.toBuffer());\n    ss.write(outputsSingleHash);\n  }\n\n  // Data about the input/prevout being spent\n  $.checkArgument(execdata.annexInit, 'missing or invalid annexInit');\n  const spendType = (extFlag << 1) + (execdata.annexPresent ? 1 : 0); // The low bit indicates whether an annex is present.\n  ss.writeUInt8(spendType);\n  if (inputType === Signature.SIGHASH_ANYONECANPAY) {\n    // ss << tx_to.vin[in_pos].prevout;\n    const buf = new BufferWriter();\n    buf.writeReverse(transaction.inputs[inputNumber].prevTxId);\n    buf.writeInt32LE(transaction.inputs[inputNumber].outputIndex);\n    ss.write(buf.toBuffer());\n    // ss << cache.m_spent_outputs[inputNumber];\n    ss.write(transaction.inputs[inputNumber].output.toBufferWriter().toBuffer());\n    ss.writeUInt32LE(transaction.inputs[inputNumber].sequenceNumber);\n  } else {\n    ss.writeUInt32LE(inputNumber);\n  }\n  if (execdata.annexPresent) {\n    ss.write(execdata.annexHash);\n  }\n\n  // Data about the output (if only one).\n  if (outputType === Signature.SIGHASH_SINGLE) {\n    if (inputNumber >= transaction.outputs.length) {\n      return false;\n    }\n    const bw = new BufferWriter();\n    bw.writeUInt64LEBN(transaction.outputs[inputNumber]._satoshisBN);\n    const buf = transaction.outputs[inputNumber].script.toBuffer();\n    bw.writeVarintNum(buf.length);\n    bw.write(buf);\n    ss.write(Hash.sha256(bw.toBuffer()));\n  }\n\n  // Additional data for BIP 342 signatures\n  if (sigversion == Signature.Version.TAPSCRIPT) {\n    $.checkArgument(execdata.tapleafHashInit, 'missing or invalid tapleafHashInit');\n    ss.write(execdata.tapleafHash);\n    ss.writeUInt8(keyVersion);\n    $.checkArgument(execdata.codeseparatorPosInit, 'missing or invalid codeseparatorPosInit');\n    ss.writeUInt32LE(execdata.codeseparatorPos);\n  }\n\n  // Return the SHA256 hash\n  return ss.finalize();\n};\n\n\nfunction _getExecData(sigversion, leafHash) {\n  const execdata = { annexInit: true, annexPresent: false };\n  if (sigversion === Signature.Version.TAPSCRIPT) {\n    execdata.codeseparatorPosInit = true;\n    execdata.codeseparatorPos = 0xFFFFFFFF; // Only support non-OP_CODESEPARATOR BIP342 signing for now.\n    if (!leafHash) return false; // BIP342 signing needs leaf hash.\n    execdata.tapleafHashInit = true;\n    execdata.tapleafHash = leafHash;\n  }\n  return execdata;\n}\n\n\n/**\n * Create a Schnorr signature\n *\n * @name Signing.sign\n * @param {Transaction} transaction\n * @param {Buffer|BN|PrivateKey} privateKey\n * @param {number} sighash\n * @param {number} inputIndex\n * @param {number} sigversion\n * @param {Buffer} leafHash\n * @return {Signature}\n */\nfunction sign(transaction, privateKey, sighashType, inputIndex, sigversion, leafHash) {\n  $.checkArgument(sigversion === Signature.Version.TAPROOT || sigversion === Signature.Version.TAPSCRIPT, 'Invalid sigversion');\n  \n  const execdata = _getExecData(sigversion, leafHash);\n  const hashbuf = _signatureHash(transaction, sighashType, inputIndex, sigversion, execdata);\n  if (!hashbuf) {\n    return false;\n  }\n  const sig = Schnorr.sign(privateKey, hashbuf);\n  if (sighashType !== Signature.SIGHASH_DEFAULT) {\n    return Buffer.concat([sig, Buffer.from([sighashType])]); // 65 bytes\n  }\n  return sig; // 64 bytes\n};\n\n\n/**\n * Verify a Schnorr signature\n *\n * @name Signing.verify\n * @param {Transaction} transaction\n * @param {Signature} signature\n * @param {PublicKey} publicKey\n * @param {Number} inputIndex\n * @param {object|Buffer|null} execdata If given, can be full execdata object or just the leafHash buffer\n * @return {Boolean}\n */\nfunction verify(transaction, signature, publicKey, sigversion, inputIndex, execdata) {\n  $.checkArgument(transaction != null, 'Transaction Undefined');\n\n  if (!execdata || Buffer.isBuffer(execdata)) {\n    const leafHash = execdata;\n    execdata = _getExecData(sigversion, leafHash);\n  }\n\n  $.checkArgument(execdata.annexInit, 'invalid execdata');\n\n  const hashbuf = _signatureHash(transaction, signature.nhashtype, inputIndex, sigversion, execdata);\n  if (!hashbuf) {\n    return false;\n  }\n  const verified = Schnorr.verify(publicKey, hashbuf, signature);\n  return verified;\n};\n\n/**\n * @namespace Signing\n */\nmodule.exports = {\n  sign: sign,\n  verify: verify\n};\n","'use strict';\n\n/* jshint maxparams:5 */\n\nvar Signature = require('../crypto/signature');\nvar Script = require('../script');\nvar BufferReader = require('../encoding/bufferreader');\nvar BufferWriter = require('../encoding/bufferwriter');\nvar Hash = require('../crypto/hash');\nvar ECDSA = require('../crypto/ecdsa');\nvar $ = require('../util/preconditions');\nvar _ = require('lodash');\n\n/**\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\n * for witness programs as defined by:\n * https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki\n *\n * @name Signing.sighash\n * @param {Transaction} transaction the transaction to sign\n * @param {number} sighashType the type of the hash\n * @param {number} inputNumber the input index for the signature\n * @param {Buffer} scriptCode\n * @param {Buffer} satoshisBuffer\n */\nvar sighash = function sighash(transaction, sighashType, inputNumber, scriptCode, satoshisBuffer) {\n  /* jshint maxstatements: 50 */\n\n  var hashPrevouts = Buffer.alloc(32);\n  var hashSequence = Buffer.alloc(32);\n  var hashOutputs = Buffer.alloc(32);\n\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY)) {\n    var buffers = [];\n    for (var n = 0; n < transaction.inputs.length; n++) {\n      var input = transaction.inputs[n];\n      var prevTxIdBuffer = new BufferReader(input.prevTxId).readReverse();\n      buffers.push(prevTxIdBuffer);\n      var outputIndexBuffer = Buffer.alloc(4);\n      outputIndexBuffer.writeUInt32LE(input.outputIndex, 0);\n      buffers.push(outputIndexBuffer);\n    }\n    hashPrevouts = Hash.sha256sha256(Buffer.concat(buffers));\n  }\n\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY) &&\n      (sighashType & 0x1f) !== Signature.SIGHASH_SINGLE && (sighashType & 0x1f) !== Signature.SIGHASH_NONE) {\n\n    var sequenceBuffers = [];\n    for (var m = 0; m < transaction.inputs.length; m++) {\n      var sequenceBuffer = Buffer.alloc(4);\n      sequenceBuffer.writeUInt32LE(transaction.inputs[m].sequenceNumber, 0);\n      sequenceBuffers.push(sequenceBuffer);\n    }\n    hashSequence = Hash.sha256sha256(Buffer.concat(sequenceBuffers));\n  }\n\n  var outputWriter = new BufferWriter();\n  if ((sighashType & 0x1f) !== Signature.SIGHASH_SINGLE && (sighashType & 0x1f) !== Signature.SIGHASH_NONE) {\n    for (var p = 0; p < transaction.outputs.length; p++) {\n      transaction.outputs[p].toBufferWriter(outputWriter);\n    }\n    hashOutputs = Hash.sha256sha256(outputWriter.toBuffer());\n  } else if ((sighashType & 0x1f) === Signature.SIGHASH_SINGLE && inputNumber < transaction.outputs.length) {\n    transaction.outputs[inputNumber].toBufferWriter(outputWriter);\n    hashOutputs = Hash.sha256sha256(outputWriter.toBuffer());\n  }\n\n  // Version\n  var writer = new BufferWriter();\n  writer.writeUInt32LE(transaction.version);\n\n  // Input prevouts/nSequence (none/all, depending on flags)\n  writer.write(hashPrevouts);\n  writer.write(hashSequence);\n\n  // The input being signed (replacing the scriptSig with scriptCode + amount)\n  // The prevout may already be contained in hashPrevout, and the nSequence\n  // may already be contain in hashSequence.\n  var outpointId = new BufferReader(transaction.inputs[inputNumber].prevTxId).readReverse();\n  writer.write(outpointId);\n  writer.writeUInt32LE(transaction.inputs[inputNumber].outputIndex);\n\n  writer.write(scriptCode);\n\n  writer.write(satoshisBuffer);\n\n  writer.writeUInt32LE(transaction.inputs[inputNumber].sequenceNumber);\n\n  // Outputs (none/one/all, depending on flags)\n  writer.write(hashOutputs);\n\n  // Locktime\n  writer.writeUInt32LE(transaction.nLockTime);\n\n  // Sighash type\n  writer.writeInt32LE(sighashType);\n\n  return Hash.sha256sha256(writer.toBuffer());\n\n};\n\n/**\n * Create a signature\n *\n * @name Signing.sign\n * @param {Transaction} transaction\n * @param {PrivateKey} privateKey\n * @param {number} sighash\n * @param {number} inputIndex\n * @param {Script} subscript\n * @return {Signature}\n */\nfunction sign(transaction, privateKey, sighashType, inputIndex, scriptCode, satoshisBuffer) {\n  let hashbuf = sighash(transaction, sighashType, inputIndex, scriptCode, satoshisBuffer);\n  return ECDSA.sign(hashbuf, privateKey).set({ nhashtype: sighashType });\n}\n\n/**\n * Verify a signature\n *\n * @name Signing.verify\n * @param {Transaction} transaction\n * @param {Signature} signature\n * @param {PublicKey} publicKey\n * @param {number} inputIndex\n * @param {Script} subscript\n * @return {boolean}\n */\nfunction verify(transaction, signature, publicKey, inputIndex, scriptCode, satoshisBuffer) {\n  $.checkArgument(!_.isUndefined(transaction), \"Transaction Undefined\");\n  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype), \"Signature Undefined\");\n\n  let hashbuf = sighash(transaction, signature.nhashtype, inputIndex, scriptCode, satoshisBuffer);\n  return ECDSA.verify(hashbuf, signature, publicKey);\n}\n\n/**\n * @namespace Signing\n */\nmodule.exports = {\n  sighash: sighash,\n  sign: sign,\n  verify: verify\n};\n","'use strict';\n\nvar $ = require('../util/preconditions');\nvar inherits = require('inherits');\nvar BufferUtil = require('../util/buffer');\nvar JSUtil = require('../util/js');\n\nvar PublicKey = require('../publickey');\nvar errors = require('../errors');\nvar Signature = require('../crypto/signature');\n\n/**\n * @desc\n * Wrapper around Signature with fields related to signing a transaction specifically\n *\n * @param {Object|string|TransactionSignature} arg\n * @constructor\n */\nfunction TransactionSignature(arg) {\n  if (!(this instanceof TransactionSignature)) {\n    return new TransactionSignature(arg);\n  }\n  if (arg instanceof TransactionSignature) {\n    return arg;\n  }\n  if (arg && typeof arg === 'object') {\n    return this._fromObject(arg);\n  }\n  throw new errors.InvalidArgument('TransactionSignatures must be instantiated from an object');\n}\ninherits(TransactionSignature, Signature);\n\nTransactionSignature.prototype._fromObject = function(arg) {\n  this._checkObjectArgs(arg);\n  this.publicKey = new PublicKey(arg.publicKey);\n  this.prevTxId = BufferUtil.isBuffer(arg.prevTxId) ? arg.prevTxId : Buffer.from(arg.prevTxId, 'hex');\n  this.outputIndex = arg.outputIndex;\n  this.inputIndex = arg.inputIndex;\n  this.signature = (arg.signature instanceof Signature) ? arg.signature :\n                     BufferUtil.isBuffer(arg.signature) ? Signature.fromBuffer(arg.signature) :\n                     Signature.fromString(arg.signature);\n  this.sigtype = arg.sigtype;\n  return this;\n};\n\nTransactionSignature.prototype._checkObjectArgs = function(arg) {\n  $.checkArgument(PublicKey(arg.publicKey), 'invalid publicKey');\n  $.checkArgument(arg.inputIndex != null, 'missing inputIndex');\n  $.checkArgument(arg.outputIndex != null, 'missing outputIndex');\n  $.checkState(!isNaN(arg.inputIndex), 'inputIndex must be a number');\n  $.checkState(!isNaN(arg.outputIndex), 'outputIndex must be a number');\n  $.checkArgument(arg.signature, 'missing signature');\n  $.checkArgument(arg.prevTxId, 'missing prevTxId');\n  $.checkState(arg.signature instanceof Signature ||\n               BufferUtil.isBuffer(arg.signature) ||\n               JSUtil.isHexa(arg.signature), 'signature must be a buffer or hexa value');\n  $.checkState(BufferUtil.isBuffer(arg.prevTxId) ||\n               JSUtil.isHexa(arg.prevTxId), 'prevTxId must be a buffer or hexa value');\n  $.checkArgument(arg.sigtype != null, 'missing sigtype');\n  $.checkState(!isNaN(arg.sigtype), 'sigtype must be a number');\n};\n\n/**\n * Serializes a transaction to a plain JS object\n * @return {Object}\n */\nTransactionSignature.prototype.toObject = TransactionSignature.prototype.toJSON = function toObject() {\n  return {\n    publicKey: this.publicKey.toString(),\n    prevTxId: this.prevTxId.toString('hex'),\n    outputIndex: this.outputIndex,\n    inputIndex: this.inputIndex,\n    signature: this.signature.toString(),\n    sigtype: this.sigtype\n  };\n};\n\n/**\n * Builds a TransactionSignature from an object\n * @param {Object} object\n * @return {TransactionSignature}\n */\nTransactionSignature.fromObject = function(object) {\n  $.checkArgument(object);\n  return new TransactionSignature(object);\n};\n\nmodule.exports = TransactionSignature;\n","'use strict';\n\nvar _ = require('lodash');\nvar $ = require('../util/preconditions');\nvar buffer = require('buffer');\nvar compare = Buffer.compare || require('buffer-compare');\n\nvar errors = require('../errors');\nvar BufferUtil = require('../util/buffer');\nvar JSUtil = require('../util/js');\nvar BufferReader = require('../encoding/bufferreader');\nvar BufferWriter = require('../encoding/bufferwriter');\nvar Hash = require('../crypto/hash');\nvar Signature = require('../crypto/signature');\nvar Sighash = require('./sighash');\nvar SighashWitness = require('./sighashwitness');\nconst SighashSchnorr = require('./sighashschnorr');\n\nvar Address = require('../address');\nvar UnspentOutput = require('./unspentoutput');\nvar Input = require('./input');\nvar PublicKeyHashInput = Input.PublicKeyHash;\nvar PublicKeyInput = Input.PublicKey;\nvar MultiSigScriptHashInput = Input.MultiSigScriptHash;\nvar MultiSigInput = Input.MultiSig;\nconst TaprootInput = Input.Taproot;\nvar Output = require('./output');\nvar Script = require('../script');\nvar PrivateKey = require('../privatekey');\nvar BN = require('../crypto/bn');\n\n/**\n * Represents a transaction, a set of inputs and outputs to change ownership of tokens\n *\n * @param {*} serialized\n * @constructor\n */\nfunction Transaction(serialized, opts) {\n  if (!(this instanceof Transaction)) {\n    return new Transaction(serialized);\n  }\n  this.inputs = [];\n  this.outputs = [];\n  this._inputAmount = undefined;\n  this._outputAmount = undefined;\n\n  if (serialized) {\n    if (serialized instanceof Transaction) {\n      return Transaction.shallowCopy(serialized);\n    } else if (JSUtil.isHexa(serialized)) {\n      this.fromString(serialized);\n    } else if (BufferUtil.isBuffer(serialized)) {\n      this.fromBuffer(serialized);\n    } else if (_.isObject(serialized)) {\n      this.fromObject(serialized, opts);\n    } else {\n      throw new errors.InvalidArgument('Must provide an object or string to deserialize a transaction');\n    }\n  } else {\n    this._newTransaction();\n  }\n}\nvar CURRENT_VERSION = 2;\nvar DEFAULT_NLOCKTIME = 0;\nvar MAX_BLOCK_SIZE = 1000000;\n\n// Minimum amount for an output for it not to be considered a dust output\nTransaction.DUST_AMOUNT = 546;\n\n// Margin of error to allow fees in the vecinity of the expected value but doesn't allow a big difference\nTransaction.FEE_SECURITY_MARGIN = 150;\n\n// max amount of satoshis in circulation\nTransaction.MAX_MONEY = 21000000 * 1e8;\n\n// nlocktime limit to be considered block height rather than a timestamp\nTransaction.NLOCKTIME_BLOCKHEIGHT_LIMIT = 5e8;\n\n// Max value for an unsigned 32 bit value\nTransaction.NLOCKTIME_MAX_VALUE = 4294967295;\n\n// Value used for fee estimation (satoshis per kilobyte)\nTransaction.FEE_PER_KB = 100000;\n\n// Safe upper bound for change address script size in bytes\nTransaction.CHANGE_OUTPUT_MAX_SIZE = 20 + 4 + 34 + 4;\nTransaction.MAXIMUM_EXTRA_SIZE = 4 + 9 + 9 + 4;\n\n/* Constructors and Serialization */\n\n/**\n * Create a 'shallow' copy of the transaction, by serializing and deserializing\n * it dropping any additional information that inputs and outputs may have hold\n *\n * @param {Transaction} transaction\n * @return {Transaction}\n */\nTransaction.shallowCopy = function(transaction) {\n  var copy = new Transaction(transaction.toBuffer());\n  return copy;\n};\n\nvar hashProperty = {\n  configurable: false,\n  enumerable: true,\n  get: function() {\n    this._hash = new BufferReader(this._getHash()).readReverse().toString('hex');\n    return this._hash;\n  }\n};\n\nvar witnessHashProperty = {\n  configurable: false,\n  enumerable: true,\n  get: function() {\n    return new BufferReader(this._getWitnessHash()).readReverse().toString('hex');\n  }\n};\n\nObject.defineProperty(Transaction.prototype, 'witnessHash', witnessHashProperty);\nObject.defineProperty(Transaction.prototype, 'hash', hashProperty);\nObject.defineProperty(Transaction.prototype, 'id', hashProperty);\n\nvar ioProperty = {\n  configurable: false,\n  enumerable: true,\n  get: function() {\n    return this._getInputAmount();\n  }\n};\nObject.defineProperty(Transaction.prototype, 'inputAmount', ioProperty);\nioProperty.get = function() {\n  return this._getOutputAmount();\n};\nObject.defineProperty(Transaction.prototype, 'outputAmount', ioProperty);\n\nObject.defineProperty(Transaction.prototype, 'size', {\n  configurable: false,\n  enumerable: false,\n  get: function() {\n    return this._calculateSize();\n  }\n});\n\nObject.defineProperty(Transaction.prototype, 'vsize', {\n  configurable: false,\n  enumerable: false,\n  get: function() {\n    return this._calculateVSize();\n  }\n});\n\nObject.defineProperty(Transaction.prototype, 'weight', {\n  configurable: false,\n  enumerable: false,\n  get: function() {\n    return this._calculateWeight();\n  }\n});\n\n/**\n * Retrieve the little endian hash of the transaction (used for serialization)\n * @return {Buffer}\n */\nTransaction.prototype._getHash = function() {\n  return Hash.sha256sha256(this.toBuffer(true));\n};\n\n/**\n * Retrieve the little endian hash of the transaction including witness data\n * @return {Buffer}\n */\nTransaction.prototype._getWitnessHash = function() {\n  return Hash.sha256sha256(this.toBuffer(false));\n};\n\n/**\n * Retrieve a hexa string that can be used with bitcoind's CLI interface\n * (decoderawtransaction, sendrawtransaction)\n *\n * @param {Object|boolean=} unsafe if true, skip all tests. if it's an object,\n *   it's expected to contain a set of flags to skip certain tests:\n * * `disableAll`: disable all checks\n * * `disableSmallFees`: disable checking for fees that are too small\n * * `disableLargeFees`: disable checking for fees that are too large\n * * `disableIsFullySigned`: disable checking if all inputs are fully signed\n * * `disableDustOutputs`: disable checking if there are no outputs that are dust amounts\n * * `disableMoreOutputThanInput`: disable checking if the transaction spends more bitcoins than the sum of the input amounts\n * @return {string}\n */\nTransaction.prototype.serialize = function(unsafe) {\n  if (true === unsafe || unsafe && unsafe.disableAll) {\n    return this.uncheckedSerialize();\n  } else {\n    return this.checkedSerialize(unsafe);\n  }\n};\n\nTransaction.prototype.uncheckedSerialize = Transaction.prototype.toString = function() {\n  return this.toBuffer().toString('hex');\n};\n\n/**\n * Retrieve a hexa string that can be used with bitcoind's CLI interface\n * (decoderawtransaction, sendrawtransaction)\n *\n * @param {Object} opts allows to skip certain tests. {@see Transaction#serialize}\n * @return {string}\n */\nTransaction.prototype.checkedSerialize = function(opts) {\n  var serializationError = this.getSerializationError(opts);\n  if (serializationError) {\n    serializationError.message += ' - For more information please see: ' +\n      'https://github.com/bitpay/bitcore/blob/master/packages/bitcore-lib/docs/transaction.md#serialization-checks';\n    throw serializationError;\n  }\n  return this.uncheckedSerialize();\n};\n\nTransaction.prototype.invalidSatoshis = function() {\n  var invalid = false;\n  for (var i = 0; i < this.outputs.length; i++) {\n    if (this.outputs[i].invalidSatoshis()) {\n      invalid = true;\n    }\n  }\n  return invalid;\n};\n\n/**\n * Retrieve a possible error that could appear when trying to serialize and\n * broadcast this transaction.\n *\n * @param {Object} opts allows to skip certain tests. {@see Transaction#serialize}\n * @return {bitcore.Error}\n */\nTransaction.prototype.getSerializationError = function(opts) {\n  opts = opts || {};\n\n  if (this.invalidSatoshis()) {\n    return new errors.Transaction.InvalidSatoshis();\n  }\n\n  var unspent = this._getUnspentValue();\n  var unspentError;\n  if (unspent < 0) {\n    if (!opts.disableMoreOutputThanInput) {\n      unspentError = new errors.Transaction.InvalidOutputAmountSum();\n    }\n  } else {\n    unspentError = this._hasFeeError(opts, unspent);\n  }\n\n  return unspentError ||\n    this._hasDustOutputs(opts) ||\n    this._isMissingSignatures(opts);\n};\n\nTransaction.prototype._hasFeeError = function(opts, unspent) {\n\n  if (this._fee != null && this._fee !== unspent) {\n    return new errors.Transaction.FeeError.Different(\n      'Unspent value is ' + unspent + ' but specified fee is ' + this._fee\n    );\n  }\n\n  if (!opts.disableLargeFees) {\n    var maximumFee = Math.floor(Transaction.FEE_SECURITY_MARGIN * this._estimateFee());\n    if (unspent > maximumFee) {\n      if (this._missingChange()) {\n        return new errors.Transaction.ChangeAddressMissing(\n          'Fee is too large and no change address was provided'\n        );\n      }\n      return new errors.Transaction.FeeError.TooLarge(\n        'expected less than ' + maximumFee + ' but got ' + unspent\n      );\n    }\n  }\n\n  if (!opts.disableSmallFees) {\n    var minimumFee = Math.ceil(this._estimateFee() / Transaction.FEE_SECURITY_MARGIN);\n    if (unspent < minimumFee) {\n      return new errors.Transaction.FeeError.TooSmall(\n        'expected more than ' + minimumFee + ' but got ' + unspent\n      );\n    }\n  }\n};\n\nTransaction.prototype._missingChange = function() {\n  return !this._changeScript;\n};\n\nTransaction.prototype._hasDustOutputs = function(opts) {\n  if (opts.disableDustOutputs) {\n    return;\n  }\n  var index, output;\n  for (index in this.outputs) {\n    output = this.outputs[index];\n    if (output.satoshis < Transaction.DUST_AMOUNT && !output.script.isDataOut()) {\n      return new errors.Transaction.DustOutputs();\n    }\n  }\n};\n\nTransaction.prototype._isMissingSignatures = function(opts) {\n  if (opts.disableIsFullySigned) {\n    return;\n  }\n  if (!this.isFullySigned()) {\n    return new errors.Transaction.MissingSignatures();\n  }\n};\n\nTransaction.prototype.inspect = function() {\n  return '<Transaction: ' + this.uncheckedSerialize() + '>';\n};\n\nTransaction.prototype.toBuffer = function(noWitness) {\n  var writer = new BufferWriter();\n  return this.toBufferWriter(writer, noWitness).toBuffer();\n};\n\nTransaction.prototype.hasWitnesses = function() {\n  for (var i = 0; i < this.inputs.length; i++) {\n    if (this.inputs[i].hasWitnesses()) {\n      return true;\n    }\n  }\n  return false;\n};\n\nTransaction.prototype.toBufferWriter = function(writer, noWitness) {\n  writer.writeInt32LE(this.version);\n\n  const hasWitnesses = this.hasWitnesses();\n\n  if (hasWitnesses && !noWitness) {\n    writer.write(Buffer.from('0001', 'hex'));\n  }\n\n  writer.writeVarintNum(this.inputs ? this.inputs.length : 0);\n  for (const input of this.inputs || []) {\n    input.toBufferWriter(writer);\n  }\n\n  writer.writeVarintNum(this.outputs ? this.outputs.length : 0);\n  for (const output of this.outputs || []) {\n    output.toBufferWriter(writer);\n  }\n\n  if (hasWitnesses && !noWitness) {\n    for (const input of this.inputs) {\n      const witnesses = input.getWitnesses();\n      writer.writeVarintNum(witnesses.length);\n      for (let j = 0; j < witnesses.length; j++) {\n        writer.writeVarintNum(witnesses[j].length);\n        writer.write(witnesses[j]);\n      }\n    }\n  }\n\n  writer.writeUInt32LE(this.nLockTime);\n  return writer;\n};\n\nTransaction.prototype.fromBuffer = function(buffer) {\n  var reader = new BufferReader(buffer);\n  return this.fromBufferReader(reader);\n};\n\nTransaction.prototype.fromBufferReader = function(reader) {\n  $.checkArgument(!reader.finished(), 'No transaction data received');\n\n  this.version = reader.readInt32LE();\n  var sizeTxIns = reader.readVarintNum();\n\n  // check for segwit\n  var hasWitnesses = false;\n  if (sizeTxIns === 0 && reader.buf[reader.pos] !== 0) {\n    reader.pos += 1;\n    hasWitnesses = true;\n    sizeTxIns = reader.readVarintNum();\n  }\n\n  for (var i = 0; i < sizeTxIns; i++) {\n    var input = Input.fromBufferReader(reader);\n    this.inputs.push(input);\n  }\n\n  var sizeTxOuts = reader.readVarintNum();\n  for (var j = 0; j < sizeTxOuts; j++) {\n    this.outputs.push(Output.fromBufferReader(reader));\n  }\n\n  if (hasWitnesses) {\n    for (var k = 0; k < sizeTxIns; k++) {\n      var itemCount = reader.readVarintNum();\n      var witnesses = [];\n      for (var l = 0; l < itemCount; l++) {\n        var size = reader.readVarintNum();\n        var item = reader.read(size);\n        witnesses.push(item);\n      }\n      this.inputs[k].setWitnesses(witnesses);\n    }\n  }\n\n  this.nLockTime = reader.readUInt32LE();\n  return this;\n};\n\n\nTransaction.prototype.toObject = Transaction.prototype.toJSON = function toObject() {\n  var inputs = [];\n  this.inputs.forEach(function(input) {\n    inputs.push(input.toObject());\n  });\n  var outputs = [];\n  this.outputs.forEach(function(output) {\n    outputs.push(output.toObject());\n  });\n  var obj = {\n    hash: this.hash,\n    version: this.version,\n    inputs: inputs,\n    outputs: outputs,\n    nLockTime: this.nLockTime\n  };\n  if (this._changeScript) {\n    obj.changeScript = this._changeScript.toString();\n  }\n  if (this._changeIndex != null) {\n    obj.changeIndex = this._changeIndex;\n  }\n  if (this._fee != null) {\n    obj.fee = this._fee;\n  }\n  return obj;\n};\n\nTransaction.prototype.fromObject = function fromObject(arg, opts) {\n  /* jshint maxstatements: 20 */\n  $.checkArgument(_.isObject(arg) || arg instanceof Transaction);\n  var transaction;\n  if (arg instanceof Transaction) {\n    transaction = arg.toObject();\n  } else {\n    transaction = arg;\n  }\n  for (const input of transaction.inputs || []) {\n    if (!input.output || !input.output.script) {\n      this.uncheckedAddInput(new Input(input));\n      continue;\n    }\n    var script = new Script(input.output.script);\n    var txin;\n    if ((script.isScriptHashOut() || script.isWitnessScriptHashOut()) && input.publicKeys && input.threshold) {\n      txin = new Input.MultiSigScriptHash(\n        input, input.publicKeys, input.threshold, input.signatures, opts\n      );\n    } else if (script.isPublicKeyHashOut() || script.isWitnessPublicKeyHashOut() || script.isScriptHashOut()) {\n      txin = new Input.PublicKeyHash(input);\n    } else if (script.isPublicKeyOut()) {\n      txin = new Input.PublicKey(input);\n    } else {\n      throw new errors.Transaction.Input.UnsupportedScript(input.output.script);\n    }\n    this.addInput(txin);\n  }\n  for (const output of transaction.outputs || []) {\n    this.addOutput(new Output(output));\n  }\n  if (transaction.changeIndex) {\n    this._changeIndex = transaction.changeIndex;\n  }\n  if (transaction.changeScript) {\n    this._changeScript = new Script(transaction.changeScript);\n  }\n  if (transaction.fee) {\n    this._fee = transaction.fee;\n  }\n  this.nLockTime = transaction.nLockTime;\n  this.version = transaction.version;\n  this._checkConsistency(arg);\n  return this;\n};\n\nTransaction.prototype._checkConsistency = function(arg) {\n  if (this._changeIndex != null) {\n    $.checkState(this._changeScript, 'Change script is expected.');\n    $.checkState(this.outputs[this._changeIndex], 'Change index points to undefined output.');\n    $.checkState(this.outputs[this._changeIndex].script.toString() ===\n      this._changeScript.toString(), 'Change output has an unexpected script.');\n  }\n  if (arg && arg.hash) {\n    $.checkState(arg.hash === this.hash, 'Hash in object does not match transaction hash.');\n  }\n};\n\n/**\n * Sets nLockTime so that transaction is not valid until the desired date(a\n * timestamp in seconds since UNIX epoch is also accepted)\n *\n * @param {Date | Number} time\n * @return {Transaction} this\n */\nTransaction.prototype.lockUntilDate = function(time) {\n  $.checkArgument(time);\n  if (!isNaN(time) && time < Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {\n    throw new errors.Transaction.LockTimeTooEarly();\n  }\n  if (_.isDate(time)) {\n    time = time.getTime() / 1000;\n  }\n\n  for (var i = 0; i < this.inputs.length; i++) {\n    if (this.inputs[i].sequenceNumber === Input.DEFAULT_SEQNUMBER){\n      this.inputs[i].sequenceNumber = Input.DEFAULT_LOCKTIME_SEQNUMBER;\n    }\n  }\n\n  this.nLockTime = time;\n  return this;\n};\n\n/**\n * Sets nLockTime so that transaction is not valid until the desired block\n * height.\n *\n * @param {Number} height\n * @return {Transaction} this\n */\nTransaction.prototype.lockUntilBlockHeight = function(height) {\n  $.checkArgument(!isNaN(height));\n  if (height >= Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {\n    throw new errors.Transaction.BlockHeightTooHigh();\n  }\n  if (height < 0) {\n    throw new errors.Transaction.NLockTimeOutOfRange();\n  }\n\n  for (var i = 0; i < this.inputs.length; i++) {\n    if (this.inputs[i].sequenceNumber === Input.DEFAULT_SEQNUMBER){\n      this.inputs[i].sequenceNumber = Input.DEFAULT_LOCKTIME_SEQNUMBER;\n    }\n  }\n\n\n  this.nLockTime = height;\n  return this;\n};\n\n/**\n *  Returns a semantic version of the transaction's nLockTime.\n *  @return {Number|Date}\n *  If nLockTime is 0, it returns null,\n *  if it is < 500000000, it returns a block height (number)\n *  else it returns a Date object.\n */\nTransaction.prototype.getLockTime = function() {\n  if (!this.nLockTime) {\n    return null;\n  }\n  if (this.nLockTime < Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {\n    return this.nLockTime;\n  }\n  return new Date(1000 * this.nLockTime);\n};\n\nTransaction.prototype.fromString = function(string) {\n  this.fromBuffer(buffer.Buffer.from(string, 'hex'));\n};\n\nTransaction.prototype._newTransaction = function() {\n  this.version = CURRENT_VERSION;\n  this.nLockTime = DEFAULT_NLOCKTIME;\n};\n\n/* Transaction creation interface */\n\n/**\n * @typedef {Object} Transaction~fromObject\n * @property {string} prevTxId\n * @property {number} outputIndex\n * @property {(Buffer|string|Script)} script\n * @property {number} satoshis\n */\n\n/**\n * Add an input to this transaction. This is a high level interface\n * to add an input, for more control, use @{link Transaction#addInput}.\n *\n * Can receive, as output information, the output of bitcoind's `listunspent` command,\n * and a slightly fancier format recognized by bitcore:\n *\n * ```\n * {\n *  address: 'mszYqVnqKoQx4jcTdJXxwKAissE3Jbrrc1',\n *  txId: 'a477af6b2667c29670467e4e0728b685ee07b240235771862318e29ddbe58458',\n *  outputIndex: 0,\n *  script: Script.empty(),\n *  satoshis: 1020000\n * }\n * ```\n * Where `address` can be either a string or a bitcore Address object. The\n * same is true for `script`, which can be a string or a bitcore Script.\n *\n * Beware that this resets all the signatures for inputs (in further versions,\n * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).\n *\n * @example\n * ```javascript\n * var transaction = new Transaction();\n *\n * // From a pay to public key hash output from bitcoind's listunspent\n * transaction.from({'txid': '0000...', vout: 0, amount: 0.1, scriptPubKey: 'OP_DUP ...'});\n *\n * // From a pay to public key hash output\n * transaction.from({'txId': '0000...', outputIndex: 0, satoshis: 1000, script: 'OP_DUP ...'});\n *\n * // From a multisig P2SH output\n * transaction.from({'txId': '0000...', inputIndex: 0, satoshis: 1000, script: '... OP_HASH'},\n *                  ['03000...', '02000...'], 2);\n * ```\n *\n * @param {(Array.<Transaction~fromObject>|Transaction~fromObject)} utxo\n * @param {Array=} pubkeys\n * @param {number=} threshold\n * @param {Object=} opts - Several options:\n *        - noSorting: defaults to false, if true and is multisig, don't\n *                      sort the given public keys before creating the script\n */\nTransaction.prototype.from = function(utxo, pubkeys, threshold, opts) {\n  if (Array.isArray(utxo)) {\n    for(const u of utxo) {\n      this.from(u, pubkeys, threshold, opts);\n    };\n    return this;\n  }\n  const exists = this.inputs.some(function(input) {\n    // TODO: Maybe prevTxId should be a string? Or defined as read only property?\n    return input.prevTxId.toString('hex') === utxo.txId && input.outputIndex === utxo.outputIndex;\n  });\n  if (exists) {\n    return this;\n  }\n  if (pubkeys && threshold) {\n    this._fromMultisigUtxo(utxo, pubkeys, threshold, opts);\n  } else {\n    this._fromNonP2SH(utxo, opts);\n  }\n  return this;\n};\n\n/**\n * associateInputs - Update inputs with utxos, allowing you to specify value, and pubkey.\n * Populating these inputs allows for them to be signed with .sign(privKeys)\n *\n * @param {Array<Object>} utxos\n * @param {Array<string | PublicKey>} pubkeys\n * @param {number} threshold\n * @param {Object} opts\n * @returns {Array<number>}\n */\nTransaction.prototype.associateInputs = function(utxos, pubkeys, threshold, opts = {}) {\n  let indexes = [];\n  for(let utxo of utxos) {\n    const index = this.inputs.findIndex(i => i.prevTxId.toString('hex') === utxo.txId && i.outputIndex === utxo.outputIndex);\n    indexes.push(index);\n    if(index >= 0) {\n      const sequenceNumber = this.inputs[index].sequenceNumber; // preserve the set sequence number\n      this.inputs[index] = this._getInputFrom(utxo, pubkeys, threshold, opts);\n      this.inputs[index].sequenceNumber = sequenceNumber;\n    }\n  }\n  return indexes;\n}\n\n\nTransaction.prototype._selectInputType = function(utxo, pubkeys, threshold) {\n  var clazz;\n  utxo = new UnspentOutput(utxo);\n  if(pubkeys && threshold) {\n    if (utxo.script.isMultisigOut()) {\n      clazz = MultiSigInput;\n    } else if (utxo.script.isScriptHashOut() || utxo.script.isWitnessScriptHashOut()) {\n      clazz = MultiSigScriptHashInput;\n    }\n  } else if (utxo.script.isPublicKeyHashOut() || utxo.script.isWitnessPublicKeyHashOut() || utxo.script.isScriptHashOut()) {\n    clazz = PublicKeyHashInput;\n  } else if (utxo.script.isTaproot()) {\n    clazz = TaprootInput;\n  } else if (utxo.script.isPublicKeyOut()) {\n    clazz = PublicKeyInput;\n  } else {\n    clazz = Input;\n  }\n  return clazz;\n}\n\n\nTransaction.prototype._getInputFrom = function(utxo, pubkeys, threshold, opts = {}) {\n  utxo = new UnspentOutput(utxo);\n  const InputClass = this._selectInputType(utxo, pubkeys, threshold);\n  const input = {\n    output: new Output({\n      script: utxo.script,\n      satoshis: utxo.satoshis\n    }),\n    prevTxId: utxo.txId,\n    outputIndex: utxo.outputIndex,\n    sequenceNumber: opts.sequenceNumber,\n    script: Script.empty()\n  };\n  let args = pubkeys && threshold ? [pubkeys, threshold, false, opts] : []\n  return new InputClass(input, ...args);\n}\n\nTransaction.prototype._fromNonP2SH = function(utxo, opts) {\n  const input = this._getInputFrom(utxo, null, null, opts);\n  this.addInput(input);\n};\n\nTransaction.prototype._fromMultisigUtxo = function(utxo, pubkeys, threshold, opts) {\n  $.checkArgument(threshold <= pubkeys.length,\n    'Number of required signatures must be greater than the number of public keys');\n  const input = this._getInputFrom(utxo, pubkeys, threshold, opts);\n  this.addInput(input);\n};\n\n/**\n * Add an input to this transaction. The input must be an instance of the `Input` class.\n * It should have information about the Output that it's spending, but if it's not already\n * set, two additional parameters, `outputScript` and `satoshis` can be provided.\n *\n * @param {Input} input\n * @param {String|Script} outputScript\n * @param {number} satoshis\n * @return Transaction this, for chaining\n */\nTransaction.prototype.addInput = function(input, outputScript, satoshis) {\n  $.checkArgumentType(input, Input, 'input');\n  if (!input.output && (outputScript == null || satoshis == null)) {\n    throw new errors.Transaction.NeedMoreInfo('Need information about the UTXO script and satoshis');\n  }\n  if (!input.output && outputScript && satoshis != null) {\n    outputScript = outputScript instanceof Script ? outputScript : new Script(outputScript);\n    $.checkArgumentType(satoshis, 'number', 'satoshis');\n    input.output = new Output({\n      script: outputScript,\n      satoshis: satoshis\n    });\n  }\n  return this.uncheckedAddInput(input);\n};\n\n/**\n * Add an input to this transaction, without checking that the input has information about\n * the output that it's spending.\n *\n * @param {Input} input\n * @return Transaction this, for chaining\n */\nTransaction.prototype.uncheckedAddInput = function(input) {\n  $.checkArgumentType(input, Input, 'input');\n  this.inputs.push(input);\n  this._inputAmount = undefined;\n  this._updateChangeOutput();\n  return this;\n};\n\n/**\n * Returns true if the transaction has enough info on all inputs to be correctly validated\n *\n * @return {boolean}\n */\nTransaction.prototype.hasAllUtxoInfo = function() {\n  return this.inputs.every(function(input) {\n    return !!input.output;\n  });\n};\n\n/**\n * Manually set the fee for this transaction. Beware that this resets all the signatures\n * for inputs (in further versions, SIGHASH_SINGLE or SIGHASH_NONE signatures will not\n * be reset).\n *\n * @param {number} amount satoshis to be sent\n * @return {Transaction} this, for chaining\n */\nTransaction.prototype.fee = function(amount) {\n  $.checkArgument(!isNaN(amount), 'amount must be a number');\n  this._fee = amount;\n  this._updateChangeOutput();\n  return this;\n};\n\n/**\n * Manually set the fee per KB for this transaction. Beware that this resets all the signatures\n * for inputs (in further versions, SIGHASH_SINGLE or SIGHASH_NONE signatures will not\n * be reset).\n *\n * @param {number} amount satoshis per KB to be sent\n * @return {Transaction} this, for chaining\n */\nTransaction.prototype.feePerKb = function(amount) {\n  $.checkArgument(!isNaN(amount), 'amount must be a number');\n  this._feePerKb = amount;\n  this._updateChangeOutput();\n  return this;\n};\n\n/**\n * Manually set the fee per Byte for this transaction. Beware that this resets all the signatures\n * for inputs (in further versions, SIGHASH_SINGLE or SIGHASH_NONE signatures will not\n * be reset).\n * fee per Byte will be ignored if fee per KB is set\n *\n * @param {number} amount satoshis per Byte to be sent\n * @return {Transaction} this, for chaining\n */\nTransaction.prototype.feePerByte = function (amount) {\n  $.checkArgument(!isNaN(amount), 'amount must be a number');\n  this._feePerByte = amount;\n  this._updateChangeOutput();\n  return this;\n};\n\n/* Output management */\n\n/**\n * Set the change address for this transaction\n *\n * Beware that this resets all the signatures for inputs (in further versions,\n * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).\n *\n * @param {Address} address An address for change to be sent to.\n * @return {Transaction} this, for chaining\n */\nTransaction.prototype.change = function(address) {\n  $.checkArgument(address, 'address is required');\n  this._changeScript = Script.fromAddress(address);\n  this._updateChangeOutput();\n  return this;\n};\n\n\n/**\n * @return {Output} change output, if it exists\n */\nTransaction.prototype.getChangeOutput = function() {\n  if (this._changeIndex != null) {\n    return this.outputs[this._changeIndex];\n  }\n  return null;\n};\n\n/**\n * @typedef {Object} Transaction~toObject\n * @property {(string|Address)} address\n * @property {number} satoshis\n */\n\n/**\n * Add an output to the transaction.\n *\n * Beware that this resets all the signatures for inputs (in further versions,\n * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).\n *\n * @param {(string|Address|Array.<Transaction~toObject>)} address\n * @param {number} amount in satoshis\n * @return {Transaction} this, for chaining\n */\nTransaction.prototype.to = function(address, amount) {\n  if (Array.isArray(address)) {\n    for (const to of address) {\n      this.to(to.address, to.satoshis);\n    }\n    return this;\n  }\n\n  $.checkArgument(\n    JSUtil.isNaturalNumber(amount),\n    'Amount is expected to be a positive integer'\n  );\n  this.addOutput(new Output({\n    script: Script(new Address(address)),\n    satoshis: amount\n  }));\n  return this;\n};\n\n/**\n * Add an OP_RETURN output to the transaction.\n *\n * Beware that this resets all the signatures for inputs (in further versions,\n * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).\n *\n * @param {Buffer|string} value the data to be stored in the OP_RETURN output.\n *    In case of a string, the UTF-8 representation will be stored\n * @return {Transaction} this, for chaining\n */\nTransaction.prototype.addData = function(value) {\n  this.addOutput(new Output({\n    script: Script.buildDataOut(value),\n    satoshis: 0\n  }));\n  return this;\n};\n\n\n/**\n * Add an output to the transaction.\n *\n * @param {Output} output the output to add.\n * @return {Transaction} this, for chaining\n */\nTransaction.prototype.addOutput = function(output) {\n  $.checkArgumentType(output, Output, 'output');\n  this._addOutput(output);\n  this._updateChangeOutput();\n  return this;\n};\n\n\n/**\n * Remove all outputs from the transaction.\n *\n * @return {Transaction} this, for chaining\n */\nTransaction.prototype.clearOutputs = function() {\n  this.outputs = [];\n  this._clearSignatures();\n  this._outputAmount = undefined;\n  this._changeIndex = undefined;\n  this._updateChangeOutput();\n  return this;\n};\n\n\nTransaction.prototype._addOutput = function(output) {\n  this.outputs.push(output);\n  this._outputAmount = undefined;\n};\n\n\n/**\n * Calculates or gets the total output amount in satoshis\n *\n * @return {Number} the transaction total output amount\n */\nTransaction.prototype._getOutputAmount = function() {\n  if (this._outputAmount == null) {\n    var self = this;\n    this._outputAmount = 0;\n    for (const output of this.outputs || []) {\n      self._outputAmount += output.satoshis;\n    }\n  }\n  return this._outputAmount;\n};\n\n\n/**\n * Calculates or gets the total input amount in satoshis\n *\n * @return {Number} the transaction total input amount\n */\nTransaction.prototype._getInputAmount = function() {\n  if (this._inputAmount == null) {\n    this._inputAmount = _.sumBy(this.inputs, function(input) {\n      if (input.output == null) {\n        throw new errors.Transaction.Input.MissingPreviousOutput();\n      }\n      return input.output.satoshis;\n    });\n  }\n  return this._inputAmount;\n};\n\nTransaction.prototype._updateChangeOutput = function(noClearSigs) {\n  if (!this._changeScript) {\n    return;\n  }\n  if (!noClearSigs) {\n    this._clearSignatures();\n  }\n  if (this._changeIndex != null) {\n    this._removeOutput(this._changeIndex);\n  }\n  var available = this._getUnspentValue();\n  var fee = this.getFee();\n  var changeAmount = available - fee;\n  if (changeAmount > Transaction.DUST_AMOUNT) {\n    this._changeIndex = this.outputs.length;\n    this._addOutput(new Output({\n      script: this._changeScript,\n      satoshis: changeAmount\n    }));\n  } else {\n    this._changeIndex = undefined;\n  }\n};\n/**\n * Calculates the fee of the transaction.\n *\n * If there's a fixed fee set, return that.\n *\n * If there is no change output set, the fee is the\n * total value of the outputs minus inputs. Note that\n * a serialized transaction only specifies the value\n * of its outputs. (The value of inputs are recorded\n * in the previous transaction outputs being spent.)\n * This method therefore raises a \"MissingPreviousOutput\"\n * error when called on a serialized transaction.\n *\n * If there's no fee set and no change address,\n * estimate the fee based on size.\n *\n * @return {Number} fee of this transaction in satoshis\n */\nTransaction.prototype.getFee = function() {\n  if (this.isCoinbase()) {\n    return 0;\n  }\n  if (this._fee != null) {\n    return this._fee;\n  }\n  // if no change output is set, fees should equal all the unspent amount\n  if (!this._changeScript) {\n    return this._getUnspentValue();\n  }\n  return this._estimateFee();\n};\n\n/**\n * Estimates fee from serialized transaction size in bytes.\n */\nTransaction.prototype._estimateFee = function () {\n  const estimatedSize = this._estimateSize();\n  const available = this._getUnspentValue();\n  const feeRate = this._feePerByte || (this._feePerKb || Transaction.FEE_PER_KB) / 1000;\n  function getFee(size) {\n    return size * feeRate;\n  }\n  const fee = Math.ceil(getFee(estimatedSize));\n  const feeWithChange = Math.ceil(getFee(estimatedSize) + getFee(this._estimateSizeOfChangeOutput()));\n  if (!this._changeScript || available <= feeWithChange) {\n    return fee;\n  }\n  return feeWithChange;\n};\n\nTransaction.prototype._estimateSizeOfChangeOutput = function () {\n  if (!this._changeScript) {\n    return 0;\n  }\n  const scriptLen = this._changeScript.toBuffer().length;\n  // 8 bytes for satoshis + script size + actual script size\n  return 8 + BufferWriter.varintBufNum(scriptLen).length + scriptLen;\n};\n\nTransaction.prototype._getUnspentValue = function() {\n  return this._getInputAmount() - this._getOutputAmount();\n};\n\nTransaction.prototype._clearSignatures = function() {\n  for (const input of this.inputs || []) {\n    input.clearSignatures();\n  }\n};\n\n/**\n * Estimate the tx size before input signatures are added.\n */\nTransaction.prototype._estimateSize = function() {\n  let result = 4; // version\n\n  if (this.hasWitnesses()) {\n    result += .5;\n  }\n\n  result += BufferWriter.varintBufNum(this.inputs.length).length;\n  for (const input of this.inputs || []) {\n    result += input._estimateSize();\n  }\n\n  result += BufferWriter.varintBufNum(this.outputs.length).length;\n  for (const output of this.outputs || []) {\n    result += output.calculateSize();\n  }\n\n  result += 4; // nLockTime\n  return Math.ceil(result);\n};\n\nTransaction.prototype._calculateSize = function() {\n  return this.toBuffer().length;\n};\n\nTransaction.prototype._calculateVSize = function(noRound) {\n  const vsize = this._calculateWeight() / 4;\n  return noRound ? vsize : Math.ceil(vsize);\n};\n\nTransaction.prototype._calculateWeight = function() {\n  return (this.toBuffer(true).length * 3) + this.toBuffer(false).length;\n};\n\nTransaction.prototype._removeOutput = function(index) {\n  var output = this.outputs[index];\n  this.outputs = _.without(this.outputs, output);\n  this._outputAmount = undefined;\n};\n\nTransaction.prototype.removeOutput = function(index) {\n  this._removeOutput(index);\n  this._updateChangeOutput();\n};\n\n/**\n * Sort a transaction's inputs and outputs according to BIP69\n *\n * @see {https://github.com/bitcoin/bips/blob/master/bip-0069.mediawiki}\n * @return {Transaction} this\n */\nTransaction.prototype.sort = function() {\n  this.sortInputs(function(inputs) {\n    var copy = Array.prototype.concat.apply([], inputs);\n    let i = 0;\n    copy.forEach((x) => { x.i = i++});\n    copy.sort(function(first, second) {\n     return compare(first.prevTxId, second.prevTxId)\n        || first.outputIndex - second.outputIndex\n        || first.i - second.i;  // to ensure stable sort\n    });\n    return copy;\n  });\n  this.sortOutputs(function(outputs) {\n    var copy = Array.prototype.concat.apply([], outputs);\n    let i = 0;\n    copy.forEach((x) => { x.i = i++});\n    copy.sort(function(first, second) {\n      return first.satoshis - second.satoshis\n        || compare(first.script.toBuffer(), second.script.toBuffer())\n        || first.i - second.i;  // to ensure stable sort\n    });\n    return copy;\n  });\n  return this;\n};\n\n/**\n * Randomize this transaction's outputs ordering. The shuffling algorithm is a\n * version of the Fisher-Yates shuffle, provided by lodash's _.shuffle().\n *\n * @return {Transaction} this\n */\nTransaction.prototype.shuffleOutputs = function() {\n  return this.sortOutputs(_.shuffle);\n};\n\n/**\n * Sort this transaction's outputs, according to a given sorting function that\n * takes an array as argument and returns a new array, with the same elements\n * but with a different order. The argument function MUST NOT modify the order\n * of the original array\n *\n * @param {Function} sortingFunction\n * @return {Transaction} this\n */\nTransaction.prototype.sortOutputs = function(sortingFunction) {\n  var outs = sortingFunction(this.outputs);\n  return this._newOutputOrder(outs);\n};\n\n/**\n * Sort this transaction's inputs, according to a given sorting function that\n * takes an array as argument and returns a new array, with the same elements\n * but with a different order.\n *\n * @param {Function} sortingFunction\n * @return {Transaction} this\n */\nTransaction.prototype.sortInputs = function(sortingFunction) {\n  this.inputs = sortingFunction(this.inputs);\n  this._clearSignatures();\n  return this;\n};\n\nTransaction.prototype._newOutputOrder = function(newOutputs) {\n  var isInvalidSorting = (this.outputs.length !== newOutputs.length ||\n                          _.difference(this.outputs, newOutputs).length !== 0);\n  if (isInvalidSorting) {\n    throw new errors.Transaction.InvalidSorting();\n  }\n\n  if (this._changeIndex != null) {\n    var changeOutput = this.outputs[this._changeIndex];\n    this._changeIndex = newOutputs.indexOf(changeOutput);\n  }\n\n  this.outputs = newOutputs;\n  return this;\n};\n\nTransaction.prototype.removeInput = function(txId, outputIndex) {\n  var index;\n  if (!outputIndex && !isNaN(txId)) {\n    index = txId;\n  } else {\n    index = this.inputs.findIndex(function(input) {\n      return input.prevTxId.toString('hex') === txId && input.outputIndex === outputIndex;\n    });\n  }\n  if (index < 0 || index >= this.inputs.length) {\n    throw new errors.Transaction.InvalidIndex(index, this.inputs.length);\n  }\n  var input = this.inputs[index];\n  this.inputs = _.without(this.inputs, input);\n  this._inputAmount = undefined;\n  this._updateChangeOutput();\n};\n\n/* Signature handling */\n\n/**\n * Sign the transaction using one or more private keys.\n *\n * It tries to sign each input, verifying that the signature will be valid\n * (matches a public key).\n *\n * @param {Array|String|PrivateKey} privateKey\n * @param {number} sigtype\n * @param {String} signingMethod - method used to sign - 'ecdsa' or 'schnorr'\n * @param {Buffer|String} merkleRoot - merkle root for taproot signing\n * @return {Transaction} this, for chaining\n */\nTransaction.prototype.sign = function(privateKey, sigtype, signingMethod, merkleRoot) {\n  $.checkState(this.hasAllUtxoInfo(), 'Not all utxo information is available to sign the transaction.');\n  if (Array.isArray(privateKey)) {\n    for (const pk of privateKey) {\n      this.sign(pk, sigtype, signingMethod, merkleRoot);\n    }\n    return this;\n  }\n  for (const signature of this.getSignatures(privateKey, sigtype, signingMethod, merkleRoot)) {\n    this.applySignature(signature, signingMethod);\n  }\n  return this;\n};\n\nTransaction.prototype.getSignatures = function(privKey, sigtype, signingMethod, merkleRoot) {\n  if (typeof merkleRoot === 'string') {\n    merkleRoot = Buffer.from(merkleRoot, 'hex');\n  }\n  privKey = new PrivateKey(privKey);\n  const results = [];\n  const hashData = Hash.sha256ripemd160(privKey.publicKey.toBuffer());\n  for (let i = 0; i < this.inputs.length; i++) {\n    const input = this.inputs[i];\n    for (const signature of input.getSignatures(this, privKey, i, sigtype, hashData, signingMethod, merkleRoot)) {\n      results.push(signature);\n    }\n  }\n  return results;\n};\n\n/**\n * Add a signature to the transaction\n *\n * @param {Object} signature\n * @param {number} signature.inputIndex\n * @param {number} signature.sigtype\n * @param {PublicKey} signature.publicKey\n * @param {Signature} signature.signature\n * @param {String} signingMethod - 'ecdsa' to sign transaction\n * @return {Transaction} this, for chaining\n */\nTransaction.prototype.applySignature = function(signature, signingMethod) {\n  this.inputs[signature.inputIndex].addSignature(this, signature, signingMethod);\n  return this;\n};\n\nTransaction.prototype.isFullySigned = function() {\n  for (const input of this.inputs || []) {\n    if (input.isFullySigned === Input.prototype.isFullySigned) {\n      throw new errors.Transaction.UnableToVerifySignature(\n        'Unrecognized script kind, or not enough information to execute script.' +\n        'This usually happens when creating a transaction from a serialized transaction'\n      );\n    }\n  }\n  return this.inputs.every(function(input) {\n    return input.isFullySigned();\n  });\n};\n\nTransaction.prototype.isValidSignature = function(signature, signingMethod) {\n  if (this.inputs[signature.inputIndex].isValidSignature === Input.prototype.isValidSignature) {\n    throw new errors.Transaction.UnableToVerifySignature(\n      'Unrecognized script kind, or not enough information to execute script.' +\n      'This usually happens when creating a transaction from a serialized transaction'\n    );\n  }\n  return this.inputs[signature.inputIndex].isValidSignature(this, signature, signingMethod);\n};\n\n\n/**\n * Verify ECDSA signature\n * @param {Signature} sig \n * @param {PublicKey} pubkey \n * @param {Number} nin \n * @param {Script} subscript \n * @param {Number} satoshis \n * @returns {Boolean}\n */\nTransaction.prototype.checkEcdsaSignature = function(sig, pubkey, nin, subscript, satoshis) {\n  var subscriptBuffer = subscript.toBuffer();\n  var scriptCodeWriter = new BufferWriter();\n  scriptCodeWriter.writeVarintNum(subscriptBuffer.length);\n  scriptCodeWriter.write(subscriptBuffer);\n\n  var satoshisBuffer;\n  if (satoshis) {\n    $.checkState(JSUtil.isNaturalNumber(satoshis), 'satoshis needs to be a natural number');\n    satoshisBuffer = new BufferWriter().writeUInt64LEBN(new BN(satoshis)).toBuffer();\n  } else {\n    satoshisBuffer = this.inputs[nin].getSatoshisBuffer();\n  }\n  var verified = SighashWitness.verify(\n    this,\n    sig,\n    pubkey,\n    nin,\n    scriptCodeWriter.toBuffer(),\n    satoshisBuffer\n  );\n  return verified;\n};\n\n\n/**\n * Verify Schnorr signature\n * @param {Signature|Buffer} sig \n * @param {PublicKey|Buffer} pubkey \n * @param {Number} nin \n * @param {Number} sigversion \n * @param {Object} execdata \n * @returns {Boolean}\n */\nTransaction.prototype.checkSchnorrSignature = function(sig, pubkey, nin, sigversion, execdata) {\n  if ($.isType(pubkey, 'PublicKey')) {\n    pubkey = pubkey.point.x.toBuffer();\n  }\n  $.checkArgument(pubkey && pubkey.length === 32, 'Schnorr signatures have 32-byte public keys. The caller is responsible for enforcing this.');\n\n  if (Buffer.isBuffer(sig)) {\n    if (sig.length !== 64 && sig.length !== 65) {\n      return false;\n    }\n    sig = Signature.fromSchnorr(sig);\n  }\n  // Note that in Tapscript evaluation, empty signatures are treated specially (invalid signature that does not\n  // abort script execution). This is implemented in Interpreter.evalChecksigTapscript, which won't invoke\n  // CheckSchnorrSignature in that case. In other contexts, they are invalid like every other signature with\n  // size different from 64 or 65.\n  $.checkArgument(sig.isSchnorr, 'Signature must be schnorr');\n\n  if (!SighashSchnorr.verify(this, sig, pubkey, sigversion, nin, execdata)) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * This is here largely for legacy reasons. However, if the sig type\n * is already known (via sigversion), then it would be better to call\n * checkEcdsaSignature or checkSchnorrSignature directly.\n * @param {Signature|Buffer} sig Signature to verify\n * @param {PublicKey|Buffer} pubkey Public key used to verify sig\n * @param {Number} nin Tx input index to verify signature against\n * @param {Script} subscript ECDSA only\n * @param {Number} sigversion See Signature.Version for valid versions (default: 0 or Signature.Version.BASE)\n * @param {Number} satoshis ECDSA only\n * @param {Object} execdata Schnorr only\n * @returns {Boolean} whether the signature is valid for this transaction input\n */\nTransaction.prototype.verifySignature = function(sig, pubkey, nin, subscript, sigversion, satoshis, execdata) {\n  if (sigversion == null) {\n    sigversion = Signature.Version.BASE;\n  }\n\n  switch(sigversion) {\n    case Signature.Version.WITNESS_V0:\n      return this.checkEcdsaSignature(sig, pubkey, nin, subscript, satoshis);\n    case Signature.Version.TAPROOT:\n    case Signature.Version.TAPSCRIPT:\n      return this.checkSchnorrSignature(sig, pubkey, nin, sigversion, execdata);\n    case Signature.Version.BASE:\n    default:\n      return Sighash.verify(this, sig, pubkey, nin, subscript);\n  }\n};\n\n/**\n * Check that a transaction passes basic sanity tests. If not, return a string\n * describing the error. This function contains the same logic as\n * CheckTransaction in bitcoin core.\n */\nTransaction.prototype.verify = function() {\n  // Basic checks that don't depend on any context\n  if (this.inputs.length === 0) {\n    return 'transaction txins empty';\n  }\n\n  if (this.outputs.length === 0) {\n    return 'transaction txouts empty';\n  }\n\n  // Check for negative or overflow output values\n  var valueoutbn = new BN(0);\n  for (var i = 0; i < this.outputs.length; i++) {\n    var txout = this.outputs[i];\n\n    if (txout.invalidSatoshis()) {\n      return 'transaction txout ' + i + ' satoshis is invalid';\n    }\n    if (txout._satoshisBN.gt(new BN(Transaction.MAX_MONEY, 10))) {\n      return 'transaction txout ' + i + ' greater than MAX_MONEY';\n    }\n    valueoutbn = valueoutbn.add(txout._satoshisBN);\n    if (valueoutbn.gt(new BN(Transaction.MAX_MONEY))) {\n      return 'transaction txout ' + i + ' total output greater than MAX_MONEY';\n    }\n  }\n\n  // Size limits\n  if (this.toBuffer().length > MAX_BLOCK_SIZE) {\n    return 'transaction over the maximum block size';\n  }\n\n  // Check for duplicate inputs\n  var txinmap = {};\n  for (i = 0; i < this.inputs.length; i++) {\n    var txin = this.inputs[i];\n\n    var inputid = txin.prevTxId + ':' + txin.outputIndex;\n    if (txinmap[inputid] != null) {\n      return 'transaction input ' + i + ' duplicate input';\n    }\n    txinmap[inputid] = true;\n  }\n\n  var isCoinbase = this.isCoinbase();\n  if (isCoinbase) {\n    var buf = this.inputs[0]._scriptBuffer;\n    if (buf.length < 2 || buf.length > 100) {\n      return 'coinbase transaction script size invalid';\n    }\n  } else {\n    for (i = 0; i < this.inputs.length; i++) {\n      if (this.inputs[i].isNull()) {\n        return 'transaction input ' + i + ' has null input';\n      }\n    }\n  }\n  return true;\n};\n\n/**\n * Analogous to bitcoind's IsCoinBase function in transaction.h\n */\nTransaction.prototype.isCoinbase = function() {\n  return (this.inputs.length === 1 && this.inputs[0].isNull());\n};\n\n/**\n * Determines if this transaction can be replaced in the mempool with another\n * transaction that provides a sufficiently higher fee (RBF).\n */\nTransaction.prototype.isRBF = function() {\n  for (var i = 0; i < this.inputs.length; i++) {\n    var input = this.inputs[i];\n    if (input.sequenceNumber < Input.MAXINT - 1) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Enable this transaction to be replaced in the mempool (RBF) if a transaction\n * includes a sufficiently higher fee. It will set the sequenceNumber to\n * DEFAULT_RBF_SEQNUMBER for all inputs if the sequence number does not\n * already enable RBF.\n */\nTransaction.prototype.enableRBF = function() {\n  for (var i = 0; i < this.inputs.length; i++) {\n    var input = this.inputs[i];\n    if (input.sequenceNumber >= Input.MAXINT - 1) {\n      input.sequenceNumber = Input.DEFAULT_RBF_SEQNUMBER;\n    }\n  }\n  return this;\n};\n\nTransaction.prototype.setVersion = function(version) {\n  $.checkArgument(\n    JSUtil.isNaturalNumber(version) && version <= CURRENT_VERSION,\n    'Wrong version number');\n  this.version = version;\n  return this;\n};\n\n\n\nmodule.exports = Transaction;\n","'use strict';\n\nvar _ = require('lodash');\nvar $ = require('../util/preconditions');\nvar JSUtil = require('../util/js');\n\nvar Script = require('../script');\nvar Address = require('../address');\nvar Unit = require('../unit');\n\n/**\n * Represents an unspent output information: its script, associated amount and address,\n * transaction id and output index.\n *\n * @constructor\n * @param {object} data\n * @param {string} data.txid the previous transaction id\n * @param {string=} data.txId alias for `txid`\n * @param {number} data.vout the index in the transaction\n * @param {number=} data.outputIndex alias for `vout`\n * @param {string|Script} data.scriptPubKey the script that must be resolved to release the funds\n * @param {string|Script=} data.script alias for `scriptPubKey`\n * @param {number} data.amount amount of bitcoins associated\n * @param {number=} data.satoshis alias for `amount`, but expressed in satoshis (1 BTC = 1e8 satoshis)\n * @param {string|Address=} data.address the associated address to the script, if provided\n */\nfunction UnspentOutput(data) {\n  /* jshint maxcomplexity: 20 */\n  /* jshint maxstatements: 20 */\n  if (!(this instanceof UnspentOutput)) {\n    return new UnspentOutput(data);\n  }\n  $.checkArgument(_.isObject(data), 'Must provide an object from where to extract data');\n  var address = data.address ? new Address(data.address) : undefined;\n  var txId = data.txid ? data.txid : data.txId;\n  if (!txId || !JSUtil.isHexaString(txId) || txId.length > 64) {\n    // TODO: Use the errors library\n    throw new Error('Invalid TXID in object', data);\n  }\n  var outputIndex = _.isUndefined(data.vout) ? data.outputIndex : data.vout;\n  if (!_.isNumber(outputIndex)) {\n    throw new Error('Invalid outputIndex, received ' + outputIndex);\n  }\n  $.checkArgument(!_.isUndefined(data.scriptPubKey) || !_.isUndefined(data.script),\n                  'Must provide the scriptPubKey for that output!');\n  var script = new Script(data.scriptPubKey || data.script);\n  $.checkArgument(!_.isUndefined(data.amount) || !_.isUndefined(data.satoshis),\n                      'Must provide an amount for the output');\n  var amount = !_.isUndefined(data.amount) ? new Unit.fromBTC(data.amount).toSatoshis() : data.satoshis;\n  $.checkArgument(_.isNumber(amount), 'Amount must be a number');\n  JSUtil.defineImmutable(this, {\n    address: address,\n    txId: txId,\n    outputIndex: outputIndex,\n    script: script,\n    satoshis: amount\n  });\n}\n\n/**\n * Provide an informative output when displaying this object in the console\n * @returns string\n */\nUnspentOutput.prototype.inspect = function() {\n  return '<UnspentOutput: ' + this.txId + ':' + this.outputIndex +\n         ', satoshis: ' + this.satoshis + ', address: ' + this.address + '>';\n};\n\n/**\n * String representation: just \"txid:index\"\n * @returns string\n */\nUnspentOutput.prototype.toString = function() {\n  return this.txId + ':' + this.outputIndex;\n};\n\n/**\n * Deserialize an UnspentOutput from an object\n * @param {object|string} data\n * @return UnspentOutput\n */\nUnspentOutput.fromObject = function(data) {\n  return new UnspentOutput(data);\n};\n\n/**\n * Returns a plain object (no prototype or methods) with the associated info for this output\n * @return {object}\n */\nUnspentOutput.prototype.toObject = UnspentOutput.prototype.toJSON = function toObject() {\n  return {\n    address: this.address ? this.address.toString() : undefined,\n    txid: this.txId,\n    vout: this.outputIndex,\n    scriptPubKey: this.script.toBuffer().toString('hex'),\n    amount: Unit.fromSatoshis(this.satoshis).toBTC()\n  };\n};\n\nmodule.exports = UnspentOutput;\n","'use strict';\n\nvar _ = require('lodash');\n\nvar errors = require('./errors');\nvar $ = require('./util/preconditions');\n\nvar UNITS = {\n  'BTC'      : [1e8, 8],\n  'mBTC'     : [1e5, 5],\n  'uBTC'     : [1e2, 2],\n  'bits'     : [1e2, 2],\n  'satoshis' : [1, 0]\n};\n\n/**\n * Utility for handling and converting bitcoins units. The supported units are\n * BTC, mBTC, bits (also named uBTC) and satoshis. A unit instance can be created with an\n * amount and a unit code, or alternatively using static methods like {fromBTC}.\n * It also allows to be created from a fiat amount and the exchange rate, or\n * alternatively using the {fromFiat} static method.\n * You can consult for different representation of a unit instance using it's\n * {to} method, the fixed unit methods like {toSatoshis} or alternatively using\n * the unit accessors. It also can be converted to a fiat amount by providing the\n * corresponding BTC/fiat exchange rate.\n *\n * @example\n * ```javascript\n * var sats = Unit.fromBTC(1.3).toSatoshis();\n * var mili = Unit.fromBits(1.3).to(Unit.mBTC);\n * var bits = Unit.fromFiat(1.3, 350).bits;\n * var btc = new Unit(1.3, Unit.bits).BTC;\n * ```\n *\n * @param {Number} amount - The amount to be represented\n * @param {String|Number} code - The unit of the amount or the exchange rate\n * @returns {Unit} A new instance of an Unit\n * @constructor\n */\nfunction Unit(amount, code) {\n  if (!(this instanceof Unit)) {\n    return new Unit(amount, code);\n  }\n\n  // convert fiat to BTC\n  if (_.isNumber(code)) {\n    if (code <= 0) {\n      throw new errors.Unit.InvalidRate(code);\n    }\n    amount = amount / code;\n    code = Unit.BTC;\n  }\n\n  this._value = this._from(amount, code);\n\n  var self = this;\n  var defineAccesor = function(key) {\n    Object.defineProperty(self, key, {\n      get: function() { return self.to(key); },\n      enumerable: true,\n    });\n  };\n\n  Object.keys(UNITS).forEach(defineAccesor);\n}\n\nObject.keys(UNITS).forEach(function(key) {\n  Unit[key] = key;\n});\n\n/**\n * Returns a Unit instance created from JSON string or object\n *\n * @param {String|Object} json - JSON with keys: amount and code\n * @returns {Unit} A Unit instance\n */\nUnit.fromObject = function fromObject(data){\n  $.checkArgument(_.isObject(data), 'Argument is expected to be an object');\n  return new Unit(data.amount, data.code);\n};\n\n/**\n * Returns a Unit instance created from an amount in BTC\n *\n * @param {Number} amount - The amount in BTC\n * @returns {Unit} A Unit instance\n */\nUnit.fromBTC = function(amount) {\n  return new Unit(amount, Unit.BTC);\n};\n\n/**\n * Returns a Unit instance created from an amount in mBTC\n *\n * @param {Number} amount - The amount in mBTC\n * @returns {Unit} A Unit instance\n */\nUnit.fromMillis = Unit.fromMilis = function(amount) {\n  return new Unit(amount, Unit.mBTC);\n};\n\n/**\n * Returns a Unit instance created from an amount in bits\n *\n * @param {Number} amount - The amount in bits\n * @returns {Unit} A Unit instance\n */\nUnit.fromMicros = Unit.fromBits = function(amount) {\n  return new Unit(amount, Unit.bits);\n};\n\n/**\n * Returns a Unit instance created from an amount in satoshis\n *\n * @param {Number} amount - The amount in satoshis\n * @returns {Unit} A Unit instance\n */\nUnit.fromSatoshis = function(amount) {\n  return new Unit(amount, Unit.satoshis);\n};\n\n/**\n * Returns a Unit instance created from a fiat amount and exchange rate.\n *\n * @param {Number} amount - The amount in fiat\n * @param {Number} rate - The exchange rate BTC/fiat\n * @returns {Unit} A Unit instance\n */\nUnit.fromFiat = function(amount, rate) {\n  return new Unit(amount, rate);\n};\n\nUnit.prototype._from = function(amount, code) {\n  if (!UNITS[code]) {\n    throw new errors.Unit.UnknownCode(code);\n  }\n  return parseInt((amount * UNITS[code][0]).toFixed());\n};\n\n/**\n * Returns the value represented in the specified unit\n *\n * @param {String|Number} code - The unit code or exchange rate\n * @returns {Number} The converted value\n */\nUnit.prototype.to = function(code) {\n  if (_.isNumber(code)) {\n    if (code <= 0) {\n      throw new errors.Unit.InvalidRate(code);\n    }\n    return parseFloat((this.BTC * code).toFixed(2));\n  }\n\n  if (!UNITS[code]) {\n    throw new errors.Unit.UnknownCode(code);\n  }\n\n  var value = this._value / UNITS[code][0];\n  return parseFloat(value.toFixed(UNITS[code][1]));\n};\n\n/**\n * Returns the value represented in BTC\n *\n * @returns {Number} The value converted to BTC\n */\nUnit.prototype.toBTC = function() {\n  return this.to(Unit.BTC);\n};\n\n/**\n * Returns the value represented in mBTC\n *\n * @returns {Number} The value converted to mBTC\n */\nUnit.prototype.toMillis = Unit.prototype.toMilis = function() {\n  return this.to(Unit.mBTC);\n};\n\n/**\n * Returns the value represented in bits\n *\n * @returns {Number} The value converted to bits\n */\nUnit.prototype.toMicros = Unit.prototype.toBits = function() {\n  return this.to(Unit.bits);\n};\n\n/**\n * Returns the value represented in satoshis\n *\n * @returns {Number} The value converted to satoshis\n */\nUnit.prototype.toSatoshis = function() {\n  return this.to(Unit.satoshis);\n};\n\n/**\n * Returns the value represented in fiat\n *\n * @param {string} rate - The exchange rate between BTC/currency\n * @returns {Number} The value converted to satoshis\n */\nUnit.prototype.atRate = function(rate) {\n  return this.to(rate);\n};\n\n/**\n * Returns a the string representation of the value in satoshis\n *\n * @returns {string} the value in satoshis\n */\nUnit.prototype.toString = function() {\n  return this.satoshis + ' satoshis';\n};\n\n/**\n * Returns a plain object representation of the Unit\n *\n * @returns {Object} An object with the keys: amount and code\n */\nUnit.prototype.toObject = Unit.prototype.toJSON = function toObject() {\n  return {\n    amount: this.BTC,\n    code: Unit.BTC\n  };\n};\n\n/**\n * Returns a string formatted for the console\n *\n * @returns {string} the value in satoshis\n */\nUnit.prototype.inspect = function() {\n  return '<Unit: ' + this.toString() + '>';\n};\n\nmodule.exports = Unit;\n","'use strict';\n\nvar _ = require('lodash');\nvar URL = require('url');\n\nvar Address = require('./address');\nvar Unit = require('./unit');\n\n/**\n * Bitcore URI\n *\n * Instantiate an URI from a bitcoin URI String or an Object. An URI instance\n * can be created with a bitcoin uri string or an object. All instances of\n * URI are valid, the static method isValid allows checking before instantiation.\n *\n * All standard parameters can be found as members of the class, the address\n * is represented using an {Address} instance and the amount is represented in\n * satoshis. Any other non-standard parameters can be found under the extra member.\n *\n * @example\n * ```javascript\n *\n * var uri = new URI('bitcoin:12A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu?amount=1.2');\n * console.log(uri.address, uri.amount);\n * ```\n *\n * @param {string|Object} data - A bitcoin URI string or an Object\n * @param {Array.<string>=} knownParams - Required non-standard params\n * @throws {TypeError} Invalid bitcoin address\n * @throws {TypeError} Invalid amount\n * @throws {Error} Unknown required argument\n * @returns {URI} A new valid and frozen instance of URI\n * @constructor\n */\nvar URI = function(data, knownParams) {\n  if (!(this instanceof URI)) {\n    return new URI(data, knownParams);\n  }\n\n  this.extras = {};\n  this.knownParams = knownParams || [];\n  this.address = this.network = this.amount = this.message = null;\n\n  if (typeof(data) === 'string') {\n    var params = URI.parse(data);\n    if (params.amount) {\n      params.amount = this._parseAmount(params.amount);\n    }\n    this._fromObject(params);\n  } else if (typeof(data) === 'object') {\n    this._fromObject(data);\n  } else {\n    throw new TypeError('Unrecognized data format.');\n  }\n};\n\n/**\n * Instantiate a URI from a String\n *\n * @param {string} str - JSON string or object of the URI\n * @returns {URI} A new instance of a URI\n */\nURI.fromString = function fromString(str) {\n  if (typeof(str) !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n  return new URI(str);\n};\n\n/**\n * Instantiate a URI from an Object\n *\n * @param {Object} data - object of the URI\n * @returns {URI} A new instance of a URI\n */\nURI.fromObject = function fromObject(json) {\n  return new URI(json);\n};\n\n/**\n * Check if an bitcoin URI string is valid\n *\n * @example\n * ```javascript\n *\n * var valid = URI.isValid('bitcoin:12A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu');\n * // true\n * ```\n *\n * @param {string|Object} data - A bitcoin URI string or an Object\n * @param {Array.<string>=} knownParams - Required non-standard params\n * @returns {boolean} Result of uri validation\n */\nURI.isValid = function(arg, knownParams) {\n  try {\n    new URI(arg, knownParams);\n  } catch (err) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * Convert a bitcoin URI string into a simple object.\n *\n * @param {string} uri - A bitcoin URI string\n * @throws {TypeError} Invalid bitcoin URI\n * @returns {Object} An object with the parsed params\n */\nURI.parse = function(uri) {\n  var info = URL.parse(uri, true);\n\n  if (info.protocol !== 'bitcoin:') {\n    throw new TypeError('Invalid bitcoin URI');\n  }\n\n  // workaround to host insensitiveness\n  var group = /[^:]*:\\/?\\/?([^?]*)/.exec(uri);\n  info.query.address = group && group[1] || undefined;\n\n  return info.query;\n};\n\nURI.Members = ['address', 'amount', 'message', 'label', 'r'];\n\n/**\n * Internal function to load the URI instance with an object.\n *\n * @param {Object} obj - Object with the information\n * @throws {TypeError} Invalid bitcoin address\n * @throws {TypeError} Invalid amount\n * @throws {Error} Unknown required argument\n */\nURI.prototype._fromObject = function(obj) {\n  /* jshint maxcomplexity: 10 */\n\n  if (!Address.isValid(obj.address)) {\n    throw new TypeError('Invalid bitcoin address');\n  }\n\n  this.address = new Address(obj.address);\n  this.network = this.address.network;\n  this.amount = obj.amount;\n\n  for (var key in obj) {\n    if (key === 'address' || key === 'amount') {\n      continue;\n    }\n\n    if (/^req-/.exec(key) && this.knownParams.indexOf(key) === -1) {\n      throw Error('Unknown required argument ' + key);\n    }\n\n    var destination = URI.Members.indexOf(key) > -1 ? this : this.extras;\n    destination[key] = obj[key];\n  }\n};\n\n/**\n * Internal function to transform a BTC string amount into satoshis\n *\n * @param {string} amount - Amount BTC string\n * @throws {TypeError} Invalid amount\n * @returns {Object} Amount represented in satoshis\n */\nURI.prototype._parseAmount = function(amount) {\n  amount = Number(amount);\n  if (isNaN(amount)) {\n    throw new TypeError('Invalid amount');\n  }\n  return Unit.fromBTC(amount).toSatoshis();\n};\n\nURI.prototype.toObject = URI.prototype.toJSON = function toObject() {\n  var json = {};\n  for (var i = 0; i < URI.Members.length; i++) {\n    var m = URI.Members[i];\n    if (this.hasOwnProperty(m) && typeof(this[m]) !== 'undefined') {\n      json[m] = this[m].toString();\n    }\n  }\n  _.extend(json, this.extras);\n  return json;\n};\n\n/**\n * Will return a the string representation of the URI\n *\n * @returns {string} Bitcoin URI string\n */\nURI.prototype.toString = function() {\n  var query = {};\n  if (this.amount) {\n    query.amount = Unit.fromSatoshis(this.amount).toBTC();\n  }\n  if (this.message) {\n    query.message = this.message;\n  }\n  if (this.label) {\n    query.label = this.label;\n  }\n  if (this.r) {\n    query.r = this.r;\n  }\n  _.extend(query, this.extras);\n\n  return URL.format({\n    protocol: 'bitcoin:',\n    host: this.address,\n    query: query\n  });\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Bitcoin URI\n */\nURI.prototype.inspect = function() {\n  return '<URI: ' + this.toString() + '>';\n};\n\nmodule.exports = URI;\n","'use strict';\n\nvar buffer = require('buffer');\nvar assert = require('assert');\n\nvar js = require('./js');\nvar $ = require('./preconditions');\n\nfunction equals(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  var length = a.length;\n  for (var i = 0; i < length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = {\n  /**\n   * Fill a buffer with a value.\n   *\n   * @param {Buffer} buffer\n   * @param {number} value\n   * @return {Buffer}\n   */\n  fill: function fill(buffer, value) {\n    $.checkArgumentType(buffer, 'Buffer', 'buffer');\n    $.checkArgumentType(value, 'number', 'value');\n    var length = buffer.length;\n    for (var i = 0; i < length; i++) {\n      buffer[i] = value;\n    }\n    return buffer;\n  },\n\n  /**\n   * Return a copy of a buffer\n   *\n   * @param {Buffer} original\n   * @return {Buffer}\n   */\n  copy: function(original) {\n    var buffer = Buffer.alloc(original.length);\n    original.copy(buffer);\n    return buffer;\n  },\n\n  /**\n   * Returns true if the given argument is an instance of a buffer. Tests for\n   * both node's Buffer and Uint8Array\n   *\n   * @param {*} arg\n   * @return {boolean}\n   */\n  isBuffer: function isBuffer(arg) {\n    return buffer.Buffer.isBuffer(arg) || arg instanceof Uint8Array;\n  },\n\n  /**\n   * Returns a zero-filled byte array\n   *\n   * @param {number} bytes\n   * @return {Buffer}\n   */\n  emptyBuffer: function emptyBuffer(bytes) {\n    $.checkArgumentType(bytes, 'number', 'bytes');\n    var result = Buffer.alloc(bytes);\n    for (var i = 0; i < bytes; i++) {\n      result.write('\\0', i);\n    }\n    return result;\n  },\n\n  /**\n   * Concatenates a buffer\n   *\n   * Shortcut for <tt>buffer.Buffer.concat</tt>\n   */\n  concat: buffer.Buffer.concat,\n\n  equals: equals,\n  equal: equals,\n\n  /**\n   * Transforms a number from 0 to 255 into a Buffer of size 1 with that value\n   *\n   * @param {number} integer\n   * @return {Buffer}\n   */\n  integerAsSingleByteBuffer: function integerAsSingleByteBuffer(integer) {\n    $.checkArgumentType(integer, 'number', 'integer');\n    return Buffer.from([integer & 0xff]);\n  },\n\n  /**\n   * Transform a 4-byte integer into a Buffer of length 4.\n   *\n   * @param {number} integer\n   * @return {Buffer}\n   */\n  integerAsBuffer: function integerAsBuffer(integer) {\n    $.checkArgumentType(integer, 'number', 'integer');\n    var bytes = [];\n    bytes.push((integer >> 24) & 0xff);\n    bytes.push((integer >> 16) & 0xff);\n    bytes.push((integer >> 8) & 0xff);\n    bytes.push(integer & 0xff);\n    return Buffer.from(bytes);\n  },\n\n  /**\n   * Transform the first 4 values of a Buffer into a number, in little endian encoding\n   *\n   * @param {Buffer} buffer\n   * @return {number}\n   */\n  integerFromBuffer: function integerFromBuffer(buffer) {\n    $.checkArgumentType(buffer, 'Buffer', 'buffer');\n    return buffer[0] << 24 | buffer[1] << 16 | buffer[2] << 8 | buffer[3];\n  },\n\n  /**\n   * Transforms the first byte of an array into a number ranging from -128 to 127\n   * @param {Buffer} buffer\n   * @return {number}\n   */\n  integerFromSingleByteBuffer: function integerFromBuffer(buffer) {\n    $.checkArgumentType(buffer, 'Buffer', 'buffer');\n    return buffer[0];\n  },\n\n  /**\n   * Transforms a buffer into a string with a number in hexa representation\n   *\n   * Shorthand for <tt>buffer.toString('hex')</tt>\n   *\n   * @param {Buffer} buffer\n   * @return {string}\n   */\n  bufferToHex: function bufferToHex(buffer) {\n    $.checkArgumentType(buffer, 'Buffer', 'buffer');\n    return buffer.toString('hex');\n  },\n\n  /**\n   * Reverse a buffer\n   * @param {Buffer} param\n   * @return {Buffer}\n   */\n  reverse: function reverse(param) {\n    return (Buffer.from(param)).reverse();\n  },\n};\n\nmodule.exports.NULL_HASH = module.exports.fill(Buffer.alloc(32), 0);\nmodule.exports.EMPTY_BUFFER = Buffer.alloc(0);\n","'use strict';\n\nvar _ = require('lodash');\n\n/**\n * Determines whether a string contains only hexadecimal values\n *\n * @name JSUtil.isHexa\n * @param {string} value\n * @return {boolean} true if the string is the hexa representation of a number\n */\nvar isHexa = function isHexa(value) {\n  if (!_.isString(value)) {\n    return false;\n  }\n  return /^[0-9a-fA-F]+$/.test(value);\n};\n\n/**\n * @namespace JSUtil\n */\nmodule.exports = {\n  /**\n   * Test if an argument is a valid JSON object. If it is, returns a truthy\n   * value (the json object decoded), so no double JSON.parse call is necessary\n   *\n   * @param {string} arg\n   * @return {Object|boolean} false if the argument is not a JSON string.\n   */\n  isValidJSON: function isValidJSON(arg) {\n    var parsed;\n    if (!_.isString(arg)) {\n      return false;\n    }\n    try {\n      parsed = JSON.parse(arg);\n    } catch (e) {\n      return false;\n    }\n    if (typeof(parsed) === 'object') {\n      return true;\n    }\n    return false;\n  },\n  isHexa: isHexa,\n  isHexaString: isHexa,\n\n  /**\n   * Clone an array\n   */\n  cloneArray: function(array) {\n    return [].concat(array);\n  },\n\n  /**\n   * Define immutable properties on a target object\n   *\n   * @param {Object} target - An object to be extended\n   * @param {Object} values - An object of properties\n   * @return {Object} The target object\n   */\n  defineImmutable: function defineImmutable(target, values) {\n    Object.keys(values).forEach(function(key){\n      Object.defineProperty(target, key, {\n        configurable: false,\n        enumerable: true,\n        value: values[key]\n      });\n    });\n    return target;\n  },\n  /**\n   * Checks that a value is a natural number, a positive integer or zero.\n   *\n   * @param {*} value\n   * @return {Boolean}\n   */\n  isNaturalNumber: function isNaturalNumber(value) {\n    return typeof value === 'number' &&\n      isFinite(value) &&\n      Math.floor(value) === value &&\n      value >= 0;\n  }\n};\n","'use strict';\n\nvar errors = require('../errors');\nvar _ = require('lodash');\n\nmodule.exports = {\n  checkState: function(condition, message) {\n    if (!condition) {\n      throw new errors.InvalidState(message);\n    }\n  },\n  checkArgument: function(condition, argumentName, message, docsPath) {\n    if (!condition) {\n      throw new errors.InvalidArgument(argumentName, message, docsPath);\n    }\n  },\n  checkArgumentType: function(argument, type, argumentName) {\n    argumentName = argumentName || '(unknown name)';\n    if (_.isString(type)) {\n      if (type === 'Buffer') {\n        var buffer = require('buffer'); // './buffer' fails on cordova & RN\n        if (!buffer.Buffer.isBuffer(argument)) {\n          throw new errors.InvalidArgumentType(argument, type, argumentName);\n        }\n      } else if (typeof argument !== type && (argument && argument.constructor && argument.constructor.name !== type)) {\n        // Note that the constructor check is more reliable than the `instanceof` check below.\n        throw new errors.InvalidArgumentType(argument, type, argumentName);\n      }\n    } else {\n      if (!(argument instanceof type)) {\n        throw new errors.InvalidArgumentType(argument, type.name, argumentName);\n      }\n    }\n  },\n  isType: function(argument, type, argumentName) {\n    try {\n      this.checkArgumentType(argument, type, argumentName);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n};\n","(function (module, exports) {\n  'use strict';\n\n  // Utils\n  function assert (val, msg) {\n    if (!val) throw new Error(msg || 'Assertion failed');\n  }\n\n  // Could use `inherits` module, but don't want to move from single file\n  // architecture yet.\n  function inherits (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    var TempCtor = function () {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  }\n\n  // BN\n\n  function BN (number, base, endian) {\n    if (BN.isBN(number)) {\n      return number;\n    }\n\n    this.negative = 0;\n    this.words = null;\n    this.length = 0;\n\n    // Reduction context\n    this.red = null;\n\n    if (number !== null) {\n      if (base === 'le' || base === 'be') {\n        endian = base;\n        base = 10;\n      }\n\n      this._init(number || 0, base || 10, endian || 'be');\n    }\n  }\n  if (typeof module === 'object') {\n    module.exports = BN;\n  } else {\n    exports.BN = BN;\n  }\n\n  BN.BN = BN;\n  BN.wordSize = 26;\n\n  var Buffer;\n  try {\n    Buffer = require('buffer').Buffer;\n  } catch (e) {\n  }\n\n  BN.isBN = function isBN (num) {\n    if (num instanceof BN) {\n      return true;\n    }\n\n    return num !== null && typeof num === 'object' &&\n      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\n  };\n\n  BN.max = function max (left, right) {\n    if (left.cmp(right) > 0) return left;\n    return right;\n  };\n\n  BN.min = function min (left, right) {\n    if (left.cmp(right) < 0) return left;\n    return right;\n  };\n\n  BN.prototype._init = function init (number, base, endian) {\n    if (typeof number === 'number') {\n      return this._initNumber(number, base, endian);\n    }\n\n    if (typeof number === 'object') {\n      return this._initArray(number, base, endian);\n    }\n\n    if (base === 'hex') {\n      base = 16;\n    }\n    assert(base === (base | 0) && base >= 2 && base <= 36);\n\n    number = number.toString().replace(/\\s+/g, '');\n    var start = 0;\n    if (number[0] === '-') {\n      start++;\n    }\n\n    if (base === 16) {\n      this._parseHex(number, start);\n    } else {\n      this._parseBase(number, base, start);\n    }\n\n    if (number[0] === '-') {\n      this.negative = 1;\n    }\n\n    this.strip();\n\n    if (endian !== 'le') return;\n\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initNumber = function _initNumber (number, base, endian) {\n    if (number < 0) {\n      this.negative = 1;\n      number = -number;\n    }\n    if (number < 0x4000000) {\n      this.words = [ number & 0x3ffffff ];\n      this.length = 1;\n    } else if (number < 0x10000000000000) {\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff\n      ];\n      this.length = 2;\n    } else {\n      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff,\n        1\n      ];\n      this.length = 3;\n    }\n\n    if (endian !== 'le') return;\n\n    // Reverse the bytes\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initArray = function _initArray (number, base, endian) {\n    // Perhaps a Uint8Array\n    assert(typeof number.length === 'number');\n    if (number.length <= 0) {\n      this.words = [ 0 ];\n      this.length = 1;\n      return this;\n    }\n\n    this.length = Math.ceil(number.length / 3);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    var off = 0;\n    if (endian === 'be') {\n      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {\n        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    } else if (endian === 'le') {\n      for (i = 0, j = 0; i < number.length; i += 3) {\n        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    }\n    return this.strip();\n  };\n\n  function parseHex (str, start, end) {\n    var r = 0;\n    var len = Math.min(str.length, end);\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r <<= 4;\n\n      // 'a' - 'f'\n      if (c >= 49 && c <= 54) {\n        r |= c - 49 + 0xa;\n\n      // 'A' - 'F'\n      } else if (c >= 17 && c <= 22) {\n        r |= c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        r |= c & 0xf;\n      }\n    }\n    return r;\n  }\n\n  BN.prototype._parseHex = function _parseHex (number, start) {\n    // Create possibly bigger array to ensure that it fits the number\n    this.length = Math.ceil((number.length - start) / 6);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    // Scan 24-bit chunks and add them to the number\n    var off = 0;\n    for (i = number.length - 6, j = 0; i >= start; i -= 6) {\n      w = parseHex(number, i, i + 6);\n      this.words[j] |= (w << off) & 0x3ffffff;\n      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb\n      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;\n      off += 24;\n      if (off >= 26) {\n        off -= 26;\n        j++;\n      }\n    }\n    if (i + 6 !== start) {\n      w = parseHex(number, start, i + 6);\n      this.words[j] |= (w << off) & 0x3ffffff;\n      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;\n    }\n    this.strip();\n  };\n\n  function parseBase (str, start, end, mul) {\n    var r = 0;\n    var len = Math.min(str.length, end);\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r *= mul;\n\n      // 'a'\n      if (c >= 49) {\n        r += c - 49 + 0xa;\n\n      // 'A'\n      } else if (c >= 17) {\n        r += c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        r += c;\n      }\n    }\n    return r;\n  }\n\n  BN.prototype._parseBase = function _parseBase (number, base, start) {\n    // Initialize as zero\n    this.words = [ 0 ];\n    this.length = 1;\n\n    // Find length of limb in base\n    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {\n      limbLen++;\n    }\n    limbLen--;\n    limbPow = (limbPow / base) | 0;\n\n    var total = number.length - start;\n    var mod = total % limbLen;\n    var end = Math.min(total, total - mod) + start;\n\n    var word = 0;\n    for (var i = start; i < end; i += limbLen) {\n      word = parseBase(number, i, i + limbLen, base);\n\n      this.imuln(limbPow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    if (mod !== 0) {\n      var pow = 1;\n      word = parseBase(number, i, number.length, base);\n\n      for (i = 0; i < mod; i++) {\n        pow *= base;\n      }\n\n      this.imuln(pow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n  };\n\n  BN.prototype.copy = function copy (dest) {\n    dest.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      dest.words[i] = this.words[i];\n    }\n    dest.length = this.length;\n    dest.negative = this.negative;\n    dest.red = this.red;\n  };\n\n  BN.prototype.clone = function clone () {\n    var r = new BN(null);\n    this.copy(r);\n    return r;\n  };\n\n  BN.prototype._expand = function _expand (size) {\n    while (this.length < size) {\n      this.words[this.length++] = 0;\n    }\n    return this;\n  };\n\n  // Remove leading `0` from `this`\n  BN.prototype.strip = function strip () {\n    while (this.length > 1 && this.words[this.length - 1] === 0) {\n      this.length--;\n    }\n    return this._normSign();\n  };\n\n  BN.prototype._normSign = function _normSign () {\n    // -0 = 0\n    if (this.length === 1 && this.words[0] === 0) {\n      this.negative = 0;\n    }\n    return this;\n  };\n\n  BN.prototype.inspect = function inspect () {\n    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';\n  };\n\n  /*\n\n  var zeros = [];\n  var groupSizes = [];\n  var groupBases = [];\n\n  var s = '';\n  var i = -1;\n  while (++i < BN.wordSize) {\n    zeros[i] = s;\n    s += '0';\n  }\n  groupSizes[0] = 0;\n  groupSizes[1] = 0;\n  groupBases[0] = 0;\n  groupBases[1] = 0;\n  var base = 2 - 1;\n  while (++base < 36 + 1) {\n    var groupSize = 0;\n    var groupBase = 1;\n    while (groupBase < (1 << BN.wordSize) / base) {\n      groupBase *= base;\n      groupSize += 1;\n    }\n    groupSizes[base] = groupSize;\n    groupBases[base] = groupBase;\n  }\n\n  */\n\n  var zeros = [\n    '',\n    '0',\n    '00',\n    '000',\n    '0000',\n    '00000',\n    '000000',\n    '0000000',\n    '00000000',\n    '000000000',\n    '0000000000',\n    '00000000000',\n    '000000000000',\n    '0000000000000',\n    '00000000000000',\n    '000000000000000',\n    '0000000000000000',\n    '00000000000000000',\n    '000000000000000000',\n    '0000000000000000000',\n    '00000000000000000000',\n    '000000000000000000000',\n    '0000000000000000000000',\n    '00000000000000000000000',\n    '000000000000000000000000',\n    '0000000000000000000000000'\n  ];\n\n  var groupSizes = [\n    0, 0,\n    25, 16, 12, 11, 10, 9, 8,\n    8, 7, 7, 7, 7, 6, 6,\n    6, 6, 6, 6, 6, 5, 5,\n    5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5\n  ];\n\n  var groupBases = [\n    0, 0,\n    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,\n    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,\n    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,\n    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,\n    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176\n  ];\n\n  BN.prototype.toString = function toString (base, padding) {\n    base = base || 10;\n    padding = padding | 0 || 1;\n\n    var out;\n    if (base === 16 || base === 'hex') {\n      out = '';\n      var off = 0;\n      var carry = 0;\n      for (var i = 0; i < this.length; i++) {\n        var w = this.words[i];\n        var word = (((w << off) | carry) & 0xffffff).toString(16);\n        carry = (w >>> (24 - off)) & 0xffffff;\n        if (carry !== 0 || i !== this.length - 1) {\n          out = zeros[6 - word.length] + word + out;\n        } else {\n          out = word + out;\n        }\n        off += 2;\n        if (off >= 26) {\n          off -= 26;\n          i--;\n        }\n      }\n      if (carry !== 0) {\n        out = carry.toString(16) + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    if (base === (base | 0) && base >= 2 && base <= 36) {\n      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\n      var groupSize = groupSizes[base];\n      // var groupBase = Math.pow(base, groupSize);\n      var groupBase = groupBases[base];\n      out = '';\n      var c = this.clone();\n      c.negative = 0;\n      while (!c.isZero()) {\n        var r = c.modn(groupBase).toString(base);\n        c = c.idivn(groupBase);\n\n        if (!c.isZero()) {\n          out = zeros[groupSize - r.length] + r + out;\n        } else {\n          out = r + out;\n        }\n      }\n      if (this.isZero()) {\n        out = '0' + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    assert(false, 'Base should be between 2 and 36');\n  };\n\n  BN.prototype.toNumber = function toNumber () {\n    var ret = this.words[0];\n    if (this.length === 2) {\n      ret += this.words[1] * 0x4000000;\n    } else if (this.length === 3 && this.words[2] === 0x01) {\n      // NOTE: at this stage it is known that the top bit is set\n      ret += 0x10000000000000 + (this.words[1] * 0x4000000);\n    } else if (this.length > 2) {\n      assert(false, 'Number can only safely store up to 53 bits');\n    }\n    return (this.negative !== 0) ? -ret : ret;\n  };\n\n  BN.prototype.toJSON = function toJSON () {\n    return this.toString(16);\n  };\n\n  BN.prototype.toBuffer = function toBuffer (endian, length) {\n    assert(typeof Buffer !== 'undefined');\n    return this.toArrayLike(Buffer, endian, length);\n  };\n\n  BN.prototype.toArray = function toArray (endian, length) {\n    return this.toArrayLike(Array, endian, length);\n  };\n\n  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {\n    var byteLength = this.byteLength();\n    var reqLength = length || Math.max(1, byteLength);\n    assert(byteLength <= reqLength, 'byte array longer than desired length');\n    assert(reqLength > 0, 'Requested array length <= 0');\n\n    this.strip();\n    var littleEndian = endian === 'le';\n    var res = new ArrayType(reqLength);\n\n    var b, i;\n    var q = this.clone();\n    if (!littleEndian) {\n      // Assume big-endian\n      for (i = 0; i < reqLength - byteLength; i++) {\n        res[i] = 0;\n      }\n\n      for (i = 0; !q.isZero(); i++) {\n        b = q.andln(0xff);\n        q.iushrn(8);\n\n        res[reqLength - i - 1] = b;\n      }\n    } else {\n      for (i = 0; !q.isZero(); i++) {\n        b = q.andln(0xff);\n        q.iushrn(8);\n\n        res[i] = b;\n      }\n\n      for (; i < reqLength; i++) {\n        res[i] = 0;\n      }\n    }\n\n    return res;\n  };\n\n  if (Math.clz32) {\n    BN.prototype._countBits = function _countBits (w) {\n      return 32 - Math.clz32(w);\n    };\n  } else {\n    BN.prototype._countBits = function _countBits (w) {\n      var t = w;\n      var r = 0;\n      if (t >= 0x1000) {\n        r += 13;\n        t >>>= 13;\n      }\n      if (t >= 0x40) {\n        r += 7;\n        t >>>= 7;\n      }\n      if (t >= 0x8) {\n        r += 4;\n        t >>>= 4;\n      }\n      if (t >= 0x02) {\n        r += 2;\n        t >>>= 2;\n      }\n      return r + t;\n    };\n  }\n\n  BN.prototype._zeroBits = function _zeroBits (w) {\n    // Short-cut\n    if (w === 0) return 26;\n\n    var t = w;\n    var r = 0;\n    if ((t & 0x1fff) === 0) {\n      r += 13;\n      t >>>= 13;\n    }\n    if ((t & 0x7f) === 0) {\n      r += 7;\n      t >>>= 7;\n    }\n    if ((t & 0xf) === 0) {\n      r += 4;\n      t >>>= 4;\n    }\n    if ((t & 0x3) === 0) {\n      r += 2;\n      t >>>= 2;\n    }\n    if ((t & 0x1) === 0) {\n      r++;\n    }\n    return r;\n  };\n\n  // Return number of used bits in a BN\n  BN.prototype.bitLength = function bitLength () {\n    var w = this.words[this.length - 1];\n    var hi = this._countBits(w);\n    return (this.length - 1) * 26 + hi;\n  };\n\n  function toBitArray (num) {\n    var w = new Array(num.bitLength());\n\n    for (var bit = 0; bit < w.length; bit++) {\n      var off = (bit / 26) | 0;\n      var wbit = bit % 26;\n\n      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;\n    }\n\n    return w;\n  }\n\n  // Number of trailing zero bits\n  BN.prototype.zeroBits = function zeroBits () {\n    if (this.isZero()) return 0;\n\n    var r = 0;\n    for (var i = 0; i < this.length; i++) {\n      var b = this._zeroBits(this.words[i]);\n      r += b;\n      if (b !== 26) break;\n    }\n    return r;\n  };\n\n  BN.prototype.byteLength = function byteLength () {\n    return Math.ceil(this.bitLength() / 8);\n  };\n\n  BN.prototype.toTwos = function toTwos (width) {\n    if (this.negative !== 0) {\n      return this.abs().inotn(width).iaddn(1);\n    }\n    return this.clone();\n  };\n\n  BN.prototype.fromTwos = function fromTwos (width) {\n    if (this.testn(width - 1)) {\n      return this.notn(width).iaddn(1).ineg();\n    }\n    return this.clone();\n  };\n\n  BN.prototype.isNeg = function isNeg () {\n    return this.negative !== 0;\n  };\n\n  // Return negative clone of `this`\n  BN.prototype.neg = function neg () {\n    return this.clone().ineg();\n  };\n\n  BN.prototype.ineg = function ineg () {\n    if (!this.isZero()) {\n      this.negative ^= 1;\n    }\n\n    return this;\n  };\n\n  // Or `num` with `this` in-place\n  BN.prototype.iuor = function iuor (num) {\n    while (this.length < num.length) {\n      this.words[this.length++] = 0;\n    }\n\n    for (var i = 0; i < num.length; i++) {\n      this.words[i] = this.words[i] | num.words[i];\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.ior = function ior (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuor(num);\n  };\n\n  // Or `num` with `this`\n  BN.prototype.or = function or (num) {\n    if (this.length > num.length) return this.clone().ior(num);\n    return num.clone().ior(this);\n  };\n\n  BN.prototype.uor = function uor (num) {\n    if (this.length > num.length) return this.clone().iuor(num);\n    return num.clone().iuor(this);\n  };\n\n  // And `num` with `this` in-place\n  BN.prototype.iuand = function iuand (num) {\n    // b = min-length(num, this)\n    var b;\n    if (this.length > num.length) {\n      b = num;\n    } else {\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = this.words[i] & num.words[i];\n    }\n\n    this.length = b.length;\n\n    return this.strip();\n  };\n\n  BN.prototype.iand = function iand (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuand(num);\n  };\n\n  // And `num` with `this`\n  BN.prototype.and = function and (num) {\n    if (this.length > num.length) return this.clone().iand(num);\n    return num.clone().iand(this);\n  };\n\n  BN.prototype.uand = function uand (num) {\n    if (this.length > num.length) return this.clone().iuand(num);\n    return num.clone().iuand(this);\n  };\n\n  // Xor `num` with `this` in-place\n  BN.prototype.iuxor = function iuxor (num) {\n    // a.length > b.length\n    var a;\n    var b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = a.words[i] ^ b.words[i];\n    }\n\n    if (this !== a) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = a.length;\n\n    return this.strip();\n  };\n\n  BN.prototype.ixor = function ixor (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuxor(num);\n  };\n\n  // Xor `num` with `this`\n  BN.prototype.xor = function xor (num) {\n    if (this.length > num.length) return this.clone().ixor(num);\n    return num.clone().ixor(this);\n  };\n\n  BN.prototype.uxor = function uxor (num) {\n    if (this.length > num.length) return this.clone().iuxor(num);\n    return num.clone().iuxor(this);\n  };\n\n  // Not ``this`` with ``width`` bitwidth\n  BN.prototype.inotn = function inotn (width) {\n    assert(typeof width === 'number' && width >= 0);\n\n    var bytesNeeded = Math.ceil(width / 26) | 0;\n    var bitsLeft = width % 26;\n\n    // Extend the buffer with leading zeroes\n    this._expand(bytesNeeded);\n\n    if (bitsLeft > 0) {\n      bytesNeeded--;\n    }\n\n    // Handle complete words\n    for (var i = 0; i < bytesNeeded; i++) {\n      this.words[i] = ~this.words[i] & 0x3ffffff;\n    }\n\n    // Handle the residue\n    if (bitsLeft > 0) {\n      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));\n    }\n\n    // And remove leading zeroes\n    return this.strip();\n  };\n\n  BN.prototype.notn = function notn (width) {\n    return this.clone().inotn(width);\n  };\n\n  // Set `bit` of `this`\n  BN.prototype.setn = function setn (bit, val) {\n    assert(typeof bit === 'number' && bit >= 0);\n\n    var off = (bit / 26) | 0;\n    var wbit = bit % 26;\n\n    this._expand(off + 1);\n\n    if (val) {\n      this.words[off] = this.words[off] | (1 << wbit);\n    } else {\n      this.words[off] = this.words[off] & ~(1 << wbit);\n    }\n\n    return this.strip();\n  };\n\n  // Add `num` to `this` in-place\n  BN.prototype.iadd = function iadd (num) {\n    var r;\n\n    // negative + positive\n    if (this.negative !== 0 && num.negative === 0) {\n      this.negative = 0;\n      r = this.isub(num);\n      this.negative ^= 1;\n      return this._normSign();\n\n    // positive + negative\n    } else if (this.negative === 0 && num.negative !== 0) {\n      num.negative = 0;\n      r = this.isub(num);\n      num.negative = 1;\n      return r._normSign();\n    }\n\n    // a.length > b.length\n    var a, b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n\n    this.length = a.length;\n    if (carry !== 0) {\n      this.words[this.length] = carry;\n      this.length++;\n    // Copy the rest of the words\n    } else if (a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    return this;\n  };\n\n  // Add `num` to `this`\n  BN.prototype.add = function add (num) {\n    var res;\n    if (num.negative !== 0 && this.negative === 0) {\n      num.negative = 0;\n      res = this.sub(num);\n      num.negative ^= 1;\n      return res;\n    } else if (num.negative === 0 && this.negative !== 0) {\n      this.negative = 0;\n      res = num.sub(this);\n      this.negative = 1;\n      return res;\n    }\n\n    if (this.length > num.length) return this.clone().iadd(num);\n\n    return num.clone().iadd(this);\n  };\n\n  // Subtract `num` from `this` in-place\n  BN.prototype.isub = function isub (num) {\n    // this - (-num) = this + num\n    if (num.negative !== 0) {\n      num.negative = 0;\n      var r = this.iadd(num);\n      num.negative = 1;\n      return r._normSign();\n\n    // -this - num = -(this + num)\n    } else if (this.negative !== 0) {\n      this.negative = 0;\n      this.iadd(num);\n      this.negative = 1;\n      return this._normSign();\n    }\n\n    // At this point both numbers are positive\n    var cmp = this.cmp(num);\n\n    // Optimization - zeroify\n    if (cmp === 0) {\n      this.negative = 0;\n      this.length = 1;\n      this.words[0] = 0;\n      return this;\n    }\n\n    // a > b\n    var a, b;\n    if (cmp > 0) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n\n    // Copy rest of the words\n    if (carry === 0 && i < a.length && a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = Math.max(this.length, i);\n\n    if (a !== this) {\n      this.negative = 1;\n    }\n\n    return this.strip();\n  };\n\n  // Subtract `num` from `this`\n  BN.prototype.sub = function sub (num) {\n    return this.clone().isub(num);\n  };\n\n  function smallMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    var len = (self.length + num.length) | 0;\n    out.length = len;\n    len = (len - 1) | 0;\n\n    // Peel one iteration (compiler can't do it, because of code complexity)\n    var a = self.words[0] | 0;\n    var b = num.words[0] | 0;\n    var r = a * b;\n\n    var lo = r & 0x3ffffff;\n    var carry = (r / 0x4000000) | 0;\n    out.words[0] = lo;\n\n    for (var k = 1; k < len; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = carry >>> 26;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = (k - j) | 0;\n        a = self.words[i] | 0;\n        b = num.words[j] | 0;\n        r = a * b + rword;\n        ncarry += (r / 0x4000000) | 0;\n        rword = r & 0x3ffffff;\n      }\n      out.words[k] = rword | 0;\n      carry = ncarry | 0;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry | 0;\n    } else {\n      out.length--;\n    }\n\n    return out.strip();\n  }\n\n  // TODO(indutny): it may be reasonable to omit it for users who don't need\n  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\n  // multiplication (like elliptic secp256k1).\n  var comb10MulTo = function comb10MulTo (self, num, out) {\n    var a = self.words;\n    var b = num.words;\n    var o = out.words;\n    var c = 0;\n    var lo;\n    var mid;\n    var hi;\n    var a0 = a[0] | 0;\n    var al0 = a0 & 0x1fff;\n    var ah0 = a0 >>> 13;\n    var a1 = a[1] | 0;\n    var al1 = a1 & 0x1fff;\n    var ah1 = a1 >>> 13;\n    var a2 = a[2] | 0;\n    var al2 = a2 & 0x1fff;\n    var ah2 = a2 >>> 13;\n    var a3 = a[3] | 0;\n    var al3 = a3 & 0x1fff;\n    var ah3 = a3 >>> 13;\n    var a4 = a[4] | 0;\n    var al4 = a4 & 0x1fff;\n    var ah4 = a4 >>> 13;\n    var a5 = a[5] | 0;\n    var al5 = a5 & 0x1fff;\n    var ah5 = a5 >>> 13;\n    var a6 = a[6] | 0;\n    var al6 = a6 & 0x1fff;\n    var ah6 = a6 >>> 13;\n    var a7 = a[7] | 0;\n    var al7 = a7 & 0x1fff;\n    var ah7 = a7 >>> 13;\n    var a8 = a[8] | 0;\n    var al8 = a8 & 0x1fff;\n    var ah8 = a8 >>> 13;\n    var a9 = a[9] | 0;\n    var al9 = a9 & 0x1fff;\n    var ah9 = a9 >>> 13;\n    var b0 = b[0] | 0;\n    var bl0 = b0 & 0x1fff;\n    var bh0 = b0 >>> 13;\n    var b1 = b[1] | 0;\n    var bl1 = b1 & 0x1fff;\n    var bh1 = b1 >>> 13;\n    var b2 = b[2] | 0;\n    var bl2 = b2 & 0x1fff;\n    var bh2 = b2 >>> 13;\n    var b3 = b[3] | 0;\n    var bl3 = b3 & 0x1fff;\n    var bh3 = b3 >>> 13;\n    var b4 = b[4] | 0;\n    var bl4 = b4 & 0x1fff;\n    var bh4 = b4 >>> 13;\n    var b5 = b[5] | 0;\n    var bl5 = b5 & 0x1fff;\n    var bh5 = b5 >>> 13;\n    var b6 = b[6] | 0;\n    var bl6 = b6 & 0x1fff;\n    var bh6 = b6 >>> 13;\n    var b7 = b[7] | 0;\n    var bl7 = b7 & 0x1fff;\n    var bh7 = b7 >>> 13;\n    var b8 = b[8] | 0;\n    var bl8 = b8 & 0x1fff;\n    var bh8 = b8 >>> 13;\n    var b9 = b[9] | 0;\n    var bl9 = b9 & 0x1fff;\n    var bh9 = b9 >>> 13;\n\n    out.negative = self.negative ^ num.negative;\n    out.length = 19;\n    /* k = 0 */\n    lo = Math.imul(al0, bl0);\n    mid = Math.imul(al0, bh0);\n    mid = (mid + Math.imul(ah0, bl0)) | 0;\n    hi = Math.imul(ah0, bh0);\n    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;\n    w0 &= 0x3ffffff;\n    /* k = 1 */\n    lo = Math.imul(al1, bl0);\n    mid = Math.imul(al1, bh0);\n    mid = (mid + Math.imul(ah1, bl0)) | 0;\n    hi = Math.imul(ah1, bh0);\n    lo = (lo + Math.imul(al0, bl1)) | 0;\n    mid = (mid + Math.imul(al0, bh1)) | 0;\n    mid = (mid + Math.imul(ah0, bl1)) | 0;\n    hi = (hi + Math.imul(ah0, bh1)) | 0;\n    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;\n    w1 &= 0x3ffffff;\n    /* k = 2 */\n    lo = Math.imul(al2, bl0);\n    mid = Math.imul(al2, bh0);\n    mid = (mid + Math.imul(ah2, bl0)) | 0;\n    hi = Math.imul(ah2, bh0);\n    lo = (lo + Math.imul(al1, bl1)) | 0;\n    mid = (mid + Math.imul(al1, bh1)) | 0;\n    mid = (mid + Math.imul(ah1, bl1)) | 0;\n    hi = (hi + Math.imul(ah1, bh1)) | 0;\n    lo = (lo + Math.imul(al0, bl2)) | 0;\n    mid = (mid + Math.imul(al0, bh2)) | 0;\n    mid = (mid + Math.imul(ah0, bl2)) | 0;\n    hi = (hi + Math.imul(ah0, bh2)) | 0;\n    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;\n    w2 &= 0x3ffffff;\n    /* k = 3 */\n    lo = Math.imul(al3, bl0);\n    mid = Math.imul(al3, bh0);\n    mid = (mid + Math.imul(ah3, bl0)) | 0;\n    hi = Math.imul(ah3, bh0);\n    lo = (lo + Math.imul(al2, bl1)) | 0;\n    mid = (mid + Math.imul(al2, bh1)) | 0;\n    mid = (mid + Math.imul(ah2, bl1)) | 0;\n    hi = (hi + Math.imul(ah2, bh1)) | 0;\n    lo = (lo + Math.imul(al1, bl2)) | 0;\n    mid = (mid + Math.imul(al1, bh2)) | 0;\n    mid = (mid + Math.imul(ah1, bl2)) | 0;\n    hi = (hi + Math.imul(ah1, bh2)) | 0;\n    lo = (lo + Math.imul(al0, bl3)) | 0;\n    mid = (mid + Math.imul(al0, bh3)) | 0;\n    mid = (mid + Math.imul(ah0, bl3)) | 0;\n    hi = (hi + Math.imul(ah0, bh3)) | 0;\n    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;\n    w3 &= 0x3ffffff;\n    /* k = 4 */\n    lo = Math.imul(al4, bl0);\n    mid = Math.imul(al4, bh0);\n    mid = (mid + Math.imul(ah4, bl0)) | 0;\n    hi = Math.imul(ah4, bh0);\n    lo = (lo + Math.imul(al3, bl1)) | 0;\n    mid = (mid + Math.imul(al3, bh1)) | 0;\n    mid = (mid + Math.imul(ah3, bl1)) | 0;\n    hi = (hi + Math.imul(ah3, bh1)) | 0;\n    lo = (lo + Math.imul(al2, bl2)) | 0;\n    mid = (mid + Math.imul(al2, bh2)) | 0;\n    mid = (mid + Math.imul(ah2, bl2)) | 0;\n    hi = (hi + Math.imul(ah2, bh2)) | 0;\n    lo = (lo + Math.imul(al1, bl3)) | 0;\n    mid = (mid + Math.imul(al1, bh3)) | 0;\n    mid = (mid + Math.imul(ah1, bl3)) | 0;\n    hi = (hi + Math.imul(ah1, bh3)) | 0;\n    lo = (lo + Math.imul(al0, bl4)) | 0;\n    mid = (mid + Math.imul(al0, bh4)) | 0;\n    mid = (mid + Math.imul(ah0, bl4)) | 0;\n    hi = (hi + Math.imul(ah0, bh4)) | 0;\n    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;\n    w4 &= 0x3ffffff;\n    /* k = 5 */\n    lo = Math.imul(al5, bl0);\n    mid = Math.imul(al5, bh0);\n    mid = (mid + Math.imul(ah5, bl0)) | 0;\n    hi = Math.imul(ah5, bh0);\n    lo = (lo + Math.imul(al4, bl1)) | 0;\n    mid = (mid + Math.imul(al4, bh1)) | 0;\n    mid = (mid + Math.imul(ah4, bl1)) | 0;\n    hi = (hi + Math.imul(ah4, bh1)) | 0;\n    lo = (lo + Math.imul(al3, bl2)) | 0;\n    mid = (mid + Math.imul(al3, bh2)) | 0;\n    mid = (mid + Math.imul(ah3, bl2)) | 0;\n    hi = (hi + Math.imul(ah3, bh2)) | 0;\n    lo = (lo + Math.imul(al2, bl3)) | 0;\n    mid = (mid + Math.imul(al2, bh3)) | 0;\n    mid = (mid + Math.imul(ah2, bl3)) | 0;\n    hi = (hi + Math.imul(ah2, bh3)) | 0;\n    lo = (lo + Math.imul(al1, bl4)) | 0;\n    mid = (mid + Math.imul(al1, bh4)) | 0;\n    mid = (mid + Math.imul(ah1, bl4)) | 0;\n    hi = (hi + Math.imul(ah1, bh4)) | 0;\n    lo = (lo + Math.imul(al0, bl5)) | 0;\n    mid = (mid + Math.imul(al0, bh5)) | 0;\n    mid = (mid + Math.imul(ah0, bl5)) | 0;\n    hi = (hi + Math.imul(ah0, bh5)) | 0;\n    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;\n    w5 &= 0x3ffffff;\n    /* k = 6 */\n    lo = Math.imul(al6, bl0);\n    mid = Math.imul(al6, bh0);\n    mid = (mid + Math.imul(ah6, bl0)) | 0;\n    hi = Math.imul(ah6, bh0);\n    lo = (lo + Math.imul(al5, bl1)) | 0;\n    mid = (mid + Math.imul(al5, bh1)) | 0;\n    mid = (mid + Math.imul(ah5, bl1)) | 0;\n    hi = (hi + Math.imul(ah5, bh1)) | 0;\n    lo = (lo + Math.imul(al4, bl2)) | 0;\n    mid = (mid + Math.imul(al4, bh2)) | 0;\n    mid = (mid + Math.imul(ah4, bl2)) | 0;\n    hi = (hi + Math.imul(ah4, bh2)) | 0;\n    lo = (lo + Math.imul(al3, bl3)) | 0;\n    mid = (mid + Math.imul(al3, bh3)) | 0;\n    mid = (mid + Math.imul(ah3, bl3)) | 0;\n    hi = (hi + Math.imul(ah3, bh3)) | 0;\n    lo = (lo + Math.imul(al2, bl4)) | 0;\n    mid = (mid + Math.imul(al2, bh4)) | 0;\n    mid = (mid + Math.imul(ah2, bl4)) | 0;\n    hi = (hi + Math.imul(ah2, bh4)) | 0;\n    lo = (lo + Math.imul(al1, bl5)) | 0;\n    mid = (mid + Math.imul(al1, bh5)) | 0;\n    mid = (mid + Math.imul(ah1, bl5)) | 0;\n    hi = (hi + Math.imul(ah1, bh5)) | 0;\n    lo = (lo + Math.imul(al0, bl6)) | 0;\n    mid = (mid + Math.imul(al0, bh6)) | 0;\n    mid = (mid + Math.imul(ah0, bl6)) | 0;\n    hi = (hi + Math.imul(ah0, bh6)) | 0;\n    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;\n    w6 &= 0x3ffffff;\n    /* k = 7 */\n    lo = Math.imul(al7, bl0);\n    mid = Math.imul(al7, bh0);\n    mid = (mid + Math.imul(ah7, bl0)) | 0;\n    hi = Math.imul(ah7, bh0);\n    lo = (lo + Math.imul(al6, bl1)) | 0;\n    mid = (mid + Math.imul(al6, bh1)) | 0;\n    mid = (mid + Math.imul(ah6, bl1)) | 0;\n    hi = (hi + Math.imul(ah6, bh1)) | 0;\n    lo = (lo + Math.imul(al5, bl2)) | 0;\n    mid = (mid + Math.imul(al5, bh2)) | 0;\n    mid = (mid + Math.imul(ah5, bl2)) | 0;\n    hi = (hi + Math.imul(ah5, bh2)) | 0;\n    lo = (lo + Math.imul(al4, bl3)) | 0;\n    mid = (mid + Math.imul(al4, bh3)) | 0;\n    mid = (mid + Math.imul(ah4, bl3)) | 0;\n    hi = (hi + Math.imul(ah4, bh3)) | 0;\n    lo = (lo + Math.imul(al3, bl4)) | 0;\n    mid = (mid + Math.imul(al3, bh4)) | 0;\n    mid = (mid + Math.imul(ah3, bl4)) | 0;\n    hi = (hi + Math.imul(ah3, bh4)) | 0;\n    lo = (lo + Math.imul(al2, bl5)) | 0;\n    mid = (mid + Math.imul(al2, bh5)) | 0;\n    mid = (mid + Math.imul(ah2, bl5)) | 0;\n    hi = (hi + Math.imul(ah2, bh5)) | 0;\n    lo = (lo + Math.imul(al1, bl6)) | 0;\n    mid = (mid + Math.imul(al1, bh6)) | 0;\n    mid = (mid + Math.imul(ah1, bl6)) | 0;\n    hi = (hi + Math.imul(ah1, bh6)) | 0;\n    lo = (lo + Math.imul(al0, bl7)) | 0;\n    mid = (mid + Math.imul(al0, bh7)) | 0;\n    mid = (mid + Math.imul(ah0, bl7)) | 0;\n    hi = (hi + Math.imul(ah0, bh7)) | 0;\n    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;\n    w7 &= 0x3ffffff;\n    /* k = 8 */\n    lo = Math.imul(al8, bl0);\n    mid = Math.imul(al8, bh0);\n    mid = (mid + Math.imul(ah8, bl0)) | 0;\n    hi = Math.imul(ah8, bh0);\n    lo = (lo + Math.imul(al7, bl1)) | 0;\n    mid = (mid + Math.imul(al7, bh1)) | 0;\n    mid = (mid + Math.imul(ah7, bl1)) | 0;\n    hi = (hi + Math.imul(ah7, bh1)) | 0;\n    lo = (lo + Math.imul(al6, bl2)) | 0;\n    mid = (mid + Math.imul(al6, bh2)) | 0;\n    mid = (mid + Math.imul(ah6, bl2)) | 0;\n    hi = (hi + Math.imul(ah6, bh2)) | 0;\n    lo = (lo + Math.imul(al5, bl3)) | 0;\n    mid = (mid + Math.imul(al5, bh3)) | 0;\n    mid = (mid + Math.imul(ah5, bl3)) | 0;\n    hi = (hi + Math.imul(ah5, bh3)) | 0;\n    lo = (lo + Math.imul(al4, bl4)) | 0;\n    mid = (mid + Math.imul(al4, bh4)) | 0;\n    mid = (mid + Math.imul(ah4, bl4)) | 0;\n    hi = (hi + Math.imul(ah4, bh4)) | 0;\n    lo = (lo + Math.imul(al3, bl5)) | 0;\n    mid = (mid + Math.imul(al3, bh5)) | 0;\n    mid = (mid + Math.imul(ah3, bl5)) | 0;\n    hi = (hi + Math.imul(ah3, bh5)) | 0;\n    lo = (lo + Math.imul(al2, bl6)) | 0;\n    mid = (mid + Math.imul(al2, bh6)) | 0;\n    mid = (mid + Math.imul(ah2, bl6)) | 0;\n    hi = (hi + Math.imul(ah2, bh6)) | 0;\n    lo = (lo + Math.imul(al1, bl7)) | 0;\n    mid = (mid + Math.imul(al1, bh7)) | 0;\n    mid = (mid + Math.imul(ah1, bl7)) | 0;\n    hi = (hi + Math.imul(ah1, bh7)) | 0;\n    lo = (lo + Math.imul(al0, bl8)) | 0;\n    mid = (mid + Math.imul(al0, bh8)) | 0;\n    mid = (mid + Math.imul(ah0, bl8)) | 0;\n    hi = (hi + Math.imul(ah0, bh8)) | 0;\n    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;\n    w8 &= 0x3ffffff;\n    /* k = 9 */\n    lo = Math.imul(al9, bl0);\n    mid = Math.imul(al9, bh0);\n    mid = (mid + Math.imul(ah9, bl0)) | 0;\n    hi = Math.imul(ah9, bh0);\n    lo = (lo + Math.imul(al8, bl1)) | 0;\n    mid = (mid + Math.imul(al8, bh1)) | 0;\n    mid = (mid + Math.imul(ah8, bl1)) | 0;\n    hi = (hi + Math.imul(ah8, bh1)) | 0;\n    lo = (lo + Math.imul(al7, bl2)) | 0;\n    mid = (mid + Math.imul(al7, bh2)) | 0;\n    mid = (mid + Math.imul(ah7, bl2)) | 0;\n    hi = (hi + Math.imul(ah7, bh2)) | 0;\n    lo = (lo + Math.imul(al6, bl3)) | 0;\n    mid = (mid + Math.imul(al6, bh3)) | 0;\n    mid = (mid + Math.imul(ah6, bl3)) | 0;\n    hi = (hi + Math.imul(ah6, bh3)) | 0;\n    lo = (lo + Math.imul(al5, bl4)) | 0;\n    mid = (mid + Math.imul(al5, bh4)) | 0;\n    mid = (mid + Math.imul(ah5, bl4)) | 0;\n    hi = (hi + Math.imul(ah5, bh4)) | 0;\n    lo = (lo + Math.imul(al4, bl5)) | 0;\n    mid = (mid + Math.imul(al4, bh5)) | 0;\n    mid = (mid + Math.imul(ah4, bl5)) | 0;\n    hi = (hi + Math.imul(ah4, bh5)) | 0;\n    lo = (lo + Math.imul(al3, bl6)) | 0;\n    mid = (mid + Math.imul(al3, bh6)) | 0;\n    mid = (mid + Math.imul(ah3, bl6)) | 0;\n    hi = (hi + Math.imul(ah3, bh6)) | 0;\n    lo = (lo + Math.imul(al2, bl7)) | 0;\n    mid = (mid + Math.imul(al2, bh7)) | 0;\n    mid = (mid + Math.imul(ah2, bl7)) | 0;\n    hi = (hi + Math.imul(ah2, bh7)) | 0;\n    lo = (lo + Math.imul(al1, bl8)) | 0;\n    mid = (mid + Math.imul(al1, bh8)) | 0;\n    mid = (mid + Math.imul(ah1, bl8)) | 0;\n    hi = (hi + Math.imul(ah1, bh8)) | 0;\n    lo = (lo + Math.imul(al0, bl9)) | 0;\n    mid = (mid + Math.imul(al0, bh9)) | 0;\n    mid = (mid + Math.imul(ah0, bl9)) | 0;\n    hi = (hi + Math.imul(ah0, bh9)) | 0;\n    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;\n    w9 &= 0x3ffffff;\n    /* k = 10 */\n    lo = Math.imul(al9, bl1);\n    mid = Math.imul(al9, bh1);\n    mid = (mid + Math.imul(ah9, bl1)) | 0;\n    hi = Math.imul(ah9, bh1);\n    lo = (lo + Math.imul(al8, bl2)) | 0;\n    mid = (mid + Math.imul(al8, bh2)) | 0;\n    mid = (mid + Math.imul(ah8, bl2)) | 0;\n    hi = (hi + Math.imul(ah8, bh2)) | 0;\n    lo = (lo + Math.imul(al7, bl3)) | 0;\n    mid = (mid + Math.imul(al7, bh3)) | 0;\n    mid = (mid + Math.imul(ah7, bl3)) | 0;\n    hi = (hi + Math.imul(ah7, bh3)) | 0;\n    lo = (lo + Math.imul(al6, bl4)) | 0;\n    mid = (mid + Math.imul(al6, bh4)) | 0;\n    mid = (mid + Math.imul(ah6, bl4)) | 0;\n    hi = (hi + Math.imul(ah6, bh4)) | 0;\n    lo = (lo + Math.imul(al5, bl5)) | 0;\n    mid = (mid + Math.imul(al5, bh5)) | 0;\n    mid = (mid + Math.imul(ah5, bl5)) | 0;\n    hi = (hi + Math.imul(ah5, bh5)) | 0;\n    lo = (lo + Math.imul(al4, bl6)) | 0;\n    mid = (mid + Math.imul(al4, bh6)) | 0;\n    mid = (mid + Math.imul(ah4, bl6)) | 0;\n    hi = (hi + Math.imul(ah4, bh6)) | 0;\n    lo = (lo + Math.imul(al3, bl7)) | 0;\n    mid = (mid + Math.imul(al3, bh7)) | 0;\n    mid = (mid + Math.imul(ah3, bl7)) | 0;\n    hi = (hi + Math.imul(ah3, bh7)) | 0;\n    lo = (lo + Math.imul(al2, bl8)) | 0;\n    mid = (mid + Math.imul(al2, bh8)) | 0;\n    mid = (mid + Math.imul(ah2, bl8)) | 0;\n    hi = (hi + Math.imul(ah2, bh8)) | 0;\n    lo = (lo + Math.imul(al1, bl9)) | 0;\n    mid = (mid + Math.imul(al1, bh9)) | 0;\n    mid = (mid + Math.imul(ah1, bl9)) | 0;\n    hi = (hi + Math.imul(ah1, bh9)) | 0;\n    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;\n    w10 &= 0x3ffffff;\n    /* k = 11 */\n    lo = Math.imul(al9, bl2);\n    mid = Math.imul(al9, bh2);\n    mid = (mid + Math.imul(ah9, bl2)) | 0;\n    hi = Math.imul(ah9, bh2);\n    lo = (lo + Math.imul(al8, bl3)) | 0;\n    mid = (mid + Math.imul(al8, bh3)) | 0;\n    mid = (mid + Math.imul(ah8, bl3)) | 0;\n    hi = (hi + Math.imul(ah8, bh3)) | 0;\n    lo = (lo + Math.imul(al7, bl4)) | 0;\n    mid = (mid + Math.imul(al7, bh4)) | 0;\n    mid = (mid + Math.imul(ah7, bl4)) | 0;\n    hi = (hi + Math.imul(ah7, bh4)) | 0;\n    lo = (lo + Math.imul(al6, bl5)) | 0;\n    mid = (mid + Math.imul(al6, bh5)) | 0;\n    mid = (mid + Math.imul(ah6, bl5)) | 0;\n    hi = (hi + Math.imul(ah6, bh5)) | 0;\n    lo = (lo + Math.imul(al5, bl6)) | 0;\n    mid = (mid + Math.imul(al5, bh6)) | 0;\n    mid = (mid + Math.imul(ah5, bl6)) | 0;\n    hi = (hi + Math.imul(ah5, bh6)) | 0;\n    lo = (lo + Math.imul(al4, bl7)) | 0;\n    mid = (mid + Math.imul(al4, bh7)) | 0;\n    mid = (mid + Math.imul(ah4, bl7)) | 0;\n    hi = (hi + Math.imul(ah4, bh7)) | 0;\n    lo = (lo + Math.imul(al3, bl8)) | 0;\n    mid = (mid + Math.imul(al3, bh8)) | 0;\n    mid = (mid + Math.imul(ah3, bl8)) | 0;\n    hi = (hi + Math.imul(ah3, bh8)) | 0;\n    lo = (lo + Math.imul(al2, bl9)) | 0;\n    mid = (mid + Math.imul(al2, bh9)) | 0;\n    mid = (mid + Math.imul(ah2, bl9)) | 0;\n    hi = (hi + Math.imul(ah2, bh9)) | 0;\n    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;\n    w11 &= 0x3ffffff;\n    /* k = 12 */\n    lo = Math.imul(al9, bl3);\n    mid = Math.imul(al9, bh3);\n    mid = (mid + Math.imul(ah9, bl3)) | 0;\n    hi = Math.imul(ah9, bh3);\n    lo = (lo + Math.imul(al8, bl4)) | 0;\n    mid = (mid + Math.imul(al8, bh4)) | 0;\n    mid = (mid + Math.imul(ah8, bl4)) | 0;\n    hi = (hi + Math.imul(ah8, bh4)) | 0;\n    lo = (lo + Math.imul(al7, bl5)) | 0;\n    mid = (mid + Math.imul(al7, bh5)) | 0;\n    mid = (mid + Math.imul(ah7, bl5)) | 0;\n    hi = (hi + Math.imul(ah7, bh5)) | 0;\n    lo = (lo + Math.imul(al6, bl6)) | 0;\n    mid = (mid + Math.imul(al6, bh6)) | 0;\n    mid = (mid + Math.imul(ah6, bl6)) | 0;\n    hi = (hi + Math.imul(ah6, bh6)) | 0;\n    lo = (lo + Math.imul(al5, bl7)) | 0;\n    mid = (mid + Math.imul(al5, bh7)) | 0;\n    mid = (mid + Math.imul(ah5, bl7)) | 0;\n    hi = (hi + Math.imul(ah5, bh7)) | 0;\n    lo = (lo + Math.imul(al4, bl8)) | 0;\n    mid = (mid + Math.imul(al4, bh8)) | 0;\n    mid = (mid + Math.imul(ah4, bl8)) | 0;\n    hi = (hi + Math.imul(ah4, bh8)) | 0;\n    lo = (lo + Math.imul(al3, bl9)) | 0;\n    mid = (mid + Math.imul(al3, bh9)) | 0;\n    mid = (mid + Math.imul(ah3, bl9)) | 0;\n    hi = (hi + Math.imul(ah3, bh9)) | 0;\n    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;\n    w12 &= 0x3ffffff;\n    /* k = 13 */\n    lo = Math.imul(al9, bl4);\n    mid = Math.imul(al9, bh4);\n    mid = (mid + Math.imul(ah9, bl4)) | 0;\n    hi = Math.imul(ah9, bh4);\n    lo = (lo + Math.imul(al8, bl5)) | 0;\n    mid = (mid + Math.imul(al8, bh5)) | 0;\n    mid = (mid + Math.imul(ah8, bl5)) | 0;\n    hi = (hi + Math.imul(ah8, bh5)) | 0;\n    lo = (lo + Math.imul(al7, bl6)) | 0;\n    mid = (mid + Math.imul(al7, bh6)) | 0;\n    mid = (mid + Math.imul(ah7, bl6)) | 0;\n    hi = (hi + Math.imul(ah7, bh6)) | 0;\n    lo = (lo + Math.imul(al6, bl7)) | 0;\n    mid = (mid + Math.imul(al6, bh7)) | 0;\n    mid = (mid + Math.imul(ah6, bl7)) | 0;\n    hi = (hi + Math.imul(ah6, bh7)) | 0;\n    lo = (lo + Math.imul(al5, bl8)) | 0;\n    mid = (mid + Math.imul(al5, bh8)) | 0;\n    mid = (mid + Math.imul(ah5, bl8)) | 0;\n    hi = (hi + Math.imul(ah5, bh8)) | 0;\n    lo = (lo + Math.imul(al4, bl9)) | 0;\n    mid = (mid + Math.imul(al4, bh9)) | 0;\n    mid = (mid + Math.imul(ah4, bl9)) | 0;\n    hi = (hi + Math.imul(ah4, bh9)) | 0;\n    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;\n    w13 &= 0x3ffffff;\n    /* k = 14 */\n    lo = Math.imul(al9, bl5);\n    mid = Math.imul(al9, bh5);\n    mid = (mid + Math.imul(ah9, bl5)) | 0;\n    hi = Math.imul(ah9, bh5);\n    lo = (lo + Math.imul(al8, bl6)) | 0;\n    mid = (mid + Math.imul(al8, bh6)) | 0;\n    mid = (mid + Math.imul(ah8, bl6)) | 0;\n    hi = (hi + Math.imul(ah8, bh6)) | 0;\n    lo = (lo + Math.imul(al7, bl7)) | 0;\n    mid = (mid + Math.imul(al7, bh7)) | 0;\n    mid = (mid + Math.imul(ah7, bl7)) | 0;\n    hi = (hi + Math.imul(ah7, bh7)) | 0;\n    lo = (lo + Math.imul(al6, bl8)) | 0;\n    mid = (mid + Math.imul(al6, bh8)) | 0;\n    mid = (mid + Math.imul(ah6, bl8)) | 0;\n    hi = (hi + Math.imul(ah6, bh8)) | 0;\n    lo = (lo + Math.imul(al5, bl9)) | 0;\n    mid = (mid + Math.imul(al5, bh9)) | 0;\n    mid = (mid + Math.imul(ah5, bl9)) | 0;\n    hi = (hi + Math.imul(ah5, bh9)) | 0;\n    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;\n    w14 &= 0x3ffffff;\n    /* k = 15 */\n    lo = Math.imul(al9, bl6);\n    mid = Math.imul(al9, bh6);\n    mid = (mid + Math.imul(ah9, bl6)) | 0;\n    hi = Math.imul(ah9, bh6);\n    lo = (lo + Math.imul(al8, bl7)) | 0;\n    mid = (mid + Math.imul(al8, bh7)) | 0;\n    mid = (mid + Math.imul(ah8, bl7)) | 0;\n    hi = (hi + Math.imul(ah8, bh7)) | 0;\n    lo = (lo + Math.imul(al7, bl8)) | 0;\n    mid = (mid + Math.imul(al7, bh8)) | 0;\n    mid = (mid + Math.imul(ah7, bl8)) | 0;\n    hi = (hi + Math.imul(ah7, bh8)) | 0;\n    lo = (lo + Math.imul(al6, bl9)) | 0;\n    mid = (mid + Math.imul(al6, bh9)) | 0;\n    mid = (mid + Math.imul(ah6, bl9)) | 0;\n    hi = (hi + Math.imul(ah6, bh9)) | 0;\n    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;\n    w15 &= 0x3ffffff;\n    /* k = 16 */\n    lo = Math.imul(al9, bl7);\n    mid = Math.imul(al9, bh7);\n    mid = (mid + Math.imul(ah9, bl7)) | 0;\n    hi = Math.imul(ah9, bh7);\n    lo = (lo + Math.imul(al8, bl8)) | 0;\n    mid = (mid + Math.imul(al8, bh8)) | 0;\n    mid = (mid + Math.imul(ah8, bl8)) | 0;\n    hi = (hi + Math.imul(ah8, bh8)) | 0;\n    lo = (lo + Math.imul(al7, bl9)) | 0;\n    mid = (mid + Math.imul(al7, bh9)) | 0;\n    mid = (mid + Math.imul(ah7, bl9)) | 0;\n    hi = (hi + Math.imul(ah7, bh9)) | 0;\n    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;\n    w16 &= 0x3ffffff;\n    /* k = 17 */\n    lo = Math.imul(al9, bl8);\n    mid = Math.imul(al9, bh8);\n    mid = (mid + Math.imul(ah9, bl8)) | 0;\n    hi = Math.imul(ah9, bh8);\n    lo = (lo + Math.imul(al8, bl9)) | 0;\n    mid = (mid + Math.imul(al8, bh9)) | 0;\n    mid = (mid + Math.imul(ah8, bl9)) | 0;\n    hi = (hi + Math.imul(ah8, bh9)) | 0;\n    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;\n    w17 &= 0x3ffffff;\n    /* k = 18 */\n    lo = Math.imul(al9, bl9);\n    mid = Math.imul(al9, bh9);\n    mid = (mid + Math.imul(ah9, bl9)) | 0;\n    hi = Math.imul(ah9, bh9);\n    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;\n    w18 &= 0x3ffffff;\n    o[0] = w0;\n    o[1] = w1;\n    o[2] = w2;\n    o[3] = w3;\n    o[4] = w4;\n    o[5] = w5;\n    o[6] = w6;\n    o[7] = w7;\n    o[8] = w8;\n    o[9] = w9;\n    o[10] = w10;\n    o[11] = w11;\n    o[12] = w12;\n    o[13] = w13;\n    o[14] = w14;\n    o[15] = w15;\n    o[16] = w16;\n    o[17] = w17;\n    o[18] = w18;\n    if (c !== 0) {\n      o[19] = c;\n      out.length++;\n    }\n    return out;\n  };\n\n  // Polyfill comb\n  if (!Math.imul) {\n    comb10MulTo = smallMulTo;\n  }\n\n  function bigMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    out.length = self.length + num.length;\n\n    var carry = 0;\n    var hncarry = 0;\n    for (var k = 0; k < out.length - 1; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = hncarry;\n      hncarry = 0;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = k - j;\n        var a = self.words[i] | 0;\n        var b = num.words[j] | 0;\n        var r = a * b;\n\n        var lo = r & 0x3ffffff;\n        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;\n        lo = (lo + rword) | 0;\n        rword = lo & 0x3ffffff;\n        ncarry = (ncarry + (lo >>> 26)) | 0;\n\n        hncarry += ncarry >>> 26;\n        ncarry &= 0x3ffffff;\n      }\n      out.words[k] = rword;\n      carry = ncarry;\n      ncarry = hncarry;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry;\n    } else {\n      out.length--;\n    }\n\n    return out.strip();\n  }\n\n  function jumboMulTo (self, num, out) {\n    var fftm = new FFTM();\n    return fftm.mulp(self, num, out);\n  }\n\n  BN.prototype.mulTo = function mulTo (num, out) {\n    var res;\n    var len = this.length + num.length;\n    if (this.length === 10 && num.length === 10) {\n      res = comb10MulTo(this, num, out);\n    } else if (len < 63) {\n      res = smallMulTo(this, num, out);\n    } else if (len < 1024) {\n      res = bigMulTo(this, num, out);\n    } else {\n      res = jumboMulTo(this, num, out);\n    }\n\n    return res;\n  };\n\n  // Cooley-Tukey algorithm for FFT\n  // slightly revisited to rely on looping instead of recursion\n\n  function FFTM (x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  FFTM.prototype.makeRBT = function makeRBT (N) {\n    var t = new Array(N);\n    var l = BN.prototype._countBits(N) - 1;\n    for (var i = 0; i < N; i++) {\n      t[i] = this.revBin(i, l, N);\n    }\n\n    return t;\n  };\n\n  // Returns binary-reversed representation of `x`\n  FFTM.prototype.revBin = function revBin (x, l, N) {\n    if (x === 0 || x === N - 1) return x;\n\n    var rb = 0;\n    for (var i = 0; i < l; i++) {\n      rb |= (x & 1) << (l - i - 1);\n      x >>= 1;\n    }\n\n    return rb;\n  };\n\n  // Performs \"tweedling\" phase, therefore 'emulating'\n  // behaviour of the recursive algorithm\n  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {\n    for (var i = 0; i < N; i++) {\n      rtws[i] = rws[rbt[i]];\n      itws[i] = iws[rbt[i]];\n    }\n  };\n\n  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {\n    this.permute(rbt, rws, iws, rtws, itws, N);\n\n    for (var s = 1; s < N; s <<= 1) {\n      var l = s << 1;\n\n      var rtwdf = Math.cos(2 * Math.PI / l);\n      var itwdf = Math.sin(2 * Math.PI / l);\n\n      for (var p = 0; p < N; p += l) {\n        var rtwdf_ = rtwdf;\n        var itwdf_ = itwdf;\n\n        for (var j = 0; j < s; j++) {\n          var re = rtws[p + j];\n          var ie = itws[p + j];\n\n          var ro = rtws[p + j + s];\n          var io = itws[p + j + s];\n\n          var rx = rtwdf_ * ro - itwdf_ * io;\n\n          io = rtwdf_ * io + itwdf_ * ro;\n          ro = rx;\n\n          rtws[p + j] = re + ro;\n          itws[p + j] = ie + io;\n\n          rtws[p + j + s] = re - ro;\n          itws[p + j + s] = ie - io;\n\n          /* jshint maxdepth : false */\n          if (j !== l) {\n            rx = rtwdf * rtwdf_ - itwdf * itwdf_;\n\n            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\n            rtwdf_ = rx;\n          }\n        }\n      }\n    }\n  };\n\n  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {\n    var N = Math.max(m, n) | 1;\n    var odd = N & 1;\n    var i = 0;\n    for (N = N / 2 | 0; N; N = N >>> 1) {\n      i++;\n    }\n\n    return 1 << i + 1 + odd;\n  };\n\n  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {\n    if (N <= 1) return;\n\n    for (var i = 0; i < N / 2; i++) {\n      var t = rws[i];\n\n      rws[i] = rws[N - i - 1];\n      rws[N - i - 1] = t;\n\n      t = iws[i];\n\n      iws[i] = -iws[N - i - 1];\n      iws[N - i - 1] = -t;\n    }\n  };\n\n  FFTM.prototype.normalize13b = function normalize13b (ws, N) {\n    var carry = 0;\n    for (var i = 0; i < N / 2; i++) {\n      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +\n        Math.round(ws[2 * i] / N) +\n        carry;\n\n      ws[i] = w & 0x3ffffff;\n\n      if (w < 0x4000000) {\n        carry = 0;\n      } else {\n        carry = w / 0x4000000 | 0;\n      }\n    }\n\n    return ws;\n  };\n\n  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {\n    var carry = 0;\n    for (var i = 0; i < len; i++) {\n      carry = carry + (ws[i] | 0);\n\n      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;\n      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;\n    }\n\n    // Pad with zeroes\n    for (i = 2 * len; i < N; ++i) {\n      rws[i] = 0;\n    }\n\n    assert(carry === 0);\n    assert((carry & ~0x1fff) === 0);\n  };\n\n  FFTM.prototype.stub = function stub (N) {\n    var ph = new Array(N);\n    for (var i = 0; i < N; i++) {\n      ph[i] = 0;\n    }\n\n    return ph;\n  };\n\n  FFTM.prototype.mulp = function mulp (x, y, out) {\n    var N = 2 * this.guessLen13b(x.length, y.length);\n\n    var rbt = this.makeRBT(N);\n\n    var _ = this.stub(N);\n\n    var rws = new Array(N);\n    var rwst = new Array(N);\n    var iwst = new Array(N);\n\n    var nrws = new Array(N);\n    var nrwst = new Array(N);\n    var niwst = new Array(N);\n\n    var rmws = out.words;\n    rmws.length = N;\n\n    this.convert13b(x.words, x.length, rws, N);\n    this.convert13b(y.words, y.length, nrws, N);\n\n    this.transform(rws, _, rwst, iwst, N, rbt);\n    this.transform(nrws, _, nrwst, niwst, N, rbt);\n\n    for (var i = 0; i < N; i++) {\n      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\n      rwst[i] = rx;\n    }\n\n    this.conjugate(rwst, iwst, N);\n    this.transform(rwst, iwst, rmws, _, N, rbt);\n    this.conjugate(rmws, _, N);\n    this.normalize13b(rmws, N);\n\n    out.negative = x.negative ^ y.negative;\n    out.length = x.length + y.length;\n    return out.strip();\n  };\n\n  // Multiply `this` by `num`\n  BN.prototype.mul = function mul (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return this.mulTo(num, out);\n  };\n\n  // Multiply employing FFT\n  BN.prototype.mulf = function mulf (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return jumboMulTo(this, num, out);\n  };\n\n  // In-place Multiplication\n  BN.prototype.imul = function imul (num) {\n    return this.clone().mulTo(num, this);\n  };\n\n  BN.prototype.imuln = function imuln (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n\n    // Carry\n    var carry = 0;\n    for (var i = 0; i < this.length; i++) {\n      var w = (this.words[i] | 0) * num;\n      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\n      carry >>= 26;\n      carry += (w / 0x4000000) | 0;\n      // NOTE: lo is 27bit maximum\n      carry += lo >>> 26;\n      this.words[i] = lo & 0x3ffffff;\n    }\n\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n\n    return this;\n  };\n\n  BN.prototype.muln = function muln (num) {\n    return this.clone().imuln(num);\n  };\n\n  // `this` * `this`\n  BN.prototype.sqr = function sqr () {\n    return this.mul(this);\n  };\n\n  // `this` * `this` in-place\n  BN.prototype.isqr = function isqr () {\n    return this.imul(this.clone());\n  };\n\n  // Math.pow(`this`, `num`)\n  BN.prototype.pow = function pow (num) {\n    var w = toBitArray(num);\n    if (w.length === 0) return new BN(1);\n\n    // Skip leading zeroes\n    var res = this;\n    for (var i = 0; i < w.length; i++, res = res.sqr()) {\n      if (w[i] !== 0) break;\n    }\n\n    if (++i < w.length) {\n      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {\n        if (w[i] === 0) continue;\n\n        res = res.mul(q);\n      }\n    }\n\n    return res;\n  };\n\n  // Shift-left in-place\n  BN.prototype.iushln = function iushln (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);\n    var i;\n\n    if (r !== 0) {\n      var carry = 0;\n\n      for (i = 0; i < this.length; i++) {\n        var newCarry = this.words[i] & carryMask;\n        var c = ((this.words[i] | 0) - newCarry) << r;\n        this.words[i] = c | carry;\n        carry = newCarry >>> (26 - r);\n      }\n\n      if (carry) {\n        this.words[i] = carry;\n        this.length++;\n      }\n    }\n\n    if (s !== 0) {\n      for (i = this.length - 1; i >= 0; i--) {\n        this.words[i + s] = this.words[i];\n      }\n\n      for (i = 0; i < s; i++) {\n        this.words[i] = 0;\n      }\n\n      this.length += s;\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.ishln = function ishln (bits) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushln(bits);\n  };\n\n  // Shift-right in-place\n  // NOTE: `hint` is a lowest bit before trailing zeroes\n  // NOTE: if `extended` is present - it will be filled with destroyed bits\n  BN.prototype.iushrn = function iushrn (bits, hint, extended) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var h;\n    if (hint) {\n      h = (hint - (hint % 26)) / 26;\n    } else {\n      h = 0;\n    }\n\n    var r = bits % 26;\n    var s = Math.min((bits - r) / 26, this.length);\n    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n    var maskedWords = extended;\n\n    h -= s;\n    h = Math.max(0, h);\n\n    // Extended mode, copy masked part\n    if (maskedWords) {\n      for (var i = 0; i < s; i++) {\n        maskedWords.words[i] = this.words[i];\n      }\n      maskedWords.length = s;\n    }\n\n    if (s === 0) {\n      // No-op, we should not move anything at all\n    } else if (this.length > s) {\n      this.length -= s;\n      for (i = 0; i < this.length; i++) {\n        this.words[i] = this.words[i + s];\n      }\n    } else {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    var carry = 0;\n    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {\n      var word = this.words[i] | 0;\n      this.words[i] = (carry << (26 - r)) | (word >>> r);\n      carry = word & mask;\n    }\n\n    // Push carried bits as a mask\n    if (maskedWords && carry !== 0) {\n      maskedWords.words[maskedWords.length++] = carry;\n    }\n\n    if (this.length === 0) {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.ishrn = function ishrn (bits, hint, extended) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushrn(bits, hint, extended);\n  };\n\n  // Shift-left\n  BN.prototype.shln = function shln (bits) {\n    return this.clone().ishln(bits);\n  };\n\n  BN.prototype.ushln = function ushln (bits) {\n    return this.clone().iushln(bits);\n  };\n\n  // Shift-right\n  BN.prototype.shrn = function shrn (bits) {\n    return this.clone().ishrn(bits);\n  };\n\n  BN.prototype.ushrn = function ushrn (bits) {\n    return this.clone().iushrn(bits);\n  };\n\n  // Test if n bit is set\n  BN.prototype.testn = function testn (bit) {\n    assert(typeof bit === 'number' && bit >= 0);\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) return false;\n\n    // Check bit and return\n    var w = this.words[s];\n\n    return !!(w & q);\n  };\n\n  // Return only lowers bits of number (in-place)\n  BN.prototype.imaskn = function imaskn (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n\n    assert(this.negative === 0, 'imaskn works only with positive numbers');\n\n    if (this.length <= s) {\n      return this;\n    }\n\n    if (r !== 0) {\n      s++;\n    }\n    this.length = Math.min(s, this.length);\n\n    if (r !== 0) {\n      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n      this.words[this.length - 1] &= mask;\n    }\n\n    return this.strip();\n  };\n\n  // Return only lowers bits of number\n  BN.prototype.maskn = function maskn (bits) {\n    return this.clone().imaskn(bits);\n  };\n\n  // Add plain number `num` to `this`\n  BN.prototype.iaddn = function iaddn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.isubn(-num);\n\n    // Possible sign change\n    if (this.negative !== 0) {\n      if (this.length === 1 && (this.words[0] | 0) < num) {\n        this.words[0] = num - (this.words[0] | 0);\n        this.negative = 0;\n        return this;\n      }\n\n      this.negative = 0;\n      this.isubn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    // Add without checks\n    return this._iaddn(num);\n  };\n\n  BN.prototype._iaddn = function _iaddn (num) {\n    this.words[0] += num;\n\n    // Carry\n    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {\n      this.words[i] -= 0x4000000;\n      if (i === this.length - 1) {\n        this.words[i + 1] = 1;\n      } else {\n        this.words[i + 1]++;\n      }\n    }\n    this.length = Math.max(this.length, i + 1);\n\n    return this;\n  };\n\n  // Subtract plain number `num` from `this`\n  BN.prototype.isubn = function isubn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.iaddn(-num);\n\n    if (this.negative !== 0) {\n      this.negative = 0;\n      this.iaddn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    this.words[0] -= num;\n\n    if (this.length === 1 && this.words[0] < 0) {\n      this.words[0] = -this.words[0];\n      this.negative = 1;\n    } else {\n      // Carry\n      for (var i = 0; i < this.length && this.words[i] < 0; i++) {\n        this.words[i] += 0x4000000;\n        this.words[i + 1] -= 1;\n      }\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.addn = function addn (num) {\n    return this.clone().iaddn(num);\n  };\n\n  BN.prototype.subn = function subn (num) {\n    return this.clone().isubn(num);\n  };\n\n  BN.prototype.iabs = function iabs () {\n    this.negative = 0;\n\n    return this;\n  };\n\n  BN.prototype.abs = function abs () {\n    return this.clone().iabs();\n  };\n\n  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {\n    var len = num.length + shift;\n    var i;\n\n    this._expand(len);\n\n    var w;\n    var carry = 0;\n    for (i = 0; i < num.length; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      var right = (num.words[i] | 0) * mul;\n      w -= right & 0x3ffffff;\n      carry = (w >> 26) - ((right / 0x4000000) | 0);\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n    for (; i < this.length - shift; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      carry = w >> 26;\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n\n    if (carry === 0) return this.strip();\n\n    // Subtraction overflow\n    assert(carry === -1);\n    carry = 0;\n    for (i = 0; i < this.length; i++) {\n      w = -(this.words[i] | 0) + carry;\n      carry = w >> 26;\n      this.words[i] = w & 0x3ffffff;\n    }\n    this.negative = 1;\n\n    return this.strip();\n  };\n\n  BN.prototype._wordDiv = function _wordDiv (num, mode) {\n    var shift = this.length - num.length;\n\n    var a = this.clone();\n    var b = num;\n\n    // Normalize\n    var bhi = b.words[b.length - 1] | 0;\n    var bhiBits = this._countBits(bhi);\n    shift = 26 - bhiBits;\n    if (shift !== 0) {\n      b = b.ushln(shift);\n      a.iushln(shift);\n      bhi = b.words[b.length - 1] | 0;\n    }\n\n    // Initialize quotient\n    var m = a.length - b.length;\n    var q;\n\n    if (mode !== 'mod') {\n      q = new BN(null);\n      q.length = m + 1;\n      q.words = new Array(q.length);\n      for (var i = 0; i < q.length; i++) {\n        q.words[i] = 0;\n      }\n    }\n\n    var diff = a.clone()._ishlnsubmul(b, 1, m);\n    if (diff.negative === 0) {\n      a = diff;\n      if (q) {\n        q.words[m] = 1;\n      }\n    }\n\n    for (var j = m - 1; j >= 0; j--) {\n      var qj = (a.words[b.length + j] | 0) * 0x4000000 +\n        (a.words[b.length + j - 1] | 0);\n\n      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\n      // (0x7ffffff)\n      qj = Math.min((qj / bhi) | 0, 0x3ffffff);\n\n      a._ishlnsubmul(b, qj, j);\n      while (a.negative !== 0) {\n        qj--;\n        a.negative = 0;\n        a._ishlnsubmul(b, 1, j);\n        if (!a.isZero()) {\n          a.negative ^= 1;\n        }\n      }\n      if (q) {\n        q.words[j] = qj;\n      }\n    }\n    if (q) {\n      q.strip();\n    }\n    a.strip();\n\n    // Denormalize\n    if (mode !== 'div' && shift !== 0) {\n      a.iushrn(shift);\n    }\n\n    return {\n      div: q || null,\n      mod: a\n    };\n  };\n\n  // NOTE: 1) `mode` can be set to `mod` to request mod only,\n  //       to `div` to request div only, or be absent to\n  //       request both div & mod\n  //       2) `positive` is true if unsigned mod is requested\n  BN.prototype.divmod = function divmod (num, mode, positive) {\n    assert(!num.isZero());\n\n    if (this.isZero()) {\n      return {\n        div: new BN(0),\n        mod: new BN(0)\n      };\n    }\n\n    var div, mod, res;\n    if (this.negative !== 0 && num.negative === 0) {\n      res = this.neg().divmod(num, mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.iadd(num);\n        }\n      }\n\n      return {\n        div: div,\n        mod: mod\n      };\n    }\n\n    if (this.negative === 0 && num.negative !== 0) {\n      res = this.divmod(num.neg(), mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      return {\n        div: div,\n        mod: res.mod\n      };\n    }\n\n    if ((this.negative & num.negative) !== 0) {\n      res = this.neg().divmod(num.neg(), mode);\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.isub(num);\n        }\n      }\n\n      return {\n        div: res.div,\n        mod: mod\n      };\n    }\n\n    // Both numbers are positive at this point\n\n    // Strip both numbers to approximate shift value\n    if (num.length > this.length || this.cmp(num) < 0) {\n      return {\n        div: new BN(0),\n        mod: this\n      };\n    }\n\n    // Very short reduction\n    if (num.length === 1) {\n      if (mode === 'div') {\n        return {\n          div: this.divn(num.words[0]),\n          mod: null\n        };\n      }\n\n      if (mode === 'mod') {\n        return {\n          div: null,\n          mod: new BN(this.modn(num.words[0]))\n        };\n      }\n\n      return {\n        div: this.divn(num.words[0]),\n        mod: new BN(this.modn(num.words[0]))\n      };\n    }\n\n    return this._wordDiv(num, mode);\n  };\n\n  // Find `this` / `num`\n  BN.prototype.div = function div (num) {\n    return this.divmod(num, 'div', false).div;\n  };\n\n  // Find `this` % `num`\n  BN.prototype.mod = function mod (num) {\n    return this.divmod(num, 'mod', false).mod;\n  };\n\n  BN.prototype.umod = function umod (num) {\n    return this.divmod(num, 'mod', true).mod;\n  };\n\n  // Find Round(`this` / `num`)\n  BN.prototype.divRound = function divRound (num) {\n    var dm = this.divmod(num);\n\n    // Fast case - exact division\n    if (dm.mod.isZero()) return dm.div;\n\n    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\n\n    var half = num.ushrn(1);\n    var r2 = num.andln(1);\n    var cmp = mod.cmp(half);\n\n    // Round down\n    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;\n\n    // Round up\n    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n  };\n\n  BN.prototype.modn = function modn (num) {\n    assert(num <= 0x3ffffff);\n    var p = (1 << 26) % num;\n\n    var acc = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      acc = (p * acc + (this.words[i] | 0)) % num;\n    }\n\n    return acc;\n  };\n\n  // In-place division by number\n  BN.prototype.idivn = function idivn (num) {\n    assert(num <= 0x3ffffff);\n\n    var carry = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var w = (this.words[i] | 0) + carry * 0x4000000;\n      this.words[i] = (w / num) | 0;\n      carry = w % num;\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.divn = function divn (num) {\n    return this.clone().idivn(num);\n  };\n\n  BN.prototype.egcd = function egcd (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var x = this;\n    var y = p.clone();\n\n    if (x.negative !== 0) {\n      x = x.umod(p);\n    } else {\n      x = x.clone();\n    }\n\n    // A * x + B * y = x\n    var A = new BN(1);\n    var B = new BN(0);\n\n    // C * x + D * y = y\n    var C = new BN(0);\n    var D = new BN(1);\n\n    var g = 0;\n\n    while (x.isEven() && y.isEven()) {\n      x.iushrn(1);\n      y.iushrn(1);\n      ++g;\n    }\n\n    var yp = y.clone();\n    var xp = x.clone();\n\n    while (!x.isZero()) {\n      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        x.iushrn(i);\n        while (i-- > 0) {\n          if (A.isOdd() || B.isOdd()) {\n            A.iadd(yp);\n            B.isub(xp);\n          }\n\n          A.iushrn(1);\n          B.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        y.iushrn(j);\n        while (j-- > 0) {\n          if (C.isOdd() || D.isOdd()) {\n            C.iadd(yp);\n            D.isub(xp);\n          }\n\n          C.iushrn(1);\n          D.iushrn(1);\n        }\n      }\n\n      if (x.cmp(y) >= 0) {\n        x.isub(y);\n        A.isub(C);\n        B.isub(D);\n      } else {\n        y.isub(x);\n        C.isub(A);\n        D.isub(B);\n      }\n    }\n\n    return {\n      a: C,\n      b: D,\n      gcd: y.iushln(g)\n    };\n  };\n\n  // This is reduced incarnation of the binary EEA\n  // above, designated to invert members of the\n  // _prime_ fields F(p) at a maximal speed\n  BN.prototype._invmp = function _invmp (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var a = this;\n    var b = p.clone();\n\n    if (a.negative !== 0) {\n      a = a.umod(p);\n    } else {\n      a = a.clone();\n    }\n\n    var x1 = new BN(1);\n    var x2 = new BN(0);\n\n    var delta = b.clone();\n\n    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        a.iushrn(i);\n        while (i-- > 0) {\n          if (x1.isOdd()) {\n            x1.iadd(delta);\n          }\n\n          x1.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        b.iushrn(j);\n        while (j-- > 0) {\n          if (x2.isOdd()) {\n            x2.iadd(delta);\n          }\n\n          x2.iushrn(1);\n        }\n      }\n\n      if (a.cmp(b) >= 0) {\n        a.isub(b);\n        x1.isub(x2);\n      } else {\n        b.isub(a);\n        x2.isub(x1);\n      }\n    }\n\n    var res;\n    if (a.cmpn(1) === 0) {\n      res = x1;\n    } else {\n      res = x2;\n    }\n\n    if (res.cmpn(0) < 0) {\n      res.iadd(p);\n    }\n\n    return res;\n  };\n\n  BN.prototype.gcd = function gcd (num) {\n    if (this.isZero()) return num.abs();\n    if (num.isZero()) return this.abs();\n\n    var a = this.clone();\n    var b = num.clone();\n    a.negative = 0;\n    b.negative = 0;\n\n    // Remove common factor of two\n    for (var shift = 0; a.isEven() && b.isEven(); shift++) {\n      a.iushrn(1);\n      b.iushrn(1);\n    }\n\n    do {\n      while (a.isEven()) {\n        a.iushrn(1);\n      }\n      while (b.isEven()) {\n        b.iushrn(1);\n      }\n\n      var r = a.cmp(b);\n      if (r < 0) {\n        // Swap `a` and `b` to make `a` always bigger than `b`\n        var t = a;\n        a = b;\n        b = t;\n      } else if (r === 0 || b.cmpn(1) === 0) {\n        break;\n      }\n\n      a.isub(b);\n    } while (true);\n\n    return b.iushln(shift);\n  };\n\n  // Invert number in the field F(num)\n  BN.prototype.invm = function invm (num) {\n    return this.egcd(num).a.umod(num);\n  };\n\n  BN.prototype.isEven = function isEven () {\n    return (this.words[0] & 1) === 0;\n  };\n\n  BN.prototype.isOdd = function isOdd () {\n    return (this.words[0] & 1) === 1;\n  };\n\n  // And first word and num\n  BN.prototype.andln = function andln (num) {\n    return this.words[0] & num;\n  };\n\n  // Increment at the bit position in-line\n  BN.prototype.bincn = function bincn (bit) {\n    assert(typeof bit === 'number');\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) {\n      this._expand(s + 1);\n      this.words[s] |= q;\n      return this;\n    }\n\n    // Add bit and propagate, if needed\n    var carry = q;\n    for (var i = s; carry !== 0 && i < this.length; i++) {\n      var w = this.words[i] | 0;\n      w += carry;\n      carry = w >>> 26;\n      w &= 0x3ffffff;\n      this.words[i] = w;\n    }\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n    return this;\n  };\n\n  BN.prototype.isZero = function isZero () {\n    return this.length === 1 && this.words[0] === 0;\n  };\n\n  BN.prototype.cmpn = function cmpn (num) {\n    var negative = num < 0;\n\n    if (this.negative !== 0 && !negative) return -1;\n    if (this.negative === 0 && negative) return 1;\n\n    this.strip();\n\n    var res;\n    if (this.length > 1) {\n      res = 1;\n    } else {\n      if (negative) {\n        num = -num;\n      }\n\n      assert(num <= 0x3ffffff, 'Number is too big');\n\n      var w = this.words[0] | 0;\n      res = w === num ? 0 : w < num ? -1 : 1;\n    }\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Compare two numbers and return:\n  // 1 - if `this` > `num`\n  // 0 - if `this` == `num`\n  // -1 - if `this` < `num`\n  BN.prototype.cmp = function cmp (num) {\n    if (this.negative !== 0 && num.negative === 0) return -1;\n    if (this.negative === 0 && num.negative !== 0) return 1;\n\n    var res = this.ucmp(num);\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Unsigned comparison\n  BN.prototype.ucmp = function ucmp (num) {\n    // At this point both numbers have the same sign\n    if (this.length > num.length) return 1;\n    if (this.length < num.length) return -1;\n\n    var res = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var a = this.words[i] | 0;\n      var b = num.words[i] | 0;\n\n      if (a === b) continue;\n      if (a < b) {\n        res = -1;\n      } else if (a > b) {\n        res = 1;\n      }\n      break;\n    }\n    return res;\n  };\n\n  BN.prototype.gtn = function gtn (num) {\n    return this.cmpn(num) === 1;\n  };\n\n  BN.prototype.gt = function gt (num) {\n    return this.cmp(num) === 1;\n  };\n\n  BN.prototype.gten = function gten (num) {\n    return this.cmpn(num) >= 0;\n  };\n\n  BN.prototype.gte = function gte (num) {\n    return this.cmp(num) >= 0;\n  };\n\n  BN.prototype.ltn = function ltn (num) {\n    return this.cmpn(num) === -1;\n  };\n\n  BN.prototype.lt = function lt (num) {\n    return this.cmp(num) === -1;\n  };\n\n  BN.prototype.lten = function lten (num) {\n    return this.cmpn(num) <= 0;\n  };\n\n  BN.prototype.lte = function lte (num) {\n    return this.cmp(num) <= 0;\n  };\n\n  BN.prototype.eqn = function eqn (num) {\n    return this.cmpn(num) === 0;\n  };\n\n  BN.prototype.eq = function eq (num) {\n    return this.cmp(num) === 0;\n  };\n\n  //\n  // A reduce context, could be using montgomery or something better, depending\n  // on the `m` itself.\n  //\n  BN.red = function red (num) {\n    return new Red(num);\n  };\n\n  BN.prototype.toRed = function toRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    assert(this.negative === 0, 'red works only with positives');\n    return ctx.convertTo(this)._forceRed(ctx);\n  };\n\n  BN.prototype.fromRed = function fromRed () {\n    assert(this.red, 'fromRed works only with numbers in reduction context');\n    return this.red.convertFrom(this);\n  };\n\n  BN.prototype._forceRed = function _forceRed (ctx) {\n    this.red = ctx;\n    return this;\n  };\n\n  BN.prototype.forceRed = function forceRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    return this._forceRed(ctx);\n  };\n\n  BN.prototype.redAdd = function redAdd (num) {\n    assert(this.red, 'redAdd works only with red numbers');\n    return this.red.add(this, num);\n  };\n\n  BN.prototype.redIAdd = function redIAdd (num) {\n    assert(this.red, 'redIAdd works only with red numbers');\n    return this.red.iadd(this, num);\n  };\n\n  BN.prototype.redSub = function redSub (num) {\n    assert(this.red, 'redSub works only with red numbers');\n    return this.red.sub(this, num);\n  };\n\n  BN.prototype.redISub = function redISub (num) {\n    assert(this.red, 'redISub works only with red numbers');\n    return this.red.isub(this, num);\n  };\n\n  BN.prototype.redShl = function redShl (num) {\n    assert(this.red, 'redShl works only with red numbers');\n    return this.red.shl(this, num);\n  };\n\n  BN.prototype.redMul = function redMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.mul(this, num);\n  };\n\n  BN.prototype.redIMul = function redIMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.imul(this, num);\n  };\n\n  BN.prototype.redSqr = function redSqr () {\n    assert(this.red, 'redSqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqr(this);\n  };\n\n  BN.prototype.redISqr = function redISqr () {\n    assert(this.red, 'redISqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.isqr(this);\n  };\n\n  // Square root over p\n  BN.prototype.redSqrt = function redSqrt () {\n    assert(this.red, 'redSqrt works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqrt(this);\n  };\n\n  BN.prototype.redInvm = function redInvm () {\n    assert(this.red, 'redInvm works only with red numbers');\n    this.red._verify1(this);\n    return this.red.invm(this);\n  };\n\n  // Return negative clone of `this` % `red modulo`\n  BN.prototype.redNeg = function redNeg () {\n    assert(this.red, 'redNeg works only with red numbers');\n    this.red._verify1(this);\n    return this.red.neg(this);\n  };\n\n  BN.prototype.redPow = function redPow (num) {\n    assert(this.red && !num.red, 'redPow(normalNum)');\n    this.red._verify1(this);\n    return this.red.pow(this, num);\n  };\n\n  // Prime numbers with efficient reduction\n  var primes = {\n    k256: null,\n    p224: null,\n    p192: null,\n    p25519: null\n  };\n\n  // Pseudo-Mersenne prime\n  function MPrime (name, p) {\n    // P = 2 ^ N - K\n    this.name = name;\n    this.p = new BN(p, 16);\n    this.n = this.p.bitLength();\n    this.k = new BN(1).iushln(this.n).isub(this.p);\n\n    this.tmp = this._tmp();\n  }\n\n  MPrime.prototype._tmp = function _tmp () {\n    var tmp = new BN(null);\n    tmp.words = new Array(Math.ceil(this.n / 13));\n    return tmp;\n  };\n\n  MPrime.prototype.ireduce = function ireduce (num) {\n    // Assumes that `num` is less than `P^2`\n    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\n    var r = num;\n    var rlen;\n\n    do {\n      this.split(r, this.tmp);\n      r = this.imulK(r);\n      r = r.iadd(this.tmp);\n      rlen = r.bitLength();\n    } while (rlen > this.n);\n\n    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n    if (cmp === 0) {\n      r.words[0] = 0;\n      r.length = 1;\n    } else if (cmp > 0) {\n      r.isub(this.p);\n    } else {\n      r.strip();\n    }\n\n    return r;\n  };\n\n  MPrime.prototype.split = function split (input, out) {\n    input.iushrn(this.n, 0, out);\n  };\n\n  MPrime.prototype.imulK = function imulK (num) {\n    return num.imul(this.k);\n  };\n\n  function K256 () {\n    MPrime.call(\n      this,\n      'k256',\n      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');\n  }\n  inherits(K256, MPrime);\n\n  K256.prototype.split = function split (input, output) {\n    // 256 = 9 * 26 + 22\n    var mask = 0x3fffff;\n\n    var outLen = Math.min(input.length, 9);\n    for (var i = 0; i < outLen; i++) {\n      output.words[i] = input.words[i];\n    }\n    output.length = outLen;\n\n    if (input.length <= 9) {\n      input.words[0] = 0;\n      input.length = 1;\n      return;\n    }\n\n    // Shift by 9 limbs\n    var prev = input.words[9];\n    output.words[output.length++] = prev & mask;\n\n    for (i = 10; i < input.length; i++) {\n      var next = input.words[i] | 0;\n      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);\n      prev = next;\n    }\n    prev >>>= 22;\n    input.words[i - 10] = prev;\n    if (prev === 0 && input.length > 10) {\n      input.length -= 10;\n    } else {\n      input.length -= 9;\n    }\n  };\n\n  K256.prototype.imulK = function imulK (num) {\n    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]\n    num.words[num.length] = 0;\n    num.words[num.length + 1] = 0;\n    num.length += 2;\n\n    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\n    var lo = 0;\n    for (var i = 0; i < num.length; i++) {\n      var w = num.words[i] | 0;\n      lo += w * 0x3d1;\n      num.words[i] = lo & 0x3ffffff;\n      lo = w * 0x40 + ((lo / 0x4000000) | 0);\n    }\n\n    // Fast length reduction\n    if (num.words[num.length - 1] === 0) {\n      num.length--;\n      if (num.words[num.length - 1] === 0) {\n        num.length--;\n      }\n    }\n    return num;\n  };\n\n  function P224 () {\n    MPrime.call(\n      this,\n      'p224',\n      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');\n  }\n  inherits(P224, MPrime);\n\n  function P192 () {\n    MPrime.call(\n      this,\n      'p192',\n      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');\n  }\n  inherits(P192, MPrime);\n\n  function P25519 () {\n    // 2 ^ 255 - 19\n    MPrime.call(\n      this,\n      '25519',\n      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');\n  }\n  inherits(P25519, MPrime);\n\n  P25519.prototype.imulK = function imulK (num) {\n    // K = 0x13\n    var carry = 0;\n    for (var i = 0; i < num.length; i++) {\n      var hi = (num.words[i] | 0) * 0x13 + carry;\n      var lo = hi & 0x3ffffff;\n      hi >>>= 26;\n\n      num.words[i] = lo;\n      carry = hi;\n    }\n    if (carry !== 0) {\n      num.words[num.length++] = carry;\n    }\n    return num;\n  };\n\n  // Exported mostly for testing purposes, use plain name instead\n  BN._prime = function prime (name) {\n    // Cached version of prime\n    if (primes[name]) return primes[name];\n\n    var prime;\n    if (name === 'k256') {\n      prime = new K256();\n    } else if (name === 'p224') {\n      prime = new P224();\n    } else if (name === 'p192') {\n      prime = new P192();\n    } else if (name === 'p25519') {\n      prime = new P25519();\n    } else {\n      throw new Error('Unknown prime ' + name);\n    }\n    primes[name] = prime;\n\n    return prime;\n  };\n\n  //\n  // Base reduction engine\n  //\n  function Red (m) {\n    if (typeof m === 'string') {\n      var prime = BN._prime(m);\n      this.m = prime.p;\n      this.prime = prime;\n    } else {\n      assert(m.gtn(1), 'modulus must be greater than 1');\n      this.m = m;\n      this.prime = null;\n    }\n  }\n\n  Red.prototype._verify1 = function _verify1 (a) {\n    assert(a.negative === 0, 'red works only with positives');\n    assert(a.red, 'red works only with red numbers');\n  };\n\n  Red.prototype._verify2 = function _verify2 (a, b) {\n    assert((a.negative | b.negative) === 0, 'red works only with positives');\n    assert(a.red && a.red === b.red,\n      'red works only with red numbers');\n  };\n\n  Red.prototype.imod = function imod (a) {\n    if (this.prime) return this.prime.ireduce(a)._forceRed(this);\n    return a.umod(this.m)._forceRed(this);\n  };\n\n  Red.prototype.neg = function neg (a) {\n    if (a.isZero()) {\n      return a.clone();\n    }\n\n    return this.m.sub(a)._forceRed(this);\n  };\n\n  Red.prototype.add = function add (a, b) {\n    this._verify2(a, b);\n\n    var res = a.add(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.iadd = function iadd (a, b) {\n    this._verify2(a, b);\n\n    var res = a.iadd(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.sub = function sub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.sub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.isub = function isub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.isub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.shl = function shl (a, num) {\n    this._verify1(a);\n    return this.imod(a.ushln(num));\n  };\n\n  Red.prototype.imul = function imul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.imul(b));\n  };\n\n  Red.prototype.mul = function mul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.mul(b));\n  };\n\n  Red.prototype.isqr = function isqr (a) {\n    return this.imul(a, a.clone());\n  };\n\n  Red.prototype.sqr = function sqr (a) {\n    return this.mul(a, a);\n  };\n\n  Red.prototype.sqrt = function sqrt (a) {\n    if (a.isZero()) return a.clone();\n\n    var mod3 = this.m.andln(3);\n    assert(mod3 % 2 === 1);\n\n    // Fast case\n    if (mod3 === 3) {\n      var pow = this.m.add(new BN(1)).iushrn(2);\n      return this.pow(a, pow);\n    }\n\n    // Tonelli-Shanks algorithm (Totally unoptimized and slow)\n    //\n    // Find Q and S, that Q * 2 ^ S = (P - 1)\n    var q = this.m.subn(1);\n    var s = 0;\n    while (!q.isZero() && q.andln(1) === 0) {\n      s++;\n      q.iushrn(1);\n    }\n    assert(!q.isZero());\n\n    var one = new BN(1).toRed(this);\n    var nOne = one.redNeg();\n\n    // Find quadratic non-residue\n    // NOTE: Max is such because of generalized Riemann hypothesis.\n    var lpow = this.m.subn(1).iushrn(1);\n    var z = this.m.bitLength();\n    z = new BN(2 * z * z).toRed(this);\n\n    while (this.pow(z, lpow).cmp(nOne) !== 0) {\n      z.redIAdd(nOne);\n    }\n\n    var c = this.pow(z, q);\n    var r = this.pow(a, q.addn(1).iushrn(1));\n    var t = this.pow(a, q);\n    var m = s;\n    while (t.cmp(one) !== 0) {\n      var tmp = t;\n      for (var i = 0; tmp.cmp(one) !== 0; i++) {\n        tmp = tmp.redSqr();\n      }\n      assert(i < m);\n      var b = this.pow(c, new BN(1).iushln(m - i - 1));\n\n      r = r.redMul(b);\n      c = b.redSqr();\n      t = t.redMul(c);\n      m = i;\n    }\n\n    return r;\n  };\n\n  Red.prototype.invm = function invm (a) {\n    var inv = a._invmp(this.m);\n    if (inv.negative !== 0) {\n      inv.negative = 0;\n      return this.imod(inv).redNeg();\n    } else {\n      return this.imod(inv);\n    }\n  };\n\n  Red.prototype.pow = function pow (a, num) {\n    if (num.isZero()) return new BN(1).toRed(this);\n    if (num.cmpn(1) === 0) return a.clone();\n\n    var windowSize = 4;\n    var wnd = new Array(1 << windowSize);\n    wnd[0] = new BN(1).toRed(this);\n    wnd[1] = a;\n    for (var i = 2; i < wnd.length; i++) {\n      wnd[i] = this.mul(wnd[i - 1], a);\n    }\n\n    var res = wnd[0];\n    var current = 0;\n    var currentLen = 0;\n    var start = num.bitLength() % 26;\n    if (start === 0) {\n      start = 26;\n    }\n\n    for (i = num.length - 1; i >= 0; i--) {\n      var word = num.words[i];\n      for (var j = start - 1; j >= 0; j--) {\n        var bit = (word >> j) & 1;\n        if (res !== wnd[0]) {\n          res = this.sqr(res);\n        }\n\n        if (bit === 0 && current === 0) {\n          currentLen = 0;\n          continue;\n        }\n\n        current <<= 1;\n        current |= bit;\n        currentLen++;\n        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;\n\n        res = this.mul(res, wnd[current]);\n        currentLen = 0;\n        current = 0;\n      }\n      start = 26;\n    }\n\n    return res;\n  };\n\n  Red.prototype.convertTo = function convertTo (num) {\n    var r = num.umod(this.m);\n\n    return r === num ? r.clone() : r;\n  };\n\n  Red.prototype.convertFrom = function convertFrom (num) {\n    var res = num.clone();\n    res.red = null;\n    return res;\n  };\n\n  //\n  // Montgomery method engine\n  //\n\n  BN.mont = function mont (num) {\n    return new Mont(num);\n  };\n\n  function Mont (m) {\n    Red.call(this, m);\n\n    this.shift = this.m.bitLength();\n    if (this.shift % 26 !== 0) {\n      this.shift += 26 - (this.shift % 26);\n    }\n\n    this.r = new BN(1).iushln(this.shift);\n    this.r2 = this.imod(this.r.sqr());\n    this.rinv = this.r._invmp(this.m);\n\n    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n    this.minv = this.minv.umod(this.r);\n    this.minv = this.r.sub(this.minv);\n  }\n  inherits(Mont, Red);\n\n  Mont.prototype.convertTo = function convertTo (num) {\n    return this.imod(num.ushln(this.shift));\n  };\n\n  Mont.prototype.convertFrom = function convertFrom (num) {\n    var r = this.imod(num.mul(this.rinv));\n    r.red = null;\n    return r;\n  };\n\n  Mont.prototype.imul = function imul (a, b) {\n    if (a.isZero() || b.isZero()) {\n      a.words[0] = 0;\n      a.length = 1;\n      return a;\n    }\n\n    var t = a.imul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.mul = function mul (a, b) {\n    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\n\n    var t = a.mul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.invm = function invm (a) {\n    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n    var res = this.imod(a._invmp(this.m).mul(this.r2));\n    return res._forceRed(this);\n  };\n})(typeof module === 'undefined' || module, this);\n","var basex = require('base-x')\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","const basex = require('base-x')\nconst ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n","'use strict'\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) {\n    } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = new Uint8Array(zeroes + (size - it4))\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n","'use strict'\n\nvar base58 = require('bs58')\nvar Buffer = require('safe-buffer').Buffer\n\nmodule.exports = function (checksumFn) {\n  // Encode a buffer as a base58-check encoded string\n  function encode (payload) {\n    var checksum = checksumFn(payload)\n\n    return base58.encode(Buffer.concat([\n      payload,\n      checksum\n    ], payload.length + 4))\n  }\n\n  function decodeRaw (buffer) {\n    var payload = buffer.slice(0, -4)\n    var checksum = buffer.slice(-4)\n    var newChecksum = checksumFn(payload)\n\n    if (checksum[0] ^ newChecksum[0] |\n        checksum[1] ^ newChecksum[1] |\n        checksum[2] ^ newChecksum[2] |\n        checksum[3] ^ newChecksum[3]) return\n\n    return payload\n  }\n\n  // Decode a base58-check encoded string to a buffer, no result if checksum is wrong\n  function decodeUnsafe (string) {\n    var buffer = base58.decodeUnsafe(string)\n    if (!buffer) return\n\n    return decodeRaw(buffer)\n  }\n\n  function decode (string) {\n    var buffer = base58.decode(string)\n    var payload = decodeRaw(buffer, checksumFn)\n    if (!payload) throw new Error('Invalid checksum')\n    return payload\n  }\n\n  return {\n    encode: encode,\n    decode: decode,\n    decodeUnsafe: decodeUnsafe\n  }\n}\n","'use strict'\n\nvar createHash = require('create-hash')\nvar bs58checkBase = require('./base')\n\n// SHA256(SHA256(buffer))\nfunction sha256x2 (buffer) {\n  var tmp = createHash('sha256').update(buffer).digest()\n  return createHash('sha256').update(tmp).digest()\n}\n\nmodule.exports = bs58checkBase(sha256x2)\n","var basex = require('base-x')\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n","module.exports = function(a, b) {\n  if (typeof a.compare === 'function') return a.compare(b)\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  var i = 0\n  var len = Math.min(x, y)\n  while (i < len) {\n    if (a[i] !== b[i]) break\n\n    ++i\n  }\n\n  if (i !== len) {\n    x = a[i]\n    y = b[i]\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n","'use strict';\nmodule.exports = function (a, b) {\n\tif (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n\t\tthrow new TypeError('Arguments must be Buffers');\n\t}\n\n\tif (a === b) {\n\t\treturn true;\n\t}\n\n\tif (typeof a.equals === 'function') {\n\t\treturn a.equals(b);\n\t}\n\n\tif (a.length !== b.length) {\n\t\treturn false;\n\t}\n\n\tfor (var i = 0; i < a.length; i++) {\n\t\tif (a[i] !== b[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n};\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.ECPairFactory = exports.networks = void 0;\nconst networks = require('./networks');\nexports.networks = networks;\nconst types = require('./types');\nconst randomBytes = require('randombytes');\nconst wif = require('wif');\nconst testecc_1 = require('./testecc');\nconst isOptions = types.typeforce.maybe(\n  types.typeforce.compile({\n    compressed: types.maybe(types.Boolean),\n    network: types.maybe(types.Network),\n  }),\n);\nconst toXOnly = (pubKey) =>\n  pubKey.length === 32 ? pubKey : pubKey.slice(1, 33);\nfunction ECPairFactory(ecc) {\n  (0, testecc_1.testEcc)(ecc);\n  function isPoint(maybePoint) {\n    return ecc.isPoint(maybePoint);\n  }\n  function fromPrivateKey(buffer, options) {\n    types.typeforce(types.Buffer256bit, buffer);\n    if (!ecc.isPrivate(buffer))\n      throw new TypeError('Private key not in range [1, n)');\n    types.typeforce(isOptions, options);\n    return new ECPair(buffer, undefined, options);\n  }\n  function fromPublicKey(buffer, options) {\n    types.typeforce(ecc.isPoint, buffer);\n    types.typeforce(isOptions, options);\n    return new ECPair(undefined, buffer, options);\n  }\n  function fromWIF(wifString, network) {\n    const decoded = wif.decode(wifString);\n    const version = decoded.version;\n    // list of networks?\n    if (types.Array(network)) {\n      network = network\n        .filter((x) => {\n          return version === x.wif;\n        })\n        .pop();\n      if (!network) throw new Error('Unknown network version');\n      // otherwise, assume a network object (or default to bitcoin)\n    } else {\n      network = network || networks.bitcoin;\n      if (version !== network.wif) throw new Error('Invalid network version');\n    }\n    return fromPrivateKey(decoded.privateKey, {\n      compressed: decoded.compressed,\n      network: network,\n    });\n  }\n  function makeRandom(options) {\n    types.typeforce(isOptions, options);\n    if (options === undefined) options = {};\n    const rng = options.rng || randomBytes;\n    let d;\n    do {\n      d = rng(32);\n      types.typeforce(types.Buffer256bit, d);\n    } while (!ecc.isPrivate(d));\n    return fromPrivateKey(d, options);\n  }\n  class ECPair {\n    __D;\n    __Q;\n    compressed;\n    network;\n    lowR;\n    constructor(__D, __Q, options) {\n      this.__D = __D;\n      this.__Q = __Q;\n      this.lowR = false;\n      if (options === undefined) options = {};\n      this.compressed =\n        options.compressed === undefined ? true : options.compressed;\n      this.network = options.network || networks.bitcoin;\n      if (__Q !== undefined)\n        this.__Q = Buffer.from(ecc.pointCompress(__Q, this.compressed));\n    }\n    get privateKey() {\n      return this.__D;\n    }\n    get publicKey() {\n      if (!this.__Q) {\n        // It is not possible for both `__Q` and `__D` to be `undefined` at the same time.\n        // The factory methods guard for this.\n        const p = ecc.pointFromScalar(this.__D, this.compressed);\n        // It is not possible for `p` to be null.\n        // `fromPrivateKey()` checks that `__D` is a valid scalar.\n        this.__Q = Buffer.from(p);\n      }\n      return this.__Q;\n    }\n    toWIF() {\n      if (!this.__D) throw new Error('Missing private key');\n      return wif.encode(this.network.wif, this.__D, this.compressed);\n    }\n    tweak(t) {\n      if (this.privateKey) return this.tweakFromPrivateKey(t);\n      return this.tweakFromPublicKey(t);\n    }\n    sign(hash, lowR) {\n      if (!this.__D) throw new Error('Missing private key');\n      if (lowR === undefined) lowR = this.lowR;\n      if (lowR === false) {\n        return Buffer.from(ecc.sign(hash, this.__D));\n      } else {\n        let sig = ecc.sign(hash, this.__D);\n        const extraData = Buffer.alloc(32, 0);\n        let counter = 0;\n        // if first try is lowR, skip the loop\n        // for second try and on, add extra entropy counting up\n        while (sig[0] > 0x7f) {\n          counter++;\n          extraData.writeUIntLE(counter, 0, 6);\n          sig = ecc.sign(hash, this.__D, extraData);\n        }\n        return Buffer.from(sig);\n      }\n    }\n    signSchnorr(hash) {\n      if (!this.privateKey) throw new Error('Missing private key');\n      if (!ecc.signSchnorr)\n        throw new Error('signSchnorr not supported by ecc library');\n      return Buffer.from(ecc.signSchnorr(hash, this.privateKey));\n    }\n    verify(hash, signature) {\n      return ecc.verify(hash, this.publicKey, signature);\n    }\n    verifySchnorr(hash, signature) {\n      if (!ecc.verifySchnorr)\n        throw new Error('verifySchnorr not supported by ecc library');\n      return ecc.verifySchnorr(hash, this.publicKey.subarray(1, 33), signature);\n    }\n    tweakFromPublicKey(t) {\n      const xOnlyPubKey = toXOnly(this.publicKey);\n      const tweakedPublicKey = ecc.xOnlyPointAddTweak(xOnlyPubKey, t);\n      if (!tweakedPublicKey || tweakedPublicKey.xOnlyPubkey === null)\n        throw new Error('Cannot tweak public key!');\n      const parityByte = Buffer.from([\n        tweakedPublicKey.parity === 0 ? 0x02 : 0x03,\n      ]);\n      return fromPublicKey(\n        Buffer.concat([parityByte, tweakedPublicKey.xOnlyPubkey]),\n        { network: this.network, compressed: this.compressed },\n      );\n    }\n    tweakFromPrivateKey(t) {\n      const hasOddY =\n        this.publicKey[0] === 3 ||\n        (this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1);\n      const privateKey = hasOddY\n        ? ecc.privateNegate(this.privateKey)\n        : this.privateKey;\n      const tweakedPrivateKey = ecc.privateAdd(privateKey, t);\n      if (!tweakedPrivateKey) throw new Error('Invalid tweaked private key!');\n      return fromPrivateKey(Buffer.from(tweakedPrivateKey), {\n        network: this.network,\n        compressed: this.compressed,\n      });\n    }\n  }\n  return {\n    isPoint,\n    fromPrivateKey,\n    fromPublicKey,\n    fromWIF,\n    makeRandom,\n  };\n}\nexports.ECPairFactory = ECPairFactory;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.networks = exports.ECPairFactory = exports.default = void 0;\nvar ecpair_1 = require('./ecpair');\nObject.defineProperty(exports, 'default', {\n  enumerable: true,\n  get: function () {\n    return ecpair_1.ECPairFactory;\n  },\n});\nObject.defineProperty(exports, 'ECPairFactory', {\n  enumerable: true,\n  get: function () {\n    return ecpair_1.ECPairFactory;\n  },\n});\nObject.defineProperty(exports, 'networks', {\n  enumerable: true,\n  get: function () {\n    return ecpair_1.networks;\n  },\n});\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.testnet = exports.bitcoin = void 0;\nexports.bitcoin = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'bc',\n  bip32: {\n    public: 0x0488b21e,\n    private: 0x0488ade4,\n  },\n  pubKeyHash: 0x00,\n  scriptHash: 0x05,\n  wif: 0x80,\n};\nexports.testnet = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'tb',\n  bip32: {\n    public: 0x043587cf,\n    private: 0x04358394,\n  },\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  wif: 0xef,\n};\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.testEcc = void 0;\nconst h = (hex) => Buffer.from(hex, 'hex');\nfunction testEcc(ecc) {\n  assert(\n    ecc.isPoint(\n      h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),\n    ),\n  );\n  assert(\n    !ecc.isPoint(\n      h('030000000000000000000000000000000000000000000000000000000000000005'),\n    ),\n  );\n  assert(\n    ecc.isPrivate(\n      h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),\n    ),\n  );\n  // order - 1\n  assert(\n    ecc.isPrivate(\n      h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140'),\n    ),\n  );\n  // 0\n  assert(\n    !ecc.isPrivate(\n      h('0000000000000000000000000000000000000000000000000000000000000000'),\n    ),\n  );\n  // order\n  assert(\n    !ecc.isPrivate(\n      h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),\n    ),\n  );\n  // order + 1\n  assert(\n    !ecc.isPrivate(\n      h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142'),\n    ),\n  );\n  // 1 + 0 == 1\n  assert(\n    Buffer.from(\n      ecc.privateAdd(\n        h('0000000000000000000000000000000000000000000000000000000000000001'),\n        h('0000000000000000000000000000000000000000000000000000000000000000'),\n      ),\n    ).equals(\n      h('0000000000000000000000000000000000000000000000000000000000000001'),\n    ),\n  );\n  // -3 + 3 == 0\n  assert(\n    ecc.privateAdd(\n      h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e'),\n      h('0000000000000000000000000000000000000000000000000000000000000003'),\n    ) === null,\n  );\n  assert(\n    Buffer.from(\n      ecc.privateAdd(\n        h('e211078564db65c3ce7704f08262b1f38f1ef412ad15b5ac2d76657a63b2c500'),\n        h('b51fbb69051255d1becbd683de5848242a89c229348dd72896a87ada94ae8665'),\n      ),\n    ).equals(\n      h('9730c2ee69edbb958d42db7460bafa18fef9d955325aec99044c81c8282b0a24'),\n    ),\n  );\n  assert(\n    Buffer.from(\n      ecc.privateNegate(\n        h('0000000000000000000000000000000000000000000000000000000000000001'),\n      ),\n    ).equals(\n      h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140'),\n    ),\n  );\n  assert(\n    Buffer.from(\n      ecc.privateNegate(\n        h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e'),\n      ),\n    ).equals(\n      h('0000000000000000000000000000000000000000000000000000000000000003'),\n    ),\n  );\n  assert(\n    Buffer.from(\n      ecc.privateNegate(\n        h('b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af'),\n      ),\n    ).equals(\n      h('4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792'),\n    ),\n  );\n  assert(\n    Buffer.from(\n      ecc.pointCompress(\n        h(\n          '0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n        ),\n        true,\n      ),\n    ).equals(\n      h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),\n    ),\n  );\n  assert(\n    Buffer.from(\n      ecc.pointCompress(\n        h(\n          '0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n        ),\n        false,\n      ),\n    ).equals(\n      h(\n        '0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n      ),\n    ),\n  );\n  assert(\n    Buffer.from(\n      ecc.pointCompress(\n        h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),\n        true,\n      ),\n    ).equals(\n      h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),\n    ),\n  );\n  assert(\n    Buffer.from(\n      ecc.pointCompress(\n        h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),\n        false,\n      ),\n    ).equals(\n      h(\n        '0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n      ),\n    ),\n  );\n  assert(\n    Buffer.from(\n      ecc.pointFromScalar(\n        h('b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af'),\n      ),\n    ).equals(\n      h('02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99'),\n    ),\n  );\n  assert(\n    ecc.xOnlyPointAddTweak(\n      h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),\n      h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140'),\n    ) === null,\n  );\n  let xOnlyRes = ecc.xOnlyPointAddTweak(\n    h('1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b'),\n    h('a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac'),\n  );\n  assert(\n    Buffer.from(xOnlyRes.xOnlyPubkey).equals(\n      h('e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf'),\n    ) && xOnlyRes.parity === 1,\n  );\n  xOnlyRes = ecc.xOnlyPointAddTweak(\n    h('2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991'),\n    h('823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47'),\n  );\n  assert(\n    Buffer.from(xOnlyRes.xOnlyPubkey).equals(\n      h('9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c'),\n    ) && xOnlyRes.parity === 0,\n  );\n  assert(\n    Buffer.from(\n      ecc.sign(\n        h('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'),\n        h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140'),\n      ),\n    ).equals(\n      h(\n        '54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5',\n      ),\n    ),\n  );\n  assert(\n    ecc.verify(\n      h('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'),\n      h('0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),\n      h(\n        '54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5',\n      ),\n    ),\n  );\n  if (ecc.signSchnorr) {\n    assert(\n      Buffer.from(\n        ecc.signSchnorr(\n          h('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'),\n          h('c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9'),\n          h('c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906'),\n        ),\n      ).equals(\n        h(\n          '5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7',\n        ),\n      ),\n    );\n  }\n  if (ecc.verifySchnorr) {\n    assert(\n      ecc.verifySchnorr(\n        h('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'),\n        h('dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8'),\n        h(\n          '5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7',\n        ),\n      ),\n    );\n  }\n}\nexports.testEcc = testEcc;\nfunction assert(bool) {\n  if (!bool) throw new Error('ecc library invalid');\n}\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.maybe =\n  exports.Boolean =\n  exports.Array =\n  exports.Buffer256bit =\n  exports.Network =\n  exports.typeforce =\n    void 0;\nexports.typeforce = require('typeforce');\n// exposed, external API\nexports.Network = exports.typeforce.compile({\n  messagePrefix: exports.typeforce.oneOf(\n    exports.typeforce.Buffer,\n    exports.typeforce.String,\n  ),\n  bip32: {\n    public: exports.typeforce.UInt32,\n    private: exports.typeforce.UInt32,\n  },\n  pubKeyHash: exports.typeforce.UInt8,\n  scriptHash: exports.typeforce.UInt8,\n  wif: exports.typeforce.UInt8,\n});\nexports.Buffer256bit = exports.typeforce.BufferN(32);\nexports.Array = exports.typeforce.Array;\nexports.Boolean = exports.typeforce.Boolean; // tslint:disable-line variable-name\nexports.maybe = exports.typeforce.maybe;\n","(function (root, factory) {\n    // Hack to make all exports of this module sha256 function object properties.\n    var exports = {};\n    factory(exports);\n    var sha256 = exports[\"default\"];\n    for (var k in exports) {\n        sha256[k] = exports[k];\n    }\n        \n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        module.exports = sha256;\n    } else if (typeof define === 'function' && define.amd) {\n        define(function() { return sha256; }); \n    } else {\n        root.sha256 = sha256;\n    }\n})(this, function(exports) {\n\"use strict\";\nexports.__esModule = true;\n// SHA-256 (+ HMAC and PBKDF2) for JavaScript.\n//\n// Written in 2014-2016 by Dmitry Chestnykh.\n// Public domain, no warranty.\n//\n// Functions (accept and return Uint8Arrays):\n//\n//   sha256(message) -> hash\n//   sha256.hmac(key, message) -> mac\n//   sha256.pbkdf2(password, salt, rounds, dkLen) -> dk\n//\n//  Classes:\n//\n//   new sha256.Hash()\n//   new sha256.HMAC(key)\n//\nexports.digestLength = 32;\nexports.blockSize = 64;\n// SHA-256 constants\nvar K = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,\n    0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,\n    0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,\n    0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152,\n    0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,\n    0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,\n    0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,\n    0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08,\n    0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f,\n    0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\nfunction hashBlocks(w, v, p, pos, len) {\n    var a, b, c, d, e, f, g, h, u, i, j, t1, t2;\n    while (len >= 64) {\n        a = v[0];\n        b = v[1];\n        c = v[2];\n        d = v[3];\n        e = v[4];\n        f = v[5];\n        g = v[6];\n        h = v[7];\n        for (i = 0; i < 16; i++) {\n            j = pos + i * 4;\n            w[i] = (((p[j] & 0xff) << 24) | ((p[j + 1] & 0xff) << 16) |\n                ((p[j + 2] & 0xff) << 8) | (p[j + 3] & 0xff));\n        }\n        for (i = 16; i < 64; i++) {\n            u = w[i - 2];\n            t1 = (u >>> 17 | u << (32 - 17)) ^ (u >>> 19 | u << (32 - 19)) ^ (u >>> 10);\n            u = w[i - 15];\n            t2 = (u >>> 7 | u << (32 - 7)) ^ (u >>> 18 | u << (32 - 18)) ^ (u >>> 3);\n            w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0);\n        }\n        for (i = 0; i < 64; i++) {\n            t1 = (((((e >>> 6 | e << (32 - 6)) ^ (e >>> 11 | e << (32 - 11)) ^\n                (e >>> 25 | e << (32 - 25))) + ((e & f) ^ (~e & g))) | 0) +\n                ((h + ((K[i] + w[i]) | 0)) | 0)) | 0;\n            t2 = (((a >>> 2 | a << (32 - 2)) ^ (a >>> 13 | a << (32 - 13)) ^\n                (a >>> 22 | a << (32 - 22))) + ((a & b) ^ (a & c) ^ (b & c))) | 0;\n            h = g;\n            g = f;\n            f = e;\n            e = (d + t1) | 0;\n            d = c;\n            c = b;\n            b = a;\n            a = (t1 + t2) | 0;\n        }\n        v[0] += a;\n        v[1] += b;\n        v[2] += c;\n        v[3] += d;\n        v[4] += e;\n        v[5] += f;\n        v[6] += g;\n        v[7] += h;\n        pos += 64;\n        len -= 64;\n    }\n    return pos;\n}\n// Hash implements SHA256 hash algorithm.\nvar Hash = /** @class */ (function () {\n    function Hash() {\n        this.digestLength = exports.digestLength;\n        this.blockSize = exports.blockSize;\n        // Note: Int32Array is used instead of Uint32Array for performance reasons.\n        this.state = new Int32Array(8); // hash state\n        this.temp = new Int32Array(64); // temporary state\n        this.buffer = new Uint8Array(128); // buffer for data to hash\n        this.bufferLength = 0; // number of bytes in buffer\n        this.bytesHashed = 0; // number of total bytes hashed\n        this.finished = false; // indicates whether the hash was finalized\n        this.reset();\n    }\n    // Resets hash state making it possible\n    // to re-use this instance to hash other data.\n    Hash.prototype.reset = function () {\n        this.state[0] = 0x6a09e667;\n        this.state[1] = 0xbb67ae85;\n        this.state[2] = 0x3c6ef372;\n        this.state[3] = 0xa54ff53a;\n        this.state[4] = 0x510e527f;\n        this.state[5] = 0x9b05688c;\n        this.state[6] = 0x1f83d9ab;\n        this.state[7] = 0x5be0cd19;\n        this.bufferLength = 0;\n        this.bytesHashed = 0;\n        this.finished = false;\n        return this;\n    };\n    // Cleans internal buffers and re-initializes hash state.\n    Hash.prototype.clean = function () {\n        for (var i = 0; i < this.buffer.length; i++) {\n            this.buffer[i] = 0;\n        }\n        for (var i = 0; i < this.temp.length; i++) {\n            this.temp[i] = 0;\n        }\n        this.reset();\n    };\n    // Updates hash state with the given data.\n    //\n    // Optionally, length of the data can be specified to hash\n    // fewer bytes than data.length.\n    //\n    // Throws error when trying to update already finalized hash:\n    // instance must be reset to use it again.\n    Hash.prototype.update = function (data, dataLength) {\n        if (dataLength === void 0) { dataLength = data.length; }\n        if (this.finished) {\n            throw new Error(\"SHA256: can't update because hash was finished.\");\n        }\n        var dataPos = 0;\n        this.bytesHashed += dataLength;\n        if (this.bufferLength > 0) {\n            while (this.bufferLength < 64 && dataLength > 0) {\n                this.buffer[this.bufferLength++] = data[dataPos++];\n                dataLength--;\n            }\n            if (this.bufferLength === 64) {\n                hashBlocks(this.temp, this.state, this.buffer, 0, 64);\n                this.bufferLength = 0;\n            }\n        }\n        if (dataLength >= 64) {\n            dataPos = hashBlocks(this.temp, this.state, data, dataPos, dataLength);\n            dataLength %= 64;\n        }\n        while (dataLength > 0) {\n            this.buffer[this.bufferLength++] = data[dataPos++];\n            dataLength--;\n        }\n        return this;\n    };\n    // Finalizes hash state and puts hash into out.\n    //\n    // If hash was already finalized, puts the same value.\n    Hash.prototype.finish = function (out) {\n        if (!this.finished) {\n            var bytesHashed = this.bytesHashed;\n            var left = this.bufferLength;\n            var bitLenHi = (bytesHashed / 0x20000000) | 0;\n            var bitLenLo = bytesHashed << 3;\n            var padLength = (bytesHashed % 64 < 56) ? 64 : 128;\n            this.buffer[left] = 0x80;\n            for (var i = left + 1; i < padLength - 8; i++) {\n                this.buffer[i] = 0;\n            }\n            this.buffer[padLength - 8] = (bitLenHi >>> 24) & 0xff;\n            this.buffer[padLength - 7] = (bitLenHi >>> 16) & 0xff;\n            this.buffer[padLength - 6] = (bitLenHi >>> 8) & 0xff;\n            this.buffer[padLength - 5] = (bitLenHi >>> 0) & 0xff;\n            this.buffer[padLength - 4] = (bitLenLo >>> 24) & 0xff;\n            this.buffer[padLength - 3] = (bitLenLo >>> 16) & 0xff;\n            this.buffer[padLength - 2] = (bitLenLo >>> 8) & 0xff;\n            this.buffer[padLength - 1] = (bitLenLo >>> 0) & 0xff;\n            hashBlocks(this.temp, this.state, this.buffer, 0, padLength);\n            this.finished = true;\n        }\n        for (var i = 0; i < 8; i++) {\n            out[i * 4 + 0] = (this.state[i] >>> 24) & 0xff;\n            out[i * 4 + 1] = (this.state[i] >>> 16) & 0xff;\n            out[i * 4 + 2] = (this.state[i] >>> 8) & 0xff;\n            out[i * 4 + 3] = (this.state[i] >>> 0) & 0xff;\n        }\n        return this;\n    };\n    // Returns the final hash digest.\n    Hash.prototype.digest = function () {\n        var out = new Uint8Array(this.digestLength);\n        this.finish(out);\n        return out;\n    };\n    // Internal function for use in HMAC for optimization.\n    Hash.prototype._saveState = function (out) {\n        for (var i = 0; i < this.state.length; i++) {\n            out[i] = this.state[i];\n        }\n    };\n    // Internal function for use in HMAC for optimization.\n    Hash.prototype._restoreState = function (from, bytesHashed) {\n        for (var i = 0; i < this.state.length; i++) {\n            this.state[i] = from[i];\n        }\n        this.bytesHashed = bytesHashed;\n        this.finished = false;\n        this.bufferLength = 0;\n    };\n    return Hash;\n}());\nexports.Hash = Hash;\n// HMAC implements HMAC-SHA256 message authentication algorithm.\nvar HMAC = /** @class */ (function () {\n    function HMAC(key) {\n        this.inner = new Hash();\n        this.outer = new Hash();\n        this.blockSize = this.inner.blockSize;\n        this.digestLength = this.inner.digestLength;\n        var pad = new Uint8Array(this.blockSize);\n        if (key.length > this.blockSize) {\n            (new Hash()).update(key).finish(pad).clean();\n        }\n        else {\n            for (var i = 0; i < key.length; i++) {\n                pad[i] = key[i];\n            }\n        }\n        for (var i = 0; i < pad.length; i++) {\n            pad[i] ^= 0x36;\n        }\n        this.inner.update(pad);\n        for (var i = 0; i < pad.length; i++) {\n            pad[i] ^= 0x36 ^ 0x5c;\n        }\n        this.outer.update(pad);\n        this.istate = new Uint32Array(8);\n        this.ostate = new Uint32Array(8);\n        this.inner._saveState(this.istate);\n        this.outer._saveState(this.ostate);\n        for (var i = 0; i < pad.length; i++) {\n            pad[i] = 0;\n        }\n    }\n    // Returns HMAC state to the state initialized with key\n    // to make it possible to run HMAC over the other data with the same\n    // key without creating a new instance.\n    HMAC.prototype.reset = function () {\n        this.inner._restoreState(this.istate, this.inner.blockSize);\n        this.outer._restoreState(this.ostate, this.outer.blockSize);\n        return this;\n    };\n    // Cleans HMAC state.\n    HMAC.prototype.clean = function () {\n        for (var i = 0; i < this.istate.length; i++) {\n            this.ostate[i] = this.istate[i] = 0;\n        }\n        this.inner.clean();\n        this.outer.clean();\n    };\n    // Updates state with provided data.\n    HMAC.prototype.update = function (data) {\n        this.inner.update(data);\n        return this;\n    };\n    // Finalizes HMAC and puts the result in out.\n    HMAC.prototype.finish = function (out) {\n        if (this.outer.finished) {\n            this.outer.finish(out);\n        }\n        else {\n            this.inner.finish(out);\n            this.outer.update(out, this.digestLength).finish(out);\n        }\n        return this;\n    };\n    // Returns message authentication code.\n    HMAC.prototype.digest = function () {\n        var out = new Uint8Array(this.digestLength);\n        this.finish(out);\n        return out;\n    };\n    return HMAC;\n}());\nexports.HMAC = HMAC;\n// Returns SHA256 hash of data.\nfunction hash(data) {\n    var h = (new Hash()).update(data);\n    var digest = h.digest();\n    h.clean();\n    return digest;\n}\nexports.hash = hash;\n// Function hash is both available as module.hash and as default export.\nexports[\"default\"] = hash;\n// Returns HMAC-SHA256 of data under the key.\nfunction hmac(key, data) {\n    var h = (new HMAC(key)).update(data);\n    var digest = h.digest();\n    h.clean();\n    return digest;\n}\nexports.hmac = hmac;\n// Fills hkdf buffer like this:\n// T(1) = HMAC-Hash(PRK, T(0) | info | 0x01)\nfunction fillBuffer(buffer, hmac, info, counter) {\n    // Counter is a byte value: check if it overflowed.\n    var num = counter[0];\n    if (num === 0) {\n        throw new Error(\"hkdf: cannot expand more\");\n    }\n    // Prepare HMAC instance for new data with old key.\n    hmac.reset();\n    // Hash in previous output if it was generated\n    // (i.e. counter is greater than 1).\n    if (num > 1) {\n        hmac.update(buffer);\n    }\n    // Hash in info if it exists.\n    if (info) {\n        hmac.update(info);\n    }\n    // Hash in the counter.\n    hmac.update(counter);\n    // Output result to buffer and clean HMAC instance.\n    hmac.finish(buffer);\n    // Increment counter inside typed array, this works properly.\n    counter[0]++;\n}\nvar hkdfSalt = new Uint8Array(exports.digestLength); // Filled with zeroes.\nfunction hkdf(key, salt, info, length) {\n    if (salt === void 0) { salt = hkdfSalt; }\n    if (length === void 0) { length = 32; }\n    var counter = new Uint8Array([1]);\n    // HKDF-Extract uses salt as HMAC key, and key as data.\n    var okm = hmac(salt, key);\n    // Initialize HMAC for expanding with extracted key.\n    // Ensure no collisions with `hmac` function.\n    var hmac_ = new HMAC(okm);\n    // Allocate buffer.\n    var buffer = new Uint8Array(hmac_.digestLength);\n    var bufpos = buffer.length;\n    var out = new Uint8Array(length);\n    for (var i = 0; i < length; i++) {\n        if (bufpos === buffer.length) {\n            fillBuffer(buffer, hmac_, info, counter);\n            bufpos = 0;\n        }\n        out[i] = buffer[bufpos++];\n    }\n    hmac_.clean();\n    buffer.fill(0);\n    counter.fill(0);\n    return out;\n}\nexports.hkdf = hkdf;\n// Derives a key from password and salt using PBKDF2-HMAC-SHA256\n// with the given number of iterations.\n//\n// The number of bytes returned is equal to dkLen.\n//\n// (For better security, avoid dkLen greater than hash length - 32 bytes).\nfunction pbkdf2(password, salt, iterations, dkLen) {\n    var prf = new HMAC(password);\n    var len = prf.digestLength;\n    var ctr = new Uint8Array(4);\n    var t = new Uint8Array(len);\n    var u = new Uint8Array(len);\n    var dk = new Uint8Array(dkLen);\n    for (var i = 0; i * len < dkLen; i++) {\n        var c = i + 1;\n        ctr[0] = (c >>> 24) & 0xff;\n        ctr[1] = (c >>> 16) & 0xff;\n        ctr[2] = (c >>> 8) & 0xff;\n        ctr[3] = (c >>> 0) & 0xff;\n        prf.reset();\n        prf.update(salt);\n        prf.update(ctr);\n        prf.finish(u);\n        for (var j = 0; j < len; j++) {\n            t[j] = u[j];\n        }\n        for (var j = 2; j <= iterations; j++) {\n            prf.reset();\n            prf.update(u).finish(u);\n            for (var k = 0; k < len; k++) {\n                t[k] ^= u[k];\n            }\n        }\n        for (var j = 0; j < len && i * len + j < dkLen; j++) {\n            dk[i * len + j] = t[j];\n        }\n    }\n    for (var i = 0; i < len; i++) {\n        t[i] = u[i] = 0;\n    }\n    for (var i = 0; i < 4; i++) {\n        ctr[i] = 0;\n    }\n    prf.clean();\n    return dk;\n}\nexports.pbkdf2 = pbkdf2;\n});\n","(function(){var e={452:function(e){\"use strict\";e.exports=require(\"next/dist/compiled/querystring-es3\")}};var t={};function __nccwpck_require__(o){var a=t[o];if(a!==undefined){return a.exports}var s=t[o]={exports:{}};var n=true;try{e[o](s,s.exports,__nccwpck_require__);n=false}finally{if(n)delete t[o]}return s.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var o={};!function(){var e=o;var t,a=(t=__nccwpck_require__(452))&&\"object\"==typeof t&&\"default\"in t?t.default:t,s=/https?|ftp|gopher|file/;function r(e){\"string\"==typeof e&&(e=d(e));var t=function(e,t,o){var a=e.auth,s=e.hostname,n=e.protocol||\"\",p=e.pathname||\"\",c=e.hash||\"\",i=e.query||\"\",u=!1;a=a?encodeURIComponent(a).replace(/%3A/i,\":\")+\"@\":\"\",e.host?u=a+e.host:s&&(u=a+(~s.indexOf(\":\")?\"[\"+s+\"]\":s),e.port&&(u+=\":\"+e.port)),i&&\"object\"==typeof i&&(i=t.encode(i));var f=e.search||i&&\"?\"+i||\"\";return n&&\":\"!==n.substr(-1)&&(n+=\":\"),e.slashes||(!n||o.test(n))&&!1!==u?(u=\"//\"+(u||\"\"),p&&\"/\"!==p[0]&&(p=\"/\"+p)):u||(u=\"\"),c&&\"#\"!==c[0]&&(c=\"#\"+c),f&&\"?\"!==f[0]&&(f=\"?\"+f),{protocol:n,host:u,pathname:p=p.replace(/[?#]/g,encodeURIComponent),search:f=f.replace(\"#\",\"%23\"),hash:c}}(e,a,s);return\"\"+t.protocol+t.host+t.pathname+t.search+t.hash}var n=\"http://\",p=\"w.w\",c=n+p,i=/^([a-z0-9.+-]*:\\/\\/\\/)([a-z0-9.+-]:\\/*)?/i,u=/https?|ftp|gopher|file/;function h(e,t){var o=\"string\"==typeof e?d(e):e;e=\"object\"==typeof e?r(e):e;var a=d(t),s=\"\";o.protocol&&!o.slashes&&(s=o.protocol,e=e.replace(o.protocol,\"\"),s+=\"/\"===t[0]||\"/\"===e[0]?\"/\":\"\"),s&&a.protocol&&(s=\"\",a.slashes||(s=a.protocol,t=t.replace(a.protocol,\"\")));var p=e.match(i);p&&!a.protocol&&(e=e.substr((s=p[1]+(p[2]||\"\")).length),/^\\/\\/[^/]/.test(t)&&(s=s.slice(0,-1)));var f=new URL(e,c+\"/\"),m=new URL(t,f).toString().replace(c,\"\"),v=a.protocol||o.protocol;return v+=o.slashes||a.slashes?\"//\":\"\",!s&&v?m=m.replace(n,v):s&&(m=m.replace(n,\"\")),u.test(m)||~t.indexOf(\".\")||\"/\"===e.slice(-1)||\"/\"===t.slice(-1)||\"/\"!==m.slice(-1)||(m=m.slice(0,-1)),s&&(m=s+(\"/\"===m[0]?m.substr(1):m)),m}function l(){}l.prototype.parse=d,l.prototype.format=r,l.prototype.resolve=h,l.prototype.resolveObject=h;var f=/^https?|ftp|gopher|file/,m=/^(.*?)([#?].*)/,v=/^([a-z0-9.+-]*:)(\\/{0,3})(.*)/i,_=/^([a-z0-9.+-]*:)?\\/\\/\\/*/i,b=/^([a-z0-9.+-]*:)(\\/{0,2})\\[(.*)\\]$/i;function d(e,t,o){if(void 0===t&&(t=!1),void 0===o&&(o=!1),e&&\"object\"==typeof e&&e instanceof l)return e;var s=(e=e.trim()).match(m);e=s?s[1].replace(/\\\\/g,\"/\")+s[2]:e.replace(/\\\\/g,\"/\"),b.test(e)&&\"/\"!==e.slice(-1)&&(e+=\"/\");var n=!/(^javascript)/.test(e)&&e.match(v),i=_.test(e),u=\"\";n&&(f.test(n[1])||(u=n[1].toLowerCase(),e=\"\"+n[2]+n[3]),n[2]||(i=!1,f.test(n[1])?(u=n[1],e=\"\"+n[3]):e=\"//\"+n[3]),3!==n[2].length&&1!==n[2].length||(u=n[1],e=\"/\"+n[3]));var g,y=(s?s[1]:e).match(/^https?:\\/\\/[^/]+(:[0-9]+)(?=\\/|$)/),w=y&&y[1],x=new l,C=\"\",U=\"\";try{g=new URL(e)}catch(t){C=t,u||o||!/^\\/\\//.test(e)||/^\\/\\/.+[@.]/.test(e)||(U=\"/\",e=e.substr(1));try{g=new URL(e,c)}catch(e){return x.protocol=u,x.href=u,x}}x.slashes=i&&!U,x.host=g.host===p?\"\":g.host,x.hostname=g.hostname===p?\"\":g.hostname.replace(/(\\[|\\])/g,\"\"),x.protocol=C?u||null:g.protocol,x.search=g.search.replace(/\\\\/g,\"%5C\"),x.hash=g.hash.replace(/\\\\/g,\"%5C\");var j=e.split(\"#\");!x.search&&~j[0].indexOf(\"?\")&&(x.search=\"?\"),x.hash||\"\"!==j[1]||(x.hash=\"#\"),x.query=t?a.decode(g.search.substr(1)):x.search.substr(1),x.pathname=U+(n?function(e){return e.replace(/['^|`]/g,(function(e){return\"%\"+e.charCodeAt().toString(16).toUpperCase()})).replace(/((?:%[0-9A-F]{2})+)/g,(function(e,t){try{return decodeURIComponent(t).split(\"\").map((function(e){var t=e.charCodeAt();return t>256||/^[a-z0-9]$/i.test(e)?e:\"%\"+t.toString(16).toUpperCase()})).join(\"\")}catch(e){return t}}))}(g.pathname):g.pathname),\"about:\"===x.protocol&&\"blank\"===x.pathname&&(x.protocol=\"\",x.pathname=\"\"),C&&\"/\"!==e[0]&&(x.pathname=x.pathname.substr(1)),u&&!f.test(u)&&\"/\"!==e.slice(-1)&&\"/\"===x.pathname&&(x.pathname=\"\"),x.path=x.pathname+x.search,x.auth=[g.username,g.password].map(decodeURIComponent).filter(Boolean).join(\":\"),x.port=g.port,w&&!x.host.endsWith(w)&&(x.host+=w,x.port=w.slice(1)),x.href=U?\"\"+x.pathname+x.search+x.hash:r(x);var q=/^(file)/.test(x.href)?[\"host\",\"hostname\"]:[];return Object.keys(x).forEach((function(e){~q.indexOf(e)||(x[e]=x[e]||null)})),x}e.parse=d,e.format=r,e.resolve=h,e.resolveObject=function(e,t){return d(h(e,t))},e.Url=l}();module.exports=o})();","(function(){\"use strict\";var e={815:function(e){function hasOwnProperty(e,r){return Object.prototype.hasOwnProperty.call(e,r)}e.exports=function(e,n,t,o){n=n||\"&\";t=t||\"=\";var a={};if(typeof e!==\"string\"||e.length===0){return a}var i=/\\+/g;e=e.split(n);var u=1e3;if(o&&typeof o.maxKeys===\"number\"){u=o.maxKeys}var c=e.length;if(u>0&&c>u){c=u}for(var p=0;p<c;++p){var f=e[p].replace(i,\"%20\"),s=f.indexOf(t),_,l,y,d;if(s>=0){_=f.substr(0,s);l=f.substr(s+1)}else{_=f;l=\"\"}y=decodeURIComponent(_);d=decodeURIComponent(l);if(!hasOwnProperty(a,y)){a[y]=d}else if(r(a[y])){a[y].push(d)}else{a[y]=[a[y],d]}}return a};var r=Array.isArray||function(e){return Object.prototype.toString.call(e)===\"[object Array]\"}},577:function(e){var stringifyPrimitive=function(e){switch(typeof e){case\"string\":return e;case\"boolean\":return e?\"true\":\"false\";case\"number\":return isFinite(e)?e:\"\";default:return\"\"}};e.exports=function(e,t,o,a){t=t||\"&\";o=o||\"=\";if(e===null){e=undefined}if(typeof e===\"object\"){return map(n(e),(function(n){var a=encodeURIComponent(stringifyPrimitive(n))+o;if(r(e[n])){return map(e[n],(function(e){return a+encodeURIComponent(stringifyPrimitive(e))})).join(t)}else{return a+encodeURIComponent(stringifyPrimitive(e[n]))}})).join(t)}if(!a)return\"\";return encodeURIComponent(stringifyPrimitive(a))+o+encodeURIComponent(stringifyPrimitive(e))};var r=Array.isArray||function(e){return Object.prototype.toString.call(e)===\"[object Array]\"};function map(e,r){if(e.map)return e.map(r);var n=[];for(var t=0;t<e.length;t++){n.push(r(e[t],t))}return n}var n=Object.keys||function(e){var r=[];for(var n in e){if(Object.prototype.hasOwnProperty.call(e,n))r.push(n)}return r}}};var r={};function __nccwpck_require__(n){var t=r[n];if(t!==undefined){return t.exports}var o=r[n]={exports:{}};var a=true;try{e[n](o,o.exports,__nccwpck_require__);a=false}finally{if(a)delete r[n]}return o.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var n={};!function(){var e=n;e.decode=e.parse=__nccwpck_require__(815);e.encode=e.stringify=__nccwpck_require__(577)}();module.exports=n})();","var native = require('./native')\n\nfunction getTypeName (fn) {\n  return fn.name || fn.toString().match(/function (.*?)\\s*\\(/)[1]\n}\n\nfunction getValueTypeName (value) {\n  return native.Nil(value) ? '' : getTypeName(value.constructor)\n}\n\nfunction getValue (value) {\n  if (native.Function(value)) return ''\n  if (native.String(value)) return JSON.stringify(value)\n  if (value && native.Object(value)) return ''\n  return value\n}\n\nfunction captureStackTrace (e, t) {\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(e, t)\n  }\n}\n\nfunction tfJSON (type) {\n  if (native.Function(type)) return type.toJSON ? type.toJSON() : getTypeName(type)\n  if (native.Array(type)) return 'Array'\n  if (type && native.Object(type)) return 'Object'\n\n  return type !== undefined ? type : ''\n}\n\nfunction tfErrorString (type, value, valueTypeName) {\n  var valueJson = getValue(value)\n\n  return 'Expected ' + tfJSON(type) + ', got' +\n    (valueTypeName !== '' ? ' ' + valueTypeName : '') +\n    (valueJson !== '' ? ' ' + valueJson : '')\n}\n\nfunction TfTypeError (type, value, valueTypeName) {\n  valueTypeName = valueTypeName || getValueTypeName(value)\n  this.message = tfErrorString(type, value, valueTypeName)\n\n  captureStackTrace(this, TfTypeError)\n  this.__type = type\n  this.__value = value\n  this.__valueTypeName = valueTypeName\n}\n\nTfTypeError.prototype = Object.create(Error.prototype)\nTfTypeError.prototype.constructor = TfTypeError\n\nfunction tfPropertyErrorString (type, label, name, value, valueTypeName) {\n  var description = '\" of type '\n  if (label === 'key') description = '\" with key type '\n\n  return tfErrorString('property \"' + tfJSON(name) + description + tfJSON(type), value, valueTypeName)\n}\n\nfunction TfPropertyTypeError (type, property, label, value, valueTypeName) {\n  if (type) {\n    valueTypeName = valueTypeName || getValueTypeName(value)\n    this.message = tfPropertyErrorString(type, label, property, value, valueTypeName)\n  } else {\n    this.message = 'Unexpected property \"' + property + '\"'\n  }\n\n  captureStackTrace(this, TfTypeError)\n  this.__label = label\n  this.__property = property\n  this.__type = type\n  this.__value = value\n  this.__valueTypeName = valueTypeName\n}\n\nTfPropertyTypeError.prototype = Object.create(Error.prototype)\nTfPropertyTypeError.prototype.constructor = TfTypeError\n\nfunction tfCustomError (expected, actual) {\n  return new TfTypeError(expected, {}, actual)\n}\n\nfunction tfSubError (e, property, label) {\n  // sub child?\n  if (e instanceof TfPropertyTypeError) {\n    property = property + '.' + e.__property\n\n    e = new TfPropertyTypeError(\n      e.__type, property, e.__label, e.__value, e.__valueTypeName\n    )\n\n  // child?\n  } else if (e instanceof TfTypeError) {\n    e = new TfPropertyTypeError(\n      e.__type, property, label, e.__value, e.__valueTypeName\n    )\n  }\n\n  captureStackTrace(e)\n  return e\n}\n\nmodule.exports = {\n  TfTypeError: TfTypeError,\n  TfPropertyTypeError: TfPropertyTypeError,\n  tfCustomError: tfCustomError,\n  tfSubError: tfSubError,\n  tfJSON: tfJSON,\n  getValueTypeName: getValueTypeName\n}\n","var NATIVE = require('./native')\nvar ERRORS = require('./errors')\n\nfunction _Buffer (value) {\n  return Buffer.isBuffer(value)\n}\n\nfunction Hex (value) {\n  return typeof value === 'string' && /^([0-9a-f]{2})+$/i.test(value)\n}\n\nfunction _LengthN (type, length) {\n  var name = type.toJSON()\n\n  function Length (value) {\n    if (!type(value)) return false\n    if (value.length === length) return true\n\n    throw ERRORS.tfCustomError(name + '(Length: ' + length + ')', name + '(Length: ' + value.length + ')')\n  }\n  Length.toJSON = function () { return name }\n\n  return Length\n}\n\nvar _ArrayN = _LengthN.bind(null, NATIVE.Array)\nvar _BufferN = _LengthN.bind(null, _Buffer)\nvar _HexN = _LengthN.bind(null, Hex)\nvar _StringN = _LengthN.bind(null, NATIVE.String)\n\nfunction Range (a, b, f) {\n  f = f || NATIVE.Number\n  function _range (value, strict) {\n    return f(value, strict) && (value > a) && (value < b)\n  }\n  _range.toJSON = function () {\n    return `${f.toJSON()} between [${a}, ${b}]`\n  }\n  return _range\n}\n\nvar INT53_MAX = Math.pow(2, 53) - 1\n\nfunction Finite (value) {\n  return typeof value === 'number' && isFinite(value)\n}\nfunction Int8 (value) { return ((value << 24) >> 24) === value }\nfunction Int16 (value) { return ((value << 16) >> 16) === value }\nfunction Int32 (value) { return (value | 0) === value }\nfunction Int53 (value) {\n  return typeof value === 'number' &&\n    value >= -INT53_MAX &&\n    value <= INT53_MAX &&\n    Math.floor(value) === value\n}\nfunction UInt8 (value) { return (value & 0xff) === value }\nfunction UInt16 (value) { return (value & 0xffff) === value }\nfunction UInt32 (value) { return (value >>> 0) === value }\nfunction UInt53 (value) {\n  return typeof value === 'number' &&\n    value >= 0 &&\n    value <= INT53_MAX &&\n    Math.floor(value) === value\n}\n\nvar types = {\n  ArrayN: _ArrayN,\n  Buffer: _Buffer,\n  BufferN: _BufferN,\n  Finite: Finite,\n  Hex: Hex,\n  HexN: _HexN,\n  Int8: Int8,\n  Int16: Int16,\n  Int32: Int32,\n  Int53: Int53,\n  Range: Range,\n  StringN: _StringN,\n  UInt8: UInt8,\n  UInt16: UInt16,\n  UInt32: UInt32,\n  UInt53: UInt53\n}\n\nfor (var typeName in types) {\n  types[typeName].toJSON = function (t) {\n    return t\n  }.bind(null, typeName)\n}\n\nmodule.exports = types\n","var ERRORS = require('./errors')\nvar NATIVE = require('./native')\n\n// short-hand\nvar tfJSON = ERRORS.tfJSON\nvar TfTypeError = ERRORS.TfTypeError\nvar TfPropertyTypeError = ERRORS.TfPropertyTypeError\nvar tfSubError = ERRORS.tfSubError\nvar getValueTypeName = ERRORS.getValueTypeName\n\nvar TYPES = {\n  arrayOf: function arrayOf (type, options) {\n    type = compile(type)\n    options = options || {}\n\n    function _arrayOf (array, strict) {\n      if (!NATIVE.Array(array)) return false\n      if (NATIVE.Nil(array)) return false\n      if (options.minLength !== undefined && array.length < options.minLength) return false\n      if (options.maxLength !== undefined && array.length > options.maxLength) return false\n      if (options.length !== undefined && array.length !== options.length) return false\n\n      return array.every(function (value, i) {\n        try {\n          return typeforce(type, value, strict)\n        } catch (e) {\n          throw tfSubError(e, i)\n        }\n      })\n    }\n    _arrayOf.toJSON = function () {\n      var str = '[' + tfJSON(type) + ']'\n      if (options.length !== undefined) {\n        str += '{' + options.length + '}'\n      } else if (options.minLength !== undefined || options.maxLength !== undefined) {\n        str += '{' +\n          (options.minLength === undefined ? 0 : options.minLength) + ',' +\n          (options.maxLength === undefined ? Infinity : options.maxLength) + '}'\n      }\n      return str\n    }\n\n    return _arrayOf\n  },\n\n  maybe: function maybe (type) {\n    type = compile(type)\n\n    function _maybe (value, strict) {\n      return NATIVE.Nil(value) || type(value, strict, maybe)\n    }\n    _maybe.toJSON = function () { return '?' + tfJSON(type) }\n\n    return _maybe\n  },\n\n  map: function map (propertyType, propertyKeyType) {\n    propertyType = compile(propertyType)\n    if (propertyKeyType) propertyKeyType = compile(propertyKeyType)\n\n    function _map (value, strict) {\n      if (!NATIVE.Object(value)) return false\n      if (NATIVE.Nil(value)) return false\n\n      for (var propertyName in value) {\n        try {\n          if (propertyKeyType) {\n            typeforce(propertyKeyType, propertyName, strict)\n          }\n        } catch (e) {\n          throw tfSubError(e, propertyName, 'key')\n        }\n\n        try {\n          var propertyValue = value[propertyName]\n          typeforce(propertyType, propertyValue, strict)\n        } catch (e) {\n          throw tfSubError(e, propertyName)\n        }\n      }\n\n      return true\n    }\n\n    if (propertyKeyType) {\n      _map.toJSON = function () {\n        return '{' + tfJSON(propertyKeyType) + ': ' + tfJSON(propertyType) + '}'\n      }\n    } else {\n      _map.toJSON = function () { return '{' + tfJSON(propertyType) + '}' }\n    }\n\n    return _map\n  },\n\n  object: function object (uncompiled) {\n    var type = {}\n\n    for (var typePropertyName in uncompiled) {\n      type[typePropertyName] = compile(uncompiled[typePropertyName])\n    }\n\n    function _object (value, strict) {\n      if (!NATIVE.Object(value)) return false\n      if (NATIVE.Nil(value)) return false\n\n      var propertyName\n\n      try {\n        for (propertyName in type) {\n          var propertyType = type[propertyName]\n          var propertyValue = value[propertyName]\n\n          typeforce(propertyType, propertyValue, strict)\n        }\n      } catch (e) {\n        throw tfSubError(e, propertyName)\n      }\n\n      if (strict) {\n        for (propertyName in value) {\n          if (type[propertyName]) continue\n\n          throw new TfPropertyTypeError(undefined, propertyName)\n        }\n      }\n\n      return true\n    }\n    _object.toJSON = function () { return tfJSON(type) }\n\n    return _object\n  },\n\n  anyOf: function anyOf () {\n    var types = [].slice.call(arguments).map(compile)\n\n    function _anyOf (value, strict) {\n      return types.some(function (type) {\n        try {\n          return typeforce(type, value, strict)\n        } catch (e) {\n          return false\n        }\n      })\n    }\n    _anyOf.toJSON = function () { return types.map(tfJSON).join('|') }\n\n    return _anyOf\n  },\n\n  allOf: function allOf () {\n    var types = [].slice.call(arguments).map(compile)\n\n    function _allOf (value, strict) {\n      return types.every(function (type) {\n        try {\n          return typeforce(type, value, strict)\n        } catch (e) {\n          return false\n        }\n      })\n    }\n    _allOf.toJSON = function () { return types.map(tfJSON).join(' & ') }\n\n    return _allOf\n  },\n\n  quacksLike: function quacksLike (type) {\n    function _quacksLike (value) {\n      return type === getValueTypeName(value)\n    }\n    _quacksLike.toJSON = function () { return type }\n\n    return _quacksLike\n  },\n\n  tuple: function tuple () {\n    var types = [].slice.call(arguments).map(compile)\n\n    function _tuple (values, strict) {\n      if (NATIVE.Nil(values)) return false\n      if (NATIVE.Nil(values.length)) return false\n      if (strict && (values.length !== types.length)) return false\n\n      return types.every(function (type, i) {\n        try {\n          return typeforce(type, values[i], strict)\n        } catch (e) {\n          throw tfSubError(e, i)\n        }\n      })\n    }\n    _tuple.toJSON = function () { return '(' + types.map(tfJSON).join(', ') + ')' }\n\n    return _tuple\n  },\n\n  value: function value (expected) {\n    function _value (actual) {\n      return actual === expected\n    }\n    _value.toJSON = function () { return expected }\n\n    return _value\n  }\n}\n\n// TODO: deprecate\nTYPES.oneOf = TYPES.anyOf\n\nfunction compile (type) {\n  if (NATIVE.String(type)) {\n    if (type[0] === '?') return TYPES.maybe(type.slice(1))\n\n    return NATIVE[type] || TYPES.quacksLike(type)\n  } else if (type && NATIVE.Object(type)) {\n    if (NATIVE.Array(type)) {\n      if (type.length !== 1) throw new TypeError('Expected compile() parameter of type Array of length 1')\n      return TYPES.arrayOf(type[0])\n    }\n\n    return TYPES.object(type)\n  } else if (NATIVE.Function(type)) {\n    return type\n  }\n\n  return TYPES.value(type)\n}\n\nfunction typeforce (type, value, strict, surrogate) {\n  if (NATIVE.Function(type)) {\n    if (type(value, strict)) return true\n\n    throw new TfTypeError(surrogate || type, value)\n  }\n\n  // JIT\n  return typeforce(compile(type), value, strict)\n}\n\n// assign types to typeforce function\nfor (var typeName in NATIVE) {\n  typeforce[typeName] = NATIVE[typeName]\n}\n\nfor (typeName in TYPES) {\n  typeforce[typeName] = TYPES[typeName]\n}\n\nvar EXTRA = require('./extra')\nfor (typeName in EXTRA) {\n  typeforce[typeName] = EXTRA[typeName]\n}\n\ntypeforce.compile = compile\ntypeforce.TfTypeError = TfTypeError\ntypeforce.TfPropertyTypeError = TfPropertyTypeError\n\nmodule.exports = typeforce\n","var types = {\n  Array: function (value) { return value !== null && value !== undefined && value.constructor === Array },\n  Boolean: function (value) { return typeof value === 'boolean' },\n  Function: function (value) { return typeof value === 'function' },\n  Nil: function (value) { return value === undefined || value === null },\n  Number: function (value) { return typeof value === 'number' },\n  Object: function (value) { return typeof value === 'object' },\n  String: function (value) { return typeof value === 'string' },\n  '': function () { return true }\n}\n\n// TODO: deprecate\ntypes.Null = types.Nil\n\nfor (var typeName in types) {\n  types[typeName].toJSON = function (t) {\n    return t\n  }.bind(null, typeName)\n}\n\nmodule.exports = types\n","'use strict'\nvar Buffer = require('safe-buffer').Buffer\n\n// Number.MAX_SAFE_INTEGER\nvar MAX_SAFE_INTEGER = 9007199254740991\n\nfunction checkUInt53 (n) {\n  if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0) throw new RangeError('value out of range')\n}\n\nfunction encode (number, buffer, offset) {\n  checkUInt53(number)\n\n  if (!buffer) buffer = Buffer.allocUnsafe(encodingLength(number))\n  if (!Buffer.isBuffer(buffer)) throw new TypeError('buffer must be a Buffer instance')\n  if (!offset) offset = 0\n\n  // 8 bit\n  if (number < 0xfd) {\n    buffer.writeUInt8(number, offset)\n    encode.bytes = 1\n\n  // 16 bit\n  } else if (number <= 0xffff) {\n    buffer.writeUInt8(0xfd, offset)\n    buffer.writeUInt16LE(number, offset + 1)\n    encode.bytes = 3\n\n  // 32 bit\n  } else if (number <= 0xffffffff) {\n    buffer.writeUInt8(0xfe, offset)\n    buffer.writeUInt32LE(number, offset + 1)\n    encode.bytes = 5\n\n  // 64 bit\n  } else {\n    buffer.writeUInt8(0xff, offset)\n    buffer.writeUInt32LE(number >>> 0, offset + 1)\n    buffer.writeUInt32LE((number / 0x100000000) | 0, offset + 5)\n    encode.bytes = 9\n  }\n\n  return buffer\n}\n\nfunction decode (buffer, offset) {\n  if (!Buffer.isBuffer(buffer)) throw new TypeError('buffer must be a Buffer instance')\n  if (!offset) offset = 0\n\n  var first = buffer.readUInt8(offset)\n\n  // 8 bit\n  if (first < 0xfd) {\n    decode.bytes = 1\n    return first\n\n  // 16 bit\n  } else if (first === 0xfd) {\n    decode.bytes = 3\n    return buffer.readUInt16LE(offset + 1)\n\n  // 32 bit\n  } else if (first === 0xfe) {\n    decode.bytes = 5\n    return buffer.readUInt32LE(offset + 1)\n\n  // 64 bit\n  } else {\n    decode.bytes = 9\n    var lo = buffer.readUInt32LE(offset + 1)\n    var hi = buffer.readUInt32LE(offset + 5)\n    var number = hi * 0x0100000000 + lo\n    checkUInt53(number)\n\n    return number\n  }\n}\n\nfunction encodingLength (number) {\n  checkUInt53(number)\n\n  return (\n    number < 0xfd ? 1\n      : number <= 0xffff ? 3\n        : number <= 0xffffffff ? 5\n          : 9\n  )\n}\n\nmodule.exports = { encode: encode, decode: decode, encodingLength: encodingLength }\n","var bs58check = require('bs58check')\n\nfunction decodeRaw (buffer, version) {\n  // check version only if defined\n  if (version !== undefined && buffer[0] !== version) throw new Error('Invalid network version')\n\n  // uncompressed\n  if (buffer.length === 33) {\n    return {\n      version: buffer[0],\n      privateKey: buffer.slice(1, 33),\n      compressed: false\n    }\n  }\n\n  // invalid length\n  if (buffer.length !== 34) throw new Error('Invalid WIF length')\n\n  // invalid compression flag\n  if (buffer[33] !== 0x01) throw new Error('Invalid compression flag')\n\n  return {\n    version: buffer[0],\n    privateKey: buffer.slice(1, 33),\n    compressed: true\n  }\n}\n\nfunction encodeRaw (version, privateKey, compressed) {\n  var result = new Buffer(compressed ? 34 : 33)\n\n  result.writeUInt8(version, 0)\n  privateKey.copy(result, 1)\n\n  if (compressed) {\n    result[33] = 0x01\n  }\n\n  return result\n}\n\nfunction decode (string, version) {\n  return decodeRaw(bs58check.decode(string), version)\n}\n\nfunction encode (version, privateKey, compressed) {\n  if (typeof version === 'number') return bs58check.encode(encodeRaw(version, privateKey, compressed))\n\n  return bs58check.encode(\n    encodeRaw(\n      version.version,\n      version.privateKey,\n      version.compressed\n    )\n  )\n}\n\nmodule.exports = {\n  decode: decode,\n  decodeRaw: decodeRaw,\n  encode: encode,\n  encodeRaw: encodeRaw\n}\n","import { compare } from \"uint8array-tools\";\nimport * as validate from \"./validate.js\";\nimport wasm from \"./wasm_loader.js\";\nconst WASM_BUFFER = new Uint8Array(wasm.memory.buffer);\nconst WASM_PRIVATE_KEY_PTR = wasm.PRIVATE_INPUT.value;\nconst WASM_PUBLIC_KEY_INPUT_PTR = wasm.PUBLIC_KEY_INPUT.value;\nconst WASM_PUBLIC_KEY_INPUT_PTR2 = wasm.PUBLIC_KEY_INPUT2.value;\nconst WASM_X_ONLY_PUBLIC_KEY_INPUT_PTR = wasm.X_ONLY_PUBLIC_KEY_INPUT.value;\nconst WASM_X_ONLY_PUBLIC_KEY_INPUT2_PTR = wasm.X_ONLY_PUBLIC_KEY_INPUT2.value;\nconst WASM_TWEAK_INPUT_PTR = wasm.TWEAK_INPUT.value;\nconst WASM_HASH_INPUT_PTR = wasm.HASH_INPUT.value;\nconst WASM_EXTRA_DATA_INPUT_PTR = wasm.EXTRA_DATA_INPUT.value;\nconst WASM_SIGNATURE_INPUT_PTR = wasm.SIGNATURE_INPUT.value;\nconst PRIVATE_KEY_INPUT = WASM_BUFFER.subarray(WASM_PRIVATE_KEY_PTR, WASM_PRIVATE_KEY_PTR + validate.PRIVATE_KEY_SIZE);\nconst PUBLIC_KEY_INPUT = WASM_BUFFER.subarray(WASM_PUBLIC_KEY_INPUT_PTR, WASM_PUBLIC_KEY_INPUT_PTR + validate.PUBLIC_KEY_UNCOMPRESSED_SIZE);\nconst PUBLIC_KEY_INPUT2 = WASM_BUFFER.subarray(WASM_PUBLIC_KEY_INPUT_PTR2, WASM_PUBLIC_KEY_INPUT_PTR2 + validate.PUBLIC_KEY_UNCOMPRESSED_SIZE);\nconst X_ONLY_PUBLIC_KEY_INPUT = WASM_BUFFER.subarray(WASM_X_ONLY_PUBLIC_KEY_INPUT_PTR, WASM_X_ONLY_PUBLIC_KEY_INPUT_PTR + validate.X_ONLY_PUBLIC_KEY_SIZE);\nconst X_ONLY_PUBLIC_KEY_INPUT2 = WASM_BUFFER.subarray(WASM_X_ONLY_PUBLIC_KEY_INPUT2_PTR, WASM_X_ONLY_PUBLIC_KEY_INPUT2_PTR + validate.X_ONLY_PUBLIC_KEY_SIZE);\nconst TWEAK_INPUT = WASM_BUFFER.subarray(WASM_TWEAK_INPUT_PTR, WASM_TWEAK_INPUT_PTR + validate.TWEAK_SIZE);\nconst HASH_INPUT = WASM_BUFFER.subarray(WASM_HASH_INPUT_PTR, WASM_HASH_INPUT_PTR + validate.HASH_SIZE);\nconst EXTRA_DATA_INPUT = WASM_BUFFER.subarray(WASM_EXTRA_DATA_INPUT_PTR, WASM_EXTRA_DATA_INPUT_PTR + validate.EXTRA_DATA_SIZE);\nconst SIGNATURE_INPUT = WASM_BUFFER.subarray(WASM_SIGNATURE_INPUT_PTR, WASM_SIGNATURE_INPUT_PTR + validate.SIGNATURE_SIZE);\nfunction assumeCompression(compressed, p) {\n    if (compressed === undefined) {\n        return p !== undefined ? p.length : validate.PUBLIC_KEY_COMPRESSED_SIZE;\n    }\n    return compressed\n        ? validate.PUBLIC_KEY_COMPRESSED_SIZE\n        : validate.PUBLIC_KEY_UNCOMPRESSED_SIZE;\n}\nfunction _isPoint(p) {\n    try {\n        PUBLIC_KEY_INPUT.set(p);\n        return wasm.isPoint(p.length) === 1;\n    }\n    finally {\n        PUBLIC_KEY_INPUT.fill(0);\n    }\n}\nexport function __initializeContext() {\n    wasm.initializeContext();\n}\nexport function isPoint(p) {\n    return validate.isDERPoint(p) && _isPoint(p);\n}\nexport function isPointCompressed(p) {\n    return validate.isPointCompressed(p) && _isPoint(p);\n}\nexport function isXOnlyPoint(p) {\n    return validate.isXOnlyPoint(p) && _isPoint(p);\n}\nexport function isPrivate(d) {\n    return validate.isPrivate(d);\n}\nexport function pointAdd(pA, pB, compressed) {\n    validate.validatePoint(pA);\n    validate.validatePoint(pB);\n    const outputlen = assumeCompression(compressed, pA);\n    try {\n        PUBLIC_KEY_INPUT.set(pA);\n        PUBLIC_KEY_INPUT2.set(pB);\n        return wasm.pointAdd(pA.length, pB.length, outputlen) === 1\n            ? PUBLIC_KEY_INPUT.slice(0, outputlen)\n            : null;\n    }\n    finally {\n        PUBLIC_KEY_INPUT.fill(0);\n        PUBLIC_KEY_INPUT2.fill(0);\n    }\n}\nexport function pointAddScalar(p, tweak, compressed) {\n    validate.validatePoint(p);\n    validate.validateTweak(tweak);\n    const outputlen = assumeCompression(compressed, p);\n    try {\n        PUBLIC_KEY_INPUT.set(p);\n        TWEAK_INPUT.set(tweak);\n        return wasm.pointAddScalar(p.length, outputlen) === 1\n            ? PUBLIC_KEY_INPUT.slice(0, outputlen)\n            : null;\n    }\n    finally {\n        PUBLIC_KEY_INPUT.fill(0);\n        TWEAK_INPUT.fill(0);\n    }\n}\nexport function pointCompress(p, compressed) {\n    validate.validatePoint(p);\n    const outputlen = assumeCompression(compressed, p);\n    try {\n        PUBLIC_KEY_INPUT.set(p);\n        wasm.pointCompress(p.length, outputlen);\n        return PUBLIC_KEY_INPUT.slice(0, outputlen);\n    }\n    finally {\n        PUBLIC_KEY_INPUT.fill(0);\n    }\n}\nexport function pointFromScalar(d, compressed) {\n    validate.validatePrivate(d);\n    const outputlen = assumeCompression(compressed);\n    try {\n        PRIVATE_KEY_INPUT.set(d);\n        return wasm.pointFromScalar(outputlen) === 1\n            ? PUBLIC_KEY_INPUT.slice(0, outputlen)\n            : null;\n    }\n    finally {\n        PRIVATE_KEY_INPUT.fill(0);\n        PUBLIC_KEY_INPUT.fill(0);\n    }\n}\nexport function xOnlyPointFromScalar(d) {\n    validate.validatePrivate(d);\n    try {\n        PRIVATE_KEY_INPUT.set(d);\n        wasm.xOnlyPointFromScalar();\n        return X_ONLY_PUBLIC_KEY_INPUT.slice(0, validate.X_ONLY_PUBLIC_KEY_SIZE);\n    }\n    finally {\n        PRIVATE_KEY_INPUT.fill(0);\n        X_ONLY_PUBLIC_KEY_INPUT.fill(0);\n    }\n}\nexport function xOnlyPointFromPoint(p) {\n    validate.validatePoint(p);\n    try {\n        PUBLIC_KEY_INPUT.set(p);\n        wasm.xOnlyPointFromPoint(p.length);\n        return X_ONLY_PUBLIC_KEY_INPUT.slice(0, validate.X_ONLY_PUBLIC_KEY_SIZE);\n    }\n    finally {\n        PUBLIC_KEY_INPUT.fill(0);\n        X_ONLY_PUBLIC_KEY_INPUT.fill(0);\n    }\n}\nexport function pointMultiply(p, tweak, compressed) {\n    validate.validatePoint(p);\n    validate.validateTweak(tweak);\n    const outputlen = assumeCompression(compressed, p);\n    try {\n        PUBLIC_KEY_INPUT.set(p);\n        TWEAK_INPUT.set(tweak);\n        return wasm.pointMultiply(p.length, outputlen) === 1\n            ? PUBLIC_KEY_INPUT.slice(0, outputlen)\n            : null;\n    }\n    finally {\n        PUBLIC_KEY_INPUT.fill(0);\n        TWEAK_INPUT.fill(0);\n    }\n}\nexport function privateAdd(d, tweak) {\n    validate.validatePrivate(d);\n    validate.validateTweak(tweak);\n    try {\n        PRIVATE_KEY_INPUT.set(d);\n        TWEAK_INPUT.set(tweak);\n        return wasm.privateAdd() === 1\n            ? PRIVATE_KEY_INPUT.slice(0, validate.PRIVATE_KEY_SIZE)\n            : null;\n    }\n    finally {\n        PRIVATE_KEY_INPUT.fill(0);\n        TWEAK_INPUT.fill(0);\n    }\n}\nexport function privateSub(d, tweak) {\n    validate.validatePrivate(d);\n    validate.validateTweak(tweak);\n    // We can not pass zero tweak to WASM, because WASM use `secp256k1_ec_seckey_negate` for tweak negate.\n    // (zero is not valid seckey)\n    if (validate.isZero(tweak)) {\n        return new Uint8Array(d);\n    }\n    try {\n        PRIVATE_KEY_INPUT.set(d);\n        TWEAK_INPUT.set(tweak);\n        return wasm.privateSub() === 1\n            ? PRIVATE_KEY_INPUT.slice(0, validate.PRIVATE_KEY_SIZE)\n            : null;\n    }\n    finally {\n        PRIVATE_KEY_INPUT.fill(0);\n        TWEAK_INPUT.fill(0);\n    }\n}\nexport function privateNegate(d) {\n    validate.validatePrivate(d);\n    try {\n        PRIVATE_KEY_INPUT.set(d);\n        wasm.privateNegate();\n        return PRIVATE_KEY_INPUT.slice(0, validate.PRIVATE_KEY_SIZE);\n    }\n    finally {\n        PRIVATE_KEY_INPUT.fill(0);\n    }\n}\nexport function xOnlyPointAddTweak(p, tweak) {\n    validate.validateXOnlyPoint(p);\n    validate.validateTweak(tweak);\n    try {\n        X_ONLY_PUBLIC_KEY_INPUT.set(p);\n        TWEAK_INPUT.set(tweak);\n        const parity = wasm.xOnlyPointAddTweak();\n        return parity !== -1\n            ? {\n                parity,\n                xOnlyPubkey: X_ONLY_PUBLIC_KEY_INPUT.slice(0, validate.X_ONLY_PUBLIC_KEY_SIZE),\n            }\n            : null;\n    }\n    finally {\n        X_ONLY_PUBLIC_KEY_INPUT.fill(0);\n        TWEAK_INPUT.fill(0);\n    }\n}\nexport function xOnlyPointAddTweakCheck(point, tweak, resultToCheck, tweakParity) {\n    validate.validateXOnlyPoint(point);\n    validate.validateXOnlyPoint(resultToCheck);\n    validate.validateTweak(tweak);\n    const hasParity = tweakParity !== undefined;\n    if (hasParity)\n        validate.validateParity(tweakParity);\n    try {\n        X_ONLY_PUBLIC_KEY_INPUT.set(point);\n        X_ONLY_PUBLIC_KEY_INPUT2.set(resultToCheck);\n        TWEAK_INPUT.set(tweak);\n        if (hasParity) {\n            return wasm.xOnlyPointAddTweakCheck(tweakParity) === 1;\n        }\n        else {\n            wasm.xOnlyPointAddTweak();\n            const newKey = X_ONLY_PUBLIC_KEY_INPUT.slice(0, validate.X_ONLY_PUBLIC_KEY_SIZE);\n            return compare(newKey, resultToCheck) === 0;\n        }\n    }\n    finally {\n        X_ONLY_PUBLIC_KEY_INPUT.fill(0);\n        X_ONLY_PUBLIC_KEY_INPUT2.fill(0);\n        TWEAK_INPUT.fill(0);\n    }\n}\nexport function sign(h, d, e) {\n    validate.validateHash(h);\n    validate.validatePrivate(d);\n    validate.validateExtraData(e);\n    try {\n        HASH_INPUT.set(h);\n        PRIVATE_KEY_INPUT.set(d);\n        if (e !== undefined)\n            EXTRA_DATA_INPUT.set(e);\n        wasm.sign(e === undefined ? 0 : 1);\n        return SIGNATURE_INPUT.slice(0, validate.SIGNATURE_SIZE);\n    }\n    finally {\n        HASH_INPUT.fill(0);\n        PRIVATE_KEY_INPUT.fill(0);\n        if (e !== undefined)\n            EXTRA_DATA_INPUT.fill(0);\n        SIGNATURE_INPUT.fill(0);\n    }\n}\nexport function signRecoverable(h, d, e) {\n    validate.validateHash(h);\n    validate.validatePrivate(d);\n    validate.validateExtraData(e);\n    try {\n        HASH_INPUT.set(h);\n        PRIVATE_KEY_INPUT.set(d);\n        if (e !== undefined)\n            EXTRA_DATA_INPUT.set(e);\n        const recoveryId = wasm.signRecoverable(e === undefined ? 0 : 1);\n        const signature = SIGNATURE_INPUT.slice(0, validate.SIGNATURE_SIZE);\n        return {\n            signature,\n            recoveryId,\n        };\n    }\n    finally {\n        HASH_INPUT.fill(0);\n        PRIVATE_KEY_INPUT.fill(0);\n        if (e !== undefined)\n            EXTRA_DATA_INPUT.fill(0);\n        SIGNATURE_INPUT.fill(0);\n    }\n}\nexport function signSchnorr(h, d, e) {\n    validate.validateHash(h);\n    validate.validatePrivate(d);\n    validate.validateExtraData(e);\n    try {\n        HASH_INPUT.set(h);\n        PRIVATE_KEY_INPUT.set(d);\n        if (e !== undefined)\n            EXTRA_DATA_INPUT.set(e);\n        wasm.signSchnorr(e === undefined ? 0 : 1);\n        return SIGNATURE_INPUT.slice(0, validate.SIGNATURE_SIZE);\n    }\n    finally {\n        HASH_INPUT.fill(0);\n        PRIVATE_KEY_INPUT.fill(0);\n        if (e !== undefined)\n            EXTRA_DATA_INPUT.fill(0);\n        SIGNATURE_INPUT.fill(0);\n    }\n}\nexport function verify(h, Q, signature, strict = false) {\n    validate.validateHash(h);\n    validate.validatePoint(Q);\n    validate.validateSignature(signature);\n    try {\n        HASH_INPUT.set(h);\n        PUBLIC_KEY_INPUT.set(Q);\n        SIGNATURE_INPUT.set(signature);\n        return wasm.verify(Q.length, strict === true ? 1 : 0) === 1 ? true : false;\n    }\n    finally {\n        HASH_INPUT.fill(0);\n        PUBLIC_KEY_INPUT.fill(0);\n        SIGNATURE_INPUT.fill(0);\n    }\n}\nexport function recover(h, signature, recoveryId, compressed = false) {\n    validate.validateHash(h);\n    validate.validateSignature(signature);\n    validate.validateSignatureNonzeroRS(signature);\n    if (recoveryId & 2) {\n        validate.validateSigrPMinusN(signature);\n    }\n    validate.validateSignatureCustom(() => isXOnlyPoint(signature.subarray(0, 32)));\n    const outputlen = assumeCompression(compressed);\n    try {\n        HASH_INPUT.set(h);\n        SIGNATURE_INPUT.set(signature);\n        return wasm.recover(outputlen, recoveryId) === 1\n            ? PUBLIC_KEY_INPUT.slice(0, outputlen)\n            : null;\n    }\n    finally {\n        HASH_INPUT.fill(0);\n        SIGNATURE_INPUT.fill(0);\n        PUBLIC_KEY_INPUT.fill(0);\n    }\n}\nexport function verifySchnorr(h, Q, signature) {\n    validate.validateHash(h);\n    validate.validateXOnlyPoint(Q);\n    validate.validateSignature(signature);\n    try {\n        HASH_INPUT.set(h);\n        X_ONLY_PUBLIC_KEY_INPUT.set(Q);\n        SIGNATURE_INPUT.set(signature);\n        return wasm.verifySchnorr() === 1 ? true : false;\n    }\n    finally {\n        HASH_INPUT.fill(0);\n        X_ONLY_PUBLIC_KEY_INPUT.fill(0);\n        SIGNATURE_INPUT.fill(0);\n    }\n}\n","function get4RandomBytes() {\n    const bytes = new Uint8Array(4);\n    if (typeof crypto === \"undefined\") {\n        throw new Error(\"The crypto object is unavailable. This may occur if your environment does not support the Web Cryptography API.\");\n    }\n    crypto.getRandomValues(bytes);\n    return bytes;\n}\n// Only to be used to initialize the context for rust-secp256k1\nexport function generateInt32() {\n    const array = get4RandomBytes();\n    return ((array[0] << (3 * 8)) +\n        (array[1] << (2 * 8)) +\n        (array[2] << (1 * 8)) +\n        array[3]);\n}\n","import { ERROR_BAD_PRIVATE, ERROR_BAD_POINT, ERROR_BAD_TWEAK, throwError, ERROR_BAD_HASH, ERROR_BAD_EXTRA_DATA, ERROR_BAD_SIGNATURE, ERROR_BAD_PARITY, ERROR_BAD_RECOVERY_ID, } from \"./validate_error.js\";\nexport const PRIVATE_KEY_SIZE = 32;\nexport const PUBLIC_KEY_COMPRESSED_SIZE = 33;\nexport const PUBLIC_KEY_UNCOMPRESSED_SIZE = 65;\nexport const X_ONLY_PUBLIC_KEY_SIZE = 32;\nexport const TWEAK_SIZE = 32;\nexport const HASH_SIZE = 32;\nexport const EXTRA_DATA_SIZE = 32;\nexport const SIGNATURE_SIZE = 64;\nconst BN32_ZERO = new Uint8Array(32);\nconst BN32_N = new Uint8Array([\n    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n    254, 186, 174, 220, 230, 175, 72, 160, 59, 191, 210, 94, 140, 208, 54, 65, 65,\n]);\n// Difference between field and order\nconst BN32_P_MINUS_N = new Uint8Array([\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 69, 81, 35, 25, 80, 183, 95,\n    196, 64, 45, 161, 114, 47, 201, 186, 238,\n]);\nfunction isUint8Array(value) {\n    return value instanceof Uint8Array;\n}\nfunction cmpBN32(data1, data2) {\n    for (let i = 0; i < 32; ++i) {\n        if (data1[i] !== data2[i]) {\n            return data1[i] < data2[i] ? -1 : 1;\n        }\n    }\n    return 0;\n}\nexport function isZero(x) {\n    return cmpBN32(x, BN32_ZERO) === 0;\n}\nexport function isPrivate(x) {\n    return (isUint8Array(x) &&\n        x.length === PRIVATE_KEY_SIZE &&\n        cmpBN32(x, BN32_ZERO) > 0 &&\n        cmpBN32(x, BN32_N) < 0);\n}\nexport function isPoint(p) {\n    return (isUint8Array(p) &&\n        (p.length === PUBLIC_KEY_COMPRESSED_SIZE ||\n            p.length === PUBLIC_KEY_UNCOMPRESSED_SIZE ||\n            p.length === X_ONLY_PUBLIC_KEY_SIZE));\n}\nexport function isXOnlyPoint(p) {\n    return isUint8Array(p) && p.length === X_ONLY_PUBLIC_KEY_SIZE;\n}\nexport function isDERPoint(p) {\n    return (isUint8Array(p) &&\n        (p.length === PUBLIC_KEY_COMPRESSED_SIZE ||\n            p.length === PUBLIC_KEY_UNCOMPRESSED_SIZE));\n}\nexport function isPointCompressed(p) {\n    return isUint8Array(p) && p.length === PUBLIC_KEY_COMPRESSED_SIZE;\n}\nfunction isTweak(tweak) {\n    return (isUint8Array(tweak) &&\n        tweak.length === TWEAK_SIZE &&\n        cmpBN32(tweak, BN32_N) < 0);\n}\nfunction isHash(h) {\n    return isUint8Array(h) && h.length === HASH_SIZE;\n}\nfunction isExtraData(e) {\n    return e === undefined || (isUint8Array(e) && e.length === EXTRA_DATA_SIZE);\n}\nfunction isSignature(signature) {\n    return (isUint8Array(signature) &&\n        signature.length === 64 &&\n        cmpBN32(signature.subarray(0, 32), BN32_N) < 0 &&\n        cmpBN32(signature.subarray(32, 64), BN32_N) < 0);\n}\nfunction isSigrLessThanPMinusN(signature) {\n    return (isUint8Array(signature) &&\n        signature.length === 64 &&\n        cmpBN32(signature.subarray(0, 32), BN32_P_MINUS_N) < 0);\n}\nexport function validateParity(p) {\n    if (p !== 0 && p !== 1)\n        throwError(ERROR_BAD_PARITY);\n}\nexport function validatePrivate(d) {\n    if (!isPrivate(d))\n        throwError(ERROR_BAD_PRIVATE);\n}\nexport function validatePoint(p) {\n    if (!isPoint(p))\n        throwError(ERROR_BAD_POINT);\n}\nexport function validateXOnlyPoint(p) {\n    if (!isXOnlyPoint(p))\n        throwError(ERROR_BAD_POINT);\n}\nexport function validateTweak(tweak) {\n    if (!isTweak(tweak))\n        throwError(ERROR_BAD_TWEAK);\n}\nexport function validateHash(h) {\n    if (!isHash(h))\n        throwError(ERROR_BAD_HASH);\n}\nexport function validateExtraData(e) {\n    if (!isExtraData(e))\n        throwError(ERROR_BAD_EXTRA_DATA);\n}\nexport function validateSignature(signature) {\n    if (!isSignature(signature))\n        throwError(ERROR_BAD_SIGNATURE);\n}\nexport function validateSignatureCustom(validatorFn) {\n    if (!validatorFn())\n        throwError(ERROR_BAD_SIGNATURE);\n}\nexport function validateSignatureNonzeroRS(signature) {\n    if (isZero(signature.subarray(0, 32)))\n        throwError(ERROR_BAD_SIGNATURE);\n    if (isZero(signature.subarray(32, 64)))\n        throwError(ERROR_BAD_SIGNATURE);\n}\nexport function validateSigrPMinusN(signature) {\n    if (!isSigrLessThanPMinusN(signature))\n        throwError(ERROR_BAD_RECOVERY_ID);\n}\n","export const ERROR_BAD_PRIVATE = 0;\nexport const ERROR_BAD_POINT = 1;\nexport const ERROR_BAD_TWEAK = 2;\nexport const ERROR_BAD_HASH = 3;\nexport const ERROR_BAD_SIGNATURE = 4;\nexport const ERROR_BAD_EXTRA_DATA = 5;\nexport const ERROR_BAD_PARITY = 6;\nexport const ERROR_BAD_RECOVERY_ID = 7;\nconst ERRORS_MESSAGES = {\n    [ERROR_BAD_PRIVATE.toString()]: \"Expected Private\",\n    [ERROR_BAD_POINT.toString()]: \"Expected Point\",\n    [ERROR_BAD_TWEAK.toString()]: \"Expected Tweak\",\n    [ERROR_BAD_HASH.toString()]: \"Expected Hash\",\n    [ERROR_BAD_SIGNATURE.toString()]: \"Expected Signature\",\n    [ERROR_BAD_EXTRA_DATA.toString()]: \"Expected Extra Data (32 bytes)\",\n    [ERROR_BAD_PARITY.toString()]: \"Expected Parity (1 | 0)\",\n    [ERROR_BAD_RECOVERY_ID.toString()]: \"Bad Recovery Id\",\n};\nexport function throwError(errcode) {\n    const message = ERRORS_MESSAGES[errcode.toString()] || `Unknow error code: ${errcode}`;\n    throw new TypeError(message);\n}\n","// Suppress TS2792: Cannot find module './secp256k1.wasm'.\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nimport * as wasm from \"./secp256k1.wasm\";\nexport default wasm;\n","const HEX_STRINGS = \"0123456789abcdefABCDEF\";\nconst HEX_CODES = HEX_STRINGS.split(\"\").map((c) => c.codePointAt(0));\nconst HEX_CODEPOINTS = Array(256)\n    .fill(true)\n    .map((_, i) => {\n    const s = String.fromCodePoint(i);\n    const index = HEX_STRINGS.indexOf(s);\n    // ABCDEF will use 10 - 15\n    return index < 0 ? undefined : index < 16 ? index : index - 6;\n});\nconst ENCODER = new TextEncoder();\nconst DECODER = new TextDecoder(\"ascii\");\n// There are two implementations.\n// One optimizes for length of the bytes, and uses TextDecoder.\n// One optimizes for iteration count, and appends strings.\n// This removes the overhead of TextDecoder.\nexport function toHex(bytes) {\n    const b = bytes || new Uint8Array();\n    return b.length > 512 ? _toHexLengthPerf(b) : _toHexIterPerf(b);\n}\nfunction _toHexIterPerf(bytes) {\n    let s = \"\";\n    for (let i = 0; i < bytes.length; ++i) {\n        s += HEX_STRINGS[HEX_CODEPOINTS[HEX_CODES[bytes[i] >> 4]]];\n        s += HEX_STRINGS[HEX_CODEPOINTS[HEX_CODES[bytes[i] & 15]]];\n    }\n    return s;\n}\nfunction _toHexLengthPerf(bytes) {\n    const hexBytes = new Uint8Array(bytes.length * 2);\n    for (let i = 0; i < bytes.length; ++i) {\n        hexBytes[i * 2] = HEX_CODES[bytes[i] >> 4];\n        hexBytes[i * 2 + 1] = HEX_CODES[bytes[i] & 15];\n    }\n    return DECODER.decode(hexBytes);\n}\n// Mimics Buffer.from(x, 'hex') logic\n// Stops on first non-hex string and returns\n// https://github.com/nodejs/node/blob/v14.18.1/src/string_bytes.cc#L246-L261\nexport function fromHex(hexString) {\n    const hexBytes = ENCODER.encode(hexString || \"\");\n    const resultBytes = new Uint8Array(Math.floor(hexBytes.length / 2));\n    let i;\n    for (i = 0; i < resultBytes.length; i++) {\n        const a = HEX_CODEPOINTS[hexBytes[i * 2]];\n        const b = HEX_CODEPOINTS[hexBytes[i * 2 + 1]];\n        if (a === undefined || b === undefined) {\n            break;\n        }\n        resultBytes[i] = (a << 4) | b;\n    }\n    return i === resultBytes.length ? resultBytes : resultBytes.slice(0, i);\n}\n// Same behavior as Buffer.compare()\nexport function compare(v1, v2) {\n    const minLength = Math.min(v1.length, v2.length);\n    for (let i = 0; i < minLength; ++i) {\n        if (v1[i] !== v2[i]) {\n            return v1[i] < v2[i] ? -1 : 1;\n        }\n    }\n    return v1.length === v2.length ? 0 : v1.length > v2.length ? 1 : -1;\n}\n"],"names":["secp256k1","__webpack_require__","mod","utils","_interopNamespaceDefault","e","n","Object","create","keys","forEach","k","d","getOwnPropertyDescriptor","defineProperty","get","enumerable","default","freeze","mod__namespace","utils__namespace","Point","ProjectivePoint","THROW_BAD_PRIVATE","THROW_BAD_POINT","THROW_BAD_TWEAK","THROW_BAD_SIGNATURE","THROW_BAD_EXTRA_DATA","THROW_BAD_SCALAR","BN32_N","Uint8Array","BN32_ZERO","BN32_P_MINUS_N","_1n","BigInt","cmpBN32","data1","data2","i","isTweak","tweak","length","isSignature","signature","subarray","isHash","h","isExtraData","undefined","normalizeScalar","scalar","num","Number","isSafeInteger","hexToNumber","bytesToNumberBE","normalizePrivateKey","privateKey","normPrivateKeyToScalar","_pointAddScalar","p","isCompressed","P","fromHex","t","Q","BASE","multiplyAndAddUnsafe","toRawBytes","assumeCompression","compressed","isPointCompressed","throwToNull","fn","fromXOnly","bytes","schnorr","lift_x","_isPoint","xOnly","isPoint","isPrivate","isValidPrivateKey","isXOnlyPoint","xOnlyPointFromPoint","slice","pointFromScalar","sk","getPublicKey","exports","pointAdd","a","b","A","B","equals","negate","add","pointAddScalar","pointCompress","pointMultiply","_pointMultiply","bytesToHex","multiply","privateAdd","_privateAdd","numberToBytesBE","CURVE","privateNegate","_privateNegate","not","privateSub","_privateSub","sub","recover","recoveryId","isUint8Array","s","Signature","fromCompact","addRecoveryBit","recoverPublicKey","sign","extraEntropy","toCompactRawBytes","signRecoverable","sig","recovery","signSchnorr","verify","strict","lowS","verifySchnorr","xOnlyPointAddTweak","parity","xOnlyPubkey","xOnlyPointFromScalar","value","getHash","createCurve","curveDef","defHash","weierstrass_js_1","weierstrass","hash","hmac_1","utils_1","hmac","key","msgs","concatBytes","randomBytes","wNAF","c","bits","constTimeNegate","hasPrecomputes","getW","elm","unsafeLadder","ZERO","_0n","double","precomputeWindow","W","windows","windowSize","calcWOpts","points","base","window","push","precomputes","f","mask","maxNumber","shiftBy","offset","wbits","offset2","Math","abs","cond1","cond2","wNAFUnsafe","acc","curr","getPrecomputes","transform","comp","pointPrecomputes","set","wNAFCached","wNAFCachedUnsafe","prev","setWindowSize","validateW","pointWindowSizes","delete","pippenger","fieldN","scalars","validateMSMPoints","validateMSMScalars","zero","utils_js_1","bitLen","MASK","buckets","fill","lastBits","floor","BITS","sum","j","resI","sumI","precomputeMSMUnsafe","tableSize","chunks","ceil","tables","map","res","validateBasic","curve","modular_js_1","validateField","Fp","validateObject","Gx","Gy","nBitLength","nByteLength","nLength","ORDER","condition","item","neg","Array","isArray","field","isValid","WeakMap","expand_message_xmd","expand_message_xof","hash_to_field","isogenyMap","COEFF","from","reverse","x","y","xNum","xDen","yNum","yDen","val","reduce","mul","div","createHasher","mapToCurve","def","hashToCurve","msg","options","u","DST","u0","fromAffine","u1","clearCofactor","assertValidity","encodeToCurve","encodeDST","os2ip","i2osp","anum","lenInBytes","H","abytes","utf8ToBytes","outputLen","b_in_bytes","blockLen","r_in_bytes","ell","DST_prime","Z_pad","l_i_b_str","b_0","args","strxor","arr","pseudo_random_bytes","dkLen","update","digest","count","prb","m","expand","_DST","log2p","toString","L","len_in_bytes","elm_offset","tv","isNegativeLE","pow","pow2","power","modulo","invert","tonelliShanks","FpSqrt","opts","FIELD_FIELDS","BYTES","FpPow","FpInvertBatch","FpDiv","lhs","rhs","inv","FpLegendre","FpIsSquare","legendre","eql","ONE","Field","isLE","redef","sqrtP","bitMask","is0","isOdd","sqr","sqrN","addN","subN","mulN","sqrt","invertBatch","lst","cmov","toBytes","numberToBytesLE","fromBytes","bytesToNumberLE","FpSqrtOdd","root","FpSqrtEven","hashToPrivateScalar","groupOrder","ensureBytes","hashLen","minLen","getFieldBytesLength","getMinHashLength","mapHashToField","fieldOrder","len","fieldLen","reduced","_2n","_3n","_4n","_5n","_8n","result","number","v","q","r","gcd","S","Z","legendreC","p1div4","Q1div2","g","t2","ge","c1","n2","nv","nums","tmp","lastMultiplied","inverted","reduceRight","order","legendreConst","_nBitLength","bitLength","notImplemented","isBytes","abool","title","numberToHexUnpadded","hexToBytes","numberToVarBytesBE","hex","expectedLength","equalBytes","diff","str","TextEncoder","encode","inRange","aInRange","min","max","bitGet","pos","bitSet","createHmacDrbg","qByteLen","hmacFn","u8n","reset","reseed","seed","u8fr","gen","out","sl","pred","object","validators","optValidators","checkField","fieldName","type","isOptional","checkVal","validatorFns","String","entries","memoized","arg","computed","ArrayBuffer","isView","constructor","name","hexes","_","padStart","asciis","_0","_9","F","asciiToBase16","ch","hl","al","array","ai","hi","n1","charCodeAt","char","arrays","pad","isPosBig","data","bigint","function","boolean","string","stringOrUint8Array","DER","DERErr","weierstrassPoints","validateOpts","curve_js_1","ut","bits2int","bits2int_modN","CURVE_ORDER","compressedLen","uncompressedLen","modN","invN","weierstrassEquation","isWithinCurveOrder","_c","point","toAffine","cat","hasEvenY","head","tail","y2","sqrtError","suffix","Error","message","isYOdd","numToNByteStr","isBiggerThanHalfOrder","HALF","slcNum","to","l","fromDER","toSig","msgHash","rec","includes","radj","prefix","R","ir","u2","hasHighS","normalizeS","toDERRawBytes","toDERHex","hexFromSig","toCompactHex","isProbPub","delta","ORDER_MASK","int2octets","defaultSigOpts","prehash","defaultVerOpts","_setWindowSize","fromPrivateKey","getSharedSecret","privateA","publicB","privKey","k2sig","prepSig","some","ent","validateSigVerOpts","h1int","seedArgs","kBytes","ik","normS","drbg","C","publicKey","_sig","format","isHex","isObj","sg","derError","Err","error","is","randomPrivateKey","precompute","SWUFpSqrtRatio","mapToCurveSimpleSWU","sqrtRatio","tv1","tv2","tv3","tv4","tv5","tv6","e1","b2n","h2b","_tlv","tag","E","dataLen","lenLen","decode","first","isLong","lengthBytes","_int","parseInt","int","tlv","seqBytes","seqLeftBytes","rBytes","rLeftBytes","sBytes","sLeftBytes","rs","ss","validatePointOpts","allowedPrivateKeyLengths","wrapPrivateKey","isTorsionFree","allowInfinityPoint","endo","beta","splitScalar","Fn","_isCompressed","x2","x3","lengths","N","assertPrjPoint","other","toAffineMemo","iz","px","py","pz","z","ax","ay","zz","assertValidMemo","left","right","normalizeZ","toInv","msm","wnaf","X1","Y1","Z1","X2","Y2","Z2","U1","U2","b3","X3","Y3","Z3","t0","t1","t3","t4","t5","subtract","multiplyUnsafe","sc","I","k1neg","k1","k2neg","k2","k1p","k2p","fake","f1p","f2p","G","cofactor","toHex","_bits","o","_2n_pow_c1_1","_2n_pow_c1","c2","c3","c4","c6","c7","isQR","tvv5","y1","sha256_1","_shortw_utils_js_1","hash_to_curve_js_1","secp256k1P","secp256k1N","divNearest","sqrtMod","_6n","_11n","_22n","_23n","_44n","_88n","b2","b6","b9","b11","b22","b44","b88","b176","b220","b223","Fpk1","a1","b1","a2","POW_2_128","sha256","TAGGED_HASH_PREFIXES","taggedHash","messages","tagP","tagH","pointToBytes","numTo32b","modP","GmulAdd","schnorrGetExtPubKey","priv","d_","xx","challenge","schnorrVerify","pub","auxRand","rand","k_","rx","isoMap","mapSWU","htf","anumber","ahash","aexists","instance","checkFinished","destroyed","finished","aoutput","HashMD","setBigUint64","Chi","Maj","_assert_js_1","view","byteOffset","_32n","_u32_max","wh","wl","setUint32","Hash","padOffset","buffer","createView","take","dataView","process","roundClean","digestInto","oview","outLen","state","destroy","_cloneInto","crypto","globalThis","HMAC","_key","iHash","oHash","buf","getPrototypeOf","ripemd160","RIPEMD160","_md_js_1","Rho","Id","Pi","idxL","idxR","shifts","shiftsL","idx","shiftsR","Kl","Uint32Array","Kr","group","R_BUF","h0","h1","h2","h3","h4","getUint32","ar","bl","br","cl","cr","dl","dr","el","er","rGroup","hbl","hbr","rl","rr","sr","tl","rotl","tr","wrapConstructor","sha1","SHA1","SHA1_IV","SHA1_W","D","K","T","sha224","SHA256","SHA256_K","SHA256_IV","SHA256_W","W15","W2","s0","rotr","s1","sigma1","T1","sigma0","T2","SHA224","nextTick","byteSwapIfBE","u8","byteLength","u32","DataView","word","shift","byteSwap","byteSwap32","asyncLoop","checkOpts","defaults","call","merged","assign","hashCons","hashC","wrapConstructorWithOpts","wrapXOFConstructorWithOpts","bytesLength","crypto_1","getRandomValues","iters","tick","cb","ts","Date","now","clone","verifyMessage","text","bitcore_lib_default","Message","Buffer","magicHash","ecdsa","ECDSA","hashbuf","pubkeyInSig","toPublicKey","PublicKey","toObject","_Buffer","module","ALPHABET","BASE_MAP","charAt","xc","LEADER","FACTOR","log","iFACTOR","decodeUnsafe","source","alloc","psz","zeroes","size","b256","carry","it3","it4","vch","allocUnsafe","isBuffer","pbegin","pend","b58","it1","it2","repeat","bech32m","bech32","ALPHABET_MAP","polymodStep","pre","prefixChk","chk","convert","inBits","outBits","maxV","toWords","fromWordsUnsafe","words","fromWords","getLibraryFromEncoding","encoding","ENCODING_CONST","__decode","LIMIT","lowered","toLowerCase","uppered","toUpperCase","split","lastIndexOf","wordChars","parser_1","keyPusher","selfSet","selfKeyVals","otherKeyVals","has","newKv","filter","kv","getTx","psbt","globalMap","unsignedTx","getKeySet","keyVals","Set","keyVal","combine","psbts","self","psbtToKeyVals","others","selfTx","selfGlobalSet","globalKeyVals","selfInputSets","inputKeyVals","selfOutputSets","outputKeyVals","otherTx","toBuffer","otherGlobalSet","otherInputSets","inputSet","otherOutputSets","outputSet","psbtFromKeyVals","globalMapKeyVals","typeFields_1","range","GlobalTypes","GLOBAL_XPUB","extendedPubkey","masterFingerprint","path","readUInt32LE","isHard","concat","splitPath","copy","level","writeUInt32LE","expected","check","epk","mfp","indexOf","match","canAddToArray","dupeSet","dupeString","UNSIGNED_TX","globalXpub","finalScriptSig","finalScriptWitness","nonWitnessUtxo","partialSig","porCommitment","sighashType","tapKeySig","tapLeafScript","tapMerkleRoot","tapScriptSig","witnessUtxo","tapTree","bip32Derivation","checkPubkey","redeemScript","tapBip32Derivation","tapInternalKey","witnessScript","globals","makeChecker","inputs","makeConverter","InputTypes","BIP32_DERIVATION","REDEEM_SCRIPT","WITNESS_SCRIPT","PARTIAL_SIG","TAP_BIP32_DERIVATION","TAP_INTERNAL_KEY","outputs","OutputTypes","FINAL_SCRIPTSIG","canAdd","currentData","newData","FINAL_SCRIPTWITNESS","NON_WITNESS_UTXO","pubkey","pSig","isDerSigWithSighash","rLen","sLen","POR_COMMITMENT","SIGHASH_TYPE","TAP_KEY_SIG","TAP_LEAF_SCRIPT","leafVersion","script","controlBlock","tScript","verBuf","TAP_MERKLE_ROOT","TAP_SCRIPT_SIG","leafHash","tSig","tools_1","varuint","WITNESS_UTXO","readUInt64LE","_offset","scriptLen","encodingLength","varintLen","writeUInt64LE","TAP_TREE","depth","leaves","tree","bufs","tapLeaf","of","every","isValidDERKey","TYPE_BYTE","isValidPubkey","pubkeyTypes","isValidBIP340Key","parent","nHashes","nHashesLen","leafHashes","nHashesBuf","keyValToBuffer","keyLen","valLen","keyVarIntLen","valVarIntLen","verifuint","reverseBuffer","keyValsToBuffer","buffers","writeInt32LE","checkUInt53","_number","writeUInt8","writeUInt16LE","readUInt8","readUInt16LE","lo","checkKeyBuffer","keyBuf","keyNum","txCount","unknownKeyVals","inputCount","outputCount","index","input","output","psbtFromBuffer","txGetter","varSlice","getKeyValue","checkEndOfKeyValPairs","isEnd","readUInt32BE","globalKeyIndex","hexKey","unsignedTxMaps","getInputOutputCounts","inputKeyIndex","outputKeyIndex","__export","hasOwnProperty","psbtToBuffer","globalBuffer","keyValsOrEmptyToBuffer","inputBuffers","outputBuffers","header","writeUIntBE","sortKeyVals","compare","keyValsFromMap","keyValMap","converterFactory","keyHexSet","converter","encodedKeyVals","keyHexes","sort","combiner_1","Psbt","tx","fromBase64","txFromBuffer","fromBuffer","results","toBase64","updateGlobal","updateData","updateInput","inputIndex","checkForInput","updateOutput","outputIndex","checkForOutput","addUnknownKeyValToGlobal","checkHasKey","getEnumLength","addUnknownKeyValToInput","addUnknownKeyValToOutput","addInput","inputData","addKeyVals","addInputAttributes","addOutput","outputData","addOutputAttributes","clearFinalizedInput","inputCheckUncleanFinalized","those","getTransaction","GLOBAL_TYPE_NAMES","INPUT_TYPE_NAMES","OUTPUT_TYPE_NAMES","throwForUpdateMaker","typeName","JSON","stringify","updateMaker","mainData","dupeCheckSet","checkKeyVal","enumLength","myenum","isNaN","needScriptSig","needWitnessScript","scriptSigOK","witnessScriptOK","hasOneFinal","defaultVersionSetter","version","txBuf","defaultLocktimeSetter","locktime","__createBinding","desc","__esModule","writable","configurable","__setModuleDefault","__importStar","prototype","fast_sha256_1","bitcoin","BIP322","hashMessage","tagHasher","TAG","tagHash","messageHasher","messageHash","buildToSpendTx","scriptPublicKey","setVersion","setLocktime","scriptSigPartOne","scriptSig","sequence","extractTransaction","buildToSignTx","toSpendTxId","isRedeemScript","encodeWitness","signedPsbt","witness","__importDefault","BIP322_1","ecpair_1","helpers_1","secp256k1_1","bitcoinMessage","address","toSignTx","ECPair","signer","fromWIF","networks","testnet","regtest","checkPubKeyCorrespondToAddress","Address","isP2PKH","scriptPubKey","convertAdressToScriptPubkey","toSpendTx","isP2SH","payments","p2wpkh","hash160","network","getNetworkFromAddess","getId","isP2WPKH","internalPublicKey","Key","toXOnly","Transaction","SIGHASH_ALL","toSignTxSigned","signAllInputs","finalizeAllInputs","claimedAddress","derivedAddresses","convertPubKeyIntoAddress","isP2TR","mainnet","bitcoinjs_1","verifySignature","signerAddress","signatureBase64","useStrictVerification","isValidBitcoinAddress","BIP137","isBIP137Signature","verifyBIP137Signature","ins","encodedSignature","isP2WPKHWitness","hashToSign","decodeScriptSignature","hashedPubkey","getHashForSigP2SHInP2WPKH","lockingScript","hashedLockingScript","hashedLockingScriptInScriptPubKey","getHashForSigP2WPKH","hashedPubkeyInScriptPubkey","isSingleKeyP2TRWitness","getHashForSigP2TR","publicKeySignedUncompressed","publicKeySigned","bitcoinMessageVerifyWrap","publicKeySignedRaw","derivePubKey","compressPublicKey","uncompressPublicKey","p2pkhSigningAddressUncompressed","p2pkhSigningAddressCompressed","p2shSigningAddress","p2wpkhSigningAddress","p2pkhAddressDerivedUncompressed","p2pkhAddressDerivedCompressed","p2shAddressDerived","p2wpkhAddressDerived","p2trAddressDerived","validity","err","signingScript","p2pkh","hashForWitnessV0","hashType","SIGHASH_DEFAULT","hashForWitnessV1","bstart","hashTypeMod","decoded","decode2","lenR","lenS","DecodeScriptSignature_1","Key_1","test","p2sh","p2wsh","p2tr","addressType","redeem","internalPubkey","toOutputScript","signatureBuffer","signatureDecoded","decodeSignature","ecdsaRecover","flagByte","elliptic_1","uncompressedPublicKey","ec","keyPair","keyFromPublic","compressedPublicKey","getPublic","writeUIntLE","readUIntLE","VarInt_1","lengthBuffer","lengthByteLength","VarStr_1","serialize","witnesses","witnessStack","deserialize","encodedWitness","witnessToDecode","witnessDecoded","witnessCount","varIntLength","witnessLength","Witness","VarStr","VarInt","Address_1","BIP137_1","Witness_1","Verifier","Signer","Signer_1","Verifier_1","initEccLib","EC","ecparams","BN","loadPublicKey","loadCompressedPublicKey","xbuf","cmp","toRed","red","redSqr","redIMul","redIAdd","redSqrt","redNeg","redISub","isZero","loadUncompressedPublicKey","ybuf","savePublicKey","contextRandomize","privateKeyVerify","seckey","bn","privateKeyNegate","umod","toArrayLike","privateKeyTweakAdd","iadd","isub","tweaked","privateKeyTweakMul","imul","publicKeyVerify","pair","publicKeyCreate","keyFromPrivate","publicKeyConvert","publicKeyNegate","publicKeyCombine","pubkeys","pairs","isInfinity","publicKeyTweakAdd","publicKeyTweakMul","signatureNormalize","nh","signatureExport","obj","sigR","sigS","posR","posS","outputlen","signatureImport","ecdsaSign","noncefn","_noncefn","nonce","counter","canonical","pers","recid","recoveryParam","ecdsaVerify","msg32","sigObj","sigr","sigs","recoverPubKey","ecdh","hashfn","getX","toArray","getY","errors","IMPOSSIBLE_CASE","TWEAK_ADD","TWEAK_MUL","CONTEXT_RANDOMIZE_UNKNOW","SECKEY_INVALID","PUBKEY_PARSE","PUBKEY_SERIALIZE","PUBKEY_COMBINE","SIG_PARSE","SIGN","RECOVER","ECDH","assert","cond","numbers","join","toTypeString","getAssertedOutput","base58","checksumFn","decodeRaw","payload","checksum","newChecksum","payloadU8","both","bs58checkBase","fromOutputScript","toBech32","toBase58Check","fromBech32","fromBase58Check","bscript","types_1","bech32_1","bs58check","FUTURE_SEGWIT_VERSION_WARNING","unshift","typeforce","tuple","Hash160bit","UInt8","arguments","_toFutureSegwitAddress","console","warn","toASM","decodeBase58","decodeBech32","pubKeyHash","scriptHash","compile","Block","bufferutils_1","bcrypto","merkle_1","transaction_1","types","errorMerkleNoTxes","errorWitnessNotSegwit","prevHash","merkleRoot","timestamp","witnessCommit","transactions","bufferReader","BufferReader","block","readInt32","readSlice","readUInt32","readTransaction","nTransactions","readVarInt","getWitnessCommit","calculateTarget","target","calculateMerkleRoot","forWitness","Function","txesHaveWitnessCommit","hashes","transaction","rootHash","fastMerkleRoot","hash256","witnessCommits","outs","hasWitnessCommit","hasWitness","weight","total","headersOnly","allowWitness","getUTCDate","date","setUTCSeconds","bufferWriter","BufferWriter","writeInt32","writeSlice","writeUInt32","txSize","checkTxRoots","__checkMerkleRoot","__checkWitnessCommit","checkProofOfWork","actualMerkleRoot","actualWitnessCommit","cloneBuffer","withCapacity","UInt32","writeUInt64","writeVarInt","writeVarSlice","writeVector","vector","end","readInt32LE","readUInt64","vi","readVarSlice","readVector","TAGS","ripemd160_1","sha1_1","TapLeaf","TapBranch","TapSighash","TapTweak","getEccLib","_ECCLIB_CACHE","eccLib","DANGER_DO_NOT_VERIFY_ECCLIB","ecc","tweakAddVectors","bool","opcodes","block_1","psbt_1","ops_1","OPS","ecc_lib_1","values","digestFn","TypeError","messagePrefix","bip32","public","private","wif","REVERSE_OPS","OP_FALSE","OP_0","OP_PUSHDATA1","OP_PUSHDATA2","OP_PUSHDATA4","OP_1NEGATE","OP_RESERVED","OP_TRUE","OP_1","OP_2","OP_3","OP_4","OP_5","OP_6","OP_7","OP_8","OP_9","OP_10","OP_11","OP_12","OP_13","OP_14","OP_15","OP_16","OP_NOP","OP_VER","OP_IF","OP_NOTIF","OP_VERIF","OP_VERNOTIF","OP_ELSE","OP_ENDIF","OP_VERIFY","OP_RETURN","OP_TOALTSTACK","OP_FROMALTSTACK","OP_2DROP","OP_2DUP","OP_3DUP","OP_2OVER","OP_2ROT","OP_2SWAP","OP_IFDUP","OP_DEPTH","OP_DROP","OP_DUP","OP_NIP","OP_OVER","OP_PICK","OP_ROLL","OP_ROT","OP_SWAP","OP_TUCK","OP_CAT","OP_SUBSTR","OP_LEFT","OP_RIGHT","OP_SIZE","OP_INVERT","OP_AND","OP_OR","OP_XOR","OP_EQUAL","OP_EQUALVERIFY","OP_RESERVED1","OP_RESERVED2","OP_1ADD","OP_1SUB","OP_2MUL","OP_2DIV","OP_NEGATE","OP_ABS","OP_NOT","OP_0NOTEQUAL","OP_ADD","OP_SUB","OP_MUL","OP_DIV","OP_MOD","OP_LSHIFT","OP_RSHIFT","OP_BOOLAND","OP_BOOLOR","OP_NUMEQUAL","OP_NUMEQUALVERIFY","OP_NUMNOTEQUAL","OP_LESSTHAN","OP_GREATERTHAN","OP_LESSTHANOREQUAL","OP_GREATERTHANOREQUAL","OP_MIN","OP_MAX","OP_WITHIN","OP_RIPEMD160","OP_SHA1","OP_SHA256","OP_HASH160","OP_HASH256","OP_CODESEPARATOR","OP_CHECKSIG","OP_CHECKSIGVERIFY","OP_CHECKMULTISIG","OP_CHECKMULTISIGVERIFY","OP_NOP1","OP_NOP2","OP_CHECKLOCKTIMEVERIFY","OP_NOP3","OP_CHECKSEQUENCEVERIFY","OP_NOP4","OP_NOP5","OP_NOP6","OP_NOP7","OP_NOP8","OP_NOP9","OP_NOP10","OP_CHECKSIGADD","OP_PUBKEYHASH","OP_PUBKEY","OP_INVALIDOPCODE","op","code","tweakKey","tapTweakHash","tapleafHash","findScriptPath","toHashTree","rootHashFromPath","MAX_TAPTREE_DEPTH","LEAF_VERSION_TAPSCRIPT","buffer_1","isHashBranch","ht","leaf","serializeScript","pubKey","tapBranchHash","kj","ej","scriptTree","isTapleaf","node","leftPath","rightPath","tweakHash","p2data","networks_1","lazy","validate","maybe","arrayOf","prop","decompile","stacksEqual","p2pk","p2ms","embed","embed_1","p2ms_1","p2pk_1","p2pkh_1","p2sh_1","p2wpkh_1","p2wsh_1","p2tr_1","_value","OP_INT_BASE","signatures","isAcceptableSignature","isCanonicalScriptSignature","allowIncomplete","_chunks","BufferN","_address","hash2","pkh","_redeem","lastChunk","nameParts","checkRedeem","countNonPushOnlyOPs","hasInput","richunks","isPushOnly","bip341_1","address_1","anyOf","isTaptree","redeemVersion","_witness","_hashTree","hashTree","w","TAPLEAF_VERSION_MASK","tweakedKey","outputKey","controlBock","EMPTY_BUFFER","chunkHasUncompressedPubkey","chunk","_rchunks","stack","toStack","wScript","bip174_1","bip371_1","psbtutils_1","DEFAULT_OPTS","maximumFeeRate","psbtBase","transactionFromBuffer","checkTxForDupeIns","cache","checkTxInputCache","__CACHE","__TX","PsbtTransaction","__NON_WITNESS_UTXO_TX_CACHE","__NON_WITNESS_UTXO_BUF_CACHE","__TX_IN_CACHE","__UNSAFE_SIGN_NONSEGWIT","dpew","attr","txInputs","txOutputs","parse","setMaximumFeeRate","satoshiPerByte","check32Bit","checkInputsForPartialSig","__EXTRACTED_TX","setInputSequence","addInputs","inputDatas","checkTaprootInputFields","checkInvalidP2WSH","txIn","addNonWitnessTxCache","__FEE","__FEE_RATE","addOutputs","outputDatas","checkTaprootOutputFields","disableFeeCheck","isFinalized","checkFees","feeRate","getFeeRate","vsize","virtualSize","satoshis","toFixed","inputFinalizeGetAmts","getTxCacheValue","getFee","finalizeInput","finalScriptsFunc","isTaprootInput","_finalizeTaprootInput","_finalizeInput","finalizeTaprootInput","tapLeafHashToFinalize","tapScriptFinalizer","getFinalScripts","isP2WSH","isSegwit","getScriptFromInput","nonWitnessUtxoTx","nonWitnessUtxoTxFromCache","prevoutIndex","checkPartialSigSighashes","payment","witnessStackToScriptWitness","getInputType","getScriptFromUtxo","getMeaningfulScript","redeemFromFinalScriptSig","finalScript","decomp","lastItem","isPubkeyLike","sDecomp","redeemFromFinalWitnessScript","scriptWitnessToWitnessStack","mainType","classifyScript","meaningfulScript","inputHasPubkey","pubkeyInInput","pubkeyInScript","inputHasHDKey","derivationIsMine","bip32DerivationIsMine","outputHasPubkey","pubkeyInOutput","outputHasHDKey","validateSignaturesOfAllInputs","validator","validateSignaturesOfInput","final","validateSignaturesOfTaprootInput","_validateSignaturesOfInput","hashCache","scriptCache","sighashCache","mySigs","getHashForSig","checkScriptForPubkey","allHashses","getTaprootHashesForSig","getAllTaprootHashesForSig","allPublicKeys","getPrevoutTaprootKey","tapScriptPubkeys","tss","allHashes","pubicKey","flat","tapKeyHash","find","validationResultCount","isValidTapkeySig","trimTaprootSig","tapSig","tapSigHash","isValidTapScriptSig","signAllInputsHD","hdKeyPair","sighashTypes","fingerprint","signInputHD","signAllInputsHDAsync","Promise","resolve","reject","promises","signInputHDAsync","then","all","signers","getSignersFromHD","signInput","signInputAsync","catch","signAllInputsAsync","_signTaprootInput","_signInput","signTaprootInput","tapLeafHashToSign","getHashAndSighashType","allowedSighashTypes","hashesForSig","checkTaprootHashesForSig","serializeTaprootSignature","_signTaprootInputAsync","_signInputAsync","signTaprootInputAsync","tapLeafHash","signaturePromises","tapKeySigPromise","tapScriptHashes","tapScriptSigPromises","tsh","checkCache","checkTxEmpty","isEmpty","hasSigs","neededSigs","pkey","compressPubkey","newKey","derivePath","action","throws","checkTaprootInputForSigs","checkInputForSig","scriptCheckerFactory","paymentScriptName","ioType","redeemScriptOutput","checkRedeemScript","checkWitnessScript","mustFinalize","scriptType","canFinalize","prepareFinalScripts","getPayment","getSortedSigs","pk","ps","forValidate","prevout","checkSighashTypeAllowed","prevoutHash","utxoHash","hashForSignature","getScriptAndAmountFromUtxo","prevOuts","signingScripts","tapLeafHashes","tapScriptHash","sighashTypeToString","SIGHASH_ANYONECANPAY","SIGHASH_SINGLE","SIGHASH_NONE","myDerivations","bipDv","txCache","newBuf","inputAmount","nwTx","vout","outputAmount","fee","isCanonicalPubKey","isP2SHScript","isP2SHP2WSH","isP2WSHScript","isP2MS","isP2PK","tapTreeFromList","tapTreeToList","tweakInternalPubKey","isTaprootOutput","payments_1","psbtutils_2","instertLeavesInTree","instertLeafInTree","leftSide","rightSide","decodeSchnorrSignature","isTapLeafInTree","hasNonTaprootFields","io","findTapLeafToFinalize","leafHashToFinalize","canFinalizeLeaf","whiteListedHash","sortSignatures","positionInScript","pubkeyPositionInScript","sighashTypeByte","newInputData","checkMixedTaprootAndNonTaprootInputFields","isBadTaprootUpdate","isBadNonTaprootUpdate","hasMixedFields","checkIfTapLeafInTree","newLeafsInTree","oldLeafsInTree","newOutputData","checkMixedTaprootAndNonTaprootOutputFields","checkTaprootScriptPubkey","scriptPubkey","getTaprootScripPubkey","_tapTreeToList","extractTaprootSigs","finalTapKeySig","getTapKeySigFromWithness","signatureBlocksAction","isPaymentFactory","pubkeyHash","pubkeyXOnly","decompiled","findIndex","element","signatureDecodeFn","whitelist","isAnyoneCanPay","currentLen","pSigs","extractPartialSigs","getPsigsFromInputFinalScripts","scriptItems","witnessItems","opcode","isDefinedHashType","fromASM","bip66","pushdata","scriptNumber","scriptSignature","isPushOnlyChunk","asMinimalOP","chunksIsBuffer","singleChunkIsBuffer","bufferSize","accum","asm","chunkStr","Hex","maxLength","minimal","negative","script_1","toDER","hashTypeBuffer","varSliceSize","someScript","EMPTY_WITNESS","VALUE_UINT64_MAX","BLANK_OUTPUT","valueBuffer","_NO_STRICT","marker","flag","hasWitnesses","ADVANCED_TRANSACTION_MARKER","ADVANCED_TRANSACTION_FLAG","vinLen","voutLen","isCoinbaseHash","Hash256bit","isCoinbase","Null","DEFAULT_SEQUENCE","Satoshi","stripWitnesses","_ALLOW_WITNESS","vectorSize","someVector","newTx","txOut","inIndex","prevOutScript","ourScript","txTmp","__toBuffer","prevOutScripts","annex","outputType","SIGHASH_OUTPUT_MASK","inputType","SIGHASH_INPUT_MASK","isNone","isSingle","hashPrevouts","hashAmounts","hashScriptPubKeys","hashSequences","hashOutputs","txOutsSize","spendType","sigMsgSize","sigMsgWriter","tbuffer","hashSequence","initialOffset","setInputScript","setWitness","oneOf","Boolean","Buffer256bit","ZERO32","EC_P","SATOSHI_MAX","UInt53","bufferEquals","createHash","SEGWIT_TYPES","P2WPKH","P2SH_P2WPKH","encodeSignature","segwitType","messageVISize","prepareSign","messagePrefixArg","sigOptions","isSigner","segwitRedeemHash","publicKeyHash","signAsync","checkSegwitAlways","actual","parsed","redeemHash","apply","toWordsUnsafe","bitcore","i8","versionGuard","_bitcore","Schnorr","Random","TaggedHash","Base58","Base58Check","Varint","util","js","preconditions","MerkleBlock","BlockHeader","HDPrivateKey","HDPublicKey","Networks","Opcode","PrivateKey","Script","URI","Unit","deps","bnjs","bs58","elliptic","sighash","$","Bech32","JSUtil","multisigType","isNumber","createMultisig","checkArgument","PayToPublicKeyHash","PayToScriptHash","PayToWitnessPublicKeyHash","PayToWitnessScriptHash","PayToTaproot","info","_classifyArguments","defaultNetwork","defineImmutable","hashBuffer","_transformHash","_transformBuffer","_transformPublicKey","_transformScript","_transformString","isObject","_transformObject","_classifyFromVersion","pubkeyhashNetwork","scripthashNetwork","networkObj","bufferVersion","xpubkey","sha256ripemd160","buildWitnessV0Out","createTapTweak","tweakedPubKey","getAddressInfo","CantDeriveAddress","publicKeys","threshold","nestedWitness","buildMultisigOut","payingTo","buildWitnessMultisigOutFromScript","trim","addressBuffer","fromPublicKey","fromPublicKeyHash","fromScriptHash","fromScript","fromString","fromObject","checkState","isHexa","getValidationError","isPayToPublicKeyHash","isPayToScriptHash","isPayToWitnessPublicKeyHash","isPayToWitnessScriptHash","isPayToTaproot","toJSON","bech32prefix","encodings","BECH32","BECH32M","inspect","BufferUtil","extend","_from","MAX_BLOCK_SIZE","_fromBufferReader","_fromObject","fromBufferReader","readVarintNum","fromRawBlock","Values","START_OF_BLOCK","toBufferWriter","bw","write","writeVarintNum","getTransactionHashes","NULL_HASH","_getHash","getMerkleTree","i2","sha256sha256","getMerkleRoot","validMerkleRoot","idProperty","_id","id","noop","time","isString","Constants","START_OF_HEADER","read","getTargetDifficulty","mov","getDifficulty","difficulty1TargetBN","currentTargetBN","difficultyString","decimalPos","parseFloat","readReverse","validTimestamp","currentTime","round","getTime","MAX_TIME_OFFSET","validProofOfWork","LARGEST_HASH","numTransactions","flags","_flagBitsUsed","_hashesUsed","validMerkleTree","height","_calcTreeHeight","hashesUsed","flagBitsUsed","_traverseMerkleTree","filterdTxsHash","InvalidMerkleTree","txs","checkForTxs","isParentOfMatch","_calcTreeWidth","hasTransaction","isUndefined","numHashes","numFlags","reversebuf","buf2","Zero","One","Minus1","fromNumber","endian","fromSM","ret","toNumber","natlen","toSMBigEndian","toSM","fromScriptNumBuffer","fRequireMinimal","nMaxNumSize","toScriptNumBuffer","rbuf","isSecondKey","getN","getG","fromX","nR","eNeg","rInv","invm","fromPoint","getRandomK","getRandomBuffer","lt","gt","getDeterministicK","privkey","badrs","sha256hmac","toLowS","verificationError","sinv","mulAdd","randomK","calci","Qprime","eq","__testing__","blocksize","sha512","hashf","o_key","i_key","o_key_pad","i_key_pad","sha512hmac","ecPoint","bind","ecPointFromX","pointFromX","isRed","odd","getP","_getX","_getY","p2","pointToCompressed","liftX","fieldSize","one","two","three","four","seven","redPow","pointX","fromRed","pointY","getRandomBufferBrowser","getRandomBufferNode","msCrypto","bbuf","getPseudoRandomBuffer","random","JS","aux","isHexaString","isType","dPrime","eqn","gte","Pbuf","encodeCompressed","isEven","xor","finalize","kPrime","Rbuf","getE","inf","isSchnorr","nhashtype","fromSchnorr","parseDER","fromTxFormat","derbuf","buflength","rheader","rlength","rneg","sheader","slength","sbuf","sneg","sumlength","toCompact","hashTypeBuf","rnbuf","snbuf","isTxDER","nLenR","nLenS","hasLowS","hasDefinedHashtype","isNaturalNumber","temp","toTxFormat","Version","WITNESS_V0","TAPROOT","TAPSCRIPT","inherits","messageEncoding","taghash","defineProperties","TAPSIGHASH","TAPLEAF","TAPBRANCH","validCharacters","chars","validChecksum","csum","hash4","checkedBuf","b32Variety","eof","readAll","readUInt16BE","readUInt64BEBN","readUInt64LEBN","second","combined","readVarLengthBuffer","readVarintBuf","readVarintBN","bufferUtil","bufLen","writeReverse","writeUInt16BE","writeUInt32BE","writeUInt64BEBN","writeUInt64LEBN","varintBufNum","writeVarintBN","varintBufBN","fromBN","toBN","traverseNode","errorDefinition","NodeError","replace","isFunction","childDefinitions","each","childDefinition","spec","Network","hdErrors","BITS_TO_BYTES","_generateRandomly","isValidSerialized","_buildFromSerialized","isValidJSON","_buildFromJSON","getSerializedError","_buildFromObject","UnrecognizedArgument","isValidPath","hardened","indexes","_getDerivationIndexes","Hardened","MaxIndex","steps","RootElementAlias","step","isHardened","NaN","derive","deriveNonCompliantChild","deriveChild","_deriveWithNumber","_deriveFromString","InvalidDerivationArgument","nonCompliant","InvalidPath","indexBuffer","integerAsBuffer","nonZeroPadded","privateKeyBuffer","_buffers","chainCode","leftPart","toBigNumber","parentFingerPrint","fingerPrint","childIndex","InvalidB58Char","InvalidB58Checksum","DataLength","InvalidLength","_validateNetwork","networkArg","InvalidNetworkArgument","integerFromBuffer","xprivkey","InvalidNetwork","integerAsSingleByteBuffer","_buildFromBuffers","VersionStart","VersionEnd","DepthStart","DepthEnd","ParentFingerPrintStart","ParentFingerPrintEnd","ChildIndexStart","ChildIndexEnd","ChainCodeStart","ChainCodeEnd","PrivateKeyStart","PrivateKeyEnd","ChecksumStart","ChecksumEnd","fromSeed","hexa","InvalidEntropyArgument","MINIMUM_ENTROPY_BITS","NotEnoughEntropy","MAXIMUM_ENTROPY_BITS","TooMuchEntropy","_calcHDPublicKey","_hdPublicKey","_validateBufferArguments","emptyBuffer","ParentFingerPrintSize","integerFromSingleByteBuffer","checkBuffer","buff","VersionSize","DepthSize","ChildIndexSize","ChainCodeSize","PrivateKeySize","CheckSumSize","bufferToHex","DefaultDepth","DefaultFingerprint","DefaultChildIndex","SerializedByteSize","bitcoreErrors","ArgumentIsPrivateExtended","hdPublicKey","_buildFromPrivate","MustSupplyArgument","InvalidIndexCantDeriveHardened","isNull","DataSize","livenet","PublicKeyStart","PublicKeyEnd","PublicKeySize","MAGIC_BYTES","prefix1","messageBuffer","prefix2","_sign","_verify","verified","bitcoinAddress","signatureString","signatureAddress","fromJSON","json","networkMaps","alias","addNetwork","pubkeyhash","privatekey","scripthash","networkMagic","port","dnsSeeds","variant","variants","testnet3","signet","remove","splice","enableRegtest","regtestEnabled","disableRegtest","reverseMap","smallInt","decodeOpN","isOpSuccess","isSmallIntOp","_getRandomBN","_transformWIF","privbuf","_transformBNBuffer","fromRandom","toWIF","toBufferNoPadding","_pubkey","toAddress","secKey","taggedWriter","tweakedPrivKey","uncompressed","extra","_classifyArgs","_transformDER","_isBuffer","_isPrivateKey","_transformPrivateKey","param","_transformX","fromTaproot","hexBuf","isValidTaproot","computeTapTweakHash","checkTapTweak","control","_getID","Interpreter","SighashWitness","SighashSchnorr","initialize","verifyWitnessProgram","program","WITNESS_V0_SCRIPTHASH_SIZE","errstr","scriptPubKeyBuffer","executeWitnessScript","WITNESS_V0_KEYHASH_SIZE","WITNESS_V1_TAPROOT_SIZE","SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM","execdata","annexPresent","SCRIPT_VERIFY_TAPROOT","ANNEX_TAG","pop","annexWriter","annexHash","annexInit","checkSchnorrSignature","scriptPubKeyBuf","TAPROOT_CONTROL_BASE_SIZE","TAPROOT_CONTROL_MAX_SIZE","TAPROOT_CONTROL_NODE_SIZE","computeTapleafHash","TAPROOT_LEAF_MASK","verifyTaprootCommitment","tapleafHashInit","TAPROOT_LEAF_TAPSCRIPT","witnessSize","validationWeightLeft","VALIDATION_WEIGHT_OFFSET","validationWeightLeftInit","SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION","sigversion","opcodenum","SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS","MAX_STACK_SIZE","elem","MAX_SCRIPT_ELEMENT_SIZE","evaluate","castToBool","nin","stackCopy","SCRIPT_VERIFY_SIGPUSHONLY","SCRIPT_VERIFY_P2SH","hadWitness","SCRIPT_VERIFY_WITNESS","witnessValues","isWitnessProgram","isScriptHashOut","redeemScriptSerialized","p2shWitnessValues","redeemScriptPush","SCRIPT_VERIFY_CLEANSTACK","altstack","pc","pbegincodehash","nOpCount","vfExec","true","false","MAX_SCRIPT_SIZE","LOCKTIME_THRESHOLD","LOCKTIME_THRESHOLD_BN","SCRIPT_VERIFY_NONE","SCRIPT_VERIFY_STRICTENC","SCRIPT_VERIFY_DERSIG","SCRIPT_VERIFY_LOW_S","SCRIPT_VERIFY_NULLDUMMY","SCRIPT_VERIFY_MINIMALDATA","SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS","SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY","SCRIPT_VERIFY_CHECKSEQUENCEVERIFY","SCRIPT_VERIFY_MINIMALIF","SCRIPT_VERIFY_NULLFAIL","SCRIPT_VERIFY_WITNESS_PUBKEYTYPE","SCRIPT_ENABLE_SIGHASH_FORKID","SCRIPT_ENABLE_REPLAY_PROTECTION","SCRIPT_VERIFY_CONST_SCRIPTCODE","SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE","SEQUENCE_LOCKTIME_DISABLE_FLAG","SEQUENCE_LOCKTIME_TYPE_FLAG","SEQUENCE_LOCKTIME_MASK","TAPROOT_CONTROL_MAX_NODE_COUNT","PROTOCOL_VERSION","checkSignatureEncoding","checkPubkeyEncoding","checkEcdsaSignature","subscript","subscriptBuffer","scriptCodeWriter","satoshisBuffer","_evalChecksigPreTapscript","bufSig","bufPubkey","retVal","success","tmpScript","found","findAndDelete","_evalChecksigTapscript","VALIDATION_WEIGHT_PER_SIGOP_PASSED","_evalCheckSig","checkLockTime","nLockTime","isFinal","checkSequence","nSequence","txToSequence","sequenceNumber","nLockTimeMask","txToSequenceMasked","nSequenceMasked","and","SEQUENCE_LOCKTIME_TYPE_FLAG_BN","lte","scriptBuf","tagWriter","computeTaprootMerkleRoot","pathLen","start","fExec","codeseparatorPosInit","codeseparatorPos","checkMinimalPush","fValue","buf1","buf3","spliced","x1","fEqual","bn1","bn2","bn3","bufHash","fSuccess","addn","fOk","nKeysCount","ikey","ikey2","nSigsCount","isig","fromAddress","RangeError","InvalidBuffer","tokens","token","_chunkToString","numstr","substr","isPublicKeyHashOut","isPublicKeyHashIn","signatureBuf","pubkeyBuf","isPublicKeyOut","getPublicKeyHash","isWitnessPublicKeyHashOut","isTaproot","isVersion","isPublicKeyIn","isWitnessScriptHashOut","isScriptHashIn","redeemBuf","redeemChunk","classify","UNKNOWN","isMultisigOut","isMultisigIn","isDataOut","OP_RETURN_STANDARD_SIZE","getData","PUBKEY_OUT","PUBKEY_IN","PUBKEYHASH_OUT","PUBKEYHASH_IN","SCRIPTHASH_OUT","SCRIPTHASH_IN","MULTISIG_OUT","MULTISIG_IN","DATA_OUT","_isInput","classifyInput","_isOutput","classifyOutput","outputIdentifiers","inputIdentifiers","isStandard","prepend","_addByType","_addOpcode","_addBuffer","_insertAtPosition","hasCodeseparators","removeCodeseparators","sorted","noSorting","sortBy","buildMultisigIn","buildP2SHMultisigIn","cachedMultisig","buildPublicKeyHashOut","_network","buildWitnessV1Out","buildTree","leftH","rightH","hWriter","leafWriter","buildPublicKeyOut","buildDataOut","buildScriptHashOut","buildPublicKeyIn","sigtype","buildPublicKeyHashIn","empty","toScriptHashOut","UnrecognizedAddress","_getInputAddressInfo","_getOutputAddressInfo","getSignatureOperationsCount","accurate","lastOpcode","Input","Output","UnspentOutput","Sighash","PublicKeyHash","MultiSig","MultiSigScriptHash","Taproot","params","MAXINT","DEFAULT_SEQNUMBER","DEFAULT_LOCKTIME_SEQNUMBER","DEFAULT_RBF_SEQNUMBER","_script","_scriptBuffer","prevTxId","txidbuf","txoutnum","seqnum","scriptBuffer","MissingScript","setScript","scriptString","writer","getSignatures","AbstractMethodInvoked","getSatoshisBuffer","_satoshisBN","isFullySigned","addSignature","clearSignatures","getWitnesses","setWitnesses","isValidSignature","signingMethod","_estimateSize","_getBaseSize","lockForSeconds","seconds","SEQUENCE_LOCKTIME_GRANULARITY","LockTimeRange","lockUntilBlockHeight","heightDiff","BlockHeightOutOfRange","getLockTime","TransactionSignature","MultiSigInput","publicKeyIndex","_deserializeSignatures","_serializeSignatures","hashData","_updateScript","_createSignatures","countSignatures","countMissingSignatures","publicKeysWithoutSignature","normalizeSignatures","signatureMatch","OPCODES_SIZE","SIGNATURE_SIZE","MultiSigScriptHashInput","nested","getScriptCode","redeemScriptBuffer","getSighash","scriptCode","MAX_OPCODES_SIZE","MAX_SIGNATURE_SIZE","MAX_PUBKEY_SIZE","REDEEM_SCRIPT_SIZE","PublicKeyInput","SCRIPT_MAX_SIZE","PublicKeyHashInput","getRedeemScript","PubKeyHashInput","TaprootInput","tweakedPk","txSig","setScriptFromBuffer","branch","_isValid","_branch","_satoshis","invalidSatoshis","scriptStr","calculateSize","track","merkleBranch","_insertNode","_combineNodes","_nodes","m_branch","isComplete","inputNumber","txcopy","shallowCopy","_signatureHash","extFlag","keyVersion","prevoutsBW","spentAmountsBW","spentScriptsBW","sequencesBW","vin","prevoutsSingleHash","spentAmountsSingleHash","spentScriptsSingleHash","sequencesSingleHash","outputsBW","outputsSingleHash","_getExecData","prevTxIdBuffer","outputIndexBuffer","sequenceBuffers","sequenceBuffer","outputWriter","outpointId","InvalidArgument","_checkObjectArgs","serialized","_inputAmount","_outputAmount","_newTransaction","DUST_AMOUNT","FEE_SECURITY_MARGIN","MAX_MONEY","NLOCKTIME_BLOCKHEIGHT_LIMIT","NLOCKTIME_MAX_VALUE","FEE_PER_KB","CHANGE_OUTPUT_MAX_SIZE","MAXIMUM_EXTRA_SIZE","hashProperty","_hash","_getWitnessHash","ioProperty","_getInputAmount","_getOutputAmount","_calculateSize","_calculateVSize","_calculateWeight","unsafe","disableAll","uncheckedSerialize","checkedSerialize","serializationError","getSerializationError","invalid","InvalidSatoshis","unspentError","unspent","_getUnspentValue","disableMoreOutputThanInput","InvalidOutputAmountSum","_hasFeeError","_hasDustOutputs","_isMissingSignatures","_fee","FeeError","Different","disableLargeFees","maximumFee","_estimateFee","_missingChange","ChangeAddressMissing","TooLarge","disableSmallFees","minimumFee","TooSmall","_changeScript","disableDustOutputs","DustOutputs","disableIsFullySigned","MissingSignatures","noWitness","reader","sizeTxIns","sizeTxOuts","itemCount","changeScript","_changeIndex","changeIndex","uncheckedAddInput","txin","UnsupportedScript","_checkConsistency","lockUntilDate","LockTimeTooEarly","isDate","BlockHeightTooHigh","NLockTimeOutOfRange","utxo","exists","txId","_fromMultisigUtxo","_fromNonP2SH","associateInputs","utxos","_getInputFrom","_selectInputType","clazz","InputClass","outputScript","checkArgumentType","NeedMoreInfo","_updateChangeOutput","hasAllUtxoInfo","amount","feePerKb","_feePerKb","feePerByte","_feePerByte","change","getChangeOutput","addData","_addOutput","clearOutputs","_clearSignatures","sumBy","MissingPreviousOutput","noClearSigs","_removeOutput","changeAmount","available","estimatedSize","feeWithChange","_estimateSizeOfChangeOutput","noRound","without","removeOutput","sortInputs","sortOutputs","shuffleOutputs","shuffle","sortingFunction","_newOutputOrder","newOutputs","difference","InvalidSorting","changeOutput","removeInput","InvalidIndex","applySignature","UnableToVerifySignature","valueoutbn","txout","txinmap","inputid","isRBF","enableRBF","txid","fromBTC","toSatoshis","fromSatoshis","toBTC","UNITS","InvalidRate","BTC","fromMillis","fromMilis","mBTC","fromMicros","fromBits","fromFiat","rate","UnknownCode","toMillis","toMilis","toMicros","toBits","atRate","URL","knownParams","extras","_parseAmount","uri","protocol","exec","query","Members","destination","label","host","original","equal","integer","cloneArray","isFinite","InvalidState","argumentName","docsPath","argument","InvalidArgumentType","ctor","superCtor","super_","TempCtor","isBN","_init","wordSize","parseHex","parseBase","_initNumber","_initArray","_parseHex","_parseBase","strip","off","limbLen","limbPow","imuln","_iaddn","dest","_expand","_normSign","zeros","groupSizes","groupBases","smallMulTo","ncarry","rword","maxJ","padding","groupSize","groupBase","modn","idivn","ArrayType","reqLength","andln","iushrn","clz32","_countBits","_zeroBits","zeroBits","toTwos","width","inotn","iaddn","fromTwos","testn","notn","ineg","isNeg","iuor","ior","or","uor","iuand","iand","uand","iuxor","ixor","uxor","bytesNeeded","bitsLeft","setn","bit","wbit","comb10MulTo","mid","a0","al0","ah0","al1","ah1","al2","ah2","a3","al3","ah3","a4","al4","ah4","a5","al5","ah5","a6","al6","ah6","a7","al7","ah7","a8","al8","ah8","a9","al9","ah9","b0","bl0","bh0","bl1","bh1","bl2","bh2","bl3","bh3","b4","bl4","bh4","b5","bl5","bh5","bl6","bh6","b7","bl7","bh7","b8","bl8","bh8","bl9","bh9","w0","w1","w2","w3","w4","w5","w6","w7","w8","w9","w10","w11","w12","w13","w14","w15","w16","w17","w18","jumboMulTo","fftm","FFTM","mulp","mulTo","bigMulTo","hncarry","makeRBT","revBin","rb","permute","rbt","rws","iws","rtws","itws","rtwdf","cos","PI","itwdf","sin","rtwdf_","itwdf_","re","ie","ro","guessLen13b","conjugate","normalize13b","ws","convert13b","stub","ph","rwst","iwst","nrws","nrwst","niwst","rmws","mulf","muln","isqr","toBitArray","iushln","carryMask","newCarry","ishln","hint","extended","maskedWords","ishrn","shln","ushln","shrn","ushrn","imaskn","maskn","isubn","subn","iabs","_ishlnsubmul","_wordDiv","mode","bhi","qj","divmod","positive","divn","divRound","dm","half","r2","egcd","yp","xp","im","jm","_invmp","cmpn","bincn","ucmp","gtn","gten","ltn","lten","Red","ctx","convertTo","_forceRed","convertFrom","forceRed","redAdd","redSub","redShl","shl","redMul","_verify2","_verify1","redISqr","redInvm","primes","k256","p224","p192","p25519","MPrime","_tmp","K256","P224","P192","P25519","prime","_prime","Mont","imod","rinv","minv","ireduce","rlen","imulK","next","mod3","nOne","lpow","wnd","current","mont","basex","ECPairFactory","testecc_1","isOptions","testEcc","__D","__Q","lowR","tweakFromPrivateKey","tweakFromPublicKey","extraData","xOnlyPubKey","tweakedPublicKey","parityByte","hasOddY","tweakedPrivateKey","maybePoint","wifString","makeRandom","rng","xOnlyRes","__WEBPACK_AMD_DEFINE_RESULT__","factory","digestLength","blockSize","hashBlocks","Int32Array","bufferLength","bytesHashed","clean","dataLength","dataPos","finish","bitLenHi","bitLenLo","padLength","_saveState","_restoreState","inner","outer","istate","ostate","hkdfSalt","hkdf","salt","okm","hmac_","bufpos","fillBuffer","pbkdf2","password","iterations","prf","ctr","dk","__nccwpck_require__","ab","__dirname","auth","hostname","pathname","encodeURIComponent","search","slashes","resolveObject","U","href","decodeURIComponent","username","endsWith","Url","maxKeys","stringifyPrimitive","native","getTypeName","getValueTypeName","Nil","captureStackTrace","tfJSON","tfErrorString","valueTypeName","valueJson","TfTypeError","__type","__value","__valueTypeName","TfPropertyTypeError","property","description","__label","__property","tfCustomError","tfSubError","NATIVE","ERRORS","_LengthN","Length","_ArrayN","_BufferN","_HexN","ArrayN","Finite","HexN","Int8","Int16","Int32","Int53","Range","_range","StringN","UInt16","TYPES","_arrayOf","minLength","Infinity","_maybe","propertyType","propertyKeyType","_map","propertyName","propertyValue","uncompiled","typePropertyName","_object","_anyOf","allOf","_allOf","quacksLike","_quacksLike","_tuple","surrogate","EXTRA","encodeRaw","WASM_BUFFER","_wasm_loader_js__WEBPACK_IMPORTED_MODULE_2__","memory","WASM_PRIVATE_KEY_PTR","PRIVATE_INPUT","WASM_PUBLIC_KEY_INPUT_PTR","PUBLIC_KEY_INPUT","WASM_PUBLIC_KEY_INPUT_PTR2","PUBLIC_KEY_INPUT2","WASM_X_ONLY_PUBLIC_KEY_INPUT_PTR","X_ONLY_PUBLIC_KEY_INPUT","WASM_X_ONLY_PUBLIC_KEY_INPUT2_PTR","X_ONLY_PUBLIC_KEY_INPUT2","WASM_TWEAK_INPUT_PTR","TWEAK_INPUT","WASM_HASH_INPUT_PTR","HASH_INPUT","WASM_EXTRA_DATA_INPUT_PTR","EXTRA_DATA_INPUT","WASM_SIGNATURE_INPUT_PTR","SIGNATURE_INPUT","PRIVATE_KEY_INPUT","_validate_js__WEBPACK_IMPORTED_MODULE_1__","Yl","Bl","Vt","jx","ZM","P0","fJ","XM","__initializeContext","initializeContext","DV","rH","vC","hv","pA","pB","yE","Cm","Fr","$Q","xOnlyPointAddTweakCheck","resultToCheck","tweakParity","hasParity","Y6","uint8array_tools__WEBPACK_IMPORTED_MODULE_0__","qu","IB","XS","K7","yT","generateInt32","get4RandomBytes","PRIVATE_KEY_SIZE","PUBLIC_KEY_COMPRESSED_SIZE","PUBLIC_KEY_UNCOMPRESSED_SIZE","X_ONLY_PUBLIC_KEY_SIZE","TWEAK_SIZE","HASH_SIZE","EXTRA_DATA_SIZE","isDERPoint","validateParity","_validate_error_js__WEBPACK_IMPORTED_MODULE_0__","_y","validatePrivate","validatePoint","validateXOnlyPoint","validateTweak","NQ","validateHash","AI","validateExtraData","B6","validateSignature","bf","validateSignatureCustom","validatorFn","validateSignatureNonzeroRS","validateSigrPMinusN","ERROR_BAD_PRIVATE","ERROR_BAD_POINT","ERROR_BAD_TWEAK","ERROR_BAD_HASH","ERROR_BAD_SIGNATURE","ERROR_BAD_EXTRA_DATA","ERROR_BAD_PARITY","ERROR_BAD_RECOVERY_ID","ERRORS_MESSAGES","throwError","errcode","__webpack_exports__","_secp256k1_wasm__WEBPACK_IMPORTED_MODULE_0__","HEX_STRINGS","v1","v2","codePointAt","fromCodePoint","TextDecoder"],"sourceRoot":""}