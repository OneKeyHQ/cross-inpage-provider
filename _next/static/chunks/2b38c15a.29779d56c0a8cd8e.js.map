{"version":3,"file":"static/chunks/2b38c15a.29779d56c0a8cd8e.js","mappings":"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EAAA,uCACA,sCACA,uCACAC,EAAA,uCACA,sCACA,uCACAxE,EAAA,uCACA,sCACA,uCACAC,EAAA,IAEAE,EAAA,KACAC,EAAA,CACA,uCACA,sCACA,uCACA,uCACA,sCACA,uCACAwE,EACA,EAEA,CACA,EAowBAqf,KA5vBA,cAAAtR,WACA7T,YAAA8F,CAAA,EACA,OACA1F,GAAA,OACAC,KAAA,YACAH,KAAA,QACAI,OAAA,KACAC,KAAA,SACAG,MAAA,OAEAC,EAAA,uCACA,sCACA,sCACA,sCACA,YAEA8E,EAAA,uCACA,sCACA,sCACA,sCACA,YACAC,EAAA,uCACA,sCACA,sCACA,sCACA,YACAxE,EAAA,uCACA,sCACA,sCACA,sCACA,YACAC,EAAA,IAEAE,EAAA,KACAC,EAAA,CACA,uCACA,sCACA,sCACA,sCACA,YACA,uCACA,sCACA,sCACA,sCACA,YACAwE,EACA,EAEA,CACA,EA4sBAsf,UApsBA,cAAAvR,WACA7T,YAAA8F,CAAA,EACA,OACA1F,GAAA,YACAC,KAAA,YACAH,KAAA,QACAI,OAAA,KACAC,KAAA,SACAG,MAAA,OAEAC,EAAA,uCACA,uCACA8E,EAAA,IACAC,EAAA,IACAxE,EAAA,uCACA,uCACAC,EAAA,IAEAE,EAAA,IAEAkP,EAAA,uCACA,uCACAjP,EAAA,CACA,uCACA,uCACA,uCACA,uCACAwE,EACA,CAEA1D,KAAA,CACA2P,KAAA,uCACA,uCACAkF,OAAA,uCACA,uCACAK,MAAA,CACA,CACA7R,EAAA,mCACAC,EAAA,mCACA,EACA,CACAD,EAAA,oCACAC,EAAA,kCACA,EACA,CACAI,IAAA,CACA,IACA,uCACA,uCACA,KACA,sCACA,uCACA,CAEA,EACA,CACA,EA6oBAuf,cAtoBA,cAAAxR,WACA7T,YAAA8F,CAAA,EACA,OACA1F,GAAA,gBACAC,KAAA,kBACAH,KAAA,QACAI,OAAA,KACAC,KAAA,SACAG,MAAA,KAEAC,EAAA,uCACA,uCACA8E,EAAA,uCACA,uCACAC,EAAA,uCACA,uCACAxE,EAAA,uCACA,uCACAC,EAAA,IAEAE,EAAA,KACAC,EAAA,CACA,uCACA,uCACA,uCACA,uCACAwE,EACA,EAEA,CACA,EAymBAwf,cAlmBA,cAAAzR,WACA7T,YAAA8F,CAAA,EACA,OACA1F,GAAA,gBACAC,KAAA,kBACAH,KAAA,QACAI,OAAA,KACAC,KAAA,SACAG,MAAA,KAEAC,EAAA,uCACA,sCACA,uCACA8E,EAAA,uCACA,sCACA,uCACAC,EAAA,uCACA,sCACA,uCACAxE,EAAA,uCACA,sCACA,uCACAC,EAAA,IAEAE,EAAA,KACAC,EAAA,CACA,uCACA,sCACA,uCACA,uCACA,sCACA,uCACAwE,EACA,EAEA,CACA,EA+jBAyf,cAxjBA,cAAA1R,WACA7T,YAAA8F,CAAA,EACA,OACA1F,GAAA,gBACAC,KAAA,kBACAH,KAAA,QACAI,OAAA,KACAC,KAAA,SACAG,MAAA,KAEAC,EAAA,uCACA,sCACA,sCACA,uCACA8E,EAAA,uCACA,sCACA,sCACA,uCACAC,EAAA,uCACA,sCACA,sCACA,uCACAxE,EAAA,uCACA,sCACA,sCACA,uCACAC,EAAA,IAEAE,EAAA,IACAC,EAAA,CACA,uCACA,sCACA,sCACA,uCACA,uCACA,sCACA,sCACA,uCACAwE,EACA,EAEA,CACA,EA+gBA0f,OAxgBA,cAAA9P,UACA1V,aAAA,CACA,OACAI,GAAA,SACAC,KAAA,SACAH,KAAA,OACAI,OAAA,KACAC,KAAA,SACAG,MAAA,SAEAC,EAAA,uCACA,uCAEA8E,EAAA,QACAC,EAAA,IACAxE,EAAA,uCACA,uCACAC,EAAA,IAEAE,EAAA,IACAC,EAAA,CACA,uCACA,uCAEA,uCACA,uCACA,CACAa,QAAA,CACA,GACA,CACA,uCACA,uCACA,uCACA,uCACA,CACA,CACA,uCACA,uCACA,uCACA,uCACA,CACA,CACA,uCACA,uCACA,uCACA,uCACA,CACA,CACA,uCACA,uCACA,uCACA,uCACA,CACA,CACA,uCACA,uCACA,uCACA,uCACA,CACA,CACA,uCACA,uCACA,uCACA,uCACA,CACA,CACA,uCACA,uCACA,uCACA,uCACA,CACA,EAEA,CACA,EA+bAsjB,KAxbA,cAAA/P,UACA1V,aAAA,CACA,OACAI,GAAA,OACAC,KAAA,OACAH,KAAA,OACAI,OAAA,KACAC,KAAA,WACAG,MAAA,OAEAC,EAAA,uCACA,sCACA,sCACA,qBAEA8E,EAAA,QACAC,EAAA,IACAxE,EAAA,uCACA,sCACA,sCACA,qBACAC,EAAA,IAEAE,EAAA,KACAC,EAAA,CACA,uCACA,sCACA,sCACA,qBACA,uCACA,sCACA,sCACA,qBACA,CACAa,QAAA,CACA,GACA,CACA,uCACA,sCACA,sCACA,qBACA,uCACA,sCACA,sCACA,qBACA,CACA,CACA,uCACA,sCACA,sCACA,qBACA,uCACA,sCACA,sCACA,qBACA,CACA,CACA,uCACA,sCACA,sCACA,qBACA,uCACA,sCACA,sCACA,qBACA,CACA,EAEA,CACA,EAoXAujB,QA7WA,cAAAhQ,UACA1V,aAAA,CACA,OACAI,GAAA,UACAC,KAAA,KACAH,KAAA,OACAI,OAAA,KACAC,KAAA,WACAG,MAAA,OAEAC,EAAA,uCACA,sCACA,sCACA,qBAEA8E,EAAA,uCACA,sCACA,sCACA,qBACAC,EAAA,IACAxE,EAAA,uCACA,sCACA,sCACA,qBACAC,EAAA,IAEAE,EAAA,KACAC,EAAA,CACA,uCACA,sCACA,sCACA,qBACA,uCACA,sCACA,sCACA,qBACA,CACAa,QAAA,CACA,GACA,CACA,uCACA,sCACA,sCACA,qBACA,uCACA,sCACA,sCACA,qBACA,CACA,CACA,uCACA,sCACA,sCACA,qBACA,uCACA,sCACA,sCACA,qBACA,CACA,CACA,uCACA,sCACA,sCACA,qBACA,uCACA,sCACA,sCACA,qBACA,CACA,EAEA,CACA,EAsSAwjB,QA/RA,cAAA5P,aACA/V,YAAA8F,CAAA,EACA,OACA1F,GAAA,UACAC,KAAA,UACAH,KAAA,UACAI,OAAA,KACAC,KAAA,SACAC,OAAA,mCACAC,QAAA,GACAC,MAAA,SAEAC,EAAA,uCACA,uCACA8E,EAAA,KAEA4K,EAAA,uCACA,uCACAnP,EAAA,uCACA,uCACAC,EAAA,IAEAE,EAAA,IACAC,EAAA,CACA,uCACA,uCAEA,uCACA,uCACAwE,EACA,CACA3D,QAAA,CACA,CACA,uCACA,uCACA,uCACA,uCACA,CACA,CACA,uCACA,uCACA,uCACA,uCACA,CACA,CACA,uCACA,uCACA,uCACA,uCACA,CACA,CACA,uCACA,uCACA,uCACA,uCACA,CACA,CACA,uCACA,uCACA,uCACA,uCACA,CACA,CACA,uCACA,uCACA,uCACA,uCACA,CACA,CACA,uCACA,uCACA,uCACA,uCACA,CACA,CACA,uCACA,uCACA,uCACA,uCACA,CACA,EAEA,CACA,EA6MAyjB,OArMA,cAAA7P,aACA/V,YAAA8F,CAAA,EACA,OACA1F,GAAA,SACAC,KAAA,KACAH,KAAA,UACAI,OAAA,KACAC,KAAA,WACAC,OAAA,WACAC,QAAA,GACAC,MAAA,OAEAC,EAAA,uCACA,sCACA,sCACA,qBACA8E,EAAA,IAEA4K,EAAA,uCACA,sCACA,sCACA,qBACAnP,EAAA,uCACA,sCACA,sCACA,qBACAC,EAAA,IAEAE,EAAA,KACAC,EAAA,CACA,uCACA,sCACA,sCACA,qBAEA,uCACA,sCACA,sCACA,qBACAwE,EACA,CACA3D,QAAA,CACA,CACA,uCACA,sCACA,sCACA,qBACA,uCACA,sCACA,sCACA,qBACA,CACA,CACA,uCACA,sCACA,sCACA,qBACA,uCACA,sCACA,sCACA,qBACA,CACA,CACA,uCACA,sCACA,sCACA,qBACA,uCACA,sCACA,sCACA,qBACA,CACA,CACA,uCACA,sCACA,sCACA,qBACA,uCACA,sCACA,sCACA,qBACA,CACA,EAEA,CACA,EAiHA0jB,MA1GA,cAAA9P,aACA/V,YAAA8F,CAAA,EACA,OACA1F,GAAA,QACAC,KAAA,QACAH,KAAA,UACAI,OAAA,KACAC,KAAA,WACAC,OAAA,WACAC,QAAA,GACAC,MAAA,OAEAC,EAAA,uCACA,sCACA,sCACA,qBACA8E,EAAA,IAEA4K,EAAA,uCACA,sCACA,sCACA,qBACAnP,EAAA,uCACA,sCACA,sCACA,qBACAC,EAAA,IAEAE,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","sources":["webpack://_N_E/./node_modules/bcrypto/lib/js/elliptic.js","webpack://_N_E/<anon>"],"sourcesContent":["/*!\n * elliptic.js - elliptic curves for bcrypto\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on indutny/elliptic:\n *   Copyright (c) 2014, Fedor Indutny (MIT License).\n *   https://github.com/indutny/elliptic\n *\n * Formulas from DJB and Tanja Lange [EFD].\n *\n * References:\n *\n *   [GECC] Guide to Elliptic Curve Cryptography\n *     D. Hankerson, A. Menezes, and S. Vanstone\n *     https://tinyurl.com/guide-to-ecc\n *\n *   [GLV] Faster Point Multiplication on Elliptic Curves\n *     R. Gallant, R. Lambert, and S. Vanstone\n *     https://link.springer.com/content/pdf/10.1007/3-540-44647-8_11.pdf\n *\n *   [MONT1] Montgomery curves and the Montgomery ladder\n *     Daniel J. Bernstein, Tanja Lange\n *     https://eprint.iacr.org/2017/293.pdf\n *\n *   [SQUARED] Elligator Squared\n *     Mehdi Tibouchi\n *     https://eprint.iacr.org/2014/043.pdf\n *\n *   [SEC1] SEC 1 - Standards for Efficient Cryptography Group\n *     Certicom Research\n *     https://www.secg.org/sec1-v2.pdf\n *\n *   [SEC2] SEC 2: Recommended Elliptic Curve Domain Parameters\n *     Certicom Research\n *     https://www.secg.org/sec2-v2.pdf\n *\n *   [SIDE1] Elliptic Curves and Side-Channel Attacks\n *     Marc Joye\n *     https://pdfs.semanticscholar.org/8d69/9645033e25d74fcfd4cbf07a770d2e943e14.pdf\n *\n *   [BLIND] Side-Channel Analysis on Blinding Regular Scalar Multiplications\n *     B. Feix, M. Roussellet, A. Venelli\n *     https://eprint.iacr.org/2014/191.pdf\n *\n *   [ALT] Alternative Elliptic Curve Representations\n *     R. Struik\n *     https://tools.ietf.org/id/draft-ietf-lwig-curve-representations-02.html\n *\n *   [ARITH1] Arithmetic of Elliptic Curves\n *     Christophe Doche, Tanja Lange\n *     Handbook of Elliptic and Hyperelliptic Curve Cryptography\n *     Page 267, Section 13 (978-1-58488-518-4)\n *     https://hyperelliptic.org/HEHCC/index.html\n *\n *   [ARITH2] The Arithmetic of Elliptic Curves, 2nd Edition\n *     Joseph H. Silverman\n *     http://www.pdmi.ras.ru/~lowdimma/BSD/Silverman-Arithmetic_of_EC.pdf\n *\n *   [EFD] Explicit-Formulas Database\n *     Daniel J. Bernstein, Tanja Lange\n *     https://hyperelliptic.org/EFD/index.html\n *\n *   [SAFE] SafeCurves: choosing safe curves for elliptic-curve cryptography\n *     Daniel J. Bernstein\n *     https://safecurves.cr.yp.to/\n *\n *   [4GLV] Refinement of the Four-Dimensional GLV Method on Elliptic Curves\n *     Hairong Yi, Yuqing Zhu, and Dongdai Lin\n *     http://www.site.uottawa.ca/~cadams/papers/prepro/paper_19_slides.pdf\n *\n *   [SSWU1] Efficient Indifferentiable Hashing into Ordinary Elliptic Curves\n *     E. Brier, J. Coron, T. Icart, D. Madore, H. Randriam, M. Tibouchi\n *     https://eprint.iacr.org/2009/340.pdf\n *\n *   [SSWU2] Rational points on certain hyperelliptic curves over finite fields\n *     Maciej Ulas\n *     https://arxiv.org/abs/0706.1448\n *\n *   [H2EC] Hashing to Elliptic Curves\n *     A. Faz-Hernandez, S. Scott, N. Sullivan, R. S. Wahby, C. A. Wood\n *     https://git.io/JeWz6\n *     https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve\n *\n *   [SVDW1] Construction of Rational Points on Elliptic Curves\n *     A. Shallue, C. E. van de Woestijne\n *     https://works.bepress.com/andrew_shallue/1/download/\n *\n *   [SVDW2] Indifferentiable Hashing to Barreto-Naehrig Curves\n *     Pierre-Alain Fouque, Mehdi Tibouchi\n *     https://www.di.ens.fr/~fouque/pub/latincrypt12.pdf\n *\n *   [SVDW3] Covert ECDH over secp256k1\n *     Pieter Wuille\n *     https://gist.github.com/sipa/29118d3fcfac69f9930d57433316c039\n *\n *   [MONT2] Montgomery Curve (wikipedia)\n *     https://en.wikipedia.org/wiki/Montgomery_curve\n *\n *   [MONT3] Montgomery Curves and their arithmetic\n *     C. Costello, B. Smith\n *     https://eprint.iacr.org/2017/212.pdf\n *\n *   [ELL2] Elliptic-curve points indistinguishable from uniform random strings\n *     D. Bernstein, M. Hamburg, A. Krasnova, T. Lange\n *     https://elligator.cr.yp.to/elligator-20130828.pdf\n *\n *   [RFC7748] Elliptic Curves for Security\n *     A. Langley, M. Hamburg, S. Turner\n *     https://tools.ietf.org/html/rfc7748\n *\n *   [TWISTED] Twisted Edwards Curves\n *     D. Bernstein, P. Birkner, M. Joye, T. Lange, C. Peters\n *     https://eprint.iacr.org/2008/013.pdf\n *\n *   [ELL1] Injective Encodings to Elliptic Curves\n *     P. Fouque, A. Joux, M. Tibouchi\n *     https://eprint.iacr.org/2013/373.pdf\n *\n *   [ISOGENY] Twisting Edwards curves with isogenies\n *     Mike Hamburg\n *     https://www.shiftleft.org/papers/isogeny/isogeny.pdf\n *\n *   [RFC8032] Edwards-Curve Digital Signature Algorithm (EdDSA)\n *     S. Josefsson, SJD AB, I. Liusvaara\n *     https://tools.ietf.org/html/rfc8032\n *\n *   [SCHNORR] Schnorr Signatures for secp256k1\n *     Pieter Wuille\n *     https://github.com/sipa/bips/blob/d194620/bip-schnorr.mediawiki\n *\n *   [BIP340] Schnorr Signatures for secp256k1\n *     Pieter Wuille, Jonas Nick, Tim Ruffing\n *     https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n *\n *   [JCEN12] Efficient Software Implementation of Public-Key Cryptography\n *            on Sensor Networks Using the MSP430X Microcontroller\n *     C. P. L. Gouvea, L. B. Oliveira, J. Lopez\n *     http://conradoplg.cryptoland.net/files/2010/12/jcen12.pdf\n *\n *   [FIPS186] Federal Information Processing Standards Publication\n *     National Institute of Standards and Technology\n *     https://tinyurl.com/fips-186-3\n *\n *   [RFC5639] Elliptic Curve Cryptography (ECC) Brainpool\n *             Standard Curves and Curve Generation\n *     M. Lochter, BSI, J. Merkle\n *     https://tools.ietf.org/html/rfc5639\n *\n *   [TWISTEQ] Twisted Edwards & Short Weierstrass Equivalence\n *     Christopher Jeffrey\n *     https://gist.github.com/chjj/16ba7fa08d64e8dda269a9fe5b2a8bbc\n *\n *   [ECPM] Elliptic Curve Point Multiplication (wikipedia)\n *     https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication\n */\n\n'use strict';\n\nconst {custom} = require('../internal/custom');\nconst BN = require('../bn');\n\n/*\n * Constants\n */\n\nconst types = {\n  AFFINE: 0,\n  JACOBIAN: 1,\n  PROJECTIVE: 2,\n  EXTENDED: 3\n};\n\nconst jsfIndex = [\n  -3, // -1 -1\n  -1, // -1 0\n  -5, // -1 1\n  -7, // 0 -1\n  0, // 0 0\n  7, // 0 1\n  5, // 1 -1\n  1, // 1 0\n  3  // 1 1\n];\n\nconst USE_FIXED = false;\n\nlet uid = 0;\n\n/**\n * Curve\n */\n\nclass Curve {\n  constructor(Point, type, conf) {\n    this.Point = null;\n    this.id = null;\n    this.uid = uid++;\n    this.ossl = null;\n    this.type = 'base';\n    this.endian = 'be';\n    this.hash = null;\n    this.prefix = null;\n    this.context = false;\n    this.prime = null;\n    this.p = null;\n    this.red = null;\n    this.fieldSize = 0;\n    this.fieldBits = 0;\n    this.adjustedSize = 0;\n    this.signBit = 0;\n    this.mask = 0;\n    this.n = null;\n    this.h = null;\n    this.q = null;\n    this.z = null;\n    this.g = null;\n    this.nh = null;\n    this.scalarSize = 0;\n    this.scalarBits = 0;\n    this.zero = null;\n    this.one = null;\n    this.two = null;\n    this.three = null;\n    this.four = null;\n    this.i2 = null;\n    this.i3 = null;\n    this.i4 = null;\n    this.i6 = null;\n    this.torsion = null;\n    this.endo = null;\n    this.hi = null;\n    this._init(Point, type, conf);\n  }\n\n  _init(Point, type, conf) {\n    assert(typeof Point === 'function');\n    assert(typeof type === 'string');\n    assert(conf && typeof conf === 'object');\n    assert(conf.red == null || (conf.red instanceof BN.Red));\n    assert(conf.p != null, 'Must pass a prime.');\n    assert(conf.id == null || typeof conf.id === 'string');\n    assert(conf.ossl == null || typeof conf.ossl === 'string');\n    assert(conf.endian == null || typeof conf.endian === 'string');\n    assert(conf.hash == null || typeof conf.hash === 'string');\n    assert(conf.prefix == null || typeof conf.prefix === 'string');\n    assert(conf.context == null || typeof conf.context === 'boolean');\n    assert(conf.prime == null || typeof conf.prime === 'string');\n    assert(conf.torsion == null || Array.isArray(conf.torsion));\n\n    // Point class.\n    this.Point = Point;\n\n    // Meta.\n    this.id = conf.id || null;\n    this.ossl = conf.ossl || null;\n    this.type = type;\n    this.endian = conf.endian || (type === 'short' ? 'be' : 'le');\n    this.hash = conf.hash || null;\n    this.prefix = conf.prefix ? Buffer.from(conf.prefix, 'binary') : null;\n    this.context = conf.context || false;\n    this.prime = conf.prime || null;\n\n    // Prime.\n    this.p = BN.fromJSON(conf.p);\n\n    // Reduction.\n    if (conf.red) {\n      this.red = conf.red;\n    } else {\n      // Use Montgomery when there is no fast reduction for the prime.\n      this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);\n      this.red.precompute();\n    }\n\n    // Precalculate encoding length.\n    this.fieldSize = this.p.byteLength();\n    this.fieldBits = this.p.bitLength();\n    this.adjustedSize = this.fieldSize + ((this.fieldBits & 7) === 0);\n    this.signBit = this.adjustedSize * 8 - 1;\n    this.mask = 0xff;\n\n    if ((this.fieldBits & 7) !== 0)\n      this.mask = (1 << (this.fieldBits & 7)) - 1;\n\n    // Curve configuration, optional.\n    this.n = BN.fromJSON(conf.n || '0');\n    this.h = BN.fromJSON(conf.h || '1');\n    this.q = this.n.mul(this.h);\n    this.z = BN.fromJSON(conf.z || '0').toRed(this.red);\n    this.g = null;\n    this.nh = this.n.ushrn(1);\n    this.scalarSize = this.n.byteLength();\n    this.scalarBits = this.n.bitLength();\n\n    // Useful for many curves.\n    this.zero = new BN(0).toRed(this.red);\n    this.one = new BN(1).toRed(this.red);\n    this.two = new BN(2).toRed(this.red);\n    this.three = new BN(3).toRed(this.red);\n    this.four = new BN(4).toRed(this.red);\n\n    // Inverses.\n    this.i2 = this.two.redInvert();\n    this.i3 = this.three.redInvert();\n    this.i4 = this.i2.redSqr();\n    this.i6 = this.i2.redMul(this.i3);\n\n    // Torsion.\n    this.torsion = new Array(this.h.word(0));\n\n    for (let i = 0; i < this.torsion.length; i++)\n      this.torsion[i] = this.point();\n\n    // Endomorphism.\n    this.endo = null;\n\n    // Cache.\n    this.hi = null;\n\n    // Memoize.\n    this._scale = memoize(this._scale, this);\n    this.isIsomorphic = memoize(this.isIsomorphic, this);\n    this.isIsogenous = memoize(this.isIsogenous, this);\n\n    // Sanity checks.\n    assert(this.p.sign() > 0 && this.p.isOdd());\n    assert(this.n.sign() >= 0);\n    assert(this.h.sign() > 0 && this.h.cmpn(255) <= 0);\n    assert(this.endian === 'be' || this.endian === 'le');\n\n    return this;\n  }\n\n  _finalize(conf) {\n    assert(conf && typeof conf === 'object');\n\n    // Create base point.\n    this.g = conf.g ? this.pointFromJSON(conf.g) : this.point();\n\n    // Parse small order points.\n    if (conf.torsion) {\n      assert(conf.torsion.length === this.torsion.length);\n\n      for (let i = 0; i < this.torsion.length; i++)\n        this.torsion[i] = this.pointFromJSON(conf.torsion[i]);\n    }\n\n    return this;\n  }\n\n  _findTorsion() {\n    // Find all torsion points by grinding.\n    assert(!this.n.isZero());\n\n    const h = this.h.word(0);\n    const x = this.one.redNeg();\n    const out = [this.point()];\n    const set = new Set();\n\n    let len = h;\n\n    while (out.length < len) {\n      let p;\n\n      x.redIAdd(this.one);\n\n      try {\n        p = this.pointFromX(x.clone());\n      } catch (e) {\n        continue;\n      }\n\n      try {\n        p = p.mul(this.n);\n      } catch (e) {\n        len = 2;\n        continue;\n      }\n\n      if (p.isInfinity())\n        continue;\n\n      p.normalize();\n\n      for (const point of [p, p.neg()]) {\n        const key = point.key();\n\n        if (!set.has(key)) {\n          out.push(point);\n          set.add(key);\n        }\n      }\n    }\n\n    out.sort((a, b) => a.cmp(b));\n\n    while (out.length < h)\n      out.push(this.point());\n\n    return out;\n  }\n\n  _fixedMul(p, k) {\n    // Fixed-base method for point multiplication.\n    //\n    // [ECPM] \"Windowed method\".\n    // [GECC] Page 95, Section 3.3.\n    //\n    // Windows are appropriately shifted to avoid any\n    // doublings. This reduces a 256 bit multiplication\n    // down to 64 additions with a window size of 4.\n    assert(p instanceof Point);\n    assert(k instanceof BN);\n    assert(p.pre && p.pre.windows);\n\n    // Get precomputed windows.\n    const {width, points} = p._getWindows(0, 0);\n\n    // Recompute window size.\n    const size = 1 << width;\n\n    // Recompute steps.\n    const bits = k.bitLength();\n    const steps = ((bits + width - 1) / width) >>> 0;\n\n    // Multiply.\n    let acc = this.jpoint();\n\n    for (let i = 0; i < steps; i++) {\n      const bits = k.bits(i * width, width);\n\n      acc = acc.add(points[i * size + bits]);\n    }\n\n    // Adjust sign.\n    if (k.isNeg())\n      acc = acc.neg();\n\n    return acc;\n  }\n\n  _fixedNafMul(p, k) {\n    // Fixed-base NAF windowing method for point multiplication.\n    //\n    // [GECC] Algorithm 3.42, Page 105, Section 3.3.\n    assert(p instanceof Point);\n    assert(k instanceof BN);\n    assert(p.pre && p.pre.doubles);\n\n    // Get precomputed doubles.\n    const {step, points} = p._getDoubles(0, 0);\n\n    // Get fixed NAF (in a more windowed form).\n    const naf = getFixedNAF(k, 2, k.bitLength() + 1, step);\n\n    // Compute steps.\n    const I = ((1 << (step + 1)) - (step % 2 === 0 ? 2 : 1)) / 3;\n\n    // Multiply.\n    let a = this.jpoint();\n    let b = this.jpoint();\n\n    for (let i = I; i > 0; i--) {\n      for (let j = 0; j < naf.length; j++) {\n        const nafW = naf[j];\n\n        if (nafW === i)\n          b = b.add(points[j]);\n        else if (nafW === -i)\n          b = b.sub(points[j]);\n      }\n\n      a = a.add(b);\n    }\n\n    return a;\n  }\n\n  _wnafMul(w, p, k) {\n    // Window NAF method for point multiplication.\n    //\n    // [GECC] Algorithm 3.36, Page 100, Section 3.3.\n    assert(p instanceof Point);\n    assert(k instanceof BN);\n\n    // Precompute window.\n    const {width, points} = p._safeNAF(w);\n\n    // Get NAF form.\n    const naf = getNAF(k, width, k.bitLength() + 1);\n\n    // Add `this`*(N+1) for every w-NAF index.\n    let acc = this.jpoint();\n\n    for (let i = naf.length - 1; i >= 0; i--) {\n      const z = naf[i];\n\n      if (i !== naf.length - 1)\n        acc = acc.dbl();\n\n      if (z > 0)\n        acc = acc.add(points[(z - 1) >> 1]);\n      else if (z < 0)\n        acc = acc.sub(points[(-z - 1) >> 1]);\n    }\n\n    return acc;\n  }\n\n  _wnafMulAdd(w, points, coeffs) {\n    // Multiple point multiplication, also known\n    // as \"Shamir's trick\" (with interleaved NAFs).\n    //\n    // [GECC] Algorithm 3.48, Page 109, Section 3.3.3.\n    //        Algorithm 3.51, Page 112, Section 3.3.\n    //\n    // This is particularly useful for signature\n    // verifications and mutiplications after an\n    // endomorphism split.\n    assert((w >>> 0) === w);\n    assert(Array.isArray(points));\n    assert(Array.isArray(coeffs));\n    assert(points.length === coeffs.length);\n\n    const length = points.length;\n    const wnd = new Array(length);\n    const naf = new Array(length);\n\n    // Check arrays and calculate size.\n    let max = 0;\n\n    for (let i = 0; i < length; i++) {\n      const point = points[i];\n      const coeff = coeffs[i];\n\n      assert(point instanceof Point);\n      assert(coeff instanceof BN);\n\n      if (i > 0 && point.type !== points[i - 1].type)\n        throw new Error('Cannot mix points.');\n\n      // Avoid sparse arrays.\n      wnd[i] = null;\n      naf[i] = null;\n\n      // Compute max scalar size.\n      max = Math.max(max, coeff.bitLength() + 1);\n    }\n\n    // Compute NAFs.\n    let ppoint = null;\n    let pcoeff = null;\n    let len = 0;\n\n    for (let i = 0; i < length; i++) {\n      const point = points[i];\n      const coeff = coeffs[i];\n      const pre = point._getNAF(0);\n\n      // Use precomputation if available.\n      if (pre) {\n        wnd[len] = pre.points;\n        naf[len] = getNAF(coeff, pre.width, max);\n        len += 1;\n        continue;\n      }\n\n      // Save last non-precomputed point.\n      if (!ppoint) {\n        ppoint = point;\n        pcoeff = coeff;\n        continue;\n      }\n\n      // Compute JSF in NAF form.\n      wnd[len] = ppoint._getJNAF(point);\n      naf[len] = getJNAF(pcoeff, coeff, max);\n\n      ppoint = null;\n      pcoeff = null;\n\n      len += 1;\n    }\n\n    // Regular NAF for odd points.\n    if (ppoint) {\n      const nafw = ppoint._safeNAF(w);\n\n      wnd[len] = nafw.points;\n      naf[len] = getNAF(pcoeff, nafw.width, max);\n\n      len += 1;\n    }\n\n    // Multiply and add.\n    let acc = this.jpoint();\n\n    for (let i = max - 1; i >= 0; i--) {\n      if (i !== max - 1)\n        acc = acc.dbl();\n\n      for (let j = 0; j < len; j++) {\n        const z = naf[j][i];\n\n        if (z > 0)\n          acc = acc.add(wnd[j][(z - 1) >> 1]);\n        else if (z < 0)\n          acc = acc.sub(wnd[j][(-z - 1) >> 1]);\n      }\n    }\n\n    return acc;\n  }\n\n  _endoWnafMulAdd(points, coeffs) {\n    throw new Error('Not implemented.');\n  }\n\n  _scale(curve, invert) {\n    assert(curve instanceof Curve);\n    assert(curve.p.eq(this.p));\n\n    switch (curve.type) {\n      case 'short':\n        return this._scaleShort(curve, invert);\n      case 'mont':\n        return this._scaleMont(curve, invert);\n      case 'edwards':\n        return this._scaleEdwards(curve, invert);\n      default:\n        throw new Error('Not implemented.');\n    }\n  }\n\n  _scaleShort(curve, invert) {\n    throw new Error('Not implemented.');\n  }\n\n  _scaleMont(curve, invert) {\n    throw new Error('Not implemented.');\n  }\n\n  _scaleEdwards(curve, invert) {\n    throw new Error('Not implemented.');\n  }\n\n  isElliptic() {\n    throw new Error('Not implemented.');\n  }\n\n  jinv() {\n    throw new Error('Not implemented.');\n  }\n\n  isComplete() {\n    return false;\n  }\n\n  precompute(rng) {\n    assert(!this.g.isInfinity(), 'Must have base point.');\n    assert(!this.n.isZero(), 'Must have order.');\n\n    this.g.precompute(this.n.bitLength(), rng);\n\n    return this;\n  }\n\n  scalar(num, base, endian) {\n    const k = new BN(num, base, endian);\n\n    assert(!k.red);\n\n    if (this.n.isZero())\n      return k;\n\n    return k.imod(this.n);\n  }\n\n  field(num, base, endian) {\n    const x = BN.cast(num, base, endian);\n\n    if (x.red)\n      return x.forceRed(this.red);\n\n    return x.toRed(this.red);\n  }\n\n  point(x, y) {\n    throw new Error('Not implemented.');\n  }\n\n  jpoint(x, y, z) {\n    throw new Error('Not implemented.');\n  }\n\n  xpoint(x, z) {\n    throw new Error('Not implemented.');\n  }\n\n  cpoint(xx, xz, yy, yz) {\n    assert(xx instanceof BN);\n    assert(xz instanceof BN);\n    assert(yy instanceof BN);\n    assert(yz instanceof BN);\n\n    if (xz.isZero() || yz.isZero())\n      return this.point();\n\n    const z = xz.redMul(yz).redInvert();\n    const x = xx.redMul(yz).redMul(z);\n    const y = yy.redMul(xz).redMul(z);\n\n    return this.point(x, y);\n  }\n\n  solveX2(y) {\n    throw new Error('Not implemented.');\n  }\n\n  solveX(y) {\n    return this.solveX2(y).redSqrt();\n  }\n\n  solveY2(x) {\n    throw new Error('Not implemented.');\n  }\n\n  solveY(x) {\n    return this.solveY2(x).redSqrt();\n  }\n\n  validate(point) {\n    throw new Error('Not implemented.');\n  }\n\n  pointFromX(x, sign) {\n    throw new Error('Not implemented.');\n  }\n\n  pointFromY(y, sign) {\n    throw new Error('Not implemented.');\n  }\n\n  isIsomorphic(curve) {\n    throw new Error('Not implemented.');\n  }\n\n  isIsogenous(curve) {\n    throw new Error('Not implemented.');\n  }\n\n  pointFromShort(point) {\n    throw new Error('Not implemented.');\n  }\n\n  pointFromMont(point, sign) {\n    throw new Error('Not implemented.');\n  }\n\n  pointFromEdwards(point) {\n    throw new Error('Not implemented.');\n  }\n\n  pointFromUniform(u) {\n    throw new Error('Not implemented.');\n  }\n\n  pointToUniform(p) {\n    throw new Error('Not implemented.');\n  }\n\n  pointFromHash(bytes, pake = false) {\n    // [H2EC] \"Roadmap\".\n    assert(Buffer.isBuffer(bytes));\n    assert(typeof pake === 'boolean');\n\n    if (bytes.length !== this.fieldSize * 2)\n      throw new Error('Invalid hash size.');\n\n    // Random oracle encoding.\n    // Ensure a proper distribution.\n    const s1 = bytes.slice(0, this.fieldSize);\n    const s2 = bytes.slice(this.fieldSize);\n    const u1 = this.decodeUniform(s1);\n    const u2 = this.decodeUniform(s2);\n    const p1 = this.pointFromUniform(u1);\n    const p2 = this.pointFromUniform(u2);\n    const p3 = p1.add(p2);\n\n    return pake ? p3.mulH() : p3;\n  }\n\n  pointToHash(p, subgroup, rng) {\n    // [SQUARED] Algorithm 1, Page 8, Section 3.3.\n    assert(p instanceof this.Point);\n    assert((subgroup >>> 0) === subgroup);\n\n    // Add a random torsion component.\n    const i = subgroup % this.torsion.length;\n    const p0 = p.add(this.torsion[i]);\n\n    // Average Cost (R = sqrt):\n    //\n    //   SSWU (~4 iterations) => 8I + 16R\n    //   SVDW (~4 iterations) => 12I + 28R\n    //   Elligator 1 (~2 iterations) => 6I + 10R\n    //   Elligator 2 (~2 iterations) => 4I + 6R\n    //   Ristretto (~1 iteration) => 1I + 2R + h*1R\n    for (;;) {\n      const u1 = this.randomField(rng);\n      const p1 = this.pointFromUniform(u1);\n\n      // Avoid 2-torsion points:\n      //   Short Weierstrass: ((A / 3) / B, 0)\n      //   Montgomery: (0, 0)\n      //   Twisted Edwards: (0, -1)\n      if (p1.neg().eq(p1))\n        continue;\n\n      const p2 = p0.sub(p1);\n      const hint = randomInt(rng);\n\n      let u2;\n      try {\n        u2 = this.pointToUniform(p2, hint & 15);\n      } catch (e) {\n        if (e.message === 'Invalid point.')\n          continue;\n        throw e;\n      }\n\n      const s1 = this.encodeUniform(u1, hint >>> 8);\n      const s2 = this.encodeUniform(u2, hint >>> 16);\n\n      return Buffer.concat([s1, s2]);\n    }\n  }\n\n  randomScalar(rng) {\n    const max = this.n.isZero() ? this.p : this.n;\n    return BN.random(rng, 1, max);\n  }\n\n  randomField(rng) {\n    return BN.random(rng, 1, this.p).toRed(this.red);\n  }\n\n  randomPoint(rng) {\n    let p;\n\n    for (;;) {\n      const x = this.randomField(rng);\n      const sign = (randomInt(rng) & 1) !== 0;\n\n      try {\n        p = this.pointFromX(x, sign);\n      } catch (e) {\n        continue;\n      }\n\n      assert(p.validate());\n\n      return p.mulH();\n    }\n  }\n\n  mulAll(points, coeffs) {\n    return this.jmulAll(points, coeffs);\n  }\n\n  jmulAll(points, coeffs) {\n    assert(Array.isArray(points));\n    assert(points.length === 0 || (points[0] instanceof Point));\n\n    // Multiply with endomorphism if we're using affine points.\n    if (this.endo && points.length > 0 && points[0].type === types.AFFINE)\n      return this._endoWnafMulAdd(points, coeffs);\n\n    // Otherwise, a regular Shamir's trick.\n    return this._wnafMulAdd(5, points, coeffs);\n  }\n\n  mulH(k) {\n    assert(k instanceof BN);\n    return this.imulH(k.clone());\n  }\n\n  imulH(k) {\n    assert(k instanceof BN);\n    assert(!k.red);\n\n    const word = this.h.word(0);\n\n    // Optimize for powers of two.\n    if ((word & (word - 1)) === 0) {\n      const bits = this.h.bitLength();\n      return k.iushln(bits - 1).imod(this.n);\n    }\n\n    return k.imuln(word).imod(this.n);\n  }\n\n  normalizeAll(points) {\n    assert(Array.isArray(points));\n\n    const len = points.length;\n    const z = new Array(len);\n\n    for (let i = 0; i < len; i++) {\n      const p = points[i];\n\n      assert(p instanceof Point);\n      assert(p.curve === this);\n\n      if (p.type === types.AFFINE) {\n        z[i] = this.one;\n        continue;\n      }\n\n      z[i] = p.z;\n    }\n\n    const zi = this.red.invertAll(z);\n    const out = new Array(len);\n\n    for (let i = 0; i < len; i++)\n      out[i] = points[i].scale(zi[i]);\n\n    return out;\n  }\n\n  affinizeAll(points) {\n    return this.normalizeAll(points);\n  }\n\n  clamp(scalar) {\n    // [RFC7748] Page 8, Section 5.\n    // [RFC8032] Section 5.1.5 & 5.2.5.\n    assert(Buffer.isBuffer(scalar));\n    assert(scalar.length === this.scalarSize);\n    assert(this.scalarSize <= this.fieldSize);\n\n    let top = (this.fieldBits & 7) || 8;\n    let lsb = 0;\n    let msb = this.scalarSize - 1;\n\n    // Swap endianness.\n    if (this.endian === 'be')\n      [lsb, msb] = [msb, lsb];\n\n    // Adjust for low order.\n    if (this.scalarSize < this.fieldSize)\n      top = 8;\n\n    // Ensure a multiple of the cofactor.\n    scalar[lsb] &= -this.h.word(0) & 0xff;\n\n    // Clamp to the prime.\n    scalar[msb] &= (1 << top) - 1;\n\n    // Set the high bit.\n    scalar[msb] |= 1 << (top - 1);\n\n    return scalar;\n  }\n\n  splitHash(bytes) {\n    // [RFC8032] Section 5.1.6 & 5.2.6.\n    assert(Buffer.isBuffer(bytes));\n    assert(bytes.length === this.adjustedSize * 2);\n    assert(this.scalarSize <= this.adjustedSize);\n\n    let off = 0;\n\n    if (this.endian === 'be')\n      off = this.adjustedSize - this.scalarSize;\n\n    const scalar = bytes.slice(off, off + this.scalarSize);\n    const prefix = bytes.slice(this.adjustedSize);\n\n    this.clamp(scalar);\n\n    return [scalar, prefix];\n  }\n\n  encodeField(x) {\n    // [SEC1] Page 12, Section 2.3.5.\n    assert(x instanceof BN);\n    assert(!x.red);\n\n    return x.encode(this.endian, this.fieldSize);\n  }\n\n  decodeField(bytes) {\n    // [SEC1] Page 13, Section 2.3.6.\n    assert(Buffer.isBuffer(bytes));\n\n    if (bytes.length !== this.fieldSize)\n      throw new Error('Invalid field element size.');\n\n    return BN.decode(bytes, this.endian);\n  }\n\n  encodeAdjusted(x) {\n    assert(x instanceof BN);\n    assert(!x.red);\n\n    return x.encode(this.endian, this.adjustedSize);\n  }\n\n  decodeAdjusted(bytes) {\n    assert(Buffer.isBuffer(bytes));\n\n    if (bytes.length !== this.adjustedSize)\n      throw new Error('Invalid field element size.');\n\n    return BN.decode(bytes, this.endian);\n  }\n\n  encodeScalar(k) {\n    // [SEC1] Page 13, Section 2.3.7.\n    assert(k instanceof BN);\n    assert(!k.red);\n\n    return k.encode(this.endian, this.scalarSize);\n  }\n\n  decodeScalar(bytes) {\n    // [SEC1] Page 14, Section 2.3.8.\n    assert(Buffer.isBuffer(bytes));\n\n    if (bytes.length !== this.scalarSize)\n      throw new Error('Invalid scalar size.');\n\n    return BN.decode(bytes, this.endian);\n  }\n\n  encodeClamped(k) {\n    // [RFC7748] Page 8, Section 5.\n    // [RFC8032] Section 5.1.5 & 5.2.5.\n    return this.clamp(this.encodeScalar(k));\n  }\n\n  decodeClamped(bytes) {\n    // [RFC7748] Page 8, Section 5.\n    // [RFC8032] Section 5.1.5 & 5.2.5.\n    assert(Buffer.isBuffer(bytes));\n\n    if (bytes.length !== this.scalarSize)\n      throw new Error('Invalid scalar size.');\n\n    const clamped = this.clamp(Buffer.from(bytes));\n\n    return BN.decode(clamped, this.endian);\n  }\n\n  encodeUniform(x, bits) {\n    assert(x instanceof BN);\n    assert((bits >>> 0) === bits);\n\n    const msb = this.endian === 'le' ? this.fieldSize - 1 : 0;\n    const bytes = x.fromRed().encode(this.endian, this.fieldSize);\n\n    bytes[msb] |= (bits & ~this.mask) & 0xff;\n\n    return bytes;\n  }\n\n  decodeUniform(bytes) {\n    assert(Buffer.isBuffer(bytes));\n\n    if (bytes.length !== this.fieldSize)\n      throw new Error('Invalid field size.');\n\n    const x = BN.decode(bytes, this.endian);\n\n    x.iumaskn(this.fieldBits);\n\n    return x.toRed(this.red);\n  }\n\n  encodePoint(point, compact) {\n    assert(point instanceof Point);\n    return point.encode(compact);\n  }\n\n  decodePoint(bytes) {\n    throw new Error('Not implemented.');\n  }\n\n  encodeX(point) {\n    throw new Error('Not implemented.');\n  }\n\n  decodeX(bytes) {\n    throw new Error('Not implemented.');\n  }\n\n  decodeEven(bytes) {\n    throw new Error('Not implemented.');\n  }\n\n  decodeSquare(bytes) {\n    throw new Error('Not implemented.');\n  }\n\n  toShort() {\n    throw new Error('Not implemented.');\n  }\n\n  toMont(b0) {\n    throw new Error('Not implemented.');\n  }\n\n  toEdwards(a0) {\n    throw new Error('Not implemented.');\n  }\n\n  pointToJSON(point, pre) {\n    assert(point instanceof Point);\n    return point.toJSON(pre);\n  }\n\n  pointFromJSON(json) {\n    throw new Error('Not implemented.');\n  }\n\n  toJSON(pre) {\n    let prefix, context;\n    let n, z, endo;\n\n    if (this.type === 'edwards') {\n      prefix = this.prefix ? this.prefix.toString() : null;\n      context = this.context;\n    }\n\n    if (!this.n.isZero())\n      n = this.n.toJSON();\n\n    if (!this.z.isZero()) {\n      z = this.z.fromRed();\n\n      if (this.z.redIsHigh())\n        z.isub(this.p);\n\n      z = z.toString(16);\n    }\n\n    if (this.endo)\n      endo = this.endo.toJSON();\n\n    return {\n      id: this.id,\n      ossl: this.ossl,\n      type: this.type,\n      endian: this.endian,\n      hash: this.hash,\n      prefix,\n      context,\n      prime: this.prime,\n      p: this.p.toJSON(),\n      a: undefined,\n      b: undefined,\n      d: undefined,\n      n,\n      h: this.h.toString(16),\n      s: undefined,\n      z,\n      c: undefined,\n      g: this.g.toJSON(pre),\n      endo\n    };\n  }\n\n  static fromJSON(json) {\n    return new this(json);\n  }\n}\n\n/**\n * Point\n */\n\nclass Point {\n  constructor(curve, type) {\n    assert(curve instanceof Curve);\n    assert((type >>> 0) === type);\n\n    this.curve = curve;\n    this.type = type;\n    this.pre = null;\n  }\n\n  _init() {\n    throw new Error('Not implemented.');\n  }\n\n  _safeNAF(width) {\n    assert((width >>> 0) === width);\n\n    if (this.pre && this.pre.naf)\n      return this.pre.naf;\n\n    if (width === 0)\n      return null;\n\n    const size = 1 << (width - 2);\n    const points = new Array(size);\n    const p = this.toJ();\n    const dbl = size === 1 ? null : p.dbl();\n\n    points[0] = p;\n\n    for (let i = 1; i < size; i++)\n      points[i] = points[i - 1].add(dbl);\n\n    return new NAF(width, points);\n  }\n\n  _getNAF(width) {\n    assert((width >>> 0) === width);\n\n    if (this.pre && this.pre.naf)\n      return this.pre.naf;\n\n    if (width === 0)\n      return null;\n\n    const odds = this._safeNAF(width).points;\n    const points = this.curve.affinizeAll(odds);\n\n    return new NAF(width, points);\n  }\n\n  _getWindows(width, bits) {\n    assert((width >>> 0) === width);\n    assert((bits >>> 0) === bits);\n\n    if (this.pre && this.pre.windows)\n      return this.pre.windows;\n\n    if (width === 0)\n      return null;\n\n    const size = 1 << width;\n    const steps = ((bits + width - 1) / width) >>> 0;\n    const wnds = new Array(steps * size);\n\n    let g = this.toJ();\n\n    for (let i = 0; i < steps; i++) {\n      wnds[i * size] = this.curve.jpoint();\n\n      for (let j = 1; j < size; j++)\n        wnds[i * size + j] = wnds[i * size + j - 1].add(g);\n\n      g = g.dblp(width);\n    }\n\n    const points = this.curve.affinizeAll(wnds);\n\n    return new Windows(width, bits, points);\n  }\n\n  _getDoubles(step, power) {\n    assert((step >>> 0) === step);\n    assert((power >>> 0) === power);\n\n    if (this.pre && this.pre.doubles)\n      return this.pre.doubles;\n\n    if (step === 0)\n      return null;\n\n    const len = Math.ceil(power / step) + 1;\n    const dbls = new Array(len);\n\n    let acc = this.toJ();\n    let k = 0;\n\n    dbls[k++] = acc;\n\n    for (let i = 0; i < power; i += step) {\n      for (let j = 0; j < step; j++)\n        acc = acc.dbl();\n\n      dbls[k++] = acc;\n    }\n\n    assert(k === len);\n\n    const points = this.curve.affinizeAll(dbls);\n\n    return new Doubles(step, points);\n  }\n\n  _getBeta() {\n    return null;\n  }\n\n  _getBlinding(rng) {\n    if (this.pre && this.pre.blinding)\n      return this.pre.blinding;\n\n    if (!rng)\n      return null;\n\n    if (this.curve.n.isZero())\n      return null;\n\n    // Pregenerate a random blinding value:\n    //\n    //   blind = random integer in [1,n-1]\n    //   unblind = G * blind\n    //\n    // We intend to subtract the blinding value\n    // from scalars before multiplication. We\n    // can add the unblinding point once the\n    // multiplication is complete.\n    const blind = this.curve.randomScalar(rng);\n    const unblind = this.mul(blind);\n\n    return new Blinding(blind, unblind);\n  }\n\n  _hasWindows(k) {\n    assert(k instanceof BN);\n\n    if (!this.pre || !this.pre.windows)\n      return false;\n\n    const {width, bits} = this.pre.windows;\n    const steps = ((bits + width - 1) / width) >>> 0;\n\n    return k.bitLength() <= steps * width;\n  }\n\n  _hasDoubles(k) {\n    assert(k instanceof BN);\n\n    if (!this.pre || !this.pre.doubles)\n      return false;\n\n    const {step, points} = this.pre.doubles;\n    const power = k.bitLength() + 1;\n\n    return points.length >= Math.ceil(power / step) + 1;\n  }\n\n  _getJNAF(point) {\n    assert(point instanceof Point);\n    assert(point.type === this.type);\n\n    // Create comb for JSF.\n    return [\n      this, // 1\n      this.add(point), // 3\n      this.sub(point), // 5\n      point // 7\n    ];\n  }\n\n  _blind(k, rng) {\n    // [SIDE1] Page 5, Section 4.\n    // [BLIND] Page 20, Section 7.\n    assert(k instanceof BN);\n    assert(!k.red);\n\n    // Scalar splitting (requires precomputation).\n    //\n    // Blind a multiplication by first subtracting\n    // a blinding value from the scalar. Example:\n    //\n    //   b = random integer in [1,n-1]\n    //   B = P * b (precomputed)\n    //   Q = P * (k - b) + B\n    //\n    // Note that Joye describes a different method\n    // (multiplier randomization) which computes:\n    //\n    //   B = random point in E\n    //   Q = (P + B) * k - B * k\n    //\n    // Our method is more similar to the \"scalar\n    // splitting\" technique described in the\n    // second source above.\n    //\n    // The blinding value and its corresponding\n    // point are randomly generated and computed\n    // on boot. As long as an attacker is not\n    // able to observe the boot, this should give\n    // a decent bit of protection against various\n    // channel attacks.\n    if (this.pre && this.pre.blinding) {\n      const {blind, unblind} = this.pre.blinding;\n      const t = k.sub(blind);\n\n      return [this, t, unblind];\n    }\n\n    // Randomization is not possible without\n    // an RNG. Do a normal multiplication.\n    if (!rng)\n      return [this, k, null];\n\n    // If we have no precomputed blinding\n    // factor, there are two possibilities\n    // for randomization:\n    //\n    // 1. Randomize the multiplier by adding\n    //    a random multiple of `n`.\n    //\n    // 2. Re-scale the point itself by a\n    //    random factor.\n    //\n    // The first option can be accomplished\n    // with some like:\n    //\n    //   a = random integer in [1,n-1]\n    //   r = a * n\n    //   Q = P * (k + r)\n    //\n    // The second is accomplished with:\n    //\n    //   a = random element in F(p)\n    //   R = (x * a^2, y * a^3, z * a)\n    //   Q = R * k\n    //\n    // If we have precomputed doubles / naf\n    // points, we opt for the first method\n    // to avoid randomizing everything.\n    if (this.pre) {\n      if (this.curve.n.isZero())\n        return [this, k, null];\n\n      const a = this.curve.randomScalar(rng);\n      const r = a.mul(this.curve.n);\n      const t = r.iadd(k);\n\n      return [this, t, null];\n    }\n\n    // If there is no precomputation _at all_,\n    // we opt for the second method.\n    const p = this.randomize(rng);\n\n    return [p, k, null];\n  }\n\n  clone() {\n    throw new Error('Not implemented.');\n  }\n\n  precompute(bits, rng) {\n    assert((bits >>> 0) === bits);\n\n    if (!this.pre)\n      this.pre = new Precomp();\n\n    if (!this.pre.naf)\n      this.pre.naf = this._getNAF(9);\n\n    if (USE_FIXED && !this.pre.windows)\n      this.pre.windows = this._getWindows(4, bits);\n\n    if (!this.pre.doubles)\n      this.pre.doubles = this._getDoubles(4, bits + 1);\n\n    if (!this.pre.beta)\n      this.pre.beta = this._getBeta();\n\n    if (!this.pre.blinding)\n      this.pre.blinding = this._getBlinding(rng);\n\n    return this;\n  }\n\n  validate() {\n    return this.curve.validate(this);\n  }\n\n  normalize() {\n    return this;\n  }\n\n  scale(a) {\n    throw new Error('Not implemented.');\n  }\n\n  randomize(rng) {\n    const z = this.curve.randomField(rng);\n    return this.scale(z);\n  }\n\n  neg() {\n    throw new Error('Not implemented.');\n  }\n\n  add(point) {\n    throw new Error('Not implemented.');\n  }\n\n  sub(point) {\n    assert(point instanceof Point);\n    return this.add(point.neg());\n  }\n\n  dbl() {\n    throw new Error('Not implemented.');\n  }\n\n  dblp(pow) {\n    // Repeated doubling. This can\n    // be optimized by child classes.\n    assert((pow >>> 0) === pow);\n\n    let r = this;\n\n    for (let i = 0; i < pow; i++)\n      r = r.dbl();\n\n    return r;\n  }\n\n  diffAddDbl(p, q) {\n    throw new Error('Not implemented.');\n  }\n\n  getX() {\n    throw new Error('Not implemented.');\n  }\n\n  getY() {\n    throw new Error('Not implemented.');\n  }\n\n  eq(point) {\n    throw new Error('Not implemented.');\n  }\n\n  cmp(point) {\n    throw new Error('Not implemented.');\n  }\n\n  isInfinity() {\n    throw new Error('Not implemented.');\n  }\n\n  isOrder2() {\n    throw new Error('Not implemented.');\n  }\n\n  isOdd() {\n    throw new Error('Not implemented.');\n  }\n\n  isEven() {\n    throw new Error('Not implemented.');\n  }\n\n  isSquare() {\n    throw new Error('Not implemented.');\n  }\n\n  eqX(x) {\n    throw new Error('Not implemented.');\n  }\n\n  eqR(x) {\n    throw new Error('Not implemented.');\n  }\n\n  isSmall() {\n    // Test whether the point is of small order.\n    if (this.isInfinity())\n      return false;\n\n    // P * h = O\n    return this.jmulH().isInfinity();\n  }\n\n  hasTorsion() {\n    // Test whether the point is in another subgroup.\n    if (this.isInfinity())\n      return false;\n\n    // P * n != O\n    return !this.jmul(this.curve.n).isInfinity();\n  }\n\n  order() {\n    // Calculate point order.\n    const {h, n} = this.curve;\n\n    let p = this.toJ();\n    let q = new BN(1);\n\n    while (!p.isInfinity()) {\n      q.iaddn(1);\n\n      if (q.cmp(h) > 0) {\n        q = n.clone();\n        break;\n      }\n\n      p = p.add(this);\n    }\n\n    return q;\n  }\n\n  mul(k) {\n    return this.jmul(k);\n  }\n\n  muln(k) {\n    return this.jmuln(k);\n  }\n\n  mulBlind(k, rng) {\n    return this.jmulBlind(k, rng);\n  }\n\n  mulAdd(k1, p2, k2) {\n    return this.jmulAdd(k1, p2, k2);\n  }\n\n  mulH() {\n    return this.jmulH();\n  }\n\n  div(k) {\n    return this.jdiv(k);\n  }\n\n  divn(k) {\n    return this.jdivn(k);\n  }\n\n  divH() {\n    return this.jdivH();\n  }\n\n  jmul(k) {\n    if (USE_FIXED && this._hasWindows(k))\n      return this.curve._fixedMul(this, k);\n\n    if (this._hasDoubles(k))\n      return this.curve._fixedNafMul(this, k);\n\n    if (this.curve.endo && this.type === types.AFFINE)\n      return this.curve._endoWnafMulAdd([this], [k]);\n\n    return this.curve._wnafMul(5, this, k);\n  }\n\n  jmuln(k) {\n    assert((k | 0) === k);\n    return this.jmul(new BN(k));\n  }\n\n  jmulBlind(k, rng = null) {\n    const [p, t, unblind] = this._blind(k, rng);\n    const q = p.jmul(t);\n\n    if (unblind)\n      return q.add(unblind);\n\n    return q;\n  }\n\n  jmulAdd(k1, p2, k2) {\n    if (this.curve.endo && this.type === types.AFFINE)\n      return this.curve._endoWnafMulAdd([this, p2], [k1, k2]);\n\n    return this.curve._wnafMulAdd(5, [this, p2], [k1, k2]);\n  }\n\n  jmulH() {\n    const word = this.curve.h.word(0);\n\n    // Optimize for powers of two.\n    if ((word & (word - 1)) === 0) {\n      const bits = this.curve.h.bitLength();\n      return this.toJ().dblp(bits - 1);\n    }\n\n    return this.jmul(this.curve.h);\n  }\n\n  jdiv(k) {\n    assert(k instanceof BN);\n    assert(!k.red);\n\n    return this.jmul(k.invert(this.curve.n));\n  }\n\n  jdivn(k) {\n    assert(!this.curve.n.isZero());\n\n    if (this.curve.h.cmpn(k) === 0)\n      return this.jdivH();\n\n    return this.jdiv(new BN(k));\n  }\n\n  jdivH() {\n    if (this.curve.n.isZero())\n      return this.toJ();\n\n    if (this.curve.h.cmpn(1) === 0)\n      return this.toJ();\n\n    if (this.curve.hi === null)\n      this.curve.hi = this.curve.h.invert(this.curve.n);\n\n    return this.jmul(this.curve.hi);\n  }\n\n  toP() {\n    return this.normalize();\n  }\n\n  toJ() {\n    return this;\n  }\n\n  toX() {\n    return this;\n  }\n\n  key() {\n    if (this.isInfinity())\n      return `${this.curve.uid}:oo`;\n\n    this.normalize();\n\n    const x = this.getX().toString(16);\n    const y = this.getY().toString(16);\n\n    return `${this.curve.uid}:${x},${y}`;\n  }\n\n  encode(compact) {\n    throw new Error('Not implemented.');\n  }\n\n  static decode(curve, bytes) {\n    throw new Error('Not implemented.');\n  }\n\n  encodeX() {\n    throw new Error('Not implemented.');\n  }\n\n  static decodeX(curve, bytes) {\n    throw new Error('Not implemented.');\n  }\n\n  static decodeEven(curve, bytes) {\n    throw new Error('Not implemented.');\n  }\n\n  static decodeSquare(curve, bytes) {\n    throw new Error('Not implemented.');\n  }\n\n  toJSON(pre) {\n    throw new Error('Not implemented.');\n  }\n\n  static fromJSON(curve, json) {\n    throw new Error('Not implemented.');\n  }\n\n  [custom]() {\n    return '<Point>';\n  }\n}\n\n/**\n * ShortCurve\n */\n\nclass ShortCurve extends Curve {\n  constructor(conf) {\n    super(ShortPoint, 'short', conf);\n\n    this.a = BN.fromJSON(conf.a).toRed(this.red);\n    this.b = BN.fromJSON(conf.b).toRed(this.red);\n    this.c = BN.fromJSON(conf.c || '0').toRed(this.red);\n    this.ai = this.a.isZero() ? this.zero : this.a.redInvert();\n    this.zi = this.z.isZero() ? this.zero : this.z.redInvert();\n\n    this.zeroA = this.a.isZero();\n    this.threeA = this.a.eq(this.three.redNeg());\n    this.redN = this.n.toRed(this.red);\n    this.pmodn = this.p.clone();\n    this.highOrder = this.n.cmp(this.p) >= 0;\n    this.smallGap = false;\n\n    this._finalize(conf);\n  }\n\n  _finalize(conf) {\n    super._finalize(conf);\n\n    // Precalculate endomorphism.\n    if (conf.endo != null)\n      this.endo = Endo.fromJSON(this, conf.endo);\n    else\n      this.endo = this._getEndomorphism();\n\n    if (!this.n.isZero()) {\n      this.pmodn = this.p.mod(this.n);\n\n      // Check for Maxwell's trick (see eqR).\n      this.smallGap = this.p.div(this.n).cmpn(1) <= 0;\n    }\n\n    return this;\n  }\n\n  static _isomorphism(curveA, curveB, custom, odd) {\n    // Short Weierstrass Isomorphism.\n    //\n    // [GECC] Page 84, Section 3.1.5.\n    // [ARITH1] Page 274, Section 13.1.5.\n    // [ALT] Appendix F.3 (Isomorphic Mapping between Weierstrass Curves).\n    //\n    // Find `u` such that `a * u^4 = a'` and `b * u^6 = b'`.\n    //\n    // Transformation:\n    //\n    //   u4 = a' / a\n    //   u2 = +-sqrt(u4)\n    //   u6 = u4 * u2\n    //   a' = a * u4\n    //   b' = b * u6\n    //\n    // Where `u2` is any root that is square.\n    //\n    // If a = 0, we can do:\n    //\n    //   a' = 0\n    //   b' = b'\n    //\n    // Where (b' / b)^(1 / 3) is square.\n    //\n    // If b = 0, we can do:\n    //\n    //   a' = a'\n    //   b' = 0\n    //\n    // Where sqrt(a' / a) is square.\n    assert(curveA instanceof BN);\n    assert(curveB instanceof BN);\n    assert(custom instanceof BN);\n    assert(odd == null || typeof odd === 'boolean');\n    assert(!curveA.isZero() || !curveB.isZero());\n\n    if (custom.isZero())\n      throw new Error('Invalid coefficient.');\n\n    if (curveA.isZero()) {\n      const customB = custom;\n      const u6 = customB.redDiv(curveB);\n      // Todo: allow index flag.\n      const u2 = uncube(u6);\n\n      // Already checked in uncube().\n      assert(u2.redJacobi() === 1);\n\n      return [curveA.clone(), customB.clone()];\n    }\n\n    if (curveB.isZero()) {\n      const customA = custom;\n      const u4 = customA.redDiv(curveA);\n      const u2 = u4.redSqrt();\n\n      // Todo: allow odd flag.\n      if (u2.redJacobi() !== 1)\n        u2.redINeg();\n\n      if (u2.redJacobi() !== 1)\n        throw new Error('Invalid `a` coefficient.');\n\n      return [customA.clone(), curveB.clone()];\n    }\n\n    const customA = custom;\n    const u4 = customA.redDiv(curveA);\n    const u2 = u4.redSqrt();\n\n    if (odd != null) {\n      if (u2.redIsOdd() !== odd)\n        u2.redINeg();\n    } else {\n      if (u2.redJacobi() !== 1)\n        u2.redINeg();\n    }\n\n    if (u2.redJacobi() !== 1)\n      throw new Error('Invalid `a` coefficient.');\n\n    const u6 = u4.redMul(u2);\n    const a = curveA.redMul(u4);\n    const b = curveB.redMul(u6);\n\n    assert(a.eq(customA));\n\n    return [a, b];\n  }\n\n  _short(a0, odd) {\n    return ShortCurve._isomorphism(this.a, this.b, a0, odd);\n  }\n\n  _mont(b0, odd) {\n    // Short Weierstrass->Montgomery Equivalence.\n    //\n    // [ARITH1] Page 286, Section 13.2.3.c.\n    // [SAFE] \"Ladders\".\n    //\n    // Transformation:\n    //\n    //   r = A / (3 * B)\n    //   s = +-sqrt(3 * r^2 + a)\n    //   A = 3 * r / s\n    //   B = 1 / s\n    const [r, s] = this._findRS(odd);\n    const b = s.redInvert();\n    const a = r.redMuln(3).redMul(b);\n\n    if (b0 != null)\n      return MontCurve._isomorphism(a, b, b0);\n\n    return [a, b];\n  }\n\n  _edwards(a0, odd) {\n    // Short Weierstrass->Twisted Edwards Equivalence.\n    //\n    // [TWISTEQ] Section 1.\n    //\n    // Transformation:\n    //\n    //   r = (a' + d') / 6\n    //   s = +-sqrt(3 * r^2 + a)\n    //   a' = 3 * r + 2 * s\n    //   d' = 3 * r - 2 * s\n    const [r, s] = this._findRS(odd);\n    const r3 = r.redMuln(3);\n    const s2 = s.redMuln(2);\n    const a = r3.redAdd(s2);\n    const d = r3.redSub(s2);\n\n    if (a0 != null)\n      return EdwardsCurve._isomorphism(a, d, a0);\n\n    return [a, d];\n  }\n\n  _findRS(sign) {\n    // Find `r` and `s` for equivalence.\n    //\n    // [ARITH1] Page 286, Section 13.2.3.c.\n    // [SAFE] \"Ladders\".\n    //\n    // Computation:\n    //\n    //   r = solve(r^3 + a * r + b == 0, r)\n    //   s = +-sqrt(3 * r^2 + a)\n    //\n    // Computing `r` is non-trivial. We need\n    // to solve `r^3 + a * r + b = 0`, but we\n    // don't have a polynomial solver, so we\n    // loop over random points until we find\n    // one with 2-torsion. Multiplying by the\n    // subgroup order should yield a point of\n    // ((A / 3) / B, 0) which is a solution.\n    assert(sign == null || typeof sign === 'boolean');\n    assert(this.h.word(0) >= 4);\n    assert(!this.n.isZero());\n\n    const x = this.one.redNeg();\n\n    let p;\n\n    for (;;) {\n      x.redIAdd(this.one);\n\n      try {\n        p = this.pointFromX(x.clone());\n      } catch (e) {\n        continue;\n      }\n\n      p = p.mul(this.n);\n\n      if (p.isInfinity())\n        continue;\n\n      if (!p.y.isZero())\n        continue;\n\n      break;\n    }\n\n    const r = p.x;\n    const r2 = r.redSqr();\n    const s = r2.redMuln(3).redIAdd(this.a).redSqrt();\n\n    if (sign != null) {\n      if (s.redIsOdd() !== sign)\n        s.redINeg();\n    }\n\n    return [r, s];\n  }\n\n  _scale0(a, b) {\n    // We can extract the isomorphism factors with:\n    //\n    //   u4 = a' / a\n    //   u6 = b' / b\n    //   u2 = +-sqrt(u4)\n    //   u = +-sqrt(u2)\n    //   u3 = u2 * u\n    //\n    // `u2` should be picked such that `u4 * u2 = u6`.\n    //\n    // If a = 0, we can do:\n    //\n    //   u6 = b' / b\n    //   u2 = u6^(1 / 3)\n    //   u = +-sqrt(u2)\n    //   u3 = u2 * u\n    //\n    // Where `u2` is any root that is square.\n    //\n    // If b = 0, we can do:\n    //\n    //   u4 = a' / a\n    //   u2 = +-sqrt(u4)\n    //   u = +-sqrt(u2)\n    //   u3 = u2 * u\n    //\n    // Where `u2` is any root that is square.\n    assert(this.a.isZero() === a.isZero());\n    assert(this.b.isZero() === b.isZero());\n\n    if (this.a.isZero()) {\n      const u6 = this.b.redDiv(this.field(b));\n      // Todo: figure out how to check index.\n      const u2 = uncube(u6);\n      const u = u2.redSqrt();\n      const u3 = u2.redMul(u);\n\n      assert(u3.redSqr().eq(u6));\n      assert(!u.isZero());\n\n      return [u2, u3];\n    }\n\n    if (this.b.isZero()) {\n      const u4 = this.a.redDiv(this.field(a));\n      const u2 = u4.redSqrt();\n\n      // Todo: figure out how to check oddness.\n      if (u2.redJacobi() !== 1)\n        u2.redINeg();\n\n      const u = u2.redSqrt();\n      const u3 = u2.redMul(u);\n\n      assert(u3.redMul(u).eq(u4));\n      assert(!u.isZero());\n\n      return [u2, u3];\n    }\n\n    const u4 = this.a.redDiv(this.field(a));\n    const u6 = this.b.redDiv(this.field(b));\n    const u2 = u4.redSqrt();\n\n    if (!u4.redMul(u2).eq(u6))\n      u2.redINeg();\n\n    assert(u4.redMul(u2).eq(u6));\n\n    const u = u2.redSqrt();\n    const u3 = u2.redMul(u);\n\n    assert(!u.isZero());\n\n    return [u2, u3];\n  }\n\n  _scale1(x, y) {\n    // If base points are available, it is much\n    // easier, with:\n    //\n    //   u2 = x' / x\n    //   u3 = y' / y\n    //   u = +-sqrt(u2)\n    //\n    // `u` should be picked such that `u2 * u = u3`.\n    const u2 = this.g.x.redDiv(this.field(x));\n    const u3 = this.g.y.redDiv(this.field(y));\n    const u = u2.redSqrt();\n\n    if (!u2.redMul(u).eq(u3))\n      u.redINeg();\n\n    assert(u2.redMul(u).eq(u3));\n    assert(!u.isZero());\n\n    return [u2, u3];\n  }\n\n  _scaleShort(curve) {\n    assert(curve instanceof ShortCurve);\n\n    if (this.g.isInfinity() || curve.g.isInfinity())\n      return this._scale0(curve.a, curve.b);\n\n    return this._scale1(curve.g.x, curve.g.y);\n  }\n\n  _scaleMont(curve) {\n    assert(curve instanceof MontCurve);\n\n    if (this.g.isInfinity() || curve.g.isInfinity()) {\n      const [a, b] = curve._short();\n      return this._scale0(a, b);\n    }\n\n    const {x, y} = curve.g;\n    const nx = x.redAdd(curve.a3).redMul(curve.bi);\n    const ny = y.redMul(curve.bi);\n\n    return this._scale1(nx, ny);\n  }\n\n  _scaleEdwards(curve) {\n    assert(curve instanceof EdwardsCurve);\n\n    if (this.g.isInfinity() || curve.g.isInfinity()) {\n      const [a, b] = curve._short();\n      return this._scale0(a, b);\n    }\n\n    const {x, y, z} = curve.g;\n    const a5 = curve.a.redMuln(5);\n    const d5 = curve.d.redMuln(5);\n    const dma = curve.d.redSub(curve.a);\n    const d5a = d5.redSub(curve.a);\n    const da5 = curve.d.redSub(a5);\n    const ypz = y.redAdd(z);\n    const ymz = y.redSub(z);\n    const xx = d5a.redMul(y).redIAdd(da5.redMul(z));\n    const xz = ymz.redMuln(12);\n    const yy = dma.redMul(ypz).redMul(z);\n    const yz = ymz.redMul(x).redIMuln(4);\n    const zi = xz.redMul(yz).redInvert();\n    const nx = xx.redMul(yz).redMul(zi);\n    const ny = yy.redMul(xz).redMul(zi);\n\n    return this._scale1(nx, ny);\n  }\n\n  _getEndomorphism(index = 0) {\n    // Compute endomorphism.\n    //\n    // [GECC] Example 3.76, Page 128, Section 3.5.\n\n    // No curve params.\n    if (this.n.isZero() || this.g.isInfinity())\n      return null;\n\n    // No efficient endomorphism.\n    if (!this.zeroA || this.p.modrn(3) !== 1 || this.n.modrn(3) !== 1)\n      return null;\n\n    // Solve beta^3 mod p = 1.\n    const [b1, b2] = this._getEndoRoots(this.p);\n\n    // Choose the smallest beta by default.\n    const beta = [b1, b2][index & 1].toRed(this.red);\n\n    // Solve lambda^3 mod n = 1.\n    const [l1, l2] = this._getEndoRoots(this.n);\n\n    // Choose the lambda matching selected beta.\n    // Note that P * lambda = (x * beta, y).\n    const p = this.point(this.g.x.redMul(beta), this.g.y);\n\n    let lambda;\n\n    if (this.g.mul(l1).eq(p)) {\n      lambda = l1;\n    } else {\n      assert(this.g.mul(l2).eq(p));\n      lambda = l2;\n    }\n\n    // Get basis vectors.\n    const basis = this._getEndoBasis(lambda);\n\n    // Precompute `g1` and `g2`.\n    const pre = this._getEndoPrecomp(basis);\n\n    return new Endo(beta, lambda, basis, pre);\n  }\n\n  _getEndoRoots(num) {\n    // Find roots for x^2 + x + 1 in F.\n    //\n    // [GECC] Example 3.76, Page 128, Section 3.5.\n    // [GLV] Page 192, Section 2 (Endomorphisms).\n    //\n    // The above document doesn't fully explain how\n    // to derive these and only \"hints\" at it, as\n    // mentioned by Hal Finney[1], but we're basically\n    // computing two possible cube roots of 1 here.\n    //\n    // Note that we could also compute[2]:\n    //\n    //   beta = 2^((p - 1) / 3) mod p\n    //   lambda = 3^((n - 1) / 3) mod n\n    //\n    // As an extension of Fermat's little theorem:\n    //\n    //   g^(p - 1) mod p == 1\n    //\n    // It is suspected[3] this is how Hal Finney[4]\n    // computed his original endomorphism roots.\n    //\n    // @indutny's method for computing cube roots\n    // of unity[5] appears to be the method described\n    // on wikipedia[6][7].\n    //\n    // Sage produces the same solution:\n    //\n    //   sage: solve(x^2 + x + 1 == 0, x)\n    //   [x == -1/2*I*sqrt(3) - 1/2, x == 1/2*I*sqrt(3) - 1/2]\n    //\n    // This can be reduced to:\n    //\n    //   x = (+-sqrt(-3) - 1) / 2\n    //\n    // [1] https://bitcointalk.org/index.php?topic=3238.msg45565#msg45565\n    // [2] https://crypto.stackexchange.com/a/22739\n    // [3] https://bitcoin.stackexchange.com/a/35872\n    // [4] https://github.com/halfinney/bitcoin/commit/dc411b5\n    // [5] https://en.wikipedia.org/wiki/Cube_root_of_unity\n    // [6] https://en.wikipedia.org/wiki/Splitting_field#Cubic_example\n    // [7] http://mathworld.wolfram.com/SplittingField.html\n    const red = num === this.p ? this.red : BN.mont(num);\n    const two = new BN(2).toRed(red);\n    const three = new BN(3).toRed(red);\n    const i2 = two.redInvert();\n\n    // S1 = sqrt(-3) / 2\n    const s1 = three.redNeg().redSqrt().redMul(i2);\n\n    // S2 = -S1\n    const s2 = s1.redNeg();\n\n    // R1 = S1 - 1 / 2\n    const r1 = s1.redSub(i2).fromRed();\n\n    // R2 = S2 - 1 / 2\n    const r2 = s2.redSub(i2).fromRed();\n\n    return [r1, r2].sort(BN.cmp);\n  }\n\n  _getEndoBasis(lambda) {\n    // Compute endomorphic basis.\n    //\n    // This essentially computes Cornacchia's algorithm\n    // for solving x^2 + d * y^2 = m (d = lambda, m = order).\n    //\n    // https://en.wikipedia.org/wiki/Cornacchia%27s_algorithm\n    //\n    // [GECC] Algorithm 3.74, Page 127, Section 3.5.\n    // [GLV] Page 196, Section 4 (Decomposing K).\n    //\n    // Balanced length-two representation of a multiplier.\n    //\n    // 1. Run the extended euclidean algorithm with inputs n\n    //    and lambda. The algorithm produces a sequence of\n    //    equations si*n + ti*lam = ri where s0=1, t0=0,\n    //    r0=n, s1=0, t1=1, r1=lam, and the remainders ri\n    //    and are non-negative and strictly decreasing. Let\n    //    l be the greatest index for which rl >= sqrt(n).\n    const [rl, tl, rl1, tl1, rl2, tl2] = this._egcdSqrt(lambda);\n\n    // 2. Set (a1, b1) <- (rl+1, -tl+1).\n    const a1 = rl1;\n    const b1 = tl1.neg();\n\n    // 3. If (rl^2 + tl^2) <= (rl+2^2 + tl+2^2)\n    //    then set (a2, b2) <- (rl, -tl).\n    //    else set (a2, b2) <- (rl+2, -tl+2).\n    const lhs = rl.sqr().iadd(tl.sqr());\n    const rhs = rl2.sqr().iadd(tl2.sqr());\n\n    let a2, b2;\n\n    if (lhs.cmp(rhs) <= 0) {\n      a2 = rl;\n      b2 = tl.neg();\n    } else {\n      a2 = rl2;\n      b2 = tl2.neg();\n    }\n\n    return [\n      new Vector(a1, b1),\n      new Vector(a2, b2)\n    ];\n  }\n\n  _egcdSqrt(lambda) {\n    // Extended Euclidean algorithm for integers.\n    //\n    // [GECC] Algorithm 2.19, Page 40, Section 2.2.\n    // [GLV] Page 196, Section 4 (Decomposing K).\n    assert(lambda instanceof BN);\n    assert(!lambda.red);\n    assert(lambda.sign() > 0);\n    assert(this.n.sign() > 0);\n\n    // Note that we insert the approximate square\n    // root checks as described in algorithm 3.74.\n    //\n    // Algorithm 2.19 is defined as:\n    //\n    // 1. u <- a\n    //    v <- b\n    //\n    // 2. x1 <- 1\n    //    y1 <- 0\n    //    x2 <- 0\n    //    y2 <- 1\n    //\n    // 3. while u != 0 do\n    //\n    // 3.1. q <- floor(v / u)\n    //      r <- v - q * u\n    //      x <- x2 - q * x1\n    //      y <- y2 - q * y1\n    //\n    // 3.2. v <- u\n    //      u <- r\n    //      x2 <- x1\n    //      x1 <- x\n    //      y2 <- y1\n    //      y1 <- y\n    //\n    // 4. d <- v\n    //    x <- x2\n    //    y <- y2\n    //\n    // 5. Return (d, x, y).\n\n    // Start with an approximate square root of n.\n    const sqrtn = this.n.ushrn(this.n.bitLength() >>> 1);\n\n    let u = lambda; // r1\n    let v = this.n.clone(); // r0\n    let x1 = new BN(1); // t1\n    let y1 = new BN(0); // t0\n    let x2 = new BN(0); // s1\n    let y2 = new BN(1); // s0\n\n    // All vectors are roots of: a + b * lambda = 0 (mod n).\n    let rl, tl;\n\n    // First vector.\n    let rl1, tl1;\n\n    // Inner.\n    let i = 0;\n    let j = 0;\n    let p;\n\n    // Compute EGCD.\n    while (!u.isZero() && i < 2) {\n      const q = v.quo(u);\n      const r = v.sub(q.mul(u));\n      const x = x2.sub(q.mul(x1));\n      const y = y2.sub(q.mul(y1));\n\n      // Check for r < sqrt(n).\n      if (j === 0 && r.cmp(sqrtn) < 0) {\n        rl = p;\n        tl = x1;\n        rl1 = r;\n        tl1 = x;\n        j = 1; // 1 more round.\n      }\n\n      p = r;\n      v = u;\n      u = r;\n      x2 = x1;\n      x1 = x;\n      y2 = y1;\n      y1 = y;\n\n      i += j;\n    }\n\n    // Should never happen.\n    assert(j !== 0, 'Could not find r < sqrt(n).');\n\n    // Second vector.\n    const rl2 = x2;\n    const tl2 = x1;\n\n    return [\n      rl,\n      tl,\n      rl1,\n      tl1,\n      rl2,\n      tl2\n    ];\n  }\n\n  _getEndoPrecomp(basis) {\n    // Precompute `g1` and `g2` to avoid round division.\n    //\n    // [JCEN12] Page 5, Section 4.3.\n    //\n    // Computation:\n    //\n    //   d = a1 * b2 - b1 * a2\n    //   t = ceil(log2(d+1)) + p\n    //   g1 = round((2^t * b2) / d)\n    //   g2 = round((2^t * b1) / d)\n    //\n    // Where:\n    //\n    //   `p` is the number of precision bits.\n    //   `d` is equal to `n` (the curve order).\n    //\n    // The paper above uses 2 as the value of `p`,\n    // whereas libsecp256k1 uses 128 (total=384).\n    //\n    // We pick precision for `g1` and `g2` such that:\n    //\n    //   abs(g1) < n\n    //   abs(g2) < n\n    //\n    // This ensures maximum precision for the constants\n    // while also ensuring they fit into a fixed number\n    // of scalar limbs in more optimized implementations.\n    //\n    // Furthermore, we attempt to align to a limb width\n    // of 64 bits. This allows us to optimize the shift,\n    // a la libsecp256k1[1].\n    //\n    // [1] https://github.com/bitcoin-core/secp256k1/pull/822\n    assert(Array.isArray(basis));\n    assert(basis.length === 2);\n    assert(basis[0] instanceof Vector);\n    assert(basis[1] instanceof Vector);\n\n    const [v1, v2] = basis;\n    const d = v1.a.mul(v2.b).isub(v1.b.mul(v2.a));\n    const bits = d.bitLength();\n    const align = bits >= 160;\n\n    assert(d.eq(this.n));\n\n    // Start with a rough estimate.\n    let shift = bits + Math.ceil(bits / 2) + 1;\n    let g1, g2;\n\n    if (align)\n      shift -= shift & 63;\n\n    while (shift > bits) {\n      g1 = v2.b.ushln(shift).divRound(d);\n      g2 = v1.b.ushln(shift).divRound(d);\n\n      if (g1.ucmp(d) < 0 && g2.ucmp(d) < 0)\n        break;\n\n      if (align)\n        shift -= 64;\n      else\n        shift -= 1;\n    }\n\n    if (shift <= bits)\n      throw new Error('Could not calculate g1 and g2.');\n\n    return [shift, g1, g2];\n  }\n\n  _endoSplit(k) {\n    // Balanced length-two representation of a multiplier.\n    //\n    // [GECC] Algorithm 3.74, Page 127, Section 3.5.\n    //\n    // Also note that it is possible to precompute[1]\n    // values in order to avoid the division[2][3][4].\n    //\n    // This involves precomputing `g1` and `g2 (see\n    // above). `c1` and `c2` can then be computed as\n    // follows:\n    //\n    //   t = ceil(log2(n+1)) + p\n    //   c1 = (k * g1) >> t\n    //   c2 = -((k * g2) >> t)\n    //\n    // Where `>>` is an _unsigned_ right shift. Also\n    // note that the last bit discarded in the shift\n    // must be stored. If it is 1, then add 1 to the\n    // scalar (absolute addition).\n    //\n    // It's worth noting that libsecp256k1 uses a\n    // different calculation along the lines of:\n    //\n    //   t = ceil(log2(n+1)) + p\n    //   c1 = ((k * g1) >> t) * -b1\n    //   c2 = ((k * -g2) >> t) * -b2\n    //   k2 = c1 + c2\n    //   k1 = k2 * -lambda + k\n    //\n    // So, in the future, we can consider changing\n    // step 4 to:\n    //\n    //   4. Compute c1 = (k * g1) >> t\n    //          and c2 = -((k * g2) >> t).\n    //\n    //   const [shift, g1, g2] = this.endo.pre;\n    //   const c1 = k.mulShift(g1, shift);\n    //   const c2 = k.mulShift(g2, shift).ineg();\n    //\n    // Once we're brave enough, that is.\n    //\n    // [1] [JCEN12] Page 5, Section 4.3.\n    // [2] https://github.com/bitcoin-core/secp256k1/blob/0b70241/src/scalar_impl.h#L259\n    // [3] https://github.com/bitcoin-core/secp256k1/pull/21\n    // [4] https://github.com/bitcoin-core/secp256k1/pull/127\n    assert(k instanceof BN);\n    assert(!k.red);\n    assert(!this.n.isZero());\n\n    const [v1, v2] = this.endo.basis;\n\n    // 4. Compute c1 = round(b2 * k / n)\n    //        and c2 = round(-b1 * k / n).\n    const c1 = v2.b.mul(k).divRound(this.n);\n    const c2 = v1.b.neg().mul(k).divRound(this.n);\n\n    // 5. Compute k1 = k - c1 * a1 - c2 * a2\n    //        and k2 = -c1 * b1 - c2 * b2.\n    const p1 = c1.mul(v1.a);\n    const p2 = c2.mul(v2.a);\n    const q1 = c1.ineg().mul(v1.b);\n    const q2 = c2.mul(v2.b);\n\n    // Calculate answer.\n    const k1 = k.sub(p1).isub(p2);\n    const k2 = q1.isub(q2);\n\n    // 6. Return (k1, k2).\n    return [k1, k2];\n  }\n\n  _endoBeta(point) {\n    assert(point instanceof ShortPoint);\n    return [point, point._getBeta()];\n  }\n\n  _endoWnafMulAdd(points, coeffs) {\n    // Point multiplication with efficiently computable endomorphisms.\n    //\n    // [GECC] Algorithm 3.77, Page 129, Section 3.5.\n    // [GLV] Page 193, Section 3 (Using Efficient Endomorphisms).\n    //\n    // Note it may be possible to do this 4-dimensionally [4GLV].\n    assert(Array.isArray(points));\n    assert(Array.isArray(coeffs));\n    assert(points.length === coeffs.length);\n    assert(this.endo != null);\n\n    const len = points.length;\n    const npoints = new Array(len * 2);\n    const ncoeffs = new Array(len * 2);\n\n    for (let i = 0; i < len; i++) {\n      const [p1, p2] = this._endoBeta(points[i]);\n      const [k1, k2] = this._endoSplit(coeffs[i]);\n\n      npoints[i * 2 + 0] = p1;\n      ncoeffs[i * 2 + 0] = k1;\n      npoints[i * 2 + 1] = p2;\n      ncoeffs[i * 2 + 1] = k2;\n    }\n\n    return this._wnafMulAdd(5, npoints, ncoeffs);\n  }\n\n  _sswu(u) {\n    // Simplified Shallue-Woestijne-Ulas Method.\n    //\n    // Distribution: 3/8.\n    //\n    // [SSWU1] Page 15-16, Section 7. Appendix G.\n    // [SSWU2] Page 5, Theorem 2.3.\n    // [H2EC] \"Simplified Shallue-van de Woestijne-Ulas Method\".\n    //\n    // Assumptions:\n    //\n    //   - a != 0, b != 0.\n    //   - Let z be a non-square in F(p).\n    //   - z != -1.\n    //   - The polynomial g(x) - z is irreducible over F(p).\n    //   - g(b / (z * a)) is square in F(p).\n    //   - u != 0, u != +-sqrt(-1 / z).\n    //\n    // Map:\n    //\n    //   g(x) = x^3 + a * x + b\n    //   t1 = 1 / (z^2 * u^4 + z * u^2)\n    //   x1 = (-b / a) * (1 + t1)\n    //   x1 = b / (z * a), if t1 = 0\n    //   x2 = z * u^2 * x1\n    //   x = x1, if g(x1) is square\n    //     = x2, otherwise\n    //   y = sign(u) * abs(sqrt(g(x)))\n    const {b, z, ai, zi, one} = this;\n    const z2 = z.redSqr();\n    const ba = b.redNeg().redMul(ai);\n    const bza = b.redMul(zi).redMul(ai);\n    const u2 = u.redSqr();\n    const u4 = u2.redSqr();\n    const t0 = z2.redMul(u4).redIAdd(z.redMul(u2));\n    const t1 = t0.isZero() ? t0 : t0.redInvert();\n    const x1 = t1.isZero() ? bza : ba.redMul(one.redAdd(t1));\n    const x2 = z.redMul(u2).redMul(x1);\n    const y1 = this.solveY2(x1);\n    const y2 = this.solveY2(x2);\n    const alpha = y1.redIsSquare() | 0;\n    const x = [x1, x2][alpha ^ 1];\n    const y = [y1, y2][alpha ^ 1].redSqrt();\n\n    if (y.redIsOdd() !== u.redIsOdd())\n      y.redINeg();\n\n    return this.point(x, y);\n  }\n\n  _sswui(p, hint) {\n    // Inverting the Map (Simplified Shallue-Woestijne-Ulas).\n    //\n    // Assumptions:\n    //\n    //   - a^2 * x^2 - 2 * a * b * x - 3 * b^2 is square in F(p).\n    //   - If r < 3 then x != -b / a.\n    //\n    // Unlike SVDW, the preimages here are evenly\n    // distributed (more or less). SSWU covers ~3/8\n    // of the curve points. Each preimage has a 1/2\n    // chance of mapping to either x1 or x2.\n    //\n    // Assuming the point is within that set, each\n    // point has a 1/4 chance of inverting to any\n    // of the preimages. This means we can simply\n    // randomly select a preimage if one exists.\n    //\n    // However, the [SVDW2] sampling method seems\n    // slighly faster in practice for [SQUARED].\n    //\n    // Map:\n    //\n    //   c = sqrt(a^2 * x^2 - 2 * a * b * x - 3 * b^2)\n    //   u1 = -(a * x + b - c) / (2 * (a * x + b) * z)\n    //   u2 = -(a * x + b + c) / (2 * (a * x + b) * z)\n    //   u3 = -(a * x + b - c) / (2 * b * z)\n    //   u4 = -(a * x + b + c) / (2 * b * z)\n    //   r = random integer in [1,4]\n    //   u = sign(y) * abs(sqrt(ur))\n    const {a, b, z} = this;\n    const {x, y} = p;\n    const r = hint & 3;\n    const a2x2 = a.redSqr().redMul(x.redSqr());\n    const abx2 = a.redMul(b).redMul(x).redIMuln(2);\n    const b23 = b.redSqr().redMuln(3);\n    const axb = a.redMul(x).redIAdd(b);\n    const c = a2x2.redISub(abx2).redISub(b23).redSqrt();\n    const n0 = axb.redSub(c).redINeg();\n    const n1 = axb.redAdd(c).redINeg();\n    const d0 = axb.redMul(z).redIMuln(2);\n    const d1 = b.redMul(z).redIMuln(2);\n    const n = [n0, n1][r & 1]; // r = 1 or 3\n    const d = [d0, d1][r >>> 1]; // r = 2 or 3\n    const u = n.redDivSqrt(d);\n\n    if (u.redIsOdd() !== y.redIsOdd())\n      u.redINeg();\n\n    return u;\n  }\n\n  _svdwf(u) {\n    // Shallue-van de Woestijne Method.\n    //\n    // Distribution: 9/16.\n    //\n    // [SVDW1] Section 5.\n    // [SVDW2] Page 8, Section 3.\n    //         Page 15, Section 6, Algorithm 1.\n    // [H2EC] \"Shallue-van de Woestijne Method\".\n    //\n    // Assumptions:\n    //\n    //   - p = 1 (mod 3).\n    //   - a = 0, b != 0.\n    //   - Let z be a unique element in F(p).\n    //   - g((sqrt(-3 * z^2) - z) / 2) is square in F(p).\n    //   - u != 0, u != +-sqrt(-g(z)).\n    //\n    // Map:\n    //\n    //   g(x) = x^3 + b\n    //   c = sqrt(-3 * z^2)\n    //   t1 = u^2 + g(z)\n    //   t2 = 1 / (u^2 * t1)\n    //   t3 = u^4 * t2 * c\n    //   x1 = (c - z) / 2 - t3\n    //   x2 = t3 - (c + z) / 2\n    //   x3 = z - t1^3 * t2 / (3 * z^2)\n    //   x = x1, if g(x1) is square\n    //     = x2, if g(x2) is square\n    //     = x3, otherwise\n    //   y = sign(u) * abs(sqrt(g(x)))\n    const {c, z, zi, i2, i3} = this;\n    const gz = this.solveY2(z);\n    const z3 = i3.redMul(zi.redSqr());\n    const u2 = u.redSqr();\n    const u4 = u2.redSqr();\n    const t1 = u2.redAdd(gz);\n    const u2t1 = u2.redMul(t1);\n    const t2 = u2t1.isZero() ? u2t1 : u2t1.redInvert();\n    const t3 = u4.redMul(t2).redMul(c);\n    const t4 = t1.redSqr().redMul(t1);\n    const x1 = c.redSub(z).redMul(i2).redISub(t3);\n    const x2 = t3.redSub(c.redAdd(z).redMul(i2));\n    const x3 = z.redSub(t4.redMul(t2).redMul(z3));\n    const y1 = this.solveY2(x1);\n    const y2 = this.solveY2(x2);\n    const y3 = this.solveY2(x3);\n    const alpha = y1.redJacobi() | 1;\n    const beta = y2.redJacobi() | 1;\n    const i = mod((alpha - 1) * beta, 3);\n    const x = [x1, x2, x3][i];\n    const y = [y1, y2, y3][i];\n\n    return [x, y];\n  }\n\n  _svdw(u) {\n    const [x, yy] = this._svdwf(u);\n    const y = yy.redSqrt();\n\n    if (y.redIsOdd() !== u.redIsOdd())\n      y.redINeg();\n\n    return this.point(x, y);\n  }\n\n  _svdwi(p, hint) {\n    // Inverting the Map (Shallue-van de Woestijne).\n    //\n    // [SQUARED] Algorithm 1, Page 8, Section 3.3.\n    // [SVDW2] Page 12, Section 5.\n    // [SVDW3] \"Inverting the map\".\n    //\n    // Assumptions:\n    //\n    //   - If r = 1 then x != -(c + z) / 2.\n    //   - If r = 2 then x != (c - z) / 2.\n    //   - If r > 2 then (t0 - t1 + t2) is square in F(p).\n    //   - f(f^-1(x)) = x where f is the map function.\n    //\n    // We use the sampling method from [SVDW2],\n    // _not_ [SQUARED]. This seems to have a\n    // better distribution in practice.\n    //\n    // Note that [SVDW3] also appears to be\n    // incorrect in terms of distribution.\n    //\n    // The distribution of f(u), assuming u is\n    // random, is (1/2, 1/4, 1/4).\n    //\n    // To mirror this, f^-1(x) should simply\n    // pick (1/2, 1/4, 1/8, 1/8).\n    //\n    // To anyone running the forward map, our\n    // strings will appear to be random.\n    //\n    // Map:\n    //\n    //   g(x) = x^3 + b\n    //   c = sqrt(-3 * z^2)\n    //   t0 = 9 * (x^2 * z^2 + z^4)\n    //   t1 = 18 * x * z^3\n    //   t2 = 12 * g(z) * (x - z)\n    //   t3 = sqrt(t0 - t1 + t2)\n    //   t4 = t3 * z\n    //   u1 = g(z) * (c - 2 * x - z) / (c + 2 * x + z)\n    //   u2 = g(z) * (c + 2 * x + z) / (c - 2 * x - z)\n    //   u3 = (3 * (z^3 - x * z^2) - 2 * g(z) + t4) / 2\n    //   u4 = (3 * (z^3 - x * z^2) - 2 * g(z) - t4) / 2\n    //   r = random integer in [1,4]\n    //   u = sign(y) * abs(sqrt(ur))\n    const {b, c, z, zero, two} = this;\n    const {x, y} = p;\n    const r = hint & 3;\n    const z2 = z.redSqr();\n    const z3 = z2.redMul(z);\n    const z4 = z2.redSqr();\n    const gz = z3.redAdd(b);\n    const gz2 = gz.redMuln(2);\n    const xx = x.redSqr();\n    const x2z = x.redMuln(2).redIAdd(z);\n    const xz2 = x.redMul(z2);\n    const c0 = c.redSub(x2z);\n    const c1 = c.redAdd(x2z);\n    const t0 = xx.redMul(z2).redIAdd(z4).redIMuln(9);\n    const t1 = x.redMul(z3).redIMuln(18);\n    const t2 = gz.redMul(x.redSub(z)).redIMuln(12);\n    const t3 = r >= 2 ? t0.redISub(t1).redIAdd(t2).redSqrt() : zero;\n    const t4 = t3.redMul(z);\n    const t5 = z3.redISub(xz2).redIMuln(3).redISub(gz2);\n    const n0 = gz.redMul(c0);\n    const n1 = gz.redMul(c1);\n    const n2 = t5.redAdd(t4);\n    const n3 = t5.redSub(t4);\n    const d2 = two;\n    const n = [n0, n1, n2, n3][r];\n    const d = [c1, c0, d2, d2][r];\n    const u = n.redDivSqrt(d);\n    const [x0] = this._svdwf(u);\n\n    if (!x0.eq(x))\n      throw new Error('Invalid point.');\n\n    if (u.redIsOdd() !== y.redIsOdd())\n      u.redINeg();\n\n    return u;\n  }\n\n  isElliptic() {\n    const {a, b} = this;\n    const a2 = a.redSqr();\n    const a3 = a2.redMul(a);\n    const b2 = b.redSqr();\n    const d = b2.redMuln(27).redIAdd(a3.redMuln(4));\n\n    // 4 * a^3 + 27 * b^2 != 0\n    return !d.isZero();\n  }\n\n  jinv() {\n    // [ARITH1] Page 71, Section 4.4.\n    // http://mathworld.wolfram.com/j-Invariant.html\n    const {a, b} = this;\n    const a2 = a.redSqr();\n    const a3 = a2.redMul(a);\n    const b2 = b.redSqr();\n    const t0 = a3.redMuln(4);\n    const lhs = t0.redMuln(1728);\n    const rhs = b2.redMuln(27).redIAdd(t0);\n\n    if (rhs.isZero())\n      throw new Error('Curve is not elliptic.');\n\n    // (1728 * 4 * a^3) / (4 * a^3 + 27 * b^2)\n    return lhs.redDiv(rhs).fromRed();\n  }\n\n  point(x, y) {\n    return new ShortPoint(this, x, y);\n  }\n\n  jpoint(x, y, z) {\n    return new JPoint(this, x, y, z);\n  }\n\n  solveX(y) {\n    assert(y instanceof BN);\n\n    if (!this.a.isZero())\n      throw new Error('Not implemented.');\n\n    // x^3 = y^2 - b\n    const y2 = y.redSqr();\n    const x3 = y2.redSub(this.b);\n\n    return cubeRoots(x3);\n  }\n\n  solveY2(x) {\n    // [GECC] Page 89, Section 3.2.2.\n    // https://hyperelliptic.org/EFD/g1p/auto-shortw.html\n    assert(x instanceof BN);\n\n    // y^2 = x^3 + a * x + b\n    const x3 = x.redSqr().redMul(x);\n    const y2 = x3.redIAdd(this.b);\n\n    if (!this.zeroA) {\n      // Save some cycles for a = -3.\n      if (this.threeA)\n        y2.redIAdd(x.redMuln(-3));\n      else\n        y2.redIAdd(this.a.redMul(x));\n    }\n\n    return y2;\n  }\n\n  validate(point) {\n    assert(point instanceof ShortPoint);\n\n    if (point.inf)\n      return true;\n\n    const {x, y} = point;\n    const y2 = this.solveY2(x);\n\n    return y.redSqr().eq(y2);\n  }\n\n  pointFromX(x, sign = null) {\n    assert(x instanceof BN);\n    assert(sign == null || typeof sign === 'boolean');\n\n    if (!x.red)\n      x = x.toRed(this.red);\n\n    const y = this.solveY(x);\n\n    if (sign != null) {\n      if (this.h.cmpn(1) > 0) {\n        if (y.isZero() && sign)\n          throw new Error('Invalid point.');\n      }\n\n      if (y.redIsOdd() !== sign)\n        y.redINeg();\n    }\n\n    return this.point(x, y);\n  }\n\n  pointFromY(y, index = 0) {\n    assert(y instanceof BN);\n    assert((index >>> 0) === index);\n\n    if (!y.red)\n      y = y.toRed(this.red);\n\n    const coords = this.solveX(y);\n\n    if (index >= coords.length)\n      throw new Error('Invalid X coordinate index.');\n\n    const x = coords[index];\n\n    return this.point(x, y);\n  }\n\n  isIsomorphic(curve) {\n    // [GECC] Page 84, Section 3.1.5.\n    // [ARITH1] Page 286, Section 13.2.3.c.\n    assert(curve instanceof Curve);\n\n    if (!curve.p.eq(this.p))\n      return false;\n\n    let u2, u3;\n    try {\n      [u2, u3] = this._scale(curve);\n    } catch (e) {\n      return false;\n    }\n\n    // E(a,b) <-> E(au^4,bu^6)\n    if (curve.type === 'short') {\n      // a' = a * u^4, b' = b * u^6\n      const a = this.field(curve.a).redMul(u2.redSqr());\n      const b = this.field(curve.b).redMul(u3.redSqr());\n\n      return this.a.eq(a) && this.b.eq(b);\n    }\n\n    // E(a,b) <-> M(A,B)\n    if (curve.type === 'mont') {\n      // (A / (3 * B))^3 + a * (A / (3 * B)) + b = 0\n      const {a3, bi} = curve;\n      const x = this.field(a3.redMul(bi)).redMul(u2);\n      const y2 = this.solveY2(x);\n\n      return y2.isZero();\n    }\n\n    // E(a,b) <-> E(a,d)\n    if (curve.type === 'edwards') {\n      // ((a' + d') / 6)^3 + a * ((a' + d') / 6) + b = 0\n      const x = this.field(curve.ad6).redMul(u2);\n      const y2 = this.solveY2(x);\n\n      return y2.isZero();\n    }\n\n    return false;\n  }\n\n  isIsogenous(curve) {\n    assert(curve instanceof Curve);\n    return false;\n  }\n\n  pointFromShort(point) {\n    // [GECC] Page 84, Section 3.1.5.\n    // [ALT] Appendix F.3 (Isomorphic Mapping between Weierstrass Curves).\n    assert(point instanceof ShortPoint);\n\n    if (this.isIsomorphic(point.curve)) {\n      // Isomorphic maps for E(a,b)<->E(au^4,bu^6):\n      //\n      //   x' = x * u^2\n      //   y' = y * u^3\n      //\n      // Where a * u^4 = a' and b * u^6 = b'.\n      if (point.isInfinity())\n        return this.point();\n\n      const [u2, u3] = this._scale(point.curve);\n      const x = this.field(point.x);\n      const y = this.field(point.y);\n      const nx = x.redMul(u2);\n      const ny = y.redMul(u3);\n\n      return this.point(nx, ny);\n    }\n\n    throw new Error('Not implemented.');\n  }\n\n  pointFromMont(point) {\n    // [ALT] Appendix E.2 (Switching between Alternative Representations).\n    // [MONT2] \"Equivalence with Weierstrass curves\"\n    assert(point instanceof MontPoint);\n\n    if (this.isIsomorphic(point.curve)) {\n      // Equivalence for M(A,B)->E(a,b):\n      //\n      //   x = (u + A / 3) / B\n      //   y = v / B\n      //\n      // Undefined if ((u^3 + A * u^2 + u) / B) is not square.\n      if (point.isInfinity())\n        return this.point();\n\n      const {a3, bi} = point.curve;\n      const [u2, u3] = this._scale(point.curve);\n      const nx = point.x.redAdd(a3).redMul(bi);\n      const ny = point.y.redMul(bi);\n\n      return this.point(this.field(nx).redMul(u2),\n                        this.field(ny).redMul(u3));\n    }\n\n    throw new Error('Not implemented.');\n  }\n\n  pointFromEdwards(point) {\n    // [TWISTEQ] Section 2.\n    assert(point instanceof EdwardsPoint);\n\n    if (this.isIsomorphic(point.curve)) {\n      // Equivalence for E(a,d)->E(a',b'):\n      //\n      //   x' = ((5 * d - a) * y + d - 5 * a) / (12 * (y - 1))\n      //   y' = (d - a) * (y + 1) / (4 * x * (y - 1))\n      //\n      // Undefined for x = 0 or y = 1.\n      //\n      // Exceptional Cases:\n      //   - (0, 1) -> O\n      //   - (0, -1) -> ((a + d) / 6, 0)\n      //\n      // Unexceptional Cases:\n      //   - (sqrt(1 / a), 0) -> ((5 * a - d) / 12, (a - d) / 4 * sqrt(a))\n      const {a, d, ad6} = point.curve;\n      const [u2, u3] = this._scale(point.curve);\n\n      if (point.isInfinity())\n        return this.point();\n\n      if (point.x.isZero()) {\n        const x = this.field(ad6).redMul(u2);\n        return this.point(x, this.zero);\n      }\n\n      const {x, y, z} = point;\n      const a5 = a.redMuln(5);\n      const d5 = d.redMuln(5);\n      const dma = d.redSub(a);\n      const d5a = d5.redSub(a);\n      const da5 = d.redSub(a5);\n      const ypz = y.redAdd(z);\n      const ymz = y.redSub(z);\n      const xx = d5a.redMul(y).redIAdd(da5.redMul(z));\n      const xz = ymz.redMuln(12);\n      const yy = dma.redMul(ypz).redMul(z);\n      const yz = ymz.redMul(x).redIMuln(4);\n\n      return this.cpoint(this.field(xx).redMul(u2),\n                         this.field(xz),\n                         this.field(yy).redMul(u3),\n                         this.field(yz));\n    }\n\n    throw new Error('Not implemented.');\n  }\n\n  pointFromUniform(u) {\n    assert(u instanceof BN);\n\n    // z = 0 or b = 0\n    if (this.z.isZero() || this.b.isZero())\n      throw new Error('Not implemented.');\n\n    // a != 0, b != 0\n    if (!this.a.isZero())\n      return this._sswu(u);\n\n    // p = 1 mod 3, a = 0, b != 0\n    if (!this.c.isZero())\n      return this._svdw(u);\n\n    throw new Error('Not implemented.');\n  }\n\n  pointToUniform(p, hint) {\n    // Convert a short weierstrass point to a field\n    // element by inverting either the SSWU or SVDW\n    // map.\n    //\n    // Hint Layout:\n    //\n    //   [00000000] [0000] [0000]\n    //        |        |      |\n    //        |        |      +-- preimage index\n    //        |        +--- subgroup\n    //        +-- bits to OR with uniform bytes\n    assert(p instanceof ShortPoint);\n    assert((hint >>> 0) === hint);\n\n    // z = 0 or b = 0\n    if (this.z.isZero() || this.b.isZero())\n      throw new Error('Not implemented.');\n\n    // P = O\n    if (p.isInfinity())\n      throw new Error('Invalid point.');\n\n    // Add a random torsion component.\n    const i = ((hint >>> 4) & 15) % this.torsion.length;\n    const q = p.add(this.torsion[i]);\n\n    return wrapErrors(() => {\n      // a != 0, b != 0\n      if (!this.a.isZero())\n        return this._sswui(q, hint);\n\n      // p = 1 mod 3, a = 0, b != 0\n      if (!this.c.isZero())\n        return this._svdwi(q, hint);\n\n      throw new Error('Not implemented.');\n    });\n  }\n\n  mulAll(points, coeffs) {\n    return super.mulAll(points, coeffs).toP();\n  }\n\n  affinizeAll(points) {\n    const out = this.normalizeAll(points);\n\n    for (let i = 0; i < out.length; i++)\n      out[i] = out[i].toP();\n\n    return out;\n  }\n\n  decodePoint(bytes) {\n    return ShortPoint.decode(this, bytes);\n  }\n\n  encodeX(point) {\n    assert(point instanceof Point);\n    return point.encodeX();\n  }\n\n  decodeEven(bytes) {\n    return ShortPoint.decodeEven(this, bytes);\n  }\n\n  decodeSquare(bytes) {\n    return ShortPoint.decodeSquare(this, bytes);\n  }\n\n  toShort(a0, odd, sign = null) {\n    const [a, b] = this._short(a0, odd);\n\n    const curve = new ShortCurve({\n      red: this.red,\n      prime: this.prime,\n      p: this.p,\n      a: a,\n      b: b,\n      n: this.n,\n      h: this.h\n    });\n\n    if (sign != null) {\n      const [, u3] = curve._scale(this);\n\n      if (u3.redIsOdd() !== sign)\n        u3.redINeg();\n    }\n\n    if (!this.g.isInfinity())\n      curve.g = curve.pointFromShort(this.g);\n\n    for (let i = 0; i < this.h.word(0); i++)\n      curve.torsion[i] = curve.pointFromShort(this.torsion[i]);\n\n    return curve;\n  }\n\n  toMont(b0, odd, sign = null) {\n    const [a, b] = this._mont(b0, odd);\n\n    const curve = new MontCurve({\n      red: this.red,\n      prime: this.prime,\n      p: this.p,\n      a: a,\n      b: b,\n      n: this.n,\n      h: this.h\n    });\n\n    if (sign != null) {\n      const [, u3] = this._scale(curve);\n\n      if (u3.redIsOdd() !== sign)\n        u3.redINeg();\n    }\n\n    if (!this.g.isInfinity())\n      curve.g = curve.pointFromShort(this.g);\n\n    for (let i = 0; i < this.h.word(0); i++)\n      curve.torsion[i] = curve.pointFromShort(this.torsion[i]);\n\n    return curve;\n  }\n\n  toEdwards(a0, odd, sign = null) {\n    const [a, d] = this._edwards(a0, odd);\n\n    const curve = new EdwardsCurve({\n      red: this.red,\n      prime: this.prime,\n      p: this.p,\n      a: a,\n      d: d,\n      n: this.n,\n      h: this.h\n    });\n\n    if (sign != null) {\n      const [, u3] = this._scale(curve);\n\n      if (u3.redIsOdd() !== sign)\n        u3.redINeg();\n    }\n\n    if (!this.g.isInfinity()) {\n      curve.g = curve.pointFromShort(this.g);\n      curve.g.normalize();\n    }\n\n    if (curve.isComplete()) {\n      for (let i = 0; i < this.h.word(0); i++) {\n        curve.torsion[i] = curve.pointFromShort(this.torsion[i]);\n        curve.torsion[i].normalize();\n      }\n    }\n\n    return curve;\n  }\n\n  pointFromJSON(json) {\n    return ShortPoint.fromJSON(this, json);\n  }\n\n  toJSON(pre) {\n    const json = super.toJSON(pre);\n\n    json.a = this.a.fromRed().toJSON();\n    json.b = this.b.fromRed().toJSON();\n\n    if (!this.c.isZero())\n      json.c = this.c.fromRed().toJSON();\n\n    return json;\n  }\n}\n\n/**\n * ShortPoint\n */\n\nclass ShortPoint extends Point {\n  constructor(curve, x, y) {\n    assert(curve instanceof ShortCurve);\n\n    super(curve, types.AFFINE);\n\n    this.x = this.curve.zero;\n    this.y = this.curve.zero;\n    this.inf = true;\n\n    if (x != null)\n      this._init(x, y);\n  }\n\n  _init(x, y) {\n    assert(x instanceof BN);\n    assert(y instanceof BN);\n\n    this.x = x;\n    this.y = y;\n\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n\n    this.inf = false;\n  }\n\n  _getBeta() {\n    if (!this.curve.endo)\n      return null;\n\n    if (this.pre && this.pre.beta)\n      return this.pre.beta;\n\n    // Augment the point with our beta value.\n    // This is the counterpart to `k2` after\n    // the endomorphism split of `k`.\n    //\n    // Note that if we have precomputation,\n    // we have to clone and update all of the\n    // precomputed points below.\n    const xb = this.x.redMul(this.curve.endo.beta);\n    const beta = this.curve.point(xb, this.y);\n\n    if (this.pre) {\n      beta.pre = this.pre.map((point) => {\n        const xb = point.x.redMul(this.curve.endo.beta);\n        return this.curve.point(xb, point.y);\n      });\n\n      this.pre.beta = beta;\n    }\n\n    return beta;\n  }\n\n  _getJNAF(point) {\n    assert(point instanceof ShortPoint);\n\n    if (this.inf || point.inf)\n      return super._getJNAF(point);\n\n    // Create comb for JSF.\n    const comb = [\n      this, // 1\n      null, // 3\n      null, // 5\n      point // 7\n    ];\n\n    // Try to avoid Jacobian points, if possible.\n    if (this.y.eq(point.y)) {\n      comb[1] = this.add(point);\n      comb[2] = this.toJ().sub(point);\n    } else if (this.y.eq(point.y.redNeg())) {\n      comb[1] = this.toJ().add(point);\n      comb[2] = this.sub(point);\n    } else {\n      comb[1] = this.toJ().add(point);\n      comb[2] = this.toJ().sub(point);\n    }\n\n    return comb;\n  }\n\n  clone() {\n    if (this.inf)\n      return this.curve.point();\n\n    return this.curve.point(this.x, this.y);\n  }\n\n  scale(a) {\n    return this.toJ().scale(a);\n  }\n\n  neg() {\n    // P = O\n    if (this.inf)\n      return this;\n\n    // -(X1, Y1) = (X1, -Y1)\n    return this.curve.point(this.x, this.y.redNeg());\n  }\n\n  add(p) {\n    // [GECC] Page 80, Section 3.1.2.\n    //\n    // Addition Law:\n    //\n    //   l = (y1 - y2) / (x1 - x2)\n    //   x3 = l^2 - x1 - x2\n    //   y3 = l * (x1 - x3) - y1\n    //\n    // 1I + 2M + 1S + 6A\n    assert(p instanceof ShortPoint);\n\n    // O + P = P\n    if (this.inf)\n      return p;\n\n    // P + O = P\n    if (p.inf)\n      return this;\n\n    // P + P, P + -P\n    if (this.x.eq(p.x)) {\n      // P + -P = O\n      if (!this.y.eq(p.y))\n        return this.curve.point();\n\n      // P + P = 2P\n      return this.dbl();\n    }\n\n    // X1 != X2, Y1 = Y2\n    if (this.y.eq(p.y)) {\n      // X3 = -X1 - X2\n      const nx = this.x.redNeg().redISub(p.x);\n\n      // Y3 = -Y1\n      const ny = this.y.redNeg();\n\n      // Skip the inverse.\n      return this.curve.point(nx, ny);\n    }\n\n    // H = X1 - X2\n    const h = this.x.redSub(p.x);\n\n    // R = Y1 - Y2\n    const r = this.y.redSub(p.y);\n\n    // L = R / H\n    const l = r.redDiv(h);\n\n    // X3 = L^2 - X1 - X2\n    const nx = l.redSqr().redISub(this.x).redISub(p.x);\n\n    // Y3 = L * (X1 - X3) - Y1\n    const ny = l.redMul(this.x.redSub(nx)).redISub(this.y);\n\n    return this.curve.point(nx, ny);\n  }\n\n  dbl() {\n    // [GECC] Page 80, Section 3.1.2.\n    //\n    // Addition Law (doubling):\n    //\n    //   l = (3 * x1^2 + a) / (2 * y1)\n    //   x3 = l^2 - 2 * x1\n    //   y3 = l * (x1 - x3) - y1\n    //\n    // 1I + 2M + 2S + 3A + 2*2 + 1*3\n\n    // P = O\n    if (this.inf)\n      return this;\n\n    // Y1 = 0\n    if (this.y.isZero())\n      return this.curve.point();\n\n    // XX = X1^2\n    const xx = this.x.redSqr();\n\n    // M = 3 * XX + a\n    const m = xx.redIMuln(3).redIAdd(this.curve.a);\n\n    // Z = 2 * Y1\n    const z = this.y.redMuln(2);\n\n    // L = M / Z\n    const l = m.redDiv(z);\n\n    // X3 = L^2 - 2 * X1\n    const nx = l.redSqr().redISub(this.x).redISub(this.x);\n\n    // Y3 = L * (X1 - X3) - Y1\n    const ny = l.redMul(this.x.redSub(nx)).redISub(this.y);\n\n    return this.curve.point(nx, ny);\n  }\n\n  dblp(pow) {\n    return this.toJ().dblp(pow).toP();\n  }\n\n  getX() {\n    if (this.inf)\n      throw new Error('Invalid point.');\n\n    return this.x.fromRed();\n  }\n\n  getY() {\n    if (this.inf)\n      throw new Error('Invalid point.');\n\n    return this.y.fromRed();\n  }\n\n  eq(p) {\n    assert(p instanceof ShortPoint);\n\n    // P = Q\n    if (this === p)\n      return true;\n\n    // P = O\n    if (this.inf)\n      return p.inf;\n\n    // Q = O\n    if (p.inf)\n      return false;\n\n    // X1 = X2, Y1 = Y2\n    return this.x.eq(p.x)\n        && this.y.eq(p.y);\n  }\n\n  cmp(point) {\n    assert(point instanceof ShortPoint);\n\n    if (this.inf && !point.inf)\n      return -1;\n\n    if (!this.inf && point.inf)\n      return 1;\n\n    if (this.inf && point.inf)\n      return 0;\n\n    return this.order().cmp(point.order())\n        || this.getX().cmp(point.getX())\n        || this.getY().cmp(point.getY());\n  }\n\n  isInfinity() {\n    // Infinity cannot be represented in\n    // the affine space, except by a flag.\n    return this.inf;\n  }\n\n  isOrder2() {\n    if (this.inf)\n      return false;\n\n    return this.y.isZero();\n  }\n\n  isOdd() {\n    if (this.inf)\n      return false;\n\n    return this.y.redIsOdd();\n  }\n\n  isEven() {\n    if (this.inf)\n      return false;\n\n    return this.y.redIsEven();\n  }\n\n  isSquare() {\n    if (this.inf)\n      return false;\n\n    return this.y.redJacobi() !== -1;\n  }\n\n  eqX(x) {\n    assert(x instanceof BN);\n    assert(!x.red);\n\n    if (this.inf)\n      return false;\n\n    return this.getX().eq(x);\n  }\n\n  eqR(x) {\n    assert(x instanceof BN);\n    assert(!x.red);\n    assert(!this.curve.n.isZero());\n\n    if (this.inf)\n      return false;\n\n    return this.getX().imod(this.curve.n).eq(x);\n  }\n\n  mul(k) {\n    return super.mul(k).toP();\n  }\n\n  muln(k) {\n    return super.muln(k).toP();\n  }\n\n  mulBlind(k, rng) {\n    return super.mulBlind(k, rng).toP();\n  }\n\n  mulAdd(k1, p2, k2) {\n    return super.mulAdd(k1, p2, k2).toP();\n  }\n\n  mulH() {\n    return super.mulH().toP();\n  }\n\n  div(k) {\n    return super.div(k).toP();\n  }\n\n  divn(k) {\n    return super.divn(k).toP();\n  }\n\n  divH() {\n    return super.divH().toP();\n  }\n\n  toP() {\n    return this;\n  }\n\n  toJ() {\n    // (X3, Y3, Z3) = (1, 1, 0)\n    if (this.inf)\n      return this.curve.jpoint();\n\n    // (X3, Y3, Z3) = (X1, Y1, 1)\n    return this.curve.jpoint(this.x, this.y, this.curve.one);\n  }\n\n  encode(compact) {\n    // [SEC1] Page 10, Section 2.3.3.\n    if (compact == null)\n      compact = true;\n\n    assert(typeof compact === 'boolean');\n\n    const {fieldSize} = this.curve;\n\n    // We do not serialize points at infinity.\n    if (this.inf)\n      throw new Error('Invalid point.');\n\n    // Compressed form (0x02 = even, 0x03 = odd).\n    if (compact) {\n      const p = Buffer.alloc(1 + fieldSize);\n      const x = this.curve.encodeField(this.getX());\n\n      p[0] = 0x02 | this.y.redIsOdd();\n      x.copy(p, 1);\n\n      return p;\n    }\n\n    // Uncompressed form (0x04).\n    const p = Buffer.alloc(1 + fieldSize * 2);\n    const x = this.curve.encodeField(this.getX());\n    const y = this.curve.encodeField(this.getY());\n\n    p[0] = 0x04;\n    x.copy(p, 1);\n    y.copy(p, 1 + fieldSize);\n\n    return p;\n  }\n\n  static decode(curve, bytes) {\n    // [SEC1] Page 11, Section 2.3.4.\n    assert(curve instanceof ShortCurve);\n    assert(Buffer.isBuffer(bytes));\n\n    const len = curve.fieldSize;\n\n    if (bytes.length < 1 + len)\n      throw new Error('Not a point.');\n\n    // Point forms:\n    //\n    //   0x00 -> Infinity (openssl, unsupported)\n    //   0x02 -> Compressed Even\n    //   0x03 -> Compressed Odd\n    //   0x04 -> Uncompressed\n    //   0x06 -> Hybrid Even (openssl)\n    //   0x07 -> Hybrid Odd (openssl)\n    //\n    // Note that openssl supports serializing points\n    // at infinity as {0}. We choose not to support it\n    // because it's strange and not terribly useful.\n    const form = bytes[0];\n\n    switch (form) {\n      case 0x02:\n      case 0x03: {\n        if (bytes.length !== 1 + len)\n          throw new Error('Invalid point size for compressed.');\n\n        const x = curve.decodeField(bytes.slice(1, 1 + len));\n\n        if (x.cmp(curve.p) >= 0)\n          throw new Error('Invalid point.');\n\n        const p = curve.pointFromX(x, form === 0x03);\n\n        assert(!p.isInfinity());\n\n        return p;\n      }\n\n      case 0x04:\n      case 0x06:\n      case 0x07: {\n        if (bytes.length !== 1 + len * 2)\n          throw new Error('Invalid point size for uncompressed.');\n\n        const x = curve.decodeField(bytes.slice(1, 1 + len));\n        const y = curve.decodeField(bytes.slice(1 + len, 1 + 2 * len));\n\n        // [GECC] Algorithm 4.3, Page 180, Section 4.\n        if (x.cmp(curve.p) >= 0 || y.cmp(curve.p) >= 0)\n          throw new Error('Invalid point.');\n\n        // OpenSSL hybrid encoding.\n        if (form !== 0x04 && form !== (0x06 | y.isOdd()))\n          throw new Error('Invalid hybrid encoding.');\n\n        const p = curve.point(x, y);\n\n        if (!p.validate())\n          throw new Error('Invalid point.');\n\n        assert(!p.isInfinity());\n\n        return p;\n      }\n\n      default: {\n        throw new Error('Unknown point format.');\n      }\n    }\n  }\n\n  encodeX() {\n    // [SCHNORR] \"Specification\".\n    // [BIP340] \"Specification\".\n    return this.curve.encodeField(this.getX());\n  }\n\n  static decodeEven(curve, bytes) {\n    // [BIP340] \"Specification\".\n    assert(curve instanceof ShortCurve);\n\n    const x = curve.decodeField(bytes);\n\n    if (x.cmp(curve.p) >= 0)\n      throw new Error('Invalid point.');\n\n    return curve.pointFromX(x, false);\n  }\n\n  static decodeSquare(curve, bytes) {\n    // [SCHNORR] \"Specification\".\n    assert(curve instanceof ShortCurve);\n\n    const x = curve.decodeField(bytes);\n\n    if (x.cmp(curve.p) >= 0)\n      throw new Error('Invalid point.');\n\n    return curve.pointFromX(x);\n  }\n\n  toJSON(pre) {\n    if (this.inf)\n      return [];\n\n    const x = this.getX().toJSON();\n    const y = this.getY().toJSON();\n\n    if (pre === true && this.pre)\n      return [x, y, this.pre.toJSON()];\n\n    return [x, y];\n  }\n\n  toPretty() {\n    if (this.inf)\n      return [];\n\n    const size = this.curve.fieldSize * 2;\n    const x = toPretty(this.getX(), size);\n    const y = toPretty(this.getY(), size);\n\n    return [x, y];\n  }\n\n  static fromJSON(curve, json) {\n    assert(curve instanceof ShortCurve);\n    assert(Array.isArray(json));\n    assert(json.length === 0\n        || json.length === 2\n        || json.length === 3);\n\n    if (json.length === 0)\n      return curve.point();\n\n    const x = BN.fromJSON(json[0]);\n    const y = BN.fromJSON(json[1]);\n    const point = curve.point(x, y);\n\n    if (json.length > 2 && json[2] != null)\n      point.pre = Precomp.fromJSON(point, json[2]);\n\n    return point;\n  }\n\n  [custom]() {\n    if (this.inf)\n      return '<ShortPoint: Infinity>';\n\n    return '<ShortPoint:'\n         + ' x=' + this.x.fromRed().toString(16, 2)\n         + ' y=' + this.y.fromRed().toString(16, 2)\n         + '>';\n  }\n}\n\n/**\n * JPoint\n */\n\nclass JPoint extends Point {\n  constructor(curve, x, y, z) {\n    assert(curve instanceof ShortCurve);\n\n    super(curve, types.JACOBIAN);\n\n    this.x = this.curve.one;\n    this.y = this.curve.one;\n    this.z = this.curve.zero;\n    this.zOne = false;\n\n    if (x != null)\n      this._init(x, y, z);\n  }\n\n  _init(x, y, z) {\n    assert(x instanceof BN);\n    assert(y instanceof BN);\n    assert(z == null || (z instanceof BN));\n\n    this.x = x;\n    this.y = y;\n    this.z = z || this.curve.one;\n\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n\n    if (!this.z.red)\n      this.z = this.z.toRed(this.curve.red);\n\n    this.zOne = this.z.eq(this.curve.one);\n  }\n\n  clone() {\n    return this.curve.jpoint(this.x, this.y, this.z);\n  }\n\n  validate() {\n    // [GECC] Example 3.20, Page 88, Section 3.\n    const {a, b} = this.curve;\n\n    // P = O\n    if (this.isInfinity())\n      return true;\n\n    // Z1 = 1\n    if (this.zOne)\n      return this.curve.validate(this.toP());\n\n    // y^2 = x^3 + a * x * z^4 + b * z^6\n    const lhs = this.y.redSqr();\n    const x3 = this.x.redSqr().redMul(this.x);\n    const z2 = this.z.redSqr();\n    const z4 = z2.redSqr();\n    const z6 = z4.redMul(z2);\n    const rhs = x3.redIAdd(b.redMul(z6));\n\n    if (!this.curve.zeroA) {\n      // Save some cycles for a = -3.\n      if (this.curve.threeA)\n        rhs.redIAdd(z4.redIMuln(-3).redMul(this.x));\n      else\n        rhs.redIAdd(a.redMul(z4).redMul(this.x));\n    }\n\n    return lhs.eq(rhs);\n  }\n\n  normalize() {\n    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#scaling-z\n    // 1I + 3M + 1S\n\n    // Z = 1\n    if (this.zOne)\n      return this;\n\n    // P = O\n    if (this.isInfinity())\n      return this;\n\n    // A = 1 / Z1\n    const a = this.z.redInvert();\n\n    // AA = A^2\n    const aa = a.redSqr();\n\n    // X3 = X1 * AA\n    this.x = this.x.redMul(aa);\n\n    // Y3 = Y1 * AA * A\n    this.y = this.y.redMul(aa).redMul(a);\n\n    // Z3 = 1\n    this.z = this.curve.one;\n    this.zOne = true;\n\n    return this;\n  }\n\n  scale(a) {\n    assert(a instanceof BN);\n\n    // P = O\n    if (this.isInfinity())\n      return this.curve.jpoint();\n\n    // AA = A^2\n    const aa = a.redSqr();\n\n    // X3 = X1 * AA\n    const nx = this.x.redMul(aa);\n\n    // Y3 = Y1 * AA * A\n    const ny = this.y.redMul(aa).redMul(a);\n\n    // Z3 = Z1 * A\n    const nz = this.z.redMul(a);\n\n    return this.curve.jpoint(nx, ny, nz);\n  }\n\n  neg() {\n    // -(X1, Y1, Z1) = (X1, -Y1, Z1)\n    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n  }\n\n  add(p) {\n    assert(p instanceof Point);\n\n    if (p.type === types.AFFINE)\n      return this._mixedAdd(p);\n\n    return this._add(p);\n  }\n\n  _add(p) {\n    assert(p instanceof JPoint);\n\n    // O + P = P\n    if (this.isInfinity())\n      return p;\n\n    // P + O = P\n    if (p.isInfinity())\n      return this;\n\n    // Z1 = 1\n    if (this.zOne)\n      return p._addJA(this);\n\n    // Z2 = 1\n    if (p.zOne)\n      return this._addJA(p);\n\n    return this._addJJ(p);\n  }\n\n  _mixedAdd(p) {\n    assert(p instanceof ShortPoint);\n\n    // O + P = P\n    if (this.isInfinity())\n      return p.toJ();\n\n    // P + O = P\n    if (p.isInfinity())\n      return this;\n\n    return this._addJA(p);\n  }\n\n  _addJJ(p) {\n    // No assumptions.\n    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#addition-add-1998-cmo-2\n    // 12M + 4S + 6A + 1*2 (implemented as: 12M + 4S + 7A)\n\n    // Z1Z1 = Z1^2\n    const z1z1 = this.z.redSqr();\n\n    // Z2Z2 = Z2^2\n    const z2z2 = p.z.redSqr();\n\n    // U1 = X1 * Z2Z2\n    const u1 = this.x.redMul(z2z2);\n\n    // U2 = X2 * Z1Z1\n    const u2 = p.x.redMul(z1z1);\n\n    // S1 = Y1 * Z2 * Z2Z2\n    const s1 = this.y.redMul(p.z).redMul(z2z2);\n\n    // S2 = Y2 * Z1 * Z1Z1\n    const s2 = p.y.redMul(this.z).redMul(z1z1);\n\n    // H = U2 - U1\n    const h = u2.redISub(u1);\n\n    // r = S2 - S1\n    const r = s2.redISub(s1);\n\n    // H = 0\n    if (h.isZero()) {\n      if (!r.isZero())\n        return this.curve.jpoint();\n\n      return this.dbl();\n    }\n\n    // HH = H^2\n    const hh = h.redSqr();\n\n    // HHH = H * HH\n    const hhh = h.redMul(hh);\n\n    // V = U1 * HH\n    const v = u1.redMul(hh);\n\n    // X3 = r^2 - HHH - 2 * V\n    const nx = r.redSqr().redISub(hhh).redISub(v).redISub(v);\n\n    // Y3 = r * (V - X3) - S1 * HHH\n    const ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(hhh));\n\n    // Z3 = Z1 * Z2 * H\n    const nz = this.z.redMul(p.z).redMul(h);\n\n    return this.curve.jpoint(nx, ny, nz);\n  }\n\n  _addJA(p) {\n    // Assumes Z2 = 1.\n    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#addition-madd\n    // 8M + 3S + 6A + 5*2 (implemented as: 8M + 3S + 7A + 4*2)\n\n    // Z1Z1 = Z1^2\n    const z1z1 = this.z.redSqr();\n\n    // U2 = X2 * Z1Z1\n    const u2 = p.x.redMul(z1z1);\n\n    // S2 = Y2 * Z1 * Z1Z1\n    const s2 = p.y.redMul(this.z).redMul(z1z1);\n\n    // H = U2 - X1\n    const h = u2.redISub(this.x);\n\n    // r = 2 * (S2 - Y1)\n    const r = s2.redISub(this.y).redIMuln(2);\n\n    // H = 0\n    if (h.isZero()) {\n      if (!r.isZero())\n        return this.curve.jpoint();\n\n      return this.dbl();\n    }\n\n    // I = (2 * H)^2\n    const i = h.redMuln(2).redSqr();\n\n    // J = H * I\n    const j = h.redMul(i);\n\n    // V = X1 * I\n    const v = this.x.redMul(i);\n\n    // X3 = r^2 - J - 2 * V\n    const nx = r.redSqr().redISub(j).redISub(v).redISub(v);\n\n    // Y3 = r * (V - X3) - 2 * Y1 * J\n    const ny = r.redMul(v.redISub(nx)).redISub(this.y.redMul(j).redIMuln(2));\n\n    // Z3 = 2 * Z1 * H\n    const nz = this.z.redMul(h).redIMuln(2);\n\n    return this.curve.jpoint(nx, ny, nz);\n  }\n\n  dbl() {\n    // P = O\n    if (this.isInfinity())\n      return this;\n\n    // Y1 = 0\n    if (this.y.isZero())\n      return this.curve.jpoint();\n\n    // a = 0\n    if (this.curve.zeroA)\n      return this._dbl0();\n\n    // a = -3\n    if (this.curve.threeA)\n      return this._dbl3();\n\n    return this._dblJ();\n  }\n\n  _dblJ() {\n    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#doubling-dbl-1998-cmo-2\n    // 3M + 6S + 4A + 1*a + 2*2 + 1*3 + 1*4 + 1*8\n    // (implemented as: 3M + 6S + 5A + 1*a + 1*2 + 1*3 + 1*4 + 1*8)\n\n    // XX = X1^2\n    const xx = this.x.redSqr();\n\n    // YY = Y1^2\n    const yy = this.y.redSqr();\n\n    // ZZ = Z1^2\n    const zz = this.z.redSqr();\n\n    // S = 4 * X1 * YY\n    const s = this.x.redMul(yy).redIMuln(4);\n\n    // M = 3 * XX + a * ZZ^2\n    const m = xx.redIMuln(3).redIAdd(this.curve.a.redMul(zz.redSqr()));\n\n    // T = M^2 - 2 * S\n    const t = m.redSqr().redISub(s).redISub(s);\n\n    // X3 = T\n    const nx = t;\n\n    // Y3 = M * (S - T) - 8 * YY^2\n    const ny = m.redMul(s.redISub(t)).redISub(yy.redSqr().redIMuln(8));\n\n    // Z3 = 2 * Y1 * Z1\n    const nz = this.y.redMul(this.z).redIMuln(2);\n\n    return this.curve.jpoint(nx, ny, nz);\n  }\n\n  _dbl0() {\n    // Assumes a = 0.\n    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-dbl-2009-l\n    // 2M + 5S + 6A + 3*2 + 1*3 + 1*8\n    // (implemented as: 2M + 5S + 7A + 2*2 + 1*3 + 1*8)\n\n    // A = X1^2\n    const a = this.x.redSqr();\n\n    // B = Y1^2\n    const b = this.y.redSqr();\n\n    // C = B^2\n    const c = b.redSqr();\n\n    // + XB2 = (X1 + B)^2\n    const xb2 = b.redIAdd(this.x).redSqr();\n\n    // D = 2 * ((X1 + B)^2 - A - C)\n    const d = xb2.redISub(a).redISub(c).redIMuln(2);\n\n    // E = 3 * A\n    const e = a.redIMuln(3);\n\n    // F = E^2\n    const f = e.redSqr();\n\n    // X3 = F - 2 * D\n    const nx = f.redISub(d).redISub(d);\n\n    // Y3 = E * (D - X3) - 8 * C\n    const ny = e.redMul(d.redISub(nx)).redISub(c.redIMuln(8));\n\n    // Z3 = 2 * Y1 * Z1\n    const nz = this.y.redMul(this.z).redIMuln(2);\n\n    return this.curve.jpoint(nx, ny, nz);\n  }\n\n  _dbl3() {\n    // Assumes a = -3.\n    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n    // 3M + 5S + 8A + 1*3 + 1*4 + 2*8\n    // (implemented as: 3M + 5S + 8A + 1*2 + 1*3 + 1*4 + 1*8)\n\n    // delta = Z1^2\n    const delta = this.z.redSqr();\n\n    // gamma = Y1^2\n    const gamma = this.y.redSqr();\n\n    // beta = X1 * gamma\n    const beta = this.x.redMul(gamma);\n\n    // + xmdelta = X1 - delta\n    const xmdelta = this.x.redSub(delta);\n\n    // + xpdelta = X1 + delta\n    const xpdelta = this.x.redAdd(delta);\n\n    // alpha = 3 * (X1 - delta) * (X1 + delta)\n    const alpha = xmdelta.redMul(xpdelta).redIMuln(3);\n\n    // + beta4 = 4 * beta\n    const beta4 = beta.redIMuln(4);\n\n    // + beta8 = 2 * beta4\n    const beta8 = beta4.redMuln(2);\n\n    // + gamma28 = 8 * gamma^2\n    const gamma28 = gamma.redSqr().redIMuln(8);\n\n    // X3 = alpha^2 - 8 * beta\n    const nx = alpha.redSqr().redISub(beta8);\n\n    // Z3 = (Y1 + Z1)^2 - gamma - delta\n    const nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n\n    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n    const ny = alpha.redMul(beta4.redISub(nx)).redISub(gamma28);\n\n    return this.curve.jpoint(nx, ny, nz);\n  }\n\n  getX() {\n    if (this.isInfinity())\n      throw new Error('Invalid point.');\n\n    this.normalize();\n\n    return this.x.fromRed();\n  }\n\n  getY() {\n    if (this.isInfinity())\n      throw new Error('Invalid point.');\n\n    this.normalize();\n\n    return this.y.fromRed();\n  }\n\n  eq(p) {\n    assert(p instanceof JPoint);\n\n    // P = Q\n    if (this === p)\n      return true;\n\n    // P = O\n    if (this.isInfinity())\n      return p.isInfinity();\n\n    // Q = O\n    if (p.isInfinity())\n      return false;\n\n    // Z1 = Z2\n    if (this.z.eq(p.z)) {\n      return this.x.eq(p.x)\n          && this.y.eq(p.y);\n    }\n\n    // X1 * Z2^2 = X2 * Z1^2\n    const zz1 = this.z.redSqr();\n    const zz2 = p.z.redSqr();\n    const x1 = this.x.redMul(zz2);\n    const x2 = p.x.redMul(zz1);\n\n    if (!x1.eq(x2))\n      return false;\n\n    // Y1 * Z2^3 = Y2 * Z1^3\n    const zzz1 = zz1.redMul(this.z);\n    const zzz2 = zz2.redMul(p.z);\n    const y1 = this.y.redMul(zzz2);\n    const y2 = p.y.redMul(zzz1);\n\n    return y1.eq(y2);\n  }\n\n  cmp(point) {\n    assert(point instanceof JPoint);\n\n    const inf1 = this.isInfinity();\n    const inf2 = point.isInfinity();\n\n    if (inf1 && !inf2)\n      return -1;\n\n    if (!inf1 && inf2)\n      return 1;\n\n    if (inf1 && inf2)\n      return 0;\n\n    return this.order().cmp(point.order())\n        || this.getX().cmp(point.getX())\n        || this.getY().cmp(point.getY());\n  }\n\n  isInfinity() {\n    // Z1 = 0\n    return this.z.isZero();\n  }\n\n  isOrder2() {\n    if (this.isInfinity())\n      return false;\n\n    return this.y.isZero();\n  }\n\n  isOdd() {\n    if (this.isInfinity())\n      return false;\n\n    this.normalize();\n\n    return this.y.redIsOdd();\n  }\n\n  isEven() {\n    if (this.isInfinity())\n      return false;\n\n    this.normalize();\n\n    return this.y.redIsEven();\n  }\n\n  isSquare() {\n    if (this.isInfinity())\n      return false;\n\n    return this.y.redMul(this.z).redJacobi() !== -1;\n  }\n\n  eqX(x) {\n    // Verify that integer `x` is equal to field\n    // element `x` by scaling it by our z coordinate.\n    // This optimization is mentioned in and used for\n    // bip-schnorr[1]. This avoids having to affinize\n    // the resulting point during verification.\n    //\n    // [1] [SCHNORR] \"Optimizations\".\n    assert(x instanceof BN);\n    assert(!x.red);\n\n    if (this.isInfinity())\n      return false;\n\n    const zz = this.z.redSqr();\n    const rx = x.toRed(this.curve.red).redMul(zz);\n\n    return this.x.eq(rx);\n  }\n\n  eqR(x) {\n    // Similar to the optimization above, this\n    // optimization, suggested by Maxwell[1],\n    // compares an integer to an X coordinate\n    // by scaling it.\n    //\n    // Since a signature's R value is modulo N\n    // in ECDSA, we may be dealing with an R\n    // value greater than N in actuality.\n    //\n    // If the equality check fails, we can\n    // scale N itself by Z and add it to the\n    // X field element.\n    //\n    // [1] https://github.com/bitcoin-core/secp256k1/commit/ce7eb6f\n    assert(x instanceof BN);\n    assert(!x.red);\n\n    if (!this.curve.smallGap)\n      return this.toP().eqR(x);\n\n    if (this.isInfinity())\n      return false;\n\n    if (x.cmp(this.curve.p) >= 0)\n      return false;\n\n    const zz = this.z.redSqr();\n    const rx = x.toRed(this.curve.red).redMul(zz);\n\n    if (this.x.eq(rx))\n      return true;\n\n    if (this.curve.highOrder)\n      return false;\n\n    if (x.cmp(this.curve.pmodn) >= 0)\n      return false;\n\n    const rn = this.curve.redN.redMul(zz);\n\n    rx.redIAdd(rn);\n\n    return this.x.eq(rx);\n  }\n\n  toP() {\n    // P = O\n    if (this.isInfinity())\n      return this.curve.point();\n\n    this.normalize();\n\n    // (X3, Y3) = (X1 / Z1^2, Y1 / Z1^3)\n    return this.curve.point(this.x, this.y);\n  }\n\n  toJ() {\n    return this;\n  }\n\n  encode(compact) {\n    return this.toP().encode(compact);\n  }\n\n  static decode(curve, bytes) {\n    return ShortPoint.decode(curve, bytes).toJ();\n  }\n\n  encodeX() {\n    return this.toP().encodeX();\n  }\n\n  static decodeEven(curve, bytes) {\n    return ShortPoint.decodeEven(curve, bytes).toJ();\n  }\n\n  static decodeSquare(curve, bytes) {\n    return ShortPoint.decodeSquare(curve, bytes).toJ();\n  }\n\n  toJSON(pre) {\n    return this.toP().toJSON(pre);\n  }\n\n  toPretty() {\n    return this.toP().toPretty();\n  }\n\n  static fromJSON(curve, json) {\n    return ShortPoint.fromJSON(curve, json).toJ();\n  }\n\n  [custom]() {\n    if (this.isInfinity())\n      return '<JPoint: Infinity>';\n\n    return '<JPoint:'\n         + ' x=' + this.x.fromRed().toString(16, 2)\n         + ' y=' + this.y.fromRed().toString(16, 2)\n         + ' z=' + this.z.fromRed().toString(16, 2)\n         + '>';\n  }\n}\n\n/**\n * MontCurve\n */\n\nclass MontCurve extends Curve {\n  constructor(conf) {\n    super(MontPoint, 'mont', conf);\n\n    this.a = BN.fromJSON(conf.a).toRed(this.red);\n    this.b = BN.fromJSON(conf.b).toRed(this.red);\n\n    this.bi = this.b.redInvert();\n    this.a2 = this.a.redAdd(this.two);\n    this.a24 = this.a2.redMul(this.i4);\n    this.a3 = this.a.redMul(this.i3);\n    this.a0 = this.a.redMul(this.bi);\n    this.b0 = this.bi.redSqr();\n\n    this._finalize(conf);\n  }\n\n  static _isomorphism(curveA, curveB, customB) {\n    // Montgomery Isomorphism.\n    //\n    // [MONT3] Page 3, Section 2.1.\n    //\n    // Transformation:\n    //\n    //   A' = A\n    //   B' = B'\n    //\n    // Where (B / B') is square.\n    assert(curveA instanceof BN);\n    assert(curveB instanceof BN);\n    assert(customB instanceof BN);\n\n    const a = curveA.clone();\n    const b = customB.clone();\n    const c = curveB.redDiv(customB);\n\n    if (c.redJacobi() !== 1)\n      throw new Error('Invalid `b` coefficient.');\n\n    return [a, b];\n  }\n\n  _short(a0, odd) {\n    // Montgomery->Short Weierstrass Equivalence.\n    //\n    // [MONT2] \"Equivalence with Weierstrass curves\".\n    //\n    // Transformation:\n    //\n    //   a = (3 - A^2) / (3 * B^2)\n    //   b = (2 * A^3 - 9 * A) / (27 * B^3)\n    const {a, b, three} = this;\n    const a2 = a.redSqr();\n    const a3 = a2.redMul(a);\n    const b2 = b.redSqr();\n    const b3 = b2.redMul(b);\n    const n0 = three.redSub(a2);\n    const d0 = b2.redMuln(3);\n    const n1 = a3.redMuln(2).redISub(a.redMuln(9));\n    const d1 = b3.redMuln(27);\n    const wa = n0.redDiv(d0);\n    const wb = n1.redDiv(d1);\n\n    if (a0 != null)\n      return ShortCurve._isomorphism(wa, wb, a0, odd);\n\n    return [wa, wb];\n  }\n\n  _mont(b0) {\n    return MontCurve._isomorphism(this.a, this.b, b0);\n  }\n\n  _edwards(a0, invert = false) {\n    // Montgomery->Twisted Edwards Transformation.\n    //\n    // [MONT1] Page 11, Section 4.3.5.\n    // [TWISTED] Theorem 3.2, Page 4, Section 3.\n    //\n    // Equivalence:\n    //\n    //   a = (A + 2) / B\n    //   d = (A - 2) / B\n    //\n    // Isomorphism:\n    //\n    //   a = a'\n    //   d = a' * (A - 2) / (A + 2)\n    //\n    // Where ((A + 2) / (B * a')) is square.\n    //\n    // If `d` is square, we can usually find\n    // a complete curve by using the `invert`\n    // option. This will create an isomorphism\n    // chain of: M(A,B)->E(a,d)->E(d,a).\n    //\n    // The equivalence between E(a,d) and\n    // E(d,a) is:\n    //\n    //   (x, y) = (x, 1 / y)\n    //\n    // Meaning our map to E(d,a) is:\n    //\n    //   x = u / v\n    //   y = 1 / ((u - 1) / (u + 1))\n    //     = (u + 1) / (u - 1)\n    assert(typeof invert === 'boolean');\n\n    const {two, bi} = this;\n    const a = this.a.redAdd(two).redMul(bi);\n    const d = this.a.redSub(two).redMul(bi);\n\n    if (invert)\n      a.swap(d);\n\n    if (a0 != null)\n      return EdwardsCurve._isomorphism(a, d, a0);\n\n    return [a, d];\n  }\n\n  _scaleShort(curve) {\n    assert(curve instanceof ShortCurve);\n\n    const [u2, u3] = curve._scale(this);\n\n    return [this.field(u2.redInvert()),\n            this.field(u3.redInvert())];\n  }\n\n  _scaleMont(curve) {\n    // We can extract the isomorphism factor with:\n    //\n    //   c = +-sqrt(B / B')\n    //\n    // If base points are available, we can do:\n    //\n    //   c = v' / v\n    assert(curve instanceof MontCurve);\n\n    if (this.g.isInfinity() || curve.g.isInfinity())\n      return this.field(curve.b).redDivSqrt(this.b);\n\n    return this.g.y.redDiv(this.field(curve.g.y));\n  }\n\n  _scaleEdwards(curve, invert) {\n    // We _could_ do something like:\n    //\n    //   B = 4 / (a - d)\n    //   c = +-sqrt(B / B')\n    //\n    // Which can be reduced to:\n    //\n    //   c = +-sqrt(4 / ((a - d) * B'))\n    //\n    // If base points are available:\n    //\n    //   v = u' / x\n    //   c = v' / v\n    //\n    // Which can be reduced to:\n    //\n    //   c = v' * x / u'\n    //\n    // However, the way our maps are\n    // written, we can re-use the Edwards\n    // isomorphism factor when going the\n    // other direction.\n    assert(curve instanceof EdwardsCurve);\n\n    const c = curve._scale(this, invert);\n\n    return this.field(c);\n  }\n\n  _solveY0(x) {\n    assert(x instanceof BN);\n\n    // y^2 = x^3 + A * x^2 + B * x\n    const a = this.a0;\n    const b = this.b0;\n    const x2 = x.redSqr();\n    const x3 = x2.redMul(x);\n    const y2 = x3.redIAdd(a.redMul(x2)).redIAdd(b.redMul(x));\n\n    return y2;\n  }\n\n  _elligator2(u) {\n    // Elligator 2.\n    //\n    // Distribution: 1/2.\n    //\n    // [ELL2] Page 11, Section 5.2.\n    // [H2EC] \"Elligator 2 Method\".\n    //        \"Mappings for Montgomery curves\".\n    // [SAFE] \"Indistinguishability from uniform random strings\".\n    //\n    // Assumptions:\n    //\n    //   - y^2 = x^3 + A * x^2 + B * x.\n    //   - A != 0, B != 0.\n    //   - A^2 - 4 * B is non-zero and non-square in F(p).\n    //   - Let z be a non-square in F(p).\n    //   - u != +-sqrt(-1 / z).\n    //\n    // Note that Elligator 2 is defined over the form:\n    //\n    //   y'^2 = x'^3 + A' * x'^2 + B' * x'\n    //\n    // Instead of:\n    //\n    //   B * y^2 = x^3 + A * x^2 + x\n    //\n    // Where:\n    //\n    //   A' = A / B\n    //   B' = 1 / B^2\n    //   x' = x / B\n    //   y' = y / B\n    //\n    // And:\n    //\n    //   x = B * x'\n    //   y = B * y'\n    //\n    // This is presumably the result of Elligator 2\n    // being designed in long Weierstrass form. If\n    // we want to support B != 1, we need to do the\n    // conversion.\n    //\n    // Map:\n    //\n    //   g(x) = x^3 + A * x^2 + B * x\n    //   x1 = -A / (1 + z * u^2)\n    //   x1 = -A, if x1 = 0\n    //   x2 = -x1 - A\n    //   x = x1, if g(x1) is square\n    //     = x2, otherwise\n    //   y = sign(u) * abs(sqrt(g(x)))\n    const lhs = this.a0.redNeg();\n    const rhs = this.one.redAdd(this.z.redMul(u.redSqr()));\n\n    if (rhs.isZero())\n      rhs.inject(this.one);\n\n    const x1 = lhs.redMul(rhs.redInvert());\n    const x2 = x1.redNeg().redISub(this.a0);\n    const y1 = this._solveY0(x1);\n    const y2 = this._solveY0(x2);\n    const alpha = y1.redIsSquare() | 0;\n    const x0 = [x1, x2][alpha ^ 1];\n    const y0 = [y1, y2][alpha ^ 1].redSqrt();\n\n    if (y0.redIsOdd() !== u.redIsOdd())\n      y0.redINeg();\n\n    const x = this.b.redMul(x0);\n    const y = this.b.redMul(y0);\n\n    return this.point(x, y);\n  }\n\n  _invert2(p, hint) {\n    // Inverting the Map (Elligator 2).\n    //\n    // [ELL2] Page 12, Section 5.3.\n    //\n    // Assumptions:\n    //\n    //   - -z * x * (x + A) is square in F(p).\n    //   - If r = 1 then x != 0.\n    //   - If r = 2 then x != -A.\n    //\n    // Map:\n    //\n    //   u1 = -(x + A) / (x * z)\n    //   u2 = -x / ((x + A) * z)\n    //   r = random integer in [1,2]\n    //   u = sign(y) * abs(sqrt(ur))\n    //\n    // Note that `0 / 0` can only occur if A = 0\n    // (this violates the assumptions of Elligator 2).\n    const {x, y} = p;\n    const r = hint & 1;\n    const x0 = x.redMul(this.bi);\n    const y0 = y.redMul(this.bi);\n    const n = x0.redAdd(this.a0);\n    const d = x0;\n    const lhs = [n, d][r].redINeg();\n    const rhs = [d, n][r].redMul(this.z);\n    const u = lhs.redDivSqrt(rhs);\n\n    if (u.redIsOdd() !== y0.redIsOdd())\n      u.redINeg();\n\n    return u;\n  }\n\n  isElliptic() {\n    const a2 = this.a.redSqr();\n    const d = this.b.redMul(a2.redSub(this.four));\n\n    // B * (A^2 - 4) != 0\n    return !d.isZero();\n  }\n\n  jinv() {\n    // [MONT3] Page 3, Section 2.\n    const {a, three, four} = this;\n    const a2 = a.redSqr();\n    const t0 = a2.redSub(three);\n    const lhs = t0.redPown(3).redIMuln(256);\n    const rhs = a2.redSub(four);\n\n    if (rhs.isZero())\n      throw new Error('Curve is not elliptic.');\n\n    // (256 * (A^2 - 3)^3) / (A^2 - 4)\n    return lhs.redDiv(rhs).fromRed();\n  }\n\n  point(x, y) {\n    return new MontPoint(this, x, y);\n  }\n\n  jpoint(x, y, z) {\n    assert(x == null && y == null && z == null);\n    return this.point();\n  }\n\n  xpoint(x, z) {\n    return new XPoint(this, x, z);\n  }\n\n  solveY2(x) {\n    // [MONT3] Page 3, Section 2.\n    // https://hyperelliptic.org/EFD/g1p/auto-montgom.html\n    assert(x instanceof BN);\n\n    // B * y^2 = x^3 + A * x^2 + x\n    const x2 = x.redSqr();\n    const x3 = x2.redMul(x);\n    const by2 = x3.redIAdd(this.a.redMul(x2)).redIAdd(x);\n    const y2 = by2.redMul(this.bi);\n\n    return y2;\n  }\n\n  validate(point) {\n    assert(point instanceof MontPoint);\n\n    if (point.isInfinity())\n      return true;\n\n    const {x, y} = point;\n    const y2 = this.solveY2(x);\n\n    return y.redSqr().eq(y2);\n  }\n\n  pointFromX(x, sign = null) {\n    assert(x instanceof BN);\n    assert(sign == null || typeof sign === 'boolean');\n\n    if (!x.red)\n      x = x.toRed(this.red);\n\n    const y = this.solveY(x);\n\n    if (sign != null) {\n      if (y.isZero() && sign)\n        throw new Error('Invalid point.');\n\n      if (y.redIsOdd() !== sign)\n        y.redINeg();\n    }\n\n    return this.point(x, y);\n  }\n\n  isIsomorphic(curve, invert) {\n    // [MONT3] Page 3, Section 2.1.\n    assert(curve instanceof Curve);\n\n    if (!curve.p.eq(this.p))\n      return false;\n\n    // M(A,B) <-> M(A,B')\n    if (curve.type === 'mont') {\n      const a = this.field(curve.a);\n      const b = this.field(curve.b);\n\n      // A' = A\n      if (!this.a.eq(a))\n        return false;\n\n      // B' != 0\n      if (this.b.isZero())\n        return false;\n\n      // jacobi(B / B') = 1\n      const c = b.redDiv(this.b);\n\n      return c.redJacobi() === 1;\n    }\n\n    return curve.isIsomorphic(this, invert);\n  }\n\n  isIsogenous(curve) {\n    assert(curve instanceof Curve);\n\n    if (curve.type === 'mont')\n      return false;\n\n    return curve.isIsogenous(this);\n  }\n\n  pointFromShort(point) {\n    // [ALT] Appendix E.2 (Switching between Alternative Representations).\n    // [MONT2] \"Equivalence with Weierstrass curves\"\n    assert(point instanceof ShortPoint);\n\n    if (this.isIsomorphic(point.curve)) {\n      // Equivalence for E(a,b)->M(A,B):\n      //\n      //   u = B * x - A / 3\n      //   v = B * y\n      //\n      // Undefined if ((u^3 + A * u^2 + u) / B) is not square.\n      if (point.isInfinity())\n        return this.point();\n\n      const {a3, b} = this;\n      const [u2, u3] = this._scale(point.curve);\n      const x = this.field(point.x).redMul(u2);\n      const y = this.field(point.y).redMul(u3);\n      const u = b.redMul(x).redISub(a3);\n      const v = b.redMul(y);\n\n      return this.point(u, v);\n    }\n\n    throw new Error('Not implemented.');\n  }\n\n  pointFromMont(point) {\n    // [MONT3] Page 3, Section 2.1.\n    assert(point instanceof MontPoint);\n\n    if (this.isIsomorphic(point.curve)) {\n      // Isomorphic maps for M(A,B)<->M(A,B'):\n      //\n      //   u' = u\n      //   v' = +-sqrt(B / B') * v\n      //\n      // Undefined if (B / B') is not square.\n      if (point.isInfinity())\n        return this.point();\n\n      const c = this._scale(point.curve);\n      const u = this.field(point.x);\n      const v = this.field(point.y);\n      const nu = u;\n      const nv = c.redMul(v);\n\n      return this.point(nu, nv);\n    }\n\n    throw new Error('Not implemented.');\n  }\n\n  pointFromEdwards(point) {\n    // [RFC7748] Section 4.1 & 4.2.\n    // [MONT3] Page 6, Section 2.5.\n    // [TWISTED] Theorem 3.2, Page 4, Section 3.\n    assert(point instanceof EdwardsPoint);\n    assert(point.curve.p.eq(this.p));\n\n    // Edwards `x`, `y`, `z`.\n    const x = this.field(point.x);\n    const y = this.field(point.y);\n    const z = this.field(point.z);\n\n    if (this.isIsogenous(point.curve)) {\n      // 4-isogeny maps for E(1,d)->M(2-4d,1):\n      //\n      //   u = y^2 / x^2\n      //   v = (2 - x^2 - y^2) * y / x^3\n      //\n      // Undefined for x = 0.\n      //\n      // Exceptional Cases:\n      //   - (0, 1) -> O\n      //   - (0, -1) -> (0, 0)\n      //\n      // Unexceptional Cases:\n      //   - (+-1, 0) -> (0, 0)\n      if (point.isInfinity())\n        return this.point();\n\n      if (point.x.isZero())\n        return this.point(this.zero, this.zero);\n\n      const c = z.redSqr().redIMuln(2);\n      const uu = y.redSqr();\n      const uz = x.redSqr();\n      const vv = c.redISub(uz).redISub(uu).redMul(y);\n      const vz = uz.redMul(x);\n\n      return this.cpoint(uu, uz, vv, vz);\n    }\n\n    if (this.isIsomorphic(point.curve, true)) {\n      // Isomorphic maps for E(d,a)->M(A,B):\n      //\n      //   u = (y + 1) / (y - 1)\n      //   v = +-sqrt((A - 2) / (B * a)) * u / x\n      //\n      // Undefined for x = 0 or y = 1.\n      //\n      // Exceptional Cases:\n      //   - (0, 1) -> O\n      //   - (0, -1) -> (0, 0)\n      //\n      // Unexceptional Cases:\n      //   - (+-sqrt(1 / a), 0) -> (-1, +-sqrt((A - 2) / B))\n      if (point.isInfinity())\n        return this.point();\n\n      if (point.x.isZero())\n        return this.point(this.zero, this.zero);\n\n      const c = this._scale(point.curve, true);\n      const uu = y.redAdd(z);\n      const uz = y.redSub(z);\n      const vv = c.redMul(z).redMul(uu);\n      const vz = x.redMul(uz);\n\n      return this.cpoint(uu, uz, vv, vz);\n    }\n\n    if (this.isIsomorphic(point.curve, false)) {\n      // Isomorphic maps for E(a,d)->M(A,B):\n      //\n      //   u = (1 + y) / (1 - y)\n      //   v = +-sqrt((A + 2) / (B * a)) * u / x\n      //\n      // Undefined for x = 0 or y = 1.\n      //\n      // Exceptional Cases:\n      //   - (0, 1) -> O\n      //   - (0, -1) -> (0, 0)\n      //\n      // Unexceptional Cases:\n      //   - (+-sqrt(1 / a), 0) -> (1, +-sqrt((A + 2) / B))\n      if (point.isInfinity())\n        return this.point();\n\n      if (point.x.isZero())\n        return this.point(this.zero, this.zero);\n\n      const c = this._scale(point.curve, false);\n      const uu = z.redAdd(y);\n      const uz = z.redSub(y);\n      const vv = c.redMul(z).redMul(uu);\n      const vz = x.redMul(uz);\n\n      return this.cpoint(uu, uz, vv, vz);\n    }\n\n    throw new Error('Not implemented.');\n  }\n\n  pointFromUniform(u) {\n    assert(u instanceof BN);\n\n    // z = 0 or A = 0\n    if (this.z.isZero() || this.a.isZero())\n      throw new Error('Not implemented.');\n\n    return this._elligator2(u);\n  }\n\n  pointToUniform(p, hint) {\n    // Convert a montgomery point to a field\n    // element by inverting the elligator2 map.\n    //\n    // Hint Layout:\n    //\n    //   [00000000] [0000] [0000]\n    //        |        |      |\n    //        |        |      +-- preimage index\n    //        |        +--- subgroup\n    //        +-- bits to OR with uniform bytes\n    assert(p instanceof MontPoint);\n    assert((hint >>> 0) === hint);\n\n    // z = 0 or A = 0\n    if (this.z.isZero() || this.a.isZero())\n      throw new Error('Not implemented.');\n\n    // P = O\n    if (p.isInfinity())\n      throw new Error('Invalid point.');\n\n    // Add a random torsion component.\n    const i = ((hint >>> 4) & 15) % this.torsion.length;\n    const q = p.add(this.torsion[i]);\n\n    return wrapErrors(() => {\n      return this._invert2(q, hint);\n    });\n  }\n\n  decodePoint(bytes, sign) {\n    return MontPoint.decode(this, bytes, sign);\n  }\n\n  encodeX(point) {\n    assert(point instanceof XPoint);\n    return point.encode();\n  }\n\n  decodeX(bytes) {\n    return XPoint.decode(this, bytes);\n  }\n\n  toShort(a0, odd, sign = null) {\n    const [a, b] = this._short(a0, odd);\n\n    const curve = new ShortCurve({\n      red: this.red,\n      prime: this.prime,\n      p: this.p,\n      a: a,\n      b: b,\n      n: this.n,\n      h: this.h\n    });\n\n    if (sign != null) {\n      const [, u3] = curve._scale(this);\n\n      if (u3.redIsOdd() !== sign)\n        u3.redINeg();\n    }\n\n    if (!this.g.isInfinity())\n      curve.g = curve.pointFromMont(this.g);\n\n    for (let i = 0; i < this.h.word(0); i++)\n      curve.torsion[i] = curve.pointFromMont(this.torsion[i]);\n\n    return curve;\n  }\n\n  toMont(b0, sign = null) {\n    const [a, b] = this._mont(b0);\n\n    const curve = new MontCurve({\n      red: this.red,\n      prime: this.prime,\n      p: this.p,\n      a: a,\n      b: b,\n      n: this.n,\n      h: this.h,\n      z: this.z\n    });\n\n    if (sign != null) {\n      const c = curve._scale(this);\n\n      if (c.redIsOdd() !== sign)\n        c.redINeg();\n    }\n\n    if (!this.g.isInfinity())\n      curve.g = curve.pointFromMont(this.g);\n\n    for (let i = 0; i < this.h.word(0); i++)\n      curve.torsion[i] = curve.pointFromMont(this.torsion[i]);\n\n    return curve;\n  }\n\n  toEdwards(a0, invert, sign = null) {\n    const [a, d] = this._edwards(a0, invert);\n\n    const curve = new EdwardsCurve({\n      red: this.red,\n      prime: this.prime,\n      p: this.p,\n      a: a,\n      d: d,\n      n: this.n,\n      h: this.h,\n      z: this.z\n    });\n\n    if (sign != null) {\n      const c = curve._scale(this, invert);\n\n      if (c.redIsOdd() !== sign)\n        c.redINeg();\n    }\n\n    if (!this.g.isInfinity()) {\n      curve.g = curve.pointFromMont(this.g);\n      curve.g.normalize();\n    }\n\n    if (curve.isComplete()) {\n      for (let i = 0; i < this.h.word(0); i++) {\n        curve.torsion[i] = curve.pointFromMont(this.torsion[i]);\n        curve.torsion[i].normalize();\n      }\n    }\n\n    return curve;\n  }\n\n  pointFromJSON(json) {\n    return MontPoint.fromJSON(this, json);\n  }\n\n  toJSON(pre) {\n    const json = super.toJSON(pre);\n    json.a = this.a.fromRed().toJSON();\n    json.b = this.b.fromRed().toJSON();\n    return json;\n  }\n}\n\n/**\n * MontPoint\n */\n\nclass MontPoint extends Point {\n  constructor(curve, x, y) {\n    assert(curve instanceof MontCurve);\n\n    super(curve, types.AFFINE);\n\n    this.x = this.curve.zero;\n    this.y = this.curve.zero;\n    this.inf = true;\n\n    if (x != null)\n      this._init(x, y);\n  }\n\n  _init(x, y) {\n    assert(x instanceof BN);\n    assert(y instanceof BN);\n\n    this.x = x;\n    this.y = y;\n\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n\n    this.inf = false;\n  }\n\n  clone() {\n    if (this.inf)\n      return this.curve.point();\n\n    return this.curve.point(this.x, this.y);\n  }\n\n  scale(a) {\n    return this.clone();\n  }\n\n  randomize(rng) {\n    return this.clone();\n  }\n\n  neg() {\n    // P = O\n    if (this.inf)\n      return this;\n\n    // -(X1, Y1) = (X1, -Y1)\n    return this.curve.point(this.x, this.y.redNeg());\n  }\n\n  add(p) {\n    // [MONT1] Page 8, Section 4.3.2.\n    //\n    // Addition Law:\n    //\n    //   l = (y2 - y1) / (x2 - x1)\n    //   x3 = b * l^2 - a - x1 - x2\n    //   y3 = l * (x1 - x3) - y1\n    //\n    // 1I + 2M + 1S + 7A + 1*b\n    assert(p instanceof MontPoint);\n\n    // O + P = P\n    if (this.inf)\n      return p;\n\n    // P + O = P\n    if (p.inf)\n      return this;\n\n    // P + P, P + -P\n    if (this.x.eq(p.x)) {\n      // P + -P = O\n      if (!this.y.eq(p.y))\n        return this.curve.point();\n\n      // P + P = 2P\n      return this.dbl();\n    }\n\n    // H = X2 - X1\n    const h = p.x.redSub(this.x);\n\n    // R = Y2 - Y1\n    const r = p.y.redSub(this.y);\n\n    // L = R / H\n    const l = r.redDiv(h);\n\n    // K = b * L^2\n    const k = this.curve.b.redMul(l.redSqr());\n\n    // X3 = K - a - X1 - X2\n    const nx = k.redISub(this.curve.a).redISub(this.x).redISub(p.x);\n\n    // Y3 = L * (X1 - X3) - Y1\n    const ny = l.redMul(this.x.redSub(nx)).redISub(this.y);\n\n    return this.curve.point(nx, ny);\n  }\n\n  dbl() {\n    // [MONT1] Page 8, Section 4.3.2.\n    //\n    // Addition Law (doubling):\n    //\n    //   l = (3 * x1^2 + 2 * a * x1 + 1) / (2 * b * y1)\n    //   x3 = b * l^2 - a - 2 * x1\n    //   y3 = l * (x1 - x3) - y1\n    //\n    // 1I + 3M + 2S + 7A + 1*a + 1*b + 1*b + 2*2 + 1*3\n\n    // P = O\n    if (this.inf)\n      return this;\n\n    // Y1 = 0\n    if (this.y.isZero())\n      return this.curve.point();\n\n    // M1 = 3 * X1^2\n    const m1 = this.x.redSqr().redIMuln(3);\n\n    // M2 = 2 * a * X1\n    const m2 = this.curve.a.redMul(this.x).redIMuln(2);\n\n    // M = M1 + M2 + 1\n    const m = m1.redIAdd(m2).redIAdd(this.curve.one);\n\n    // Z = 2 * b * Y1\n    const z = this.curve.b.redMul(this.y).redIMuln(2);\n\n    // L = M / Z\n    const l = m.redDiv(z);\n\n    // K = b * L^2\n    const k = this.curve.b.redMul(l.redSqr());\n\n    // X3 = K - a - 2 * X1\n    const nx = k.redISub(this.curve.a).redISub(this.x).redISub(this.x);\n\n    // Y3 = L * (X1 - X3) - Y1\n    const ny = l.redMul(this.x.redSub(nx)).redISub(this.y);\n\n    return this.curve.point(nx, ny);\n  }\n\n  getX() {\n    if (this.inf)\n      throw new Error('Invalid point.');\n\n    return this.x.fromRed();\n  }\n\n  getY() {\n    if (this.inf)\n      throw new Error('Invalid point.');\n\n    return this.y.fromRed();\n  }\n\n  eq(p) {\n    assert(p instanceof MontPoint);\n\n    // P = Q\n    if (this === p)\n      return true;\n\n    // P = O\n    if (this.inf)\n      return p.inf;\n\n    // Q = O\n    if (p.inf)\n      return false;\n\n    // X1 = X2, Y1 = Y2\n    return this.x.eq(p.x)\n        && this.y.eq(p.y);\n  }\n\n  cmp(point) {\n    assert(point instanceof MontPoint);\n\n    if (this.inf && !point.inf)\n      return -1;\n\n    if (!this.inf && point.inf)\n      return 1;\n\n    if (this.inf && point.inf)\n      return 0;\n\n    return this.order().cmp(point.order())\n        || this.getX().cmp(point.getX())\n        || this.getY().cmp(point.getY());\n  }\n\n  isInfinity() {\n    // Infinity cannot be represented in\n    // the affine space, except by a flag.\n    return this.inf;\n  }\n\n  isOrder2() {\n    if (this.inf)\n      return false;\n\n    return this.y.isZero();\n  }\n\n  isOdd() {\n    if (this.inf)\n      return false;\n\n    return this.y.redIsOdd();\n  }\n\n  isEven() {\n    if (this.inf)\n      return false;\n\n    return this.y.redIsEven();\n  }\n\n  toP() {\n    return this;\n  }\n\n  toJ() {\n    return this;\n  }\n\n  toX() {\n    // (X3, Z3) = (1, 0)\n    if (this.inf)\n      return this.curve.xpoint();\n\n    // (X3, Z3) = (X1, 1)\n    return this.curve.xpoint(this.x, this.curve.one);\n  }\n\n  encode() {\n    return this.toX().encode();\n  }\n\n  static decode(curve, bytes, sign) {\n    assert(curve instanceof MontCurve);\n    return curve.decodeX(bytes).toP(sign);\n  }\n\n  toJSON(pre) {\n    if (this.inf)\n      return [];\n\n    const x = this.getX().toJSON();\n    const y = this.getY().toJSON();\n\n    return [x, y];\n  }\n\n  toPretty() {\n    if (this.inf)\n      return [];\n\n    const size = this.curve.fieldSize * 2;\n    const x = toPretty(this.getX(), size);\n    const y = toPretty(this.getY(), size);\n\n    return [x, y];\n  }\n\n  static fromJSON(curve, json) {\n    assert(curve instanceof MontCurve);\n    assert(Array.isArray(json));\n    assert(json.length === 0\n        || json.length === 2\n        || json.length === 3);\n\n    if (json.length === 0)\n      return curve.point();\n\n    const x = BN.fromJSON(json[0]);\n    const y = BN.fromJSON(json[1]);\n\n    return curve.point(x, y);\n  }\n\n  [custom]() {\n    if (this.inf)\n      return '<MontPoint: Infinity>';\n\n    return '<MontPoint:'\n         + ' x=' + this.x.fromRed().toString(16, 2)\n         + ' y=' + this.y.fromRed().toString(16, 2)\n         + '>';\n  }\n}\n\n/**\n * XPoint\n */\n\nclass XPoint extends Point {\n  constructor(curve, x, z) {\n    assert(curve instanceof MontCurve);\n\n    super(curve, types.PROJECTIVE);\n\n    this.x = this.curve.one;\n    this.z = this.curve.zero;\n\n    if (x != null)\n      this._init(x, z);\n  }\n\n  _init(x, z) {\n    assert(x instanceof BN);\n    assert(z == null || (z instanceof BN));\n\n    this.x = x;\n    this.z = z || this.curve.one;\n\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n\n    if (!this.z.red)\n      this.z = this.z.toRed(this.curve.red);\n  }\n\n  clone() {\n    return this.curve.xpoint(this.x, this.z);\n  }\n\n  precompute(power, rng) {\n    // No-op.\n    return this;\n  }\n\n  validate() {\n    if (this.isInfinity())\n      return true;\n\n    // B * y^2 * z = x^3 + A * x^2 * z + x * z^2\n    const {x, z} = this;\n    const x2 = x.redSqr();\n    const x3 = x2.redMul(x);\n    const z2 = z.redSqr();\n    const ax2 = this.curve.a.redMul(x2).redMul(z);\n    const by2 = x3.redIAdd(ax2).redIAdd(x.redMul(z2));\n    const y2 = by2.redMul(this.curve.bi);\n\n    // sqrt(y^2 * z^4) = y * z^2\n    return y2.redMul(z).redJacobi() !== -1;\n  }\n\n  normalize() {\n    // https://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#scaling-scale\n    // 1I + 1M\n\n    // P = O\n    if (this.isInfinity())\n      return this;\n\n    // Z1 = 1\n    if (this.z.eq(this.curve.one))\n      return this;\n\n    // X3 = X1 / Z1\n    this.x = this.x.redDiv(this.z);\n\n    // Z3 = 1\n    this.z = this.curve.one;\n\n    return this;\n  }\n\n  scale(a) {\n    assert(a instanceof BN);\n\n    // P = O\n    if (this.isInfinity())\n      return this.curve.xpoint();\n\n    // X3 = X1 * A\n    const nx = this.x.redMul(a);\n\n    // Y3 = Y1 * A\n    const nz = this.z.redMul(a);\n\n    return this.curve.xpoint(nx, nz);\n  }\n\n  neg() {\n    // -(X1, Z1) = (X1, Z1)\n    return this;\n  }\n\n  dbl() {\n    // https://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3\n    // 2M + 2S + 4A + 1*a24\n\n    // A = X1 + Z1\n    const a = this.x.redAdd(this.z);\n\n    // AA = A^2\n    const aa = a.redSqr();\n\n    // B = X1 - Z1\n    const b = this.x.redSub(this.z);\n\n    // BB = B^2\n    const bb = b.redSqr();\n\n    // C = AA - BB\n    const c = aa.redSub(bb);\n\n    // X3 = AA * BB\n    const nx = aa.redMul(bb);\n\n    // Z3 = C * (BB + a24 * C)\n    const nz = c.redMul(bb.redIAdd(this.curve.a24.redMul(c)));\n\n    return this.curve.xpoint(nx, nz);\n  }\n\n  diffAddDbl(p2, p3) {\n    // https://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#ladder-ladd-1987-m-3\n    // 6M + 4S + 8A + 1*a24\n    assert(p2 instanceof XPoint);\n    assert(p3 instanceof XPoint);\n\n    // A = X2 + Z2\n    const a = p2.x.redAdd(p2.z);\n\n    // AA = A^2\n    const aa = a.redSqr();\n\n    // B = X2 - Z2\n    const b = p2.x.redSub(p2.z);\n\n    // BB = B^2\n    const bb = b.redSqr();\n\n    // E = AA - BB\n    const e = aa.redSub(bb);\n\n    // C = X3 + Z3\n    const c = p3.x.redAdd(p3.z);\n\n    // D = X3 - Z3\n    const d = p3.x.redSub(p3.z);\n\n    // DA = D * A\n    const da = d.redMul(a);\n\n    // CB = C * B\n    const cb = c.redMul(b);\n\n    // X5 = Z1 * (DA + CB)^2\n    const x5 = this.z.redMul(da.redAdd(cb).redSqr());\n\n    // Z5 = X1 * (DA - CB)^2\n    const z5 = this.x.redMul(da.redISub(cb).redSqr());\n\n    // X4 = AA * BB\n    const x4 = aa.redMul(bb);\n\n    // Z4 = E * (BB + a24 * E)\n    const z4 = e.redMul(bb.redIAdd(this.curve.a24.redMul(e)));\n\n    return [\n      this.curve.xpoint(x4, z4),\n      this.curve.xpoint(x5, z5)\n    ];\n  }\n\n  getX() {\n    if (this.isInfinity())\n      throw new Error('Invalid point.');\n\n    this.normalize();\n\n    return this.x.fromRed();\n  }\n\n  getY(sign) {\n    return this.toP(sign).getY();\n  }\n\n  eq(p) {\n    assert(p instanceof XPoint);\n\n    // P = Q\n    if (this === p)\n      return true;\n\n    // P = O\n    if (this.isInfinity())\n      return p.isInfinity();\n\n    // Q = O\n    if (p.isInfinity())\n      return false;\n\n    // Z1 = Z2\n    if (this.z.eq(p.z))\n      return this.x.eq(p.x);\n\n    // X1 * Z2 = X2 * Z1\n    const x1 = this.x.redMul(p.z);\n    const x2 = p.x.redMul(this.z);\n\n    return x1.eq(x2);\n  }\n\n  cmp(point) {\n    assert(point instanceof XPoint);\n\n    const inf1 = this.isInfinity();\n    const inf2 = point.isInfinity();\n\n    if (inf1 && !inf2)\n      return -1;\n\n    if (!inf1 && inf2)\n      return 1;\n\n    if (inf1 && inf2)\n      return 0;\n\n    return this.order().cmp(point.order())\n        || this.getX().cmp(point.getX());\n  }\n\n  isInfinity() {\n    // Z1 = 0\n    return this.z.isZero();\n  }\n\n  isOrder2() {\n    if (this.isInfinity())\n      return false;\n\n    return this.x.isZero();\n  }\n\n  isOdd() {\n    return false;\n  }\n\n  isEven() {\n    return false;\n  }\n\n  hasTorsion() {\n    if (this.isInfinity())\n      return false;\n\n    // X1 = 0, Z1 != 0 (edge case)\n    if (this.x.isZero())\n      return true;\n\n    return super.hasTorsion();\n  }\n\n  order() {\n    try {\n      return this.toP().order();\n    } catch (e) {\n      return new BN(1);\n    }\n  }\n\n  jmul(k) {\n    // Multiply with the Montgomery Ladder.\n    //\n    // [MONT3] Algorithm 4, Page 12, Section 4.2.\n    //\n    // Note that any clamping is meant to\n    // be done _outside_ of this function.\n    assert(k instanceof BN);\n    assert(!k.red);\n\n    const bits = k.bitLength();\n\n    let a = this.curve.xpoint();\n    let b = this;\n\n    for (let i = bits - 1; i >= 0; i--) {\n      const bit = k.bit(i);\n\n      if (bit === 0)\n        [a, b] = this.diffAddDbl(a, b);\n      else\n        [b, a] = this.diffAddDbl(b, a);\n    }\n\n    return a;\n  }\n\n  jmulBlind(k, rng) {\n    if (!rng)\n      return this.jmul(k);\n\n    // Randomize if available.\n    return this.randomize(rng).jmul(k);\n  }\n\n  jmulAdd(k1, p2, k2) {\n    throw new Error('Not implemented.');\n  }\n\n  toP(sign = null) {\n    assert(sign == null || typeof sign === 'boolean');\n\n    if (this.isInfinity())\n      return this.curve.point();\n\n    this.normalize();\n\n    return this.curve.pointFromX(this.x, sign);\n  }\n\n  toJ() {\n    return this;\n  }\n\n  toX() {\n    return this;\n  }\n\n  key() {\n    if (this.isInfinity())\n      return `${this.curve.uid}:oo`;\n\n    this.normalize();\n\n    const x = this.getX().toString(16);\n\n    return `${this.curve.uid}:${x}`;\n  }\n\n  encode() {\n    // [RFC7748] Section 5.\n    return this.curve.encodeField(this.getX());\n  }\n\n  static decode(curve, bytes) {\n    assert(curve instanceof MontCurve);\n\n    // [RFC7748] Section 5.\n    const x = curve.decodeField(bytes);\n\n    // We're supposed to ignore the hi bit\n    // on montgomery points... I think. If\n    // we don't, the X25519 test vectors\n    // break, which is pretty convincing\n    // evidence. This is a no-op for X448.\n    x.iumaskn(curve.fieldBits);\n\n    // Note: montgomery points are meant to be\n    // reduced by the prime and do not have to\n    // be explicitly validated in order to do\n    // the montgomery ladder.\n    const p = curve.xpoint(x, curve.one);\n\n    assert(!p.isInfinity());\n\n    return p;\n  }\n\n  toJSON(pre) {\n    return this.toP().toJSON(pre);\n  }\n\n  toPretty() {\n    return this.toP().toPretty();\n  }\n\n  static fromJSON(curve, json) {\n    return MontPoint.fromJSON(curve, json).toX();\n  }\n\n  [custom]() {\n    if (this.isInfinity())\n      return '<XPoint: Infinity>';\n\n    return '<XPoint:'\n        + ' x=' + this.x.fromRed().toString(16, 2)\n        + ' z=' + this.z.fromRed().toString(16, 2)\n        + '>';\n  }\n}\n\n/**\n * EdwardsCurve\n */\n\nclass EdwardsCurve extends Curve {\n  constructor(conf) {\n    super(EdwardsPoint, 'edwards', conf);\n\n    this.a = BN.fromJSON(conf.a).toRed(this.red);\n    this.d = BN.fromJSON(conf.d).toRed(this.red);\n    this.s = BN.fromJSON(conf.s || '0').toRed(this.red);\n    this.si = this.s.isZero() ? this.zero : this.s.redInvert();\n\n    this.k = this.d.redMuln(2);\n    this.smi = -this.d.redNeg().word(0);\n    this.ad6 = this.a.redAdd(this.d).redMul(this.i6);\n\n    this.twisted = !this.a.eq(this.one);\n    this.oneA = this.a.eq(this.one);\n    this.mOneA = this.a.eq(this.one.redNeg());\n    this.smallD = this.prime != null && this.d.redNeg().length === 1;\n    this.alt = null;\n\n    this._finalize(conf);\n  }\n\n  static _isomorphism(curveA, curveD, customA) {\n    // Twisted Edwards Isomorphism.\n    //\n    // [TWISTED] Definition 2.1, Page 3, Section 2.\n    //\n    // Transformation:\n    //\n    //   a' = a'\n    //   d' = a' * d / a\n    //\n    // Where (a / a') is square.\n    assert(curveA instanceof BN);\n    assert(curveD instanceof BN);\n    assert(customA instanceof BN);\n\n    const a = customA.clone();\n    const d = customA.redMul(curveD).redDiv(curveA);\n    const c = curveA.redDiv(customA);\n\n    if (c.redJacobi() !== 1)\n      throw new Error('Invalid `a` coefficient.');\n\n    return [a, d];\n  }\n\n  _short(a0, odd) {\n    // Twisted Edwards->Short Weierstrass Equivalence.\n    //\n    // [TWISTEQ] Section 2.\n    //\n    // Transformation:\n    //\n    //   a' = -(a^2 + 14 * a * d + d^2) / 48\n    //   b' = (33 * (a^2 * d + a * d^2) - a^3 - d^3) / 864\n    const {a, d} = this;\n    const a2 = a.redSqr();\n    const a3 = a2.redMul(a);\n    const d2 = d.redSqr();\n    const d3 = d2.redMul(d);\n    const ad14 = a.redMul(d).redIMuln(14);\n    const a2d = a2.redMul(d);\n    const ad2 = a.redMul(d2);\n    const t0 = a2d.redIAdd(ad2).redIMuln(33);\n    const wa = a2.redAdd(ad14).redIAdd(d2).redDivn(-48);\n    const wb = t0.redISub(a3).redISub(d3).redDivn(864);\n\n    if (a0 != null)\n      return ShortCurve._isomorphism(wa, wb, a0, odd);\n\n    return [wa, wb];\n  }\n\n  _mont(b0, invert = false) {\n    // Twisted Edwards->Montgomery Transformation.\n    //\n    // [TWISTED] Theorem 3.2, Page 4, Section 3.\n    //\n    // Equivalence:\n    //\n    //   A = 2 * (a + d) / (a - d)\n    //   B = 4 / (a - d)\n    //\n    // Isomorphism:\n    //\n    //   A = 2 * (a + d) / (a - d)\n    //   B = B'\n    //\n    // Where ((4 / (a - d)) / B') is square.\n    //\n    // If `4 / (a - d)` is non-square, we can\n    // usually force B=1 by using the `invert`\n    // option. This will create an isomorphism\n    // chain of: E(a,d)->E(d,a)->M(-A,-B).\n    //\n    // The equivalence between E(a,d) and E(d,a)\n    // is:\n    //\n    //   (x, y) = (x, 1 / y)\n    //\n    // Meaning our map to M(-A,-B) is:\n    //\n    //   u = (1 + 1 / y) / (1 - 1 / y)\n    //     = (y + 1) / (y - 1)\n    //   v = u / x\n    assert(typeof invert === 'boolean');\n\n    let apd, amd;\n\n    if (invert) {\n      apd = this.d.redAdd(this.a);\n      amd = this.d.redSub(this.a);\n    } else {\n      apd = this.a.redAdd(this.d);\n      amd = this.a.redSub(this.d);\n    }\n\n    const z = amd.redInvert();\n    const a = apd.redMuln(2).redMul(z);\n    const b = z.redMuln(4);\n\n    if (b0 != null)\n      return MontCurve._isomorphism(a, b, b0);\n\n    return [a, b];\n  }\n\n  _edwards(a0) {\n    return EdwardsCurve._isomorphism(this.a, this.d, a0);\n  }\n\n  _scaleShort(curve) {\n    assert(curve instanceof ShortCurve);\n\n    const [u2, u3] = curve._scale(this);\n\n    return [this.field(u2.redInvert()),\n            this.field(u3.redInvert())];\n  }\n\n  _scaleMont(curve, invert = false) {\n    // Calculate isomorphism factor between\n    // Twisted Edwards and Montgomery with:\n    //\n    //   a = (A + 2) / B\n    //   c = +-sqrt(a / a')\n    //\n    // Which can be reduced to:\n    //\n    //   c = +-sqrt((A + 2) / (B * a'))\n    //\n    // If base points are available, we can do:\n    //\n    //   x = u / v\n    //   c = x' / x\n    //\n    // Which can be reduced to:\n    //\n    //   c = v * x' / u\n    //\n    // We can now calculate the Edwards `x` with:\n    //\n    //   x' = c * u / v\n    //\n    // And likewise, the Montgomery `v`:\n    //\n    //   v = c * u / x'\n    assert(curve instanceof MontCurve);\n    assert(typeof invert === 'boolean');\n\n    if (this.g.isInfinity() || curve.g.isInfinity()) {\n      const [a] = curve._edwards(null, invert);\n\n      return this.field(a).redDivSqrt(this.a);\n    }\n\n    const x = curve.g.x.redDiv(curve.g.y);\n\n    return this.g.x.redDiv(this.field(x));\n  }\n\n  _scaleEdwards(curve) {\n    // We can extract the isomorphism factor with:\n    //\n    //   c = +-sqrt(a / a')\n    //\n    // If base points are available, we can do:\n    //\n    //   c = x' / x\n    assert(curve instanceof EdwardsCurve);\n\n    if (this.g.isInfinity() || curve.g.isInfinity())\n      return this.field(curve.a).redDivSqrt(this.a);\n\n    return this.g.x.redDiv(this.field(curve.g.x));\n  }\n\n  _mulA(num) {\n    assert(num instanceof BN);\n\n    // n * a = n\n    if (this.oneA)\n      return num.clone();\n\n    // n * a = -n\n    if (this.mOneA)\n      return num.redNeg();\n\n    return this.a.redMul(num);\n  }\n\n  _mulD(num) {\n    assert(num instanceof BN);\n\n    // -d < 0x4000000\n    if (this.smallD)\n      return num.redMuln(this.smi);\n\n    return this.d.redMul(num);\n  }\n\n  _elligator1(t) {\n    // Elligator 1.\n    //\n    // Distribution: 1/2.\n    //\n    // [ELL1] Page 6, Section 3.\n    //        Page 15, Appendix A.\n    // [ELL2] Page 7, Section 3.2.\n    //\n    // Assumptions:\n    //\n    //   - Let p be a prime power congruent to 3 mod 4.\n    //   - Let s be a nonzero element of F(p).\n    //   - Let c = 2 / s^2.\n    //   - Let r = c + 1 / c.\n    //   - Let d = -(c + 1)^2 / (c - 1)^2.\n    //   - (s^2 - 2) * (s^2 + 2) != 0.\n    //   - c * (c - 1) * (c + 1) != 0.\n    //   - r != 0.\n    //   - d is not square.\n    //   - x^2 + y^2 = 1 + d * x^2 * y^2.\n    //   - u * v * X * Y * x * (Y + 1) != 0.\n    //   - Y^2 = X^5 + (r^2 - 2) * X^3 + X.\n    //\n    // Elligator 1, as devised by Fouque et al,\n    // takes place on the hyperelliptic curve of:\n    //\n    //   y^2 = x^5 + (r^2 - 2) * x^3 + x\n    //\n    // Not only must our Edwards curve be complete,\n    // with a prime congruent to 3 mod 4, and a = 1,\n    // our curve must be isomorphic to a hyperelliptic\n    // curve of the above form. Roughly one half of\n    // all Edwards curves are isomorphic to a curve\n    // of said form.\n    //\n    // We can derive the isomorphism with:\n    //\n    //   c = (d +- 2 * sqrt(-d) - 1) / (d + 1)\n    //   s = +-sqrt(2 / c)\n    //   r = c + 1 / c\n    //\n    // Note that even if your curve is an Elligator 1\n    // curve, Elligator 2 is probably still preferable,\n    // as it has nearly the same properties (i.e. the\n    // same distribution), and is much less complex.\n    //\n    // Map:\n    //\n    //   f(a) = a^((p - 1) / 2)\n    //   u = (1 - t) / (1 + t)\n    //   v = u^5 + (r^2 - 2) * u^3 + u\n    //   X = f(v) * u\n    //   Y = (f(v) * v)^((p + 1) / 4) * f(v) * f(u^2 + 1 / c^2)\n    //   Y = 1, if u = 0\n    //   x = (c - 1) * s * X * (1 + X) / Y\n    //   y = (r * X - (1 + X)^2) / (r * X + (1 + X)^2)\n    //\n    // When t = +-1, we create the hyperelliptic\n    // 2-torsion point of (0, 0). This needs to be\n    // mapped to (0, -1) in Edwards form, but the x\n    // denominator becomes zero. As far as I can\n    // tell, this is the only exceptional case.\n    //\n    // The only other exceptional case initially\n    // appears to be when the y denominator sums to\n    // zero (when t = sqrt(4 / r + 1)), however, the\n    // hyperelliptic `X` is negated by the sign of\n    // `v`, making this impossible.\n    const {s, si, i2, one, two} = this;\n    const c = si.redSqr().redIMuln(2);\n    const ci = s.redSqr().redMul(i2);\n    const ci2 = ci.redSqr();\n    const r = c.redAdd(ci);\n    const r2 = r.redSqr().redISub(two);\n    const cm1 = c.redSub(one);\n    const uu = one.redSub(t);\n    const uz = one.redAdd(t);\n    const u = uz.isZero() ? uz : uu.redDiv(uz);\n    const u2 = u.redSqr();\n    const u3 = u2.redMul(u);\n    const u5 = u3.redMul(u2);\n    const v = u5.redAdd(r2.redMul(u3)).redIAdd(u);\n    const f0 = this.field(v.redJacobi());\n    const f1 = this.field(u2.redAdd(ci2).redJacobi());\n    const f2 = f0.redMul(f1);\n    const X = f0.redMul(u);\n    const Y = f0.redMul(v).redSqrt().redMul(f2);\n    const X1 = one.redAdd(X);\n    const rX = r.redMul(X);\n    const X12 = X1.redSqr();\n    const xx = cm1.redMul(s).redMul(X).redMul(X1);\n    const xz = u.isZero() ? this.one : Y;\n    const yy = rX.redSub(X12);\n    const yz = rX.redAdd(X12);\n\n    return this.cpoint(xx, xz, yy, yz);\n  }\n\n  _invert1(p, hint) {\n    // Inverting the Map (Elligator 1).\n    //\n    // [ELL1] Page 6, Section 3.\n    //        Page 15, Appendix A.\n    // [ELL2] Page 7, Section 3.3.\n    //\n    // Assumptions:\n    //\n    //   - y + 1 != 0.\n    //   - (1 + n * r)^2 - 1 is square in F(p).\n    //   - If n * r = -2 then x = 2 * s * (c - 1) * f(c) / r.\n    //   - Y = (c - 1) * s * X * (1 + X) / x.\n    //\n    // Map:\n    //\n    //   f(a) = a^((p - 1) / 2)\n    //   n = (y - 1) / (2 * (y + 1))\n    //   X = -(1 + n * r) + ((1 + n * r)^2 - 1)^((p + 1) / 4)\n    //   z = f((c - 1) * s * X * (1 + X) * x * (X^2 + 1 / c^2))\n    //   u = z * X\n    //   t = (1 - u) / (1 + u)\n    const {s, si, i2, one} = this;\n    const {x, y, z} = p;\n    const sign = hint & 1;\n    const c = si.redSqr().redIMuln(2);\n    const ci = s.redSqr().redMul(i2);\n    const ci2 = ci.redSqr();\n    const r = c.redAdd(ci);\n    const cm1 = c.redSub(one);\n    const nn = y.redSub(z);\n    const nz = y.redAdd(z).redIMuln(2);\n    const n = nz.isZero() ? nz : nn.redDiv(nz);\n    const nr1 = one.redAdd(n.redMul(r));\n    const w2 = nr1.redSqr().redISub(one);\n    const w = w2.redSqrt();\n    const X = w.redSub(nr1);\n    const X1 = one.redAdd(X);\n    const YY = cm1.redMul(s).redMul(X).redMul(X1);\n    const Y = YY.redMul(x.redMul(z));\n    const X2 = X.redSqr().redIAdd(ci2);\n    const Z = this.field(Y.redMul(X2).redJacobi());\n    const u = Z.redMul(X);\n    const tt = one.redSub(u);\n    const tz = one.redAdd(u);\n    const t = tz.isZero() ? tz : tt.redDiv(tz);\n\n    if (t.redIsOdd() !== Boolean(sign))\n      t.redINeg();\n\n    return t;\n  }\n\n  _alt() {\n    if (!this.alt)\n      this.alt = this.toMont();\n\n    return this.alt;\n  }\n\n  isElliptic() {\n    const ad = this.a.redMul(this.d);\n    const amd = this.a.redSub(this.d);\n\n    // a * d * (a - d) != 0\n    return !ad.redMul(amd).isZero();\n  }\n\n  jinv() {\n    // [TWISTED] Definition 2.1, Page 3, Section 2.\n    const {a, d} = this;\n    const ad = a.redMul(d);\n    const amd4 = a.redSub(d).redPown(4);\n    const a2 = a.redSqr();\n    const d2 = d.redSqr();\n    const t0 = a2.redAdd(ad.redMuln(14)).redIAdd(d2);\n    const lhs = t0.redPown(3).redIMuln(16);\n    const rhs = ad.redMul(amd4);\n\n    if (rhs.isZero())\n      throw new Error('Curve is not elliptic.');\n\n    // 16 * (a^2 + 14 * a * d + d^2)^3 / (a * d * (a - d)^4)\n    return lhs.redDiv(rhs).fromRed();\n  }\n\n  isComplete() {\n    return this.a.redJacobi() === 1\n        && this.d.redJacobi() === -1;\n  }\n\n  point(x, y, z, t) {\n    return new EdwardsPoint(this, x, y, z, t);\n  }\n\n  jpoint(x, y, z) {\n    assert(x == null && y == null && z == null);\n    return this.point();\n  }\n\n  cpoint(xx, xz, yy, yz) {\n    assert(xx instanceof BN);\n    assert(xz instanceof BN);\n    assert(yy instanceof BN);\n    assert(yz instanceof BN);\n\n    const x = xx.redMul(yz);\n    const y = yy.redMul(xz);\n    const z = xz.redMul(yz);\n    const t = xx.redMul(yy);\n\n    return this.point(x, y, z, t);\n  }\n\n  solveX2(y) {\n    // [RFC8032] Section 5.1.3 & 5.2.3.\n    assert(y instanceof BN);\n\n    // x^2 = (y^2 - 1) / (d * y^2 - a)\n    const y2 = y.redSqr();\n    const rhs = this._mulD(y2).redISub(this.a);\n    const lhs = y2.redISub(this.one);\n    const x2 = lhs.redDiv(rhs);\n\n    return x2;\n  }\n\n  solveX(y) {\n    // Optimize with inverse square root trick.\n    //\n    // Note that `0 / 0` can only occur if\n    // `a == d` (i.e. the curve is singular).\n    const y2 = y.redSqr();\n    const rhs = this._mulD(y2).redISub(this.a);\n    const lhs = y2.redISub(this.one);\n\n    return lhs.redDivSqrt(rhs);\n  }\n\n  solveY2(x) {\n    assert(x instanceof BN);\n\n    // y^2 = (a * x^2 - 1) / (d * x^2 - 1)\n    const x2 = x.redSqr();\n    const lhs = this._mulA(x2).redISub(this.one);\n    const rhs = this._mulD(x2).redISub(this.one);\n    const y2 = lhs.redDiv(rhs);\n\n    return y2;\n  }\n\n  solveY(x) {\n    // Optimize with inverse square root trick.\n    //\n    // Note that `0 / 0` can only occur if\n    // `a == d` (i.e. the curve is singular).\n    const x2 = x.redSqr();\n    const lhs = this._mulA(x2).redISub(this.one);\n    const rhs = this._mulD(x2).redISub(this.one);\n\n    return lhs.redDivSqrt(rhs);\n  }\n\n  validate(point) {\n    // [TWISTED] Definition 2.1, Page 3, Section 2.\n    //           Page 11, Section 6.\n    assert(point instanceof EdwardsPoint);\n\n    // Z1 = 1\n    if (point.zOne) {\n      // a * x^2 + y^2 = 1 + d * x^2 * y^2\n      const x2 = point.x.redSqr();\n      const y2 = point.y.redSqr();\n      const dxy = this._mulD(x2).redMul(y2);\n      const lhs = this._mulA(x2).redIAdd(y2);\n      const rhs = this.one.redAdd(dxy);\n      const tz = point.t;\n      const xy = point.x.redMul(point.y);\n\n      return lhs.eq(rhs) && tz.eq(xy);\n    }\n\n    // (a * x^2 + y^2) * z^2 = z^4 + d * x^2 * y^2\n    const x2 = point.x.redSqr();\n    const y2 = point.y.redSqr();\n    const z2 = point.z.redSqr();\n    const z4 = z2.redSqr();\n    const dxy = this._mulD(x2).redMul(y2);\n    const lhs = this._mulA(x2).redIAdd(y2).redMul(z2);\n    const rhs = z4.redIAdd(dxy);\n    const tz = point.t.redMul(point.z);\n    const xy = point.x.redMul(point.y);\n\n    return lhs.eq(rhs) && tz.eq(xy);\n  }\n\n  pointFromX(x, sign = null) {\n    assert(x instanceof BN);\n    assert(sign == null || typeof sign === 'boolean');\n\n    if (!x.red)\n      x = x.toRed(this.red);\n\n    const y = this.solveY(x);\n\n    if (sign != null) {\n      if (y.isZero() && sign)\n        throw new Error('Invalid point.');\n\n      if (y.redIsOdd() !== sign)\n        y.redINeg();\n    }\n\n    return this.point(x, y);\n  }\n\n  pointFromY(y, sign = null) {\n    assert(y instanceof BN);\n    assert(sign == null || typeof sign === 'boolean');\n\n    if (!y.red)\n      y = y.toRed(this.red);\n\n    const x = this.solveX(y);\n\n    if (sign != null) {\n      if (x.isZero() && sign)\n        throw new Error('Invalid point.');\n\n      if (x.redIsOdd() !== sign)\n        x.redINeg();\n    }\n\n    return this.point(x, y);\n  }\n\n  isIsomorphic(curve, invert = false) {\n    // [TWISTED] Theorem 3.2, Page 4, Section 3.\n    //           Definition 2.1, Page 3, Section 2.\n    assert(curve instanceof Curve);\n    assert(typeof invert === 'boolean');\n\n    if (!curve.p.eq(this.p))\n      return false;\n\n    // E(a,d) <-> E(a,b)\n    if (curve.type === 'short')\n      return curve.isIsomorphic(this);\n\n    // E(a,d) <-> M(A,B)\n    // E(a,d) <-> M(-A,-B)\n    if (curve.type === 'mont') {\n      // A * (a - d) = 2 * (a + d)\n      const a = this.field(curve.a);\n\n      let apd, amd;\n\n      if (invert) {\n        apd = this.d.redAdd(this.a);\n        amd = this.d.redSub(this.a);\n      } else {\n        apd = this.a.redAdd(this.d);\n        amd = this.a.redSub(this.d);\n      }\n\n      return a.redMul(amd).eq(apd.redIMuln(2));\n    }\n\n    // E(a,d) <-> E(a',a'd/a)\n    if (curve.type === 'edwards') {\n      // a' * d = a * d'\n      const a = this.field(curve.a);\n      const d = this.field(curve.d);\n\n      return this.a.redMul(d).eq(a.redMul(this.d));\n    }\n\n    return false;\n  }\n\n  isIsogenous(curve) {\n    // Check for the 4-isogenies described by Hamburg:\n    // https://moderncrypto.org/mail-archive/curves/2016/000806.html\n    assert(curve instanceof Curve);\n\n    if (!curve.p.eq(this.p))\n      return false;\n\n    // E(1,d) <-> M(2-4d,1)\n    if (curve.type === 'mont') {\n      if (!this.a.eq(this.one))\n        return false;\n\n      const a = this.field(curve.a);\n      const b = this.field(curve.b);\n      const d24 = this.two.redSub(this.d.redMuln(4));\n\n      return a.eq(d24) && b.eq(this.one);\n    }\n\n    // E(a,d) <-> E(-a,d-a)\n    if (curve.type === 'edwards') {\n      const a = this.field(curve.a);\n      const d = this.field(curve.d);\n\n      return a.eq(this.a.redNeg())\n          && d.eq(this.d.redSub(this.a));\n    }\n\n    return false;\n  }\n\n  pointFromShort(point) {\n    // [TWISTEQ] Section 1.\n    assert(point instanceof ShortPoint);\n\n    if (this.isIsomorphic(point.curve)) {\n      // Equivalence for E(a,b)->E(a',d'):\n      //\n      //   x' = (6 * x - a' - d') / (6 * y)\n      //   y' = (12 * x - 5 * a' + d') / (12 * x + a' - 5 * d')\n      //\n      // Undefined for x = (5 * d' - a') / 12 or y = 0.\n      //\n      // Exceptional Cases:\n      //   - O -> (0, 1)\n      //   - ((a' + d') / 6, 0) -> (0, -1)\n      //   - ((5 * d' - a') / 12, (d' - a') / 4 * sqrt(d')) -> (sqrt(1/d'), oo)\n      //\n      // Unexceptional Cases:\n      //   - ((5 * a' - d') / 12, (a' - d') / 4 * sqrt(a')) -> (sqrt(1/a'), 0)\n      if (point.isInfinity())\n        return this.point();\n\n      if (point.y.isZero())\n        return this.point(this.zero, this.one.redNeg());\n\n      const {a, d} = this;\n      const [u2, u3] = this._scale(point.curve);\n      const a5 = a.redMuln(5);\n      const d5 = d.redMuln(5);\n      const x = this.field(point.x).redMul(u2);\n      const y = this.field(point.y).redMul(u3);\n      const x6 = x.redMuln(6);\n      const x12 = x.redMuln(12);\n      const xx = x6.redSub(a).redISub(d);\n      const xz = y.redMuln(6);\n      const yy = x12.redSub(a5).redIAdd(d);\n      const yz = x12.redAdd(a).redISub(d5);\n\n      return this.cpoint(xx, xz, yy, yz);\n    }\n\n    throw new Error('Not implemented.');\n  }\n\n  pointFromMont(point) {\n    // [RFC7748] Section 4.1 & 4.2.\n    // [MONT3] Page 6, Section 2.5.\n    // [TWISTED] Theorem 3.2, Page 4, Section 3.\n    assert(point instanceof MontPoint);\n    assert(point.curve.p.eq(this.p));\n\n    // Montgomery `u`, `v`.\n    const u = this.field(point.x);\n    const v = this.field(point.y);\n\n    if (this.isIsogenous(point.curve)) {\n      // 4-isogeny maps for M(2-4d,1)->E(1,d):\n      //\n      //   x = 4 * v * (u^2 - 1) / (u^4 - 2 * u^2 + 4 * v^2 + 1)\n      //   y = -(u^5 - 2 * u^3 - 4 * u * v^2 + u) /\n      //        (u^5 - 2 * u^2 * v^2 - 2 * u^3 - 2 * v^2 + u)\n      //\n      // Undefined for u = 0 and v = 0.\n      //\n      // Exceptional Cases:\n      //   - O -> (0, 1)\n      //   - (0, 0) -> (0, 1)\n      //\n      // Unexceptional Cases:\n      //   - (-1, +-sqrt(A - 2)) -> (0, 1)\n      //   - (1, +-sqrt(A + 2)) -> (0, -1)\n      //\n      // The point (1, v) is invalid on Curve448.\n      if (point.isInfinity())\n        return this.point();\n\n      if (point.x.isZero())\n        return this.point();\n\n      const u2 = u.redSqr();\n      const u3 = u2.redMul(u);\n      const u4 = u3.redMul(u);\n      const u5 = u4.redMul(u);\n      const v2 = v.redSqr();\n      const a = v.redMuln(4);\n      const b = u2.redSub(this.one);\n      const c = u2.redMuln(2);\n      const d = v2.redMuln(4);\n      const e = u3.redIMuln(2);\n      const f = u.redMul(v2).redIMuln(4);\n      const g = u2.redMul(v2).redIMuln(2);\n      const h = v2.redIMuln(2);\n      const xx = a.redMul(b);\n      const xz = u4.redISub(c).redIAdd(d).redIAdd(this.one);\n      const yy = u5.redSub(e).redISub(f).redIAdd(u).redINeg();\n      const yz = u5.redISub(g).redISub(e).redISub(h).redIAdd(u);\n\n      return this.cpoint(xx, xz, yy, yz).divn(4);\n    }\n\n    if (this.isIsomorphic(point.curve, true)) {\n      // Isomorphic maps for M(-A,-B)->E(a,d):\n      //\n      //   x = +-sqrt((A - 2) / (B * a)) * u / v\n      //   y = (u + 1) / (u - 1)\n      //\n      // Undefined for u = 1 or v = 0.\n      //\n      // Exceptional Cases:\n      //   - O -> (0, 1)\n      //   - (0, 0) -> (0, -1)\n      //   - (1, +-sqrt((A + 2) / B)) -> (+-sqrt(1 / d), oo)\n      //\n      // Unexceptional Cases:\n      //   - (-1, +-sqrt((A - 2) / B)) -> (+-sqrt(1 / a), 0)\n      //\n      // The point (1, v) is invalid on Curve448.\n      if (point.isInfinity())\n        return this.point();\n\n      if (point.x.isZero())\n        return this.point(this.zero, this.one.redNeg());\n\n      const c = this._scale(point.curve, true);\n      const xx = c.redMul(u);\n      const xz = v;\n      const yy = u.redAdd(this.one);\n      const yz = u.redSub(this.one);\n\n      return this.cpoint(xx, xz, yy, yz);\n    }\n\n    if (this.isIsomorphic(point.curve, false)) {\n      // Isomorphic maps for M(A,B)->E(a,d):\n      //\n      //   x = +-sqrt((A + 2) / (B * a)) * u / v\n      //   y = (u - 1) / (u + 1)\n      //\n      // Undefined for u = -1 or v = 0.\n      //\n      // Exceptional Cases:\n      //   - O -> (0, 1)\n      //   - (0, 0) -> (0, -1)\n      //   - (-1, +-sqrt((A - 2) / B)) -> (+-sqrt(1 / d), oo)\n      //\n      // Unexceptional Cases:\n      //   - (1, +-sqrt((A + 2) / B)) -> (+-sqrt(1 / a), 0)\n      //\n      // The point (-1, v) is invalid on Curve25519.\n      if (point.isInfinity())\n        return this.point();\n\n      if (point.x.isZero())\n        return this.point(this.zero, this.one.redNeg());\n\n      const c = this._scale(point.curve, false);\n      const xx = c.redMul(u);\n      const xz = v;\n      const yy = u.redSub(this.one);\n      const yz = u.redAdd(this.one);\n\n      return this.cpoint(xx, xz, yy, yz);\n    }\n\n    throw new Error('Not implemented.');\n  }\n\n  pointFromEdwards(point) {\n    // [TWISTED] Definition 2.1, Page 3, Section 2.\n    // [ISOGENY] Page 2, Section 2.\n    assert(point instanceof EdwardsPoint);\n    assert(point.curve.p.eq(this.p));\n\n    // Edwards `x`, `y`, `z`, `t`.\n    const a = this.field(point.curve.a);\n    const x = this.field(point.x);\n    const y = this.field(point.y);\n    const z = this.field(point.z);\n    const t = this.field(point.t);\n\n    if (this.isIsogenous(point.curve)) {\n      // 4-isogeny maps for E(a,d)<->E(-a,d-a):\n      //\n      //   x' = (2 * x * y) / (y^2 - a * x^2)\n      //   y' = (y^2 + a * x^2) / (2 - y^2 - a * x^2)\n      //\n      // Undefined for y^2 - a * x^2 = 0\n      //            or y^2 + a * x^2 = 2.\n      const xy = x.redMul(y);\n      const x2 = x.redSqr();\n      const y2 = y.redSqr();\n      const z2 = z.redSqr();\n      const ax2 = a.redMul(x2);\n      const xx = xy.redIMuln(2);\n      const xz = y2.redSub(ax2);\n      const yy = y2.redAdd(ax2);\n      const yz = z2.redIMuln(2).redISub(yy);\n      const p = this.cpoint(xx, xz, yy, yz);\n\n      return !this.twisted ? p.divn(4) : p;\n    }\n\n    if (this.isIsomorphic(point.curve)) {\n      // Isomorphic maps for E(a,d)<->E(a',a'd/a):\n      //\n      //   x' = +-sqrt(a / a') * x\n      //   y' = y\n      //\n      // Undefined when (a / a') is not square.\n      const c = this._scale(point.curve);\n      const nx = c.redMul(x);\n      const ny = y;\n      const nz = z;\n      const nt = c.redMul(t);\n\n      return this.point(nx, ny, nz, nt);\n    }\n\n    throw new Error('Not implemented.');\n  }\n\n  pointFromUniform(u, curve = null) {\n    assert(u instanceof BN);\n    assert(u.red === this.red);\n    assert(curve == null || (curve instanceof MontCurve));\n\n    if (!curve)\n      curve = this._alt();\n\n    const u0 = curve.field(u);\n    const p0 = curve.pointFromUniform(u0);\n\n    return this.pointFromMont(p0);\n  }\n\n  pointToUniform(p, hint, curve = null) {\n    // Convert an edwards point to a field\n    // element by inverting the elligator2 map.\n    //\n    // Hint Layout:\n    //\n    //   [00000000] [0000] [0000]\n    //        |        |      |\n    //        |        |      +-- preimage index\n    //        |        +--- subgroup\n    //        +-- bits to OR with uniform bytes\n    assert(p instanceof EdwardsPoint);\n    assert((hint >>> 0) === hint);\n    assert(curve == null || (curve instanceof MontCurve));\n\n    if (!curve)\n      curve = this._alt();\n\n    // Add a random torsion component.\n    const i = ((hint >> 4) & 15) % this.torsion.length;\n    const q = p.add(this.torsion[i]);\n\n    // Convert and invert.\n    const p0 = curve.pointFromEdwards(q);\n    const u0 = curve.pointToUniform(p0, hint & 15);\n\n    return this.field(u0);\n  }\n\n  pointFromHash(bytes, pake, curve = null) {\n    assert(curve == null || (curve instanceof MontCurve));\n\n    if (!curve)\n      curve = this._alt();\n\n    const p0 = curve.pointFromHash(bytes, pake);\n\n    return this.pointFromMont(p0);\n  }\n\n  pointToHash(p, subgroup, rng, curve = null) {\n    assert(p instanceof EdwardsPoint);\n    assert((subgroup >>> 0) === subgroup);\n    assert(curve == null || (curve instanceof MontCurve));\n\n    if (!curve)\n      curve = this._alt();\n\n    // Add a random torsion component.\n    const i = subgroup % this.torsion.length;\n    const q = p.add(this.torsion[i]);\n\n    // Convert and invert.\n    const p0 = curve.pointFromEdwards(q);\n\n    return curve.pointToHash(p0, 0, rng);\n  }\n\n  decodePoint(bytes) {\n    return EdwardsPoint.decode(this, bytes);\n  }\n\n  toShort(a0, odd, sign = null) {\n    const [a, b] = this._short(a0, odd);\n\n    const curve = new ShortCurve({\n      red: this.red,\n      prime: this.prime,\n      p: this.p,\n      a: a,\n      b: b,\n      n: this.n,\n      h: this.h\n    });\n\n    if (sign != null) {\n      const [, u3] = curve._scale(this);\n\n      if (u3.redIsOdd() !== sign)\n        u3.redINeg();\n    }\n\n    if (!this.g.isInfinity())\n      curve.g = curve.pointFromEdwards(this.g);\n\n    for (let i = 0; i < this.h.word(0); i++)\n      curve.torsion[i] = curve.pointFromEdwards(this.torsion[i]);\n\n    return curve;\n  }\n\n  toMont(b0, invert, sign = null) {\n    const [a, b] = this._mont(b0, invert);\n\n    const curve = new MontCurve({\n      red: this.red,\n      prime: this.prime,\n      p: this.p,\n      a: a,\n      b: b,\n      n: this.n,\n      h: this.h,\n      z: this.z\n    });\n\n    if (sign != null) {\n      const c = this._scale(curve, invert);\n\n      if (c.redIsOdd() !== sign)\n        c.redINeg();\n    }\n\n    if (!this.g.isInfinity())\n      curve.g = curve.pointFromEdwards(this.g);\n\n    for (let i = 0; i < this.h.word(0); i++)\n      curve.torsion[i] = curve.pointFromEdwards(this.torsion[i]);\n\n    return curve;\n  }\n\n  toEdwards(a0, sign = null) {\n    const [a, d] = this._edwards(a0);\n\n    const curve = new EdwardsCurve({\n      red: this.red,\n      prime: this.prime,\n      p: this.p,\n      a: a,\n      d: d,\n      n: this.n,\n      h: this.h,\n      z: this.z\n    });\n\n    if (sign != null) {\n      const c = curve._scale(this);\n\n      if (c.redIsOdd() !== sign)\n        c.redINeg();\n    }\n\n    if (!this.g.isInfinity()) {\n      curve.g = curve.pointFromEdwards(this.g);\n      curve.g.normalize();\n    }\n\n    if (curve.isComplete()) {\n      for (let i = 0; i < this.h.word(0); i++) {\n        curve.torsion[i] = curve.pointFromEdwards(this.torsion[i]);\n        curve.torsion[i].normalize();\n      }\n    }\n\n    return curve;\n  }\n\n  pointFromJSON(json) {\n    return EdwardsPoint.fromJSON(this, json);\n  }\n\n  toJSON(pre) {\n    const json = super.toJSON(pre);\n\n    json.a = this.a.fromRed().toJSON();\n    json.d = this.d.fromRed().toJSON();\n\n    if (!this.s.isZero())\n      json.s = this.s.fromRed().toJSON();\n\n    return json;\n  }\n}\n\n/**\n * EdwardsPoint\n */\n\nclass EdwardsPoint extends Point {\n  constructor(curve, x, y, z, t) {\n    assert(curve instanceof EdwardsCurve);\n\n    super(curve, types.EXTENDED);\n\n    this.x = this.curve.zero;\n    this.y = this.curve.one;\n    this.z = this.curve.one;\n    this.t = this.curve.zero;\n    this.zOne = true;\n\n    if (x != null)\n      this._init(x, y, z, t);\n  }\n\n  _init(x, y, z, t) {\n    assert(x instanceof BN);\n    assert(y instanceof BN);\n    assert(z == null || (z instanceof BN));\n    assert(t == null || (t instanceof BN));\n\n    this.x = x;\n    this.y = y;\n    this.z = z || this.curve.one;\n    this.t = t || null;\n\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n\n    if (!this.z.red)\n      this.z = this.z.toRed(this.curve.red);\n\n    if (this.t && !this.t.red)\n      this.t = this.t.toRed(this.curve.red);\n\n    this.zOne = this.z.eq(this.curve.one);\n\n    this._check();\n\n    if (!this.t) {\n      this.t = this.x.redMul(this.y);\n      if (!this.zOne)\n        this.t = this.t.redDiv(this.z);\n    }\n  }\n\n  _check() {\n    // In order to achieve complete\n    // addition formulas, `a` must\n    // be a square (always the case\n    // for a=1), and `d` must be a\n    // non-square.\n    //\n    // If this is not the case, the\n    // addition formulas may have\n    // exceptional cases where Z3=0.\n    //\n    // In particular, this can occur\n    // when: Q*h = -P*h and Q != -P.\n    //\n    // This is assuming 4-torsion is\n    // involved (the 4-torsion point\n    // is _not_ representable when\n    // `d` is square).\n    if (this.z.isZero())\n      throw new Error('Invalid point.');\n  }\n\n  clone() {\n    return this.curve.point(this.x, this.y, this.z, this.t);\n  }\n\n  normalize() {\n    // https://hyperelliptic.org/EFD/g1p/auto-edwards-projective.html#scaling-z\n    // 1I + 2M (+ 1M if extended)\n\n    // Z1 = 1\n    if (this.zOne)\n      return this;\n\n    // A = 1 / Z1\n    const a = this.z.redInvert();\n\n    // X3 = X1 * A\n    this.x = this.x.redMul(a);\n\n    // Y3 = Y1 * A\n    this.y = this.y.redMul(a);\n\n    // T3 = T1 * A\n    this.t = this.t.redMul(a);\n\n    // Z3 = 1\n    this.z = this.curve.one;\n    this.zOne = true;\n\n    return this;\n  }\n\n  scale(a) {\n    assert(a instanceof BN);\n\n    // X3 = X1 * A\n    const nx = this.x.redMul(a);\n\n    // Y3 = Y1 * A\n    const ny = this.y.redMul(a);\n\n    // Z3 = Z1 * A\n    const nz = this.z.redMul(a);\n\n    // T3 = T1 * A\n    const nt = this.t.redMul(a);\n\n    return this.curve.point(nx, ny, nz, nt);\n  }\n\n  neg() {\n    // -(X1, Y1, Z1, T1) = (-X1, Y1, Z1, -T1)\n    const nx = this.x.redNeg();\n    const ny = this.y;\n    const nz = this.z;\n    const nt = this.t.redNeg();\n\n    return this.curve.point(nx, ny, nz, nt);\n  }\n\n  add(p) {\n    assert(p instanceof EdwardsPoint);\n\n    // P = O\n    if (this.isInfinity())\n      return p;\n\n    // Q = O\n    if (p.isInfinity())\n      return this;\n\n    // Z1 = 1\n    if (this.zOne)\n      return p._add(this);\n\n    return this._add(p);\n  }\n\n  _add(p) {\n    // a = -1\n    if (this.curve.mOneA)\n      return this._addM1(p);\n\n    return this._addA(p);\n  }\n\n  _addM1(p) {\n    // Assumes a = -1.\n    //\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-3\n    // 8M + 8A + 1*k + 1*2\n    //\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-madd-2008-hwcd-3\n    // 7M + 8A + 1*k + 1*2\n\n    // A = (Y1 - X1) * (Y2 - X2)\n    const a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));\n\n    // B = (Y1 + X1) * (Y2 + X2)\n    const b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));\n\n    // C = T1 * k * T2\n    const c = this.t.redMul(this.curve.k).redMul(p.t);\n\n    // D = Z1 * 2 * Z2\n    const d = p.zOne ? this.z.redAdd(this.z) : this.z.redMul(p.z).redIMuln(2);\n\n    // E = B - A\n    const e = b.redSub(a);\n\n    // F = D - C\n    const f = d.redSub(c);\n\n    // G = D + C\n    const g = d.redIAdd(c);\n\n    // H = B + A\n    const h = b.redIAdd(a);\n\n    // X3 = E * F\n    const nx = e.redMul(f);\n\n    // Y3 = G * H\n    const ny = g.redMul(h);\n\n    // T3 = E * H\n    const nt = e.redMul(h);\n\n    // Z3 = F * G\n    const nz = f.redMul(g);\n\n    return this.curve.point(nx, ny, nz, nt);\n  }\n\n  _addA(p) {\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n    // 9M + 7A + 1*a + 1*d\n    //\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-madd-2008-hwcd\n    // 8M + 7A + 1*a + 1*d\n\n    // A = X1 * X2\n    const a = this.x.redMul(p.x);\n\n    // B = Y1 * Y2\n    const b = this.y.redMul(p.y);\n\n    // C = T1 * d * T2\n    const c = this.curve._mulD(this.t).redMul(p.t);\n\n    // D = Z1 * Z2\n    const d = p.zOne ? this.z.clone() : this.z.redMul(p.z);\n\n    // + XYXY = (X1 + Y1) * (X2 + Y2)\n    const xyxy = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y));\n\n    // E = (X1 + Y1) * (X2 + Y2) - A - B\n    const e = xyxy.redISub(a).redISub(b);\n\n    // F = D - C\n    const f = d.redSub(c);\n\n    // G = D + C\n    const g = d.redIAdd(c);\n\n    // H = B - a * A\n    const h = b.redISub(this.curve._mulA(a));\n\n    // X3 = E * F\n    const nx = e.redMul(f);\n\n    // Y3 = G * H\n    const ny = g.redMul(h);\n\n    // T3 = E * H\n    const nt = e.redMul(h);\n\n    // Z3 = F * G\n    const nz = f.redMul(g);\n\n    return this.curve.point(nx, ny, nz, nt);\n  }\n\n  dbl() {\n    // P = O\n    if (this.isInfinity())\n      return this;\n\n    return this._dbl();\n  }\n\n  _dbl() {\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n    // 4M + 4S + 6A + 1*a + 1*2\n    //\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-mdbl-2008-hwcd\n    // 3M + 4S + 7A + 1*a + 1*2\n\n    // A = X1^2\n    const a = this.x.redSqr();\n\n    // B = Y1^2\n    const b = this.y.redSqr();\n\n    // C = 2 * Z1^2\n    const c = this.zOne ? this.curve.two : this.z.redSqr().redIMuln(2);\n\n    // D = a * A\n    const d = this.curve._mulA(a);\n\n    // E = (X1 + Y1)^2 - A - B\n    const e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);\n\n    // G = D + B\n    const g = d.redAdd(b);\n\n    // F = G - C\n    const f = g.redSub(c);\n\n    // H = D - B\n    const h = d.redISub(b);\n\n    // X3 = E * F\n    const nx = e.redMul(f);\n\n    // Y3 = G * H\n    const ny = g.redMul(h);\n\n    // T3 = E * H\n    const nt = e.redMul(h);\n\n    // Z3 = F * G\n    const nz = f.redMul(g);\n\n    return this.curve.point(nx, ny, nz, nt);\n  }\n\n  getX() {\n    this.normalize();\n    return this.x.fromRed();\n  }\n\n  getY() {\n    this.normalize();\n    return this.y.fromRed();\n  }\n\n  eq(p) {\n    assert(p instanceof EdwardsPoint);\n    assert(!this.z.isZero());\n    assert(!p.z.isZero());\n\n    // P = Q\n    if (this === p)\n      return true;\n\n    // Z1 = Z2\n    if (this.z.eq(p.z)) {\n      return this.x.eq(p.x)\n          && this.y.eq(p.y);\n    }\n\n    // X1 * Z2 = X2 * Z1\n    const x1 = this.x.redMul(p.z);\n    const x2 = p.x.redMul(this.z);\n\n    if (!x1.eq(x2))\n      return false;\n\n    const y1 = this.y.redMul(p.z);\n    const y2 = p.y.redMul(this.z);\n\n    return y1.eq(y2);\n  }\n\n  cmp(point) {\n    assert(point instanceof EdwardsPoint);\n\n    return this.order().cmp(point.order())\n        || this.getY().cmp(point.getY())\n        || this.getX().cmp(point.getX());\n  }\n\n  isInfinity() {\n    assert(!this.z.isZero());\n\n    // X1 = 0\n    if (!this.x.isZero())\n      return false;\n\n    // Y1 = Z1\n    return this.y.eq(this.z);\n  }\n\n  isOrder2() {\n    if (this.isInfinity())\n      return false;\n\n    return this.x.isZero();\n  }\n\n  isOdd() {\n    this.normalize();\n    return this.x.redIsOdd();\n  }\n\n  isEven() {\n    this.normalize();\n    return this.x.redIsEven();\n  }\n\n  toP() {\n    return this.normalize();\n  }\n\n  toJ() {\n    return this;\n  }\n\n  encode() {\n    // [RFC8032] Section 5.1.2.\n    const y = this.getY();\n\n    // Note: `x` normalized from `getY()` call.\n    y.setn(this.curve.signBit, this.x.redIsOdd());\n\n    return this.curve.encodeAdjusted(y);\n  }\n\n  static decode(curve, bytes) {\n    // [RFC8032] Section 5.1.3.\n    assert(curve instanceof EdwardsCurve);\n\n    const y = curve.decodeAdjusted(bytes);\n    const sign = y.testn(curve.signBit) !== 0;\n\n    y.setn(curve.signBit, 0);\n\n    if (y.cmp(curve.p) >= 0)\n      throw new Error('Invalid point.');\n\n    return curve.pointFromY(y, sign);\n  }\n\n  toJSON(pre) {\n    if (this.isInfinity())\n      return [];\n\n    const x = this.getX().toJSON();\n    const y = this.getY().toJSON();\n\n    if (pre === true && this.pre)\n      return [x, y, this.pre.toJSON()];\n\n    return [x, y];\n  }\n\n  toPretty() {\n    const size = this.curve.fieldSize * 2;\n    const x = toPretty(this.getX(), size);\n    const y = toPretty(this.getY(), size);\n\n    return [x, y];\n  }\n\n  static fromJSON(curve, json) {\n    assert(curve instanceof EdwardsCurve);\n    assert(Array.isArray(json));\n    assert(json.length === 0\n        || json.length === 2\n        || json.length === 3);\n\n    if (json.length === 0)\n      return curve.point();\n\n    const x = BN.fromJSON(json[0]);\n    const y = BN.fromJSON(json[1]);\n    const point = curve.point(x, y);\n\n    if (json.length > 2 && json[2] != null)\n      point.pre = Precomp.fromJSON(point, json[2]);\n\n    return point;\n  }\n\n  [custom]() {\n    if (this.isInfinity())\n      return '<EdwardsPoint: Infinity>';\n\n    return '<EdwardsPoint:'\n        + ' x=' + this.x.fromRed().toString(16, 2)\n        + ' y=' + this.y.fromRed().toString(16, 2)\n        + ' z=' + this.z.fromRed().toString(16, 2)\n        + '>';\n  }\n}\n\n/**\n * Precomp\n */\n\nclass Precomp {\n  constructor() {\n    this.naf = null;\n    this.windows = null;\n    this.doubles = null;\n    this.blinding = null;\n    this.beta = null;\n  }\n\n  map(func) {\n    assert(typeof func === 'function');\n\n    const out = new this.constructor();\n\n    if (this.naf)\n      out.naf = this.naf.map(func);\n\n    if (this.doubles)\n      out.doubles = this.doubles.map(func);\n\n    return out;\n  }\n\n  toJSON() {\n    return {\n      naf: this.naf ? this.naf.toJSON() : null,\n      windows: this.windows ? this.windows.toJSON() : null,\n      doubles: this.doubles ? this.doubles.toJSON() : null,\n      blinding: this.blinding ? this.blinding.toJSON() : undefined\n    };\n  }\n\n  fromJSON(point, json) {\n    assert(point instanceof Point);\n    assert(json && typeof json === 'object');\n\n    if (json.naf != null)\n      this.naf = NAF.fromJSON(point, json.naf);\n\n    if (json.windows != null)\n      this.windows = Windows.fromJSON(point, json.windows);\n\n    if (json.doubles != null)\n      this.doubles = Doubles.fromJSON(point, json.doubles);\n\n    if (json.blinding != null)\n      this.blinding = Blinding.fromJSON(point, json.blinding);\n\n    return this;\n  }\n\n  static fromJSON(point, json) {\n    return new this().fromJSON(point, json);\n  }\n}\n\n/**\n * NAF\n */\n\nclass NAF {\n  constructor(width, points) {\n    this.width = width;\n    this.points = points;\n  }\n\n  map(func) {\n    assert(typeof func === 'function');\n\n    const {width} = this;\n    const points = [];\n\n    for (const point of this.points)\n      points.push(func(point));\n\n    return new this.constructor(width, points);\n  }\n\n  toJSON() {\n    return {\n      width: this.width,\n      points: this.points.slice(1).map((point) => {\n        return point.toJSON();\n      })\n    };\n  }\n\n  static fromJSON(point, json) {\n    assert(point instanceof Point);\n    assert(json && typeof json === 'object');\n    assert((json.width >>> 0) === json.width);\n    assert(Array.isArray(json.points));\n\n    const {curve} = point;\n    const {width} = json;\n    const points = [point];\n\n    for (const item of json.points)\n      points.push(curve.pointFromJSON(item));\n\n    return new this(width, points);\n  }\n}\n\n/**\n * Windows\n */\n\nclass Windows {\n  constructor(width, bits, points) {\n    this.width = width;\n    this.bits = bits;\n    this.points = points;\n  }\n\n  toJSON() {\n    return {\n      width: this.width,\n      bits: this.bits,\n      points: this.points.slice(1).map((point) => {\n        return point.toJSON();\n      })\n    };\n  }\n\n  static fromJSON(point, json) {\n    assert(point instanceof Point);\n    assert(json && typeof json === 'object');\n    assert((json.width >>> 0) === json.width);\n    assert((json.bits >>> 0) === json.bits);\n    assert(Array.isArray(json.points));\n\n    const {curve} = point;\n    const {width, bits} = json;\n    const points = [point];\n\n    for (const item of json.points)\n      points.push(curve.pointFromJSON(item));\n\n    return new this(width, bits, points);\n  }\n}\n\n/**\n * Doubles\n */\n\nclass Doubles {\n  constructor(step, points) {\n    this.step = step;\n    this.points = points;\n  }\n\n  map(func) {\n    assert(typeof func === 'function');\n\n    const {step} = this;\n    const points = [];\n\n    for (const point of this.points)\n      points.push(func(point));\n\n    return new this.constructor(step, points);\n  }\n\n  toJSON() {\n    return {\n      step: this.step,\n      points: this.points.slice(1).map((point) => {\n        return point.toJSON();\n      })\n    };\n  }\n\n  static fromJSON(point, json) {\n    assert(point instanceof Point);\n    assert(json && typeof json === 'object');\n    assert((json.step >>> 0) === json.step);\n    assert(Array.isArray(json.points));\n\n    const {curve} = point;\n    const {step} = json;\n    const points = [point];\n\n    for (const item of json.points)\n      points.push(curve.pointFromJSON(item));\n\n    return new this(step, points);\n  }\n}\n\n/**\n * Blinding\n */\n\nclass Blinding {\n  constructor(blind, unblind) {\n    this.blind = blind;\n    this.unblind = unblind;\n  }\n\n  toJSON() {\n    return {\n      blind: this.blind.toJSON(),\n      unblind: this.unblind.toJSON()\n    };\n  }\n\n  static fromJSON(point, json) {\n    assert(point instanceof Point);\n    assert(json && typeof json === 'object');\n\n    const {curve} = point;\n    const blind = BN.fromJSON(json.blind);\n    const unblind = curve.pointFromJSON(json.unblind);\n\n    return new this(blind, unblind);\n  }\n}\n\n/**\n * Endo\n */\n\nclass Endo {\n  constructor(beta, lambda, basis, pre) {\n    this.beta = beta;\n    this.lambda = lambda;\n    this.basis = basis;\n    this.pre = pre;\n  }\n\n  toJSON() {\n    return {\n      beta: this.beta.fromRed().toJSON(),\n      lambda: this.lambda.toJSON(),\n      basis: [\n        this.basis[0].toJSON(),\n        this.basis[1].toJSON()\n      ],\n      pre: [\n        this.pre[0],\n        this.pre[1].toJSON(),\n        this.pre[2].toJSON()\n      ]\n    };\n  }\n\n  static fromJSON(curve, json) {\n    assert(curve instanceof Curve);\n    assert(json && typeof json === 'object');\n    assert(Array.isArray(json.basis));\n    assert(Array.isArray(json.pre));\n    assert(json.basis.length === 2);\n    assert(json.pre.length === 3);\n    assert((json.pre[0] >>> 0) === json.pre[0]);\n\n    const beta = BN.fromJSON(json.beta).toRed(curve.red);\n    const lambda = BN.fromJSON(json.lambda);\n\n    const basis = [\n      Vector.fromJSON(json.basis[0]),\n      Vector.fromJSON(json.basis[1])\n    ];\n\n    const pre = [\n      json.pre[0],\n      BN.fromJSON(json.pre[1]),\n      BN.fromJSON(json.pre[2])\n    ];\n\n    return new this(beta, lambda, basis, pre);\n  }\n}\n\n/**\n * Vector\n */\n\nclass Vector {\n  constructor(a, b) {\n    this.a = a;\n    this.b = b;\n  }\n\n  toJSON() {\n    return {\n      a: this.a.toJSON(),\n      b: this.b.toJSON()\n    };\n  }\n\n  static fromJSON(json) {\n    assert(json && typeof json === 'object');\n\n    const a = BN.fromJSON(json.a);\n    const b = BN.fromJSON(json.b);\n\n    return new this(a, b);\n  }\n}\n\n/**\n * P192\n * https://tinyurl.com/fips-186-2 (page 29)\n * https://tinyurl.com/fips-186-3 (page 88)\n */\n\nclass P192 extends ShortCurve {\n  constructor(pre) {\n    super({\n      id: 'P192',\n      ossl: 'prime192v1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA256',\n      prime: 'p192',\n      // 2^192 - 2^64 - 1 (= 3 mod 4)\n      p: ['ffffffff ffffffff ffffffff fffffffe',\n          'ffffffff ffffffff'],\n      // -3 mod p\n      a: ['ffffffff ffffffff ffffffff fffffffe',\n          'ffffffff fffffffc'],\n      b: ['64210519 e59c80e7 0fa7e9ab 72243049',\n          'feb8deec c146b9b1'],\n      n: ['ffffffff ffffffff ffffffff 99def836',\n          '146bc9b1 b4d22831'],\n      h: '1',\n      // Icart\n      z: '-5',\n      g: [\n        ['188da80e b03090f6 7cbf20eb 43a18800',\n         'f4ff0afd 82ff1012'],\n        ['07192b95 ffc8da78 631011ed 6b24cdd5',\n         '73f977a1 1e794811'],\n        pre\n      ]\n    });\n  }\n}\n\n/**\n * P224\n * https://tinyurl.com/fips-186-2 (page 30)\n * https://tinyurl.com/fips-186-3 (page 88)\n */\n\nclass P224 extends ShortCurve {\n  constructor(pre) {\n    super({\n      id: 'P224',\n      ossl: 'secp224r1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA256',\n      prime: 'p224',\n      // 2^224 - 2^96 + 1 (1 mod 16)\n      p: ['ffffffff ffffffff ffffffff ffffffff',\n          '00000000 00000000 00000001'],\n      // -3 mod p\n      a: ['ffffffff ffffffff ffffffff fffffffe',\n          'ffffffff ffffffff fffffffe'],\n      b: ['b4050a85 0c04b3ab f5413256 5044b0b7',\n          'd7bfd8ba 270b3943 2355ffb4'],\n      n: ['ffffffff ffffffff ffffffff ffff16a2',\n          'e0b8f03e 13dd2945 5c5c2a3d'],\n      h: '1',\n      // SSWU\n      z: '1f',\n      g: [\n        ['b70e0cbd 6bb4bf7f 321390b9 4a03c1d3',\n         '56c21122 343280d6 115c1d21'],\n        ['bd376388 b5f723fb 4c22dfe6 cd4375a0',\n         '5a074764 44d58199 85007e34'],\n        pre\n      ]\n    });\n  }\n}\n\n/**\n * P256\n * https://tinyurl.com/fips-186-2 (page 31)\n * https://tinyurl.com/fips-186-3 (page 89)\n */\n\nclass P256 extends ShortCurve {\n  constructor(pre) {\n    super({\n      id: 'P256',\n      ossl: 'prime256v1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA256',\n      prime: null,\n      // 2^256 - 2^224 + 2^192 + 2^96 - 1 (= 3 mod 4)\n      p: ['ffffffff 00000001 00000000 00000000',\n          '00000000 ffffffff ffffffff ffffffff'],\n      // -3 mod p\n      a: ['ffffffff 00000001 00000000 00000000',\n          '00000000 ffffffff ffffffff fffffffc'],\n      b: ['5ac635d8 aa3a93e7 b3ebbd55 769886bc',\n          '651d06b0 cc53b0f6 3bce3c3e 27d2604b'],\n      n: ['ffffffff 00000000 ffffffff ffffffff',\n          'bce6faad a7179e84 f3b9cac2 fc632551'],\n      h: '1',\n      // SSWU\n      z: '-a',\n      g: [\n        ['6b17d1f2 e12c4247 f8bce6e5 63a440f2',\n         '77037d81 2deb33a0 f4a13945 d898c296'],\n        ['4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16',\n         '2bce3357 6b315ece cbb64068 37bf51f5'],\n        pre\n      ]\n    });\n  }\n}\n\n/**\n * P384\n * https://tinyurl.com/fips-186-2 (page 32)\n * https://tinyurl.com/fips-186-3 (page 89)\n */\n\nclass P384 extends ShortCurve {\n  constructor(pre) {\n    super({\n      id: 'P384',\n      ossl: 'secp384r1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA384',\n      prime: null,\n      // 2^384 - 2^128 - 2^96 + 2^32 - 1 (= 3 mod 4)\n      p: ['ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff ffffffff fffffffe',\n          'ffffffff 00000000 00000000 ffffffff'],\n      // -3 mod p\n      a: ['ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff ffffffff fffffffe',\n          'ffffffff 00000000 00000000 fffffffc'],\n      b: ['b3312fa7 e23ee7e4 988e056b e3f82d19',\n          '181d9c6e fe814112 0314088f 5013875a',\n          'c656398d 8a2ed19d 2a85c8ed d3ec2aef'],\n      n: ['ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff c7634d81 f4372ddf',\n          '581a0db2 48b0a77a ecec196a ccc52973'],\n      h: '1',\n      // Icart\n      z: '-c',\n      g: [\n        ['aa87ca22 be8b0537 8eb1c71e f320ad74',\n         '6e1d3b62 8ba79b98 59f741e0 82542a38',\n         '5502f25d bf55296c 3a545e38 72760ab7'],\n        ['3617de4a 96262c6f 5d9e98bf 9292dc29',\n         'f8f41dbd 289a147c e9da3113 b5f0b8c0',\n         '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'],\n        pre\n      ]\n    });\n  }\n}\n\n/**\n * P521\n * https://tinyurl.com/fips-186-2 (page 33)\n * https://tinyurl.com/fips-186-3 (page 90)\n */\n\nclass P521 extends ShortCurve {\n  constructor(pre) {\n    super({\n      id: 'P521',\n      ossl: 'secp521r1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA512',\n      prime: 'p521',\n      // 2^521 - 1 (= 3 mod 4)\n      p: ['000001ff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff'],\n      // -3 mod p\n      a: ['000001ff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff ffffffff ffffffff',\n          'fffffffc'],\n      b: ['00000051 953eb961 8e1c9a1f 929a21a0',\n          'b68540ee a2da725b 99b315f3 b8b48991',\n          '8ef109e1 56193951 ec7e937b 1652c0bd',\n          '3bb1bf07 3573df88 3d2c34f1 ef451fd4',\n          '6b503f00'],\n      n: ['000001ff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff ffffffff ffffffff',\n          'fffffffa 51868783 bf2f966b 7fcc0148',\n          'f709a5d0 3bb5c9b8 899c47ae bb6fb71e',\n          '91386409'],\n      h: '1',\n      // SSWU\n      z: '-4',\n      g: [\n        ['000000c6 858e06b7 0404e9cd 9e3ecb66',\n         '2395b442 9c648139 053fb521 f828af60',\n         '6b4d3dba a14b5e77 efe75928 fe1dc127',\n         'a2ffa8de 3348b3c1 856a429b f97e7e31',\n         'c2e5bd66'],\n        ['00000118 39296a78 9a3bc004 5c8a5fb4',\n         '2c7d1bd9 98f54449 579b4468 17afbd17',\n         '273e662c 97ee7299 5ef42640 c550b901',\n         '3fad0761 353c7086 a272c240 88be9476',\n         '9fd16650'],\n        pre\n      ]\n    });\n  }\n}\n\n/**\n * SECP256K1\n * https://www.secg.org/SEC2-Ver-1.0.pdf (page 15, section 2.7.1)\n * https://www.secg.org/sec2-v2.pdf (page 9, section 2.4.1)\n */\n\nclass SECP256K1 extends ShortCurve {\n  constructor(pre) {\n    super({\n      id: 'SECP256K1',\n      ossl: 'secp256k1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA256',\n      prime: 'k256',\n      // 2^256 - 2^32 - 977 (= 3 mod 4)\n      p: ['ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff fffffffe fffffc2f'],\n      a: '0',\n      b: '7',\n      n: ['ffffffff ffffffff ffffffff fffffffe',\n          'baaedce6 af48a03b bfd25e8c d0364141'],\n      h: '1',\n      // SVDW\n      z: '1',\n      // sqrt(-3)\n      c: ['0a2d2ba9 3507f1df 233770c2 a797962c',\n          'c61f6d15 da14ecd4 7d8d27ae 1cd5f852'],\n      g: [\n        ['79be667e f9dcbbac 55a06295 ce870b07',\n         '029bfcdb 2dce28d9 59f2815b 16f81798'],\n        ['483ada77 26a3c465 5da4fbfc 0e1108a8',\n         'fd17b448 a6855419 9c47d08f fb10d4b8'],\n        pre\n      ],\n      // Precomputed endomorphism.\n      endo: {\n        beta: ['7ae96a2b 657c0710 6e64479e ac3434e9',\n               '9cf04975 12f58995 c1396c28 719501ee'],\n        lambda: ['5363ad4c c05c30e0 a5261c02 8812645a',\n                 '122e22ea 20816678 df02967c 1b23bd72'],\n        basis: [\n          {\n            a: '3086d221a7d46bcde86c90e49284eb15',\n            b: '-e4437ed6010e88286f547fa90abfe4c3'\n          },\n          {\n            a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n            b: '3086d221a7d46bcde86c90e49284eb15'\n          }\n        ],\n        pre: [\n          384,\n          ['3086d221 a7d46bcd e86c90e4 9284eb15',\n           '3daa8a14 71e8ca7f e893209a 45dbb031'],\n          ['-',\n           'e4437ed6 010e8828 6f547fa9 0abfe4c4',\n           '221208ac 9df506c6 1571b4ae 8ac47f71']\n        ]\n      }\n    });\n  }\n}\n\n/**\n * BRAINPOOLP256\n * https://tools.ietf.org/html/rfc5639#section-3.4\n */\n\nclass BRAINPOOLP256 extends ShortCurve {\n  constructor(pre) {\n    super({\n      id: 'BRAINPOOLP256',\n      ossl: 'brainpoolP256r1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA256',\n      prime: null,\n      // (= 3 mod 4)\n      p: ['a9fb57db a1eea9bc 3e660a90 9d838d72',\n          '6e3bf623 d5262028 2013481d 1f6e5377'],\n      a: ['7d5a0975 fc2c3057 eef67530 417affe7',\n          'fb8055c1 26dc5c6c e94a4b44 f330b5d9'],\n      b: ['26dc5c6c e94a4b44 f330b5d9 bbd77cbf',\n          '95841629 5cf7e1ce 6bccdc18 ff8c07b6'],\n      n: ['a9fb57db a1eea9bc 3e660a90 9d838d71',\n          '8c397aa3 b561a6f7 901e0e82 974856a7'],\n      h: '1',\n      // Icart\n      z: '-2',\n      g: [\n        ['8bd2aeb9 cb7e57cb 2c4b482f fc81b7af',\n         'b9de27e1 e3bd23c2 3a4453bd 9ace3262'],\n        ['547ef835 c3dac4fd 97f8461a 14611dc9',\n         'c2774513 2ded8e54 5c1d54c7 2f046997'],\n        pre\n      ]\n    });\n  }\n}\n\n/**\n * BRAINPOOLP384\n * https://tools.ietf.org/html/rfc5639#section-3.6\n */\n\nclass BRAINPOOLP384 extends ShortCurve {\n  constructor(pre) {\n    super({\n      id: 'BRAINPOOLP384',\n      ossl: 'brainpoolP384r1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA384',\n      prime: null,\n      // (= 3 mod 4)\n      p: ['8cb91e82 a3386d28 0f5d6f7e 50e641df',\n          '152f7109 ed5456b4 12b1da19 7fb71123',\n          'acd3a729 901d1a71 87470013 3107ec53'],\n      a: ['7bc382c6 3d8c150c 3c72080a ce05afa0',\n          'c2bea28e 4fb22787 139165ef ba91f90f',\n          '8aa5814a 503ad4eb 04a8c7dd 22ce2826'],\n      b: ['04a8c7dd 22ce2826 8b39b554 16f0447c',\n          '2fb77de1 07dcd2a6 2e880ea5 3eeb62d5',\n          '7cb43902 95dbc994 3ab78696 fa504c11'],\n      n: ['8cb91e82 a3386d28 0f5d6f7e 50e641df',\n          '152f7109 ed5456b3 1f166e6c ac0425a7',\n          'cf3ab6af 6b7fc310 3b883202 e9046565'],\n      h: '1',\n      // SSWU\n      z: '-5',\n      g: [\n        ['1d1c64f0 68cf45ff a2a63a81 b7c13f6b',\n         '8847a3e7 7ef14fe3 db7fcafe 0cbd10e8',\n         'e826e034 36d646aa ef87b2e2 47d4af1e'],\n        ['8abe1d75 20f9c2a4 5cb1eb8e 95cfd552',\n         '62b70b29 feec5864 e19c054f f9912928',\n         '0e464621 77918111 42820341 263c5315'],\n        pre\n      ]\n    });\n  }\n}\n\n/**\n * BRAINPOOLP512\n * https://tools.ietf.org/html/rfc5639#section-3.7\n */\n\nclass BRAINPOOLP512 extends ShortCurve {\n  constructor(pre) {\n    super({\n      id: 'BRAINPOOLP512',\n      ossl: 'brainpoolP512r1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA512',\n      prime: null,\n      // (= 3 mod 4)\n      p: ['aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07',\n          'cb308db3 b3c9d20e d6639cca 70330871',\n          '7d4d9b00 9bc66842 aecda12a e6a380e6',\n          '2881ff2f 2d82c685 28aa6056 583a48f3'],\n      a: ['7830a331 8b603b89 e2327145 ac234cc5',\n          '94cbdd8d 3df91610 a83441ca ea9863bc',\n          '2ded5d5a a8253aa1 0a2ef1c9 8b9ac8b5',\n          '7f1117a7 2bf2c7b9 e7c1ac4d 77fc94ca'],\n      b: ['3df91610 a83441ca ea9863bc 2ded5d5a',\n          'a8253aa1 0a2ef1c9 8b9ac8b5 7f1117a7',\n          '2bf2c7b9 e7c1ac4d 77fc94ca dc083e67',\n          '984050b7 5ebae5dd 2809bd63 8016f723'],\n      n: ['aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07',\n          'cb308db3 b3c9d20e d6639cca 70330870',\n          '553e5c41 4ca92619 41866119 7fac1047',\n          '1db1d381 085ddadd b5879682 9ca90069'],\n      h: '1',\n      // Icart\n      z: '7',\n      g: [\n        ['81aee4bd d82ed964 5a21322e 9c4c6a93',\n         '85ed9f70 b5d916c1 b43b62ee f4d0098e',\n         'ff3b1f78 e2d0d48d 50d1687b 93b97d5f',\n         '7c6d5047 406a5e68 8b352209 bcb9f822'],\n        ['7dde385d 566332ec c0eabfa9 cf7822fd',\n         'f209f700 24a57b1a a000c55b 881f8111',\n         'b2dcde49 4a5f485e 5bca4bd8 8a2763ae',\n         'd1ca2b2f a8f05406 78cd1e0f 3ad80892'],\n        pre\n      ]\n    });\n  }\n}\n\n/**\n * X25519\n * https://tools.ietf.org/html/rfc7748#section-4.1\n */\n\nclass X25519 extends MontCurve {\n  constructor() {\n    super({\n      id: 'X25519',\n      ossl: 'X25519',\n      type: 'mont',\n      endian: 'le',\n      hash: 'SHA512',\n      prime: 'p25519',\n      // 2^255 - 19 (= 5 mod 8)\n      p: ['7fffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff ffffffff ffffffed'],\n      // 486662\n      a: '76d06',\n      b: '1',\n      n: ['10000000 00000000 00000000 00000000',\n          '14def9de a2f79cd6 5812631a 5cf5d3ed'],\n      h: '8',\n      // Elligator 2\n      z: '2',\n      g: [\n        ['00000000 00000000 00000000 00000000',\n         '00000000 00000000 00000000 00000009'],\n        // See: https://www.rfc-editor.org/errata/eid4730\n        ['5f51e65e 475f794b 1fe122d3 88b72eb3',\n         '6dc2b281 92839e4d d6163a5d 81312c14']\n      ],\n      torsion: [\n        [],\n        [\n          ['00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000'],\n          ['00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000']\n        ],\n        [\n          ['00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000001'],\n          ['6be4f497 f9a9c2af c21fa77a d7f4a6ef',\n           '635a11c7 284a9363 e9a248ef 9c884415']\n        ],\n        [\n          ['00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000001'],\n          ['141b0b68 06563d50 3de05885 280b5910',\n           '9ca5ee38 d7b56c9c 165db710 6377bbd8']\n        ],\n        [\n          ['57119fd0 dd4e22d8 868e1c58 c45c4404',\n           '5bef839c 55b1d0b1 248c50a3 bc959c5f'],\n          ['68c59389 3d458e64 31c6ca00 45fb5015',\n           '20a44346 8eaa68dd 0f103842 048065b7']\n        ],\n        [\n          ['57119fd0 dd4e22d8 868e1c58 c45c4404',\n           '5bef839c 55b1d0b1 248c50a3 bc959c5f'],\n          ['173a6c76 c2ba719b ce3935ff ba04afea',\n           'df5bbcb9 71559722 f0efc7bd fb7f9a36']\n        ],\n        [\n          ['00b8495f 16056286 fdb1329c eb8d09da',\n           '6ac49ff1 fae35616 aeb8413b 7c7aebe0'],\n          ['3931c129 569e83a5 29482c14 e628b457',\n           '933bfc29 ed801b4d 68871483 92507b1a']\n        ],\n        [\n          ['00b8495f 16056286 fdb1329c eb8d09da',\n           '6ac49ff1 fae35616 aeb8413b 7c7aebe0'],\n          ['46ce3ed6 a9617c5a d6b7d3eb 19d74ba8',\n           '6cc403d6 127fe4b2 9778eb7c 6daf84d3']\n        ]\n      ]\n    });\n  }\n}\n\n/**\n * X448\n * https://tools.ietf.org/html/rfc7748#section-4.2\n */\n\nclass X448 extends MontCurve {\n  constructor() {\n    super({\n      id: 'X448',\n      ossl: 'X448',\n      type: 'mont',\n      endian: 'le',\n      hash: 'SHAKE256',\n      prime: 'p448',\n      // 2^448 - 2^224 - 1 (= 3 mod 4)\n      p: ['ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff fffffffe ffffffff',\n          'ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff'],\n      // 156326\n      a: '262a6',\n      b: '1',\n      n: ['3fffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff ffffffff 7cca23e9',\n          'c44edb49 aed63690 216cc272 8dc58f55',\n          '2378c292 ab5844f3'],\n      h: '4',\n      // Elligator 2\n      z: '-1',\n      g: [\n        ['00000000 00000000 00000000 00000000',\n         '00000000 00000000 00000000 00000000',\n         '00000000 00000000 00000000 00000000',\n         '00000000 00000005'],\n        ['7d235d12 95f5b1f6 6c98ab6e 58326fce',\n         'cbae5d34 f55545d0 60f75dc2 8df3f6ed',\n         'b8027e23 46430d21 1312c4b1 50677af7',\n         '6fd7223d 457b5b1a']\n      ],\n      torsion: [\n        [],\n        [\n          ['00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000000'],\n          ['00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000000']\n        ],\n        [\n          ['ffffffff ffffffff ffffffff ffffffff',\n           'ffffffff ffffffff fffffffe ffffffff',\n           'ffffffff ffffffff ffffffff ffffffff',\n           'ffffffff fffffffe'],\n          ['ba4d3a08 29b6112f 8812e51b a0bb2abe',\n           'bc1cb08e b48e5569 36ba50fd d2e7d68a',\n           'f8cb3216 0522425b 3f990812 abbe635a',\n           'd37a21e1 7551b193']\n        ],\n        [\n          ['ffffffff ffffffff ffffffff ffffffff',\n           'ffffffff ffffffff fffffffe ffffffff',\n           'ffffffff ffffffff ffffffff ffffffff',\n           'ffffffff fffffffe'],\n          ['45b2c5f7 d649eed0 77ed1ae4 5f44d541',\n           '43e34f71 4b71aa96 c945af01 2d182975',\n           '0734cde9 faddbda4 c066f7ed 54419ca5',\n           '2c85de1e 8aae4e6c']\n        ]\n      ]\n    });\n  }\n}\n\n/**\n * MONT448\n * Isomorphic to Ed448-Goldilocks.\n */\n\nclass MONT448 extends MontCurve {\n  constructor() {\n    super({\n      id: 'MONT448',\n      ossl: null,\n      type: 'mont',\n      endian: 'le',\n      hash: 'SHAKE256',\n      prime: 'p448',\n      // 2^448 - 2^224 - 1 (= 3 mod 4)\n      p: ['ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff fffffffe ffffffff',\n          'ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff'],\n      // -78160 / -39082 mod p\n      a: ['b2cf97d2 d43459a9 31ed36b1 fc4e3cb5',\n          '5d93f8d2 22746997 60ccffc6 49961ed6',\n          'c5b05fca c24864ed 6fb59697 931b78da',\n          '84ddecd8 ca2b5cfb'],\n      b: '1',\n      n: ['3fffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff ffffffff 7cca23e9',\n          'c44edb49 aed63690 216cc272 8dc58f55',\n          '2378c292 ab5844f3'],\n      h: '4',\n      // Elligator 2\n      z: '-1',\n      g: [\n        ['ac0d24cc c6c75cb0 eb71f81e 7a6edf51',\n         '48e88aee 009a2a24 e795687e c28e125a',\n         '3e6730a6 0d46367b aa7fe99d 152128dc',\n         '41321bc7 7817f059'],\n        ['5a4437f6 80c0d0db 9b061276 d5d0ffcc',\n         'e786ff33 b6a53d30 98746425 82e66f09',\n         '4433dae7 7244a6e2 6b11e905 7228f483',\n         '556c41a5 913f55fe']\n      ],\n      torsion: [\n        [],\n        [\n          ['00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000000'],\n          ['00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000000']\n        ],\n        [\n          ['ffffffff ffffffff ffffffff ffffffff',\n           'ffffffff ffffffff fffffffe ffffffff',\n           'ffffffff ffffffff ffffffff ffffffff',\n           'ffffffff fffffffe'],\n          ['bec92fd0 6da2acf2 b4e261e8 7cef0d34',\n           '22e75c18 3c589857 b71924e5 73c2f9ce',\n           'e18da5f2 466e2f39 3c2eedf0 f105a60a',\n           'b40c717d 4f1e1fd7']\n        ],\n        [\n          ['ffffffff ffffffff ffffffff ffffffff',\n           'ffffffff ffffffff fffffffe ffffffff',\n           'ffffffff ffffffff ffffffff ffffffff',\n           'ffffffff fffffffe'],\n          ['4136d02f 925d530d 4b1d9e17 8310f2cb',\n           'dd18a3e7 c3a767a8 48e6db19 8c3d0631',\n           '1e725a0d b991d0c6 c3d1120f 0efa59f5',\n           '4bf38e82 b0e1e028']\n        ]\n      ]\n    });\n  }\n}\n\n/**\n * ED25519\n * https://tools.ietf.org/html/rfc8032#section-5.1\n */\n\nclass ED25519 extends EdwardsCurve {\n  constructor(pre) {\n    super({\n      id: 'ED25519',\n      ossl: 'ED25519',\n      type: 'edwards',\n      endian: 'le',\n      hash: 'SHA512',\n      prefix: 'SigEd25519 no Ed25519 collisions',\n      context: false,\n      prime: 'p25519',\n      // 2^255 - 19 (= 5 mod 8)\n      p: ['7fffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff ffffffff ffffffed'],\n      a: '-1',\n      // -121665 / 121666 mod p\n      d: ['52036cee 2b6ffe73 8cc74079 7779e898',\n          '00700a4d 4141d8ab 75eb4dca 135978a3'],\n      n: ['10000000 00000000 00000000 00000000',\n          '14def9de a2f79cd6 5812631a 5cf5d3ed'],\n      h: '8',\n      // Elligator 2\n      z: '2',\n      g: [\n        ['216936d3 cd6e53fe c0a4e231 fdd6dc5c',\n         '692cc760 9525a7b2 c9562d60 8f25d51a'],\n        // 4/5\n        ['66666666 66666666 66666666 66666666',\n         '66666666 66666666 66666666 66666658'],\n        pre\n      ],\n      torsion: [\n        [\n          ['00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000'],\n          ['00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000001']\n        ],\n        [\n          ['00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000'],\n          ['7fffffff ffffffff ffffffff ffffffff',\n           'ffffffff ffffffff ffffffff ffffffec']\n        ],\n        [\n          ['2b832480 4fc1df0b 2b4d0099 3dfbd7a7',\n           '2f431806 ad2fe478 c4ee1b27 4a0ea0b0'],\n          ['00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000']\n        ],\n        [\n          ['547cdb7f b03e20f4 d4b2ff66 c2042858',\n           'd0bce7f9 52d01b87 3b11e4d8 b5f15f3d'],\n          ['00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000']\n        ],\n        [\n          ['1fd5b9a0 06394a28 e9339932 38de4abb',\n           '5c193c70 13e5e238 dea14646 c545d14a'],\n          ['05fc536d 880238b1 3933c6d3 05acdfd5',\n           'f098eff2 89f4c345 b027b2c2 8f95e826']\n        ],\n        [\n          ['602a465f f9c6b5d7 16cc66cd c721b544',\n           'a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3'],\n          ['05fc536d 880238b1 3933c6d3 05acdfd5',\n           'f098eff2 89f4c345 b027b2c2 8f95e826']\n        ],\n        [\n          ['1fd5b9a0 06394a28 e9339932 38de4abb',\n           '5c193c70 13e5e238 dea14646 c545d14a'],\n          ['7a03ac92 77fdc74e c6cc392c fa53202a',\n           '0f67100d 760b3cba 4fd84d3d 706a17c7']\n        ],\n        [\n          ['602a465f f9c6b5d7 16cc66cd c721b544',\n           'a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3'],\n          ['7a03ac92 77fdc74e c6cc392c fa53202a',\n           '0f67100d 760b3cba 4fd84d3d 706a17c7']\n        ]\n      ]\n    });\n  }\n}\n\n/**\n * ISO448\n * https://tools.ietf.org/html/rfc7748#section-4.2\n * https://git.zx2c4.com/goldilocks/tree/_aux/ristretto/ristretto.sage#n658\n */\n\nclass ISO448 extends EdwardsCurve {\n  constructor(pre) {\n    super({\n      id: 'ISO448',\n      ossl: null,\n      type: 'edwards',\n      endian: 'le',\n      hash: 'SHAKE256',\n      prefix: 'SigEd448',\n      context: true,\n      prime: 'p448',\n      // 2^448 - 2^224 - 1 (= 3 mod 4)\n      p: ['ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff fffffffe ffffffff',\n          'ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff'],\n      a: '1',\n      // 39082 / 39081 mod p\n      d: ['d78b4bdc 7f0daf19 f24f38c2 9373a2cc',\n          'ad461572 42a50f37 809b1da3 412a12e7',\n          '9ccc9c81 264cfe9a d0809970 58fb61c4',\n          '243cc32d baa156b9'],\n      n: ['3fffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff ffffffff 7cca23e9',\n          'c44edb49 aed63690 216cc272 8dc58f55',\n          '2378c292 ab5844f3'],\n      h: '4',\n      // Elligator 2\n      z: '-1',\n      g: [\n        ['79a70b2b 70400553 ae7c9df4 16c792c6',\n         '1128751a c9296924 0c25a07d 728bdc93',\n         'e21f7787 ed697224 9de732f3 8496cd11',\n         '69871309 3e9c04fc'],\n        // Note: the RFC has this wrong.\n        ['7fffffff ffffffff ffffffff ffffffff',\n         'ffffffff ffffffff ffffffff 80000000',\n         '00000000 00000000 00000000 00000000',\n         '00000000 00000001'],\n        pre\n      ],\n      torsion: [\n        [\n          ['00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000000'],\n          ['00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000001']\n        ],\n        [\n          ['00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000000'],\n          ['ffffffff ffffffff ffffffff ffffffff',\n           'ffffffff ffffffff fffffffe ffffffff',\n           'ffffffff ffffffff ffffffff ffffffff',\n           'ffffffff fffffffe']\n        ],\n        [\n          ['00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000001'],\n          ['00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000000']\n        ],\n        [\n          ['ffffffff ffffffff ffffffff ffffffff',\n           'ffffffff ffffffff fffffffe ffffffff',\n           'ffffffff ffffffff ffffffff ffffffff',\n           'ffffffff fffffffe'],\n          ['00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000000']\n        ]\n      ]\n    });\n  }\n}\n\n/**\n * ED448\n * https://tools.ietf.org/html/rfc8032#section-5.2\n */\n\nclass ED448 extends EdwardsCurve {\n  constructor(pre) {\n    super({\n      id: 'ED448',\n      ossl: 'ED448',\n      type: 'edwards',\n      endian: 'le',\n      hash: 'SHAKE256',\n      prefix: 'SigEd448',\n      context: true,\n      prime: 'p448',\n      // 2^448 - 2^224 - 1 (= 3 mod 4)\n      p: ['ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff fffffffe ffffffff',\n          'ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff'],\n      a: '1',\n      // -39081 mod p\n      d: ['ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff fffffffe ffffffff',\n          'ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffff6756'],\n      n: ['3fffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff ffffffff 7cca23e9',\n          'c44edb49 aed63690 216cc272 8dc58f55',\n          '2378c292 ab5844f3'],\n      h: '4',\n      // Elligator 2\n      z: '-1',\n      g: [\n        ['4f1970c6 6bed0ded 221d15a6 22bf36da',\n         '9e146570 470f1767 ea6de324 a3d3a464',\n         '12ae1af7 2ab66511 433b80e1 8b00938e',\n         '2626a82b c70cc05e'],\n        ['693f4671 6eb6bc24 88762037 56c9c762',\n         '4bea7373 6ca39840 87789c1e 05a0c2d7',\n         '3ad3ff1c e67c39c4 fdbd132c 4ed7c8ad',\n         '9808795b f230fa14'],\n        pre\n      ],\n      torsion: [\n        [\n          ['00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000000'],\n          ['00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000001']\n        ],\n        [\n          ['00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000000'],\n          ['ffffffff ffffffff ffffffff ffffffff',\n           'ffffffff ffffffff fffffffe ffffffff',\n           'ffffffff ffffffff ffffffff ffffffff',\n           'ffffffff fffffffe']\n        ],\n        [\n          ['00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000001'],\n          ['00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000000']\n        ],\n        [\n          ['ffffffff ffffffff ffffffff ffffffff',\n           'ffffffff ffffffff fffffffe ffffffff',\n           'ffffffff ffffffff ffffffff ffffffff',\n           'ffffffff fffffffe'],\n          ['00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000000 00000000 00000000',\n           '00000000 00000000']\n        ]\n      ]\n    });\n  }\n}\n\n/*\n * Curve Registry\n */\n\nconst curves = {\n  __proto__: null,\n  P192,\n  P224,\n  P256,\n  P384,\n  P521,\n  SECP256K1,\n  BRAINPOOLP256,\n  BRAINPOOLP384,\n  BRAINPOOLP512,\n  X25519,\n  X448,\n  MONT448,\n  ED25519,\n  ISO448,\n  ED448\n};\n\nconst cache = {\n  __proto__: null,\n  P192: null,\n  P224: null,\n  P256: null,\n  P384: null,\n  P521: null,\n  SECP256K1: null,\n  BRAINPOOLP256: null,\n  BRAINPOOLP384: null,\n  BRAINPOOLP512: null,\n  X25519: null,\n  X448: null,\n  MONT448: null,\n  ED25519: null,\n  ISO448: null,\n  ED448: null\n};\n\nfunction curve(name, ...args) {\n  assert(typeof name === 'string');\n\n  const key = name.toUpperCase();\n\n  let curve = cache[key];\n\n  if (!curve) {\n    const Curve = curves[key];\n\n    if (!Curve)\n      throw new Error(`Curve not found: \"${name}\".`);\n\n    curve = new Curve(...args);\n    cache[key] = curve;\n  }\n\n  return curve;\n}\n\nfunction register(name, Curve) {\n  assert(typeof name === 'string');\n  assert(typeof Curve === 'function');\n\n  const key = name.toUpperCase();\n\n  if (curves[key])\n    throw new Error(`Curve already registered: \"${name}\".`);\n\n  curves[key] = Curve;\n  cache[key] = null;\n}\n\n/*\n * Scalar Recoding\n */\n\nfunction getNAF(k, width, max) {\n  // Computing the width-w NAF of a positive integer.\n  //\n  // [GECC] Algorithm 3.35, Page 100, Section 3.3.\n  //\n  // The above document describes a rather abstract\n  // method of recoding. The more optimal method\n  // below was ported from libsecp256k1.\n  assert(k instanceof BN);\n  assert(!k.red);\n  assert((width >>> 0) === width);\n  assert((max >>> 0) === max);\n\n  const naf = new Array(max);\n  const bits = k.bitLength() + 1;\n  const sign = k.sign() | 1;\n\n  assert(bits <= max);\n\n  for (let i = 0; i < max; i++)\n    naf[i] = 0;\n\n  let i = 0;\n  let carry = 0;\n  let word;\n\n  while (i < bits) {\n    if (k.bit(i) === carry) {\n      i += 1;\n      continue;\n    }\n\n    word = k.bits(i, width) + carry;\n    carry = (word >> (width - 1)) & 1;\n    word -= carry << width;\n\n    naf[i] = sign * word;\n\n    i += width;\n  }\n\n  assert(carry === 0);\n\n  return naf;\n}\n\nfunction getFixedNAF(k, width, max, step) {\n  assert((step >>> 0) === step);\n\n  // Recode to NAF.\n  const naf = getNAF(k, width, max);\n\n  // Translate into more windowed form.\n  const len = Math.ceil(naf.length / step);\n  const repr = new Array(len);\n\n  let i = 0;\n\n  for (let j = 0; j < naf.length; j += step) {\n    let nafW = 0;\n\n    for (let k = j + step - 1; k >= j; k--)\n      nafW = (nafW << 1) + naf[k];\n\n    repr[i++] = nafW;\n  }\n\n  assert(i === len);\n\n  return repr;\n}\n\nfunction getJSF(k1, k2, max) {\n  // Joint sparse form.\n  //\n  // [GECC] Algorithm 3.50, Page 111, Section 3.3.\n  assert(k1 instanceof BN);\n  assert(k2 instanceof BN);\n  assert(!k1.red);\n  assert(!k2.red);\n  assert((max >>> 0) === max);\n\n  const jsf = [new Array(max), new Array(max)];\n  const bits = Math.max(k1.bitLength(), k2.bitLength()) + 1;\n  const s1 = k1.sign() | 1;\n  const s2 = k2.sign() | 1;\n\n  assert(bits <= max);\n\n  let d1 = 0;\n  let d2 = 0;\n\n  for (let i = 0; i < bits; i++) {\n    const b1 = k1.bits(i, 3);\n    const b2 = k2.bits(i, 3);\n\n    // First phase.\n    let m14 = ((b1 & 3) + d1) & 3;\n    let m24 = ((b2 & 3) + d2) & 3;\n    let u1 = 0;\n    let u2 = 0;\n\n    if (m14 === 3)\n      m14 = -1;\n\n    if (m24 === 3)\n      m24 = -1;\n\n    if (m14 & 1) {\n      const m8 = ((b1 & 7) + d1) & 7;\n\n      if ((m8 === 3 || m8 === 5) && m24 === 2)\n        u1 = -m14;\n      else\n        u1 = m14;\n    }\n\n    if (m24 & 1) {\n      const m8 = ((b2 & 7) + d2) & 7;\n\n      if ((m8 === 3 || m8 === 5) && m14 === 2)\n        u2 = -m24;\n      else\n        u2 = m24;\n    }\n\n    jsf[0][i] = u1 * s1;\n    jsf[1][i] = u2 * s2;\n\n    // Second phase.\n    if (2 * d1 === 1 + u1)\n      d1 = 1 - d1;\n\n    if (2 * d2 === 1 + u2)\n      d2 = 1 - d2;\n  }\n\n  for (let i = bits; i < max; i++) {\n    jsf[0][i] = 0;\n    jsf[1][i] = 0;\n  }\n\n  return jsf;\n}\n\nfunction getJNAF(c1, c2, max) {\n  const jsf = getJSF(c1, c2, max);\n  const naf = new Array(max);\n\n  // JSF -> NAF conversion.\n  for (let i = 0; i < max; i++) {\n    const ja = jsf[0][i];\n    const jb = jsf[1][i];\n\n    naf[i] = jsfIndex[(ja + 1) * 3 + (jb + 1)];\n  }\n\n  return naf;\n}\n\n/*\n * Helpers\n */\n\nfunction assert(val, msg) {\n  if (!val) {\n    const err = new Error(msg || 'Assertion failed');\n\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, assert);\n\n    throw err;\n  }\n}\n\nfunction wrapErrors(fn) {\n  assert(typeof fn === 'function');\n\n  try {\n    return fn();\n  } catch (e) {\n    if (e.message === 'X is not a square mod P.'\n        || e.message === 'Not invertible.') {\n      throw new Error('Invalid point.');\n    }\n    throw e;\n  }\n}\n\nfunction mod(x, y) {\n  // Euclidean modulo.\n  let r = x % y;\n\n  if (r < 0) {\n    if (y < 0)\n      r -= y;\n    else\n      r += y;\n  }\n\n  return r;\n}\n\nfunction cubeRoot(x) {\n  assert(x instanceof BN);\n  assert(x.red);\n\n  const p = x.red.m;\n\n  if (p.cmpn(3) <= 0)\n    return x.clone();\n\n  // p = 2 mod 3\n  if (p.modrn(3) === 2) {\n    // e = (2 * p - 1) / 3\n    const e = p.ushln(1).isubn(1).idivn(3);\n    return x.redPow(e);\n  }\n\n  const mod9 = p.modrn(9);\n\n  // p = 4 mod 9\n  if (mod9 === 4) {\n    // e = (2 * p + 1) / 9\n    const e = p.ushln(1).iaddn(1).idivn(9);\n    const r = x.redPow(e);\n    const c = r.redSqr().redMul(r);\n\n    if (!c.eq(x))\n      throw new Error('X is not a cube mod P.');\n\n    return r;\n  }\n\n  // p = 7 mod 9\n  if (mod9 === 7) {\n    // e = (p + 2) / 9\n    const e = p.addn(2).idivn(9);\n    const r = x.redPow(e);\n    const c = r.redSqr().redMul(r);\n\n    if (!c.eq(x))\n      throw new Error('X is not a cube mod P.');\n\n    return r;\n  }\n\n  throw new Error('Not implemented.');\n}\n\nfunction cubeRoots(x) {\n  const r0 = cubeRoot(x);\n\n  // p = 1 mod 3\n  if (x.red.m.modrn(3) === 1) {\n    // Multiply by roots of unity to find other roots.\n    const two = new BN(2).toRed(x.red);\n    const three = new BN(3).toRed(x.red);\n    const i2 = two.redInvert();\n    const s1 = three.redNeg().redSqrt().redMul(i2);\n    const s2 = s1.redNeg();\n    const u1 = s1.redSub(i2);\n    const u2 = s2.redSub(i2);\n    const r1 = r0.redMul(u1);\n    const r2 = r0.redMul(u2);\n\n    return [r0, r1, r2];\n  }\n\n  // p = 2 mod 3 guarantees 1 cube root per element.\n  return [r0];\n}\n\nfunction uncube(x) {\n  // Find a cube root which is also a quadratic residue.\n  for (const root of cubeRoots(x)) {\n    if (root.redJacobi() >= 0)\n      return root;\n  }\n\n  throw new Error('X^(1/3) is not a square mod P.');\n}\n\nfunction randomInt(rng) {\n  return BN.randomBits(rng, 32).toNumber();\n}\n\nfunction memoize(method, self) {\n  const cache = new WeakMap();\n\n  return function memoized(curve, invert) {\n    const i = invert & 1;\n    const item = cache.get(curve);\n\n    if (item && item[i] !== null)\n      return item[i];\n\n    const result = method.call(self, curve, invert);\n\n    if (!cache.has(curve))\n      cache.set(curve, [null, null]);\n\n    cache.get(curve)[i] = result;\n\n    return result;\n  };\n}\n\nfunction toPretty(x, size) {\n  assert(x instanceof BN);\n  assert((size >>> 0) === size);\n\n  if (size & 7)\n    size += 8 - (size & 7);\n\n  const str = x.toString(16, size);\n  const chunks = [];\n  const out = [];\n\n  assert((str.length & 7) === 0);\n\n  for (let i = 0; i < str.length; i += 8)\n    chunks.push(str.slice(i, i + 8));\n\n  for (let i = 0; i < chunks.length; i += 4)\n    out.push(chunks.slice(i, i + 4).join(' '));\n\n  return out;\n}\n\n/*\n * Expose\n */\n\nexports.Curve = Curve;\nexports.Point = Point;\nexports.ShortCurve = ShortCurve;\nexports.ShortPoint = ShortPoint;\nexports.JPoint = JPoint;\nexports.MontCurve = MontCurve;\nexports.MontPoint = MontPoint;\nexports.XPoint = XPoint;\nexports.EdwardsCurve = EdwardsCurve;\nexports.EdwardsPoint = EdwardsPoint;\nexports.curves = curves;\nexports.curve = curve;\nexports.register = register;\n"],"names":["custom","__webpack_require__","BN","types","AFFINE","JACOBIAN","PROJECTIVE","EXTENDED","jsfIndex","uid","Curve","constructor","Point","type","conf","id","ossl","endian","hash","prefix","context","prime","p","red","fieldSize","fieldBits","adjustedSize","signBit","mask","n","h","q","z","g","nh","scalarSize","scalarBits","zero","one","two","three","four","i2","i3","i4","i6","torsion","endo","hi","_init","assert","Red","Array","isArray","Buffer","from","fromJSON","mont","precompute","byteLength","bitLength","mul","toRed","ushrn","redInvert","redSqr","redMul","word","i","length","point","_scale","memoize","isIsomorphic","isIsogenous","sign","isOdd","cmpn","_finalize","pointFromJSON","_findTorsion","isZero","x","redNeg","out","set","Set","len","redIAdd","pointFromX","clone","e","isInfinity","normalize","neg","key","has","push","add","sort","a","b","cmp","_fixedMul","k","pre","windows","width","points","_getWindows","size","bits","steps","acc","jpoint","isNeg","_fixedNafMul","doubles","step","_getDoubles","naf","getFixedNAF","max","getNAF","Math","ceil","repr","j","nafW","I","sub","_wnafMul","w","_safeNAF","dbl","_wnafMulAdd","coeffs","wnd","coeff","ppoint","pcoeff","_getNAF","_getJNAF","getJNAF","c1","c2","jsf","getJSF","k1","k2","s1","s2","d1","d2","b1","b2","m14","m24","u1","u2","m8","ja","jb","nafw","_endoWnafMulAdd","curve","invert","eq","_scaleShort","_scaleMont","_scaleEdwards","isElliptic","jinv","isComplete","rng","scalar","num","base","imod","field","cast","forceRed","y","xpoint","cpoint","xx","xz","yy","yz","solveX2","solveX","redSqrt","solveY2","solveY","validate","pointFromY","pointFromShort","pointFromMont","pointFromEdwards","pointFromUniform","u","pointToUniform","pointFromHash","bytes","pake","isBuffer","slice","decodeUniform","p1","p2","p3","mulH","pointToHash","subgroup","p0","randomField","hint","randomInt","message","encodeUniform","concat","randomScalar","random","randomPoint","mulAll","jmulAll","imulH","iushln","imuln","normalizeAll","zi","invertAll","scale","affinizeAll","clamp","top","lsb","msb","splitHash","off","encodeField","encode","decodeField","decode","encodeAdjusted","decodeAdjusted","encodeScalar","decodeScalar","encodeClamped","decodeClamped","clamped","fromRed","iumaskn","encodePoint","compact","decodePoint","encodeX","decodeX","decodeEven","decodeSquare","toShort","toMont","b0","toEdwards","a0","pointToJSON","toJSON","json","toString","redIsHigh","isub","undefined","d","s","c","toJ","NAF","odds","wnds","dblp","Windows","power","dbls","Doubles","_getBeta","_getBlinding","blinding","blind","unblind","Blinding","_hasWindows","_hasDoubles","_blind","t","r","iadd","randomize","Precomp","beta","pow","diffAddDbl","getX","getY","isOrder2","isEven","isSquare","eqX","eqR","isSmall","jmulH","hasTorsion","jmul","order","iaddn","muln","jmuln","mulBlind","jmulBlind","mulAdd","jmulAdd","div","jdiv","divn","jdivn","divH","jdivH","toP","toX","ShortCurve","ShortPoint","ai","zeroA","threeA","redN","pmodn","highOrder","smallGap","Endo","_getEndomorphism","mod","_isomorphism","curveA","curveB","odd","u6","customB","redDiv","uncube","redJacobi","u4","customA","redINeg","redIsOdd","_short","_mont","_findRS","redMuln","MontCurve","_edwards","r3","redAdd","redSub","EdwardsCurve","r2","_scale0","u3","_scale1","nx","a3","bi","ny","a5","d5","dma","d5a","da5","ypz","ymz","redIMuln","index","lambda","modrn","_getEndoRoots","l1","l2","basis","_getEndoBasis","_getEndoPrecomp","r1","a2","rl","tl","rl1","tl1","rl2","tl2","_egcdSqrt","lhs","sqr","rhs","Vector","sqrtn","v","x1","y1","x2","y2","quo","g1","g2","v1","v2","align","shift","ushln","divRound","ucmp","_endoSplit","q1","ineg","q2","_endoBeta","npoints","ncoeffs","_sswu","z2","ba","bza","t0","t1","alpha","redIsSquare","_sswui","a2x2","abx2","b23","axb","redISub","n0","n1","d0","redDivSqrt","_svdwf","gz","z3","u2t1","t2","t3","t4","x3","y3","_svdw","_svdwi","z4","gz2","x2z","xz2","c0","t5","n2","n3","x0","JPoint","cubeRoots","inf","coords","ad6","MontPoint","EdwardsPoint","wrapErrors","xb","map","comb","l","m","redIsEven","alloc","copy","form","toPretty","zOne","z6","aa","nz","_mixedAdd","_add","_addJA","_addJJ","z1z1","z2z2","hh","hhh","_dbl0","_dbl3","_dblJ","zz","xb2","f","delta","gamma","xmdelta","xpdelta","beta4","beta8","gamma28","zz1","zz2","zzz1","zzz2","inf1","inf2","rx","rn","a24","b3","wa","wb","swap","_solveY0","_elligator2","inject","y0","_invert2","redPown","XPoint","by2","nv","uu","uz","vv","vz","m1","m2","ax2","bb","da","cb","x5","z5","x4","bit","si","smi","twisted","oneA","mOneA","smallD","alt","curveD","d3","ad14","a2d","ad2","redDivn","apd","amd","_mulA","_mulD","_elligator1","ci","ci2","cm1","u5","f0","f1","f2","X","Y","X1","rX","X12","_invert1","nn","nr1","w2","YY","X2","Z","tt","tz","Boolean","_alt","ad","amd4","dxy","xy","d24","x6","x12","nt","u0","_check","_addM1","_addA","xyxy","_dbl","setn","testn","func","item","curves","__proto__","P192","P224","P256","P384","P521","SECP256K1","BRAINPOOLP256","BRAINPOOLP384","BRAINPOOLP512","X25519","X448","MONT448","ED25519","ISO448","ED448","cache","carry","val","msg","err","Error","captureStackTrace","fn","r0","cubeRoot","isubn","idivn","redPow","mod9","addn","root","randomBits","toNumber","method","self","WeakMap","get","result","call","str","chunks","join","exports","name","args","toUpperCase","register"],"sourceRoot":""}