"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[5983],{6873:function(t,e){Object.defineProperty(e,"__esModule",{value:!0}),e.add5L=e.add5H=e.add4H=e.add4L=e.add3H=e.add3L=e.rotlBL=e.rotlBH=e.rotlSL=e.rotlSH=e.rotr32L=e.rotr32H=e.rotrBL=e.rotrBH=e.rotrSL=e.rotrSH=e.shrSL=e.shrSH=e.toBig=void 0,e.fromBig=fromBig,e.split=split,e.add=add;let r=BigInt(4294967296-1),n=BigInt(32);function fromBig(t,e=!1){return e?{h:Number(t&r),l:Number(t>>n&r)}:{h:0|Number(t>>n&r),l:0|Number(t&r)}}function split(t,e=!1){let r=new Uint32Array(t.length),n=new Uint32Array(t.length);for(let o=0;o<t.length;o++){let{h:i,l:s}=fromBig(t[o],e);[r[o],n[o]]=[i,s]}return[r,n]}let toBig=(t,e)=>BigInt(t>>>0)<<n|BigInt(e>>>0);e.toBig=toBig;let shrSH=(t,e,r)=>t>>>r;e.shrSH=shrSH;let shrSL=(t,e,r)=>t<<32-r|e>>>r;e.shrSL=shrSL;let rotrSH=(t,e,r)=>t>>>r|e<<32-r;e.rotrSH=rotrSH;let rotrSL=(t,e,r)=>t<<32-r|e>>>r;e.rotrSL=rotrSL;let rotrBH=(t,e,r)=>t<<64-r|e>>>r-32;e.rotrBH=rotrBH;let rotrBL=(t,e,r)=>t>>>r-32|e<<64-r;e.rotrBL=rotrBL;let rotr32H=(t,e)=>e;e.rotr32H=rotr32H;let rotr32L=(t,e)=>t;e.rotr32L=rotr32L;let rotlSH=(t,e,r)=>t<<r|e>>>32-r;e.rotlSH=rotlSH;let rotlSL=(t,e,r)=>e<<r|t>>>32-r;e.rotlSL=rotlSL;let rotlBH=(t,e,r)=>e<<r-32|t>>>64-r;e.rotlBH=rotlBH;let rotlBL=(t,e,r)=>t<<r-32|e>>>64-r;function add(t,e,r,n){let o=(e>>>0)+(n>>>0);return{h:t+r+(o/4294967296|0)|0,l:0|o}}e.rotlBL=rotlBL;let add3L=(t,e,r)=>(t>>>0)+(e>>>0)+(r>>>0);e.add3L=add3L;let add3H=(t,e,r,n)=>e+r+n+(t/4294967296|0)|0;e.add3H=add3H;let add4L=(t,e,r,n)=>(t>>>0)+(e>>>0)+(r>>>0)+(n>>>0);e.add4L=add4L;let add4H=(t,e,r,n,o)=>e+r+n+o+(t/4294967296|0)|0;e.add4H=add4H;let add5L=(t,e,r,n,o)=>(t>>>0)+(e>>>0)+(r>>>0)+(n>>>0)+(o>>>0);e.add5L=add5L;let add5H=(t,e,r,n,o,i)=>e+r+n+o+i+(t/4294967296|0)|0;e.add5H=add5H,e.default={fromBig,split,toBig,shrSH,shrSL,rotrSH,rotrSL,rotrBH,rotrBL,rotr32H,rotr32L,rotlSH,rotlSL,rotlBH,rotlBL,add,add3L,add3H,add4L,add4H,add5H,add5L}},85426:function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.shake256=e.shake128=e.keccak_512=e.keccak_384=e.keccak_256=e.keccak_224=e.sha3_512=e.sha3_384=e.sha3_256=e.sha3_224=e.Keccak=void 0,e.keccakP=keccakP;let n=r(27320),o=r(6873),i=r(98089),s=[],a=[],l=[],u=BigInt(0),f=BigInt(1),d=BigInt(2),c=BigInt(7),y=BigInt(256),p=BigInt(113);for(let t=0,e=f,r=1,n=0;t<24;t++){[r,n]=[n,(2*r+3*n)%5],s.push(2*(5*n+r)),a.push((t+1)*(t+2)/2%64);let o=u;for(let t=0;t<7;t++)(e=(e<<f^(e>>c)*p)%y)&d&&(o^=f<<(f<<BigInt(t))-f);l.push(o)}let[g,b]=(0,o.split)(l,!0),rotlH=(t,e,r)=>r>32?(0,o.rotlBH)(t,e,r):(0,o.rotlSH)(t,e,r),rotlL=(t,e,r)=>r>32?(0,o.rotlBL)(t,e,r):(0,o.rotlSL)(t,e,r);function keccakP(t,e=24){let r=new Uint32Array(10);for(let n=24-e;n<24;n++){for(let e=0;e<10;e++)r[e]=t[e]^t[e+10]^t[e+20]^t[e+30]^t[e+40];for(let e=0;e<10;e+=2){let n=(e+8)%10,o=(e+2)%10,i=r[o],s=r[o+1],a=rotlH(i,s,1)^r[n],l=rotlL(i,s,1)^r[n+1];for(let r=0;r<50;r+=10)t[e+r]^=a,t[e+r+1]^=l}let e=t[2],o=t[3];for(let r=0;r<24;r++){let n=a[r],i=rotlH(e,o,n),l=rotlL(e,o,n),u=s[r];e=t[u],o=t[u+1],t[u]=i,t[u+1]=l}for(let e=0;e<50;e+=10){for(let n=0;n<10;n++)r[n]=t[e+n];for(let n=0;n<10;n++)t[e+n]^=~r[(n+2)%10]&r[(n+4)%10]}t[0]^=g[n],t[1]^=b[n]}r.fill(0)}let Keccak=class Keccak extends i.Hash{constructor(t,e,r,o=!1,s=24){if(super(),this.blockLen=t,this.suffix=e,this.outputLen=r,this.enableXOF=o,this.rounds=s,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,(0,n.anumber)(r),0>=this.blockLen||this.blockLen>=200)throw Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=(0,i.u32)(this.state)}keccak(){i.isLE||(0,i.byteSwap32)(this.state32),keccakP(this.state32,this.rounds),i.isLE||(0,i.byteSwap32)(this.state32),this.posOut=0,this.pos=0}update(t){(0,n.aexists)(this);let{blockLen:e,state:r}=this;t=(0,i.toBytes)(t);let o=t.length;for(let n=0;n<o;){let i=Math.min(e-this.pos,o-n);for(let e=0;e<i;e++)r[this.pos++]^=t[n++];this.pos===e&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;let{state:t,suffix:e,pos:r,blockLen:n}=this;t[r]^=e,(128&e)!=0&&r===n-1&&this.keccak(),t[n-1]^=128,this.keccak()}writeInto(t){(0,n.aexists)(this,!1),(0,n.abytes)(t),this.finish();let e=this.state,{blockLen:r}=this;for(let n=0,o=t.length;n<o;){this.posOut>=r&&this.keccak();let i=Math.min(r-this.posOut,o-n);t.set(e.subarray(this.posOut,this.posOut+i),n),this.posOut+=i,n+=i}return t}xofInto(t){if(!this.enableXOF)throw Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return(0,n.anumber)(t),this.xofInto(new Uint8Array(t))}digestInto(t){if((0,n.aoutput)(t,this),this.finished)throw Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){let{blockLen:e,suffix:r,outputLen:n,rounds:o,enableXOF:i}=this;return t||(t=new Keccak(e,r,n,i,o)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=o,t.suffix=r,t.outputLen=n,t.enableXOF=i,t.destroyed=this.destroyed,t}};e.Keccak=Keccak;let gen=(t,e,r)=>(0,i.wrapConstructor)(()=>new Keccak(e,t,r));e.sha3_224=gen(6,144,28),e.sha3_256=gen(6,136,32),e.sha3_384=gen(6,104,48),e.sha3_512=gen(6,72,64),e.keccak_224=gen(1,144,28),e.keccak_256=gen(1,136,32),e.keccak_384=gen(1,104,48),e.keccak_512=gen(1,72,64);let genShake=(t,e,r)=>(0,i.wrapXOFConstructorWithOpts)((n={})=>new Keccak(e,t,void 0===n.dkLen?r:n.dkLen,!0));e.shake128=genShake(31,168,16),e.shake256=genShake(31,136,32)},82192:function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.keccak512=e.keccak384=e.keccak256=e.keccak224=void 0;let n=r(84589),o=r(58040);e.keccak224=(0,o.wrapHash)(n.keccak_224),e.keccak256=(()=>{let t=(0,o.wrapHash)(n.keccak_256);return t.create=n.keccak_256.create,t})(),e.keccak384=(0,o.wrapHash)(n.keccak_384),e.keccak512=(0,o.wrapHash)(n.keccak_512)},37270:function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.getHash=getHash,e.createCurve=function(t,e){let create=e=>(0,i.weierstrass)({...t,...getHash(e)});return Object.freeze({...create(e),create})};/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */let n=r(45238),o=r(23037),i=r(70409);function getHash(t){return{hash:t,hmac:(e,...r)=>(0,n.hmac)(t,e,(0,o.concatBytes)(...r)),randomBytes:o.randomBytes}}},46061:function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.wNAF=function(t,e){let constTimeNegate=(t,e)=>{let r=e.negate();return t?r:e},opts=t=>({windows:Math.ceil(e/t)+1,windowSize:2**(t-1)});return{constTimeNegate,unsafeLadder(e,r){let n=t.ZERO,o=e;for(;r>i;)r&s&&(n=n.add(o)),o=o.double(),r>>=s;return n},precomputeWindow(t,e){let{windows:r,windowSize:n}=opts(e),o=[],i=t,s=i;for(let t=0;t<r;t++){s=i,o.push(s);for(let t=1;t<n;t++)s=s.add(i),o.push(s);i=s.double()}return o},wNAF(e,r,n){let{windows:o,windowSize:i}=opts(e),a=t.ZERO,l=t.BASE,u=BigInt(2**e-1),f=2**e,d=BigInt(e);for(let t=0;t<o;t++){let e=t*i,o=Number(n&u);n>>=d,o>i&&(o-=f,n+=s);let c=e+Math.abs(o)-1,y=t%2!=0,p=o<0;0===o?l=l.add(constTimeNegate(y,r[e])):a=a.add(constTimeNegate(p,r[c]))}return{p:a,f:l}},wNAFCached(t,e,r,n){let o=t._WINDOW_SIZE||1,i=e.get(t);return i||(i=this.precomputeWindow(t,o),1!==o&&e.set(t,n(i))),this.wNAF(o,i,r)}}},e.validateBasic=function(t){return(0,n.validateField)(t.Fp),(0,o.validateObject)(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...(0,n.nLength)(t.n,t.nBitLength),...t,p:t.Fp.ORDER})};/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */let n=r(66998),o=r(4870),i=BigInt(0),s=BigInt(1)},31315:function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.expand_message_xmd=expand_message_xmd,e.expand_message_xof=expand_message_xof,e.hash_to_field=hash_to_field,e.isogenyMap=function(t,e){let r=e.map(t=>Array.from(t).reverse());return(e,n)=>{let[o,i,s,a]=r.map(r=>r.reduce((r,n)=>t.add(t.mul(r,e),n)));return{x:e=t.div(o,i),y:n=t.mul(n,t.div(s,a))}}},e.createHasher=function(t,e,r){if("function"!=typeof e)throw Error("mapToCurve() must be defined");return{hashToCurve(n,o){let i=hash_to_field(n,2,{...r,DST:r.DST,...o}),s=t.fromAffine(e(i[0])),a=t.fromAffine(e(i[1])),l=s.add(a).clearCofactor();return l.assertValidity(),l},encodeToCurve(n,o){let i=hash_to_field(n,1,{...r,DST:r.encodeDST,...o}),s=t.fromAffine(e(i[0])).clearCofactor();return s.assertValidity(),s},mapToCurve(r){if(!Array.isArray(r))throw Error("mapToCurve: expected array of bigints");for(let t of r)if("bigint"!=typeof t)throw Error(`mapToCurve: expected array of bigints, got ${t} in array`);let n=t.fromAffine(e(r)).clearCofactor();return n.assertValidity(),n}}};let n=r(66998),o=r(4870),i=o.bytesToNumberBE;function i2osp(t,e){if(t<0||t>=1<<8*e)throw Error(`bad I2OSP call: value=${t} length=${e}`);let r=Array.from({length:e}).fill(0);for(let n=e-1;n>=0;n--)r[n]=255&t,t>>>=8;return new Uint8Array(r)}function anum(t){if(!Number.isSafeInteger(t))throw Error("number expected")}function expand_message_xmd(t,e,r,n){(0,o.abytes)(t),(0,o.abytes)(e),anum(r),e.length>255&&(e=n((0,o.concatBytes)((0,o.utf8ToBytes)("H2C-OVERSIZE-DST-"),e)));let{outputLen:i,blockLen:s}=n,a=Math.ceil(r/i);if(a>255)throw Error("Invalid xmd length");let l=(0,o.concatBytes)(e,i2osp(e.length,1)),u=i2osp(0,s),f=i2osp(r,2),d=Array(a),c=n((0,o.concatBytes)(u,t,f,i2osp(0,1),l));d[0]=n((0,o.concatBytes)(c,i2osp(1,1),l));for(let t=1;t<=a;t++){let e=[function(t,e){let r=new Uint8Array(t.length);for(let n=0;n<t.length;n++)r[n]=t[n]^e[n];return r}(c,d[t-1]),i2osp(t+1,1),l];d[t]=n((0,o.concatBytes)(...e))}let y=(0,o.concatBytes)(...d);return y.slice(0,r)}function expand_message_xof(t,e,r,n,i){if((0,o.abytes)(t),(0,o.abytes)(e),anum(r),e.length>255&&(e=i.create({dkLen:Math.ceil(2*n/8)}).update((0,o.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(e).digest()),r>65535||e.length>255)throw Error("expand_message_xof: invalid lenInBytes");return i.create({dkLen:r}).update(t).update(i2osp(r,2)).update(e).update(i2osp(e.length,1)).digest()}function hash_to_field(t,e,r){let s;(0,o.validateObject)(r,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});let{p:a,k:l,m:u,hash:f,expand:d,DST:c}=r;(0,o.abytes)(t),anum(e);let y="string"==typeof c?(0,o.utf8ToBytes)(c):c,p=a.toString(2).length,g=Math.ceil((p+l)/8),b=e*u*g;if("xmd"===d)s=expand_message_xmd(t,y,b,f);else if("xof"===d)s=expand_message_xof(t,y,b,l,f);else if("_internal_pass"===d)s=t;else throw Error('expand must be "xmd" or "xof"');let m=Array(e);for(let t=0;t<e;t++){let e=Array(u);for(let r=0;r<u;r++){let o=g*(r+t*u),l=s.subarray(o,o+g);e[r]=(0,n.mod)(i(l),a)}m[t]=e}return m}},66998:function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.isNegativeLE=void 0,e.mod=mod,e.pow=pow,e.pow2=function(t,e,r){let n=t;for(;e-- >o;)n*=n,n%=r;return n},e.invert=invert,e.tonelliShanks=tonelliShanks,e.FpSqrt=FpSqrt,e.validateField=function(t){let e=d.reduce((t,e)=>(t[e]="function",t),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"});return(0,n.validateObject)(t,e)},e.FpPow=FpPow,e.FpInvertBatch=FpInvertBatch,e.FpDiv=function(t,e,r){return t.mul(e,"bigint"==typeof r?invert(r,t.ORDER):t.inv(r))},e.FpIsSquare=function(t){let e=(t.ORDER-i)/s;return r=>{let n=t.pow(r,e);return t.eql(n,t.ZERO)||t.eql(n,t.ONE)}},e.nLength=nLength,e.Field=function(t,e,r=!1,s={}){if(t<=o)throw Error(`Expected Field ORDER > 0, got ${t}`);let{nBitLength:a,nByteLength:l}=nLength(t,e);if(l>2048)throw Error("Field lengths over 2048 bytes are not supported");let u=FpSqrt(t),f=Object.freeze({ORDER:t,BITS:a,BYTES:l,MASK:(0,n.bitMask)(a),ZERO:o,ONE:i,create:e=>mod(e,t),isValid:e=>{if("bigint"!=typeof e)throw Error(`Invalid field element: expected bigint, got ${typeof e}`);return o<=e&&e<t},is0:t=>t===o,isOdd:t=>(t&i)===i,neg:e=>mod(-e,t),eql:(t,e)=>t===e,sqr:e=>mod(e*e,t),add:(e,r)=>mod(e+r,t),sub:(e,r)=>mod(e-r,t),mul:(e,r)=>mod(e*r,t),pow:(t,e)=>FpPow(f,t,e),div:(e,r)=>mod(e*invert(r,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>invert(e,t),sqrt:s.sqrt||(t=>u(f,t)),invertBatch:t=>FpInvertBatch(f,t),cmov:(t,e,r)=>r?e:t,toBytes:t=>r?(0,n.numberToBytesLE)(t,l):(0,n.numberToBytesBE)(t,l),fromBytes:t=>{if(t.length!==l)throw Error(`Fp.fromBytes: expected ${l}, got ${t.length}`);return r?(0,n.bytesToNumberLE)(t):(0,n.bytesToNumberBE)(t)}});return Object.freeze(f)},e.FpSqrtOdd=function(t,e){if(!t.isOdd)throw Error("Field doesn't have isOdd");let r=t.sqrt(e);return t.isOdd(r)?r:t.neg(r)},e.FpSqrtEven=function(t,e){if(!t.isOdd)throw Error("Field doesn't have isOdd");let r=t.sqrt(e);return t.isOdd(r)?t.neg(r):r},e.hashToPrivateScalar=function(t,e,r=!1){t=(0,n.ensureBytes)("privateHash",t);let o=t.length,s=nLength(e).nByteLength+8;if(s<24||o<s||o>1024)throw Error(`hashToPrivateScalar: expected ${s}-1024 bytes of input, got ${o}`);let a=r?(0,n.bytesToNumberLE)(t):(0,n.bytesToNumberBE)(t);return mod(a,e-i)+i},e.getFieldBytesLength=getFieldBytesLength,e.getMinHashLength=getMinHashLength,e.mapHashToField=function(t,e,r=!1){let o=t.length,s=getFieldBytesLength(e),a=getMinHashLength(e);if(o<16||o<a||o>1024)throw Error(`expected ${a}-1024 bytes of input, got ${o}`);let l=r?(0,n.bytesToNumberBE)(t):(0,n.bytesToNumberLE)(t),u=mod(l,e-i)+i;return r?(0,n.numberToBytesLE)(u,s):(0,n.numberToBytesBE)(u,s)};/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */let n=r(4870),o=BigInt(0),i=BigInt(1),s=BigInt(2),a=BigInt(3),l=BigInt(4),u=BigInt(5),f=BigInt(8);function mod(t,e){let r=t%e;return r>=o?r:e+r}function pow(t,e,r){if(r<=o||e<o)throw Error("Expected power/modulo > 0");if(r===i)return o;let n=i;for(;e>o;)e&i&&(n=n*t%r),t=t*t%r,e>>=i;return n}function invert(t,e){if(t===o||e<=o)throw Error(`invert: expected positive integers, got n=${t} mod=${e}`);let r=mod(t,e),n=e,s=o,a=i,l=i,u=o;for(;r!==o;){let t=n/r,e=n%r,o=s-l*t,i=a-u*t;n=r,r=e,s=l,a=u,l=o,u=i}let f=n;if(f!==i)throw Error("invert: does not exist");return mod(s,e)}function tonelliShanks(t){let e,r,n;let a=(t-i)/s;for(e=t-i,r=0;e%s===o;e/=s,r++);for(n=s;n<t&&pow(n,a,t)!==t-i;n++);if(1===r){let e=(t+i)/l;return function(t,r){let n=t.pow(r,e);if(!t.eql(t.sqr(n),r))throw Error("Cannot find square root");return n}}let u=(e+i)/s;return function(t,o){if(t.pow(o,a)===t.neg(t.ONE))throw Error("Cannot find square root");let s=r,l=t.pow(t.mul(t.ONE,n),e),f=t.pow(o,u),d=t.pow(o,e);for(;!t.eql(d,t.ONE);){if(t.eql(d,t.ZERO))return t.ZERO;let e=1;for(let r=t.sqr(d);e<s&&!t.eql(r,t.ONE);e++)r=t.sqr(r);let r=t.pow(l,i<<BigInt(s-e-1));l=t.sqr(r),f=t.mul(f,r),d=t.mul(d,l),s=e}return f}}function FpSqrt(t){if(t%l===a){let e=(t+i)/l;return function(t,r){let n=t.pow(r,e);if(!t.eql(t.sqr(n),r))throw Error("Cannot find square root");return n}}if(t%f===u){let e=(t-u)/f;return function(t,r){let n=t.mul(r,s),o=t.pow(n,e),i=t.mul(r,o),a=t.mul(t.mul(i,s),o),l=t.mul(i,t.sub(a,t.ONE));if(!t.eql(t.sqr(l),r))throw Error("Cannot find square root");return l}}return tonelliShanks(t)}BigInt(9),BigInt(16),e.isNegativeLE=(t,e)=>(mod(t,e)&i)===i;let d=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function FpPow(t,e,r){if(r<o)throw Error("Expected power > 0");if(r===o)return t.ONE;if(r===i)return e;let n=t.ONE,s=e;for(;r>o;)r&i&&(n=t.mul(n,s)),s=t.sqr(s),r>>=i;return n}function FpInvertBatch(t,e){let r=Array(e.length),n=e.reduce((e,n,o)=>t.is0(n)?e:(r[o]=e,t.mul(e,n)),t.ONE),o=t.inv(n);return e.reduceRight((e,n,o)=>t.is0(n)?e:(r[o]=t.mul(e,r[o]),t.mul(e,n)),o),r}function nLength(t,e){let r=void 0!==e?e:t.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function getFieldBytesLength(t){if("bigint"!=typeof t)throw Error("field order must be bigint");let e=t.toString(2).length;return Math.ceil(e/8)}function getMinHashLength(t){let e=getFieldBytesLength(t);return e+Math.ceil(e/2)}},4870:function(t,e){Object.defineProperty(e,"__esModule",{value:!0}),e.bitMask=void 0,e.isBytes=isBytes,e.abytes=abytes,e.bytesToHex=bytesToHex,e.numberToHexUnpadded=numberToHexUnpadded,e.hexToNumber=hexToNumber,e.hexToBytes=hexToBytes,e.bytesToNumberBE=function(t){return hexToNumber(bytesToHex(t))},e.bytesToNumberLE=function(t){return abytes(t),hexToNumber(bytesToHex(Uint8Array.from(t).reverse()))},e.numberToBytesBE=numberToBytesBE,e.numberToBytesLE=function(t,e){return numberToBytesBE(t,e).reverse()},e.numberToVarBytesBE=function(t){return hexToBytes(numberToHexUnpadded(t))},e.ensureBytes=function(t,e,r){let n;if("string"==typeof e)try{n=hexToBytes(e)}catch(r){throw Error(`${t} must be valid hex string, got "${e}". Cause: ${r}`)}else if(isBytes(e))n=Uint8Array.from(e);else throw Error(`${t} must be hex string or Uint8Array`);let o=n.length;if("number"==typeof r&&o!==r)throw Error(`${t} expected ${r} bytes, got ${o}`);return n},e.concatBytes=concatBytes,e.equalBytes=function(t,e){if(t.length!==e.length)return!1;let r=0;for(let n=0;n<t.length;n++)r|=t[n]^e[n];return 0===r},e.utf8ToBytes=function(t){if("string"!=typeof t)throw Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))},e.bitLen=function(t){let e;for(e=0;t>r;t>>=n,e+=1);return e},e.bitGet=function(t,e){return t>>BigInt(e)&n},e.bitSet=function(t,e,o){return t|(o?n:r)<<BigInt(e)},e.createHmacDrbg=function(t,e,r){if("number"!=typeof t||t<2)throw Error("hashLen must be a number");if("number"!=typeof e||e<2)throw Error("qByteLen must be a number");if("function"!=typeof r)throw Error("hmacFn must be a function");let n=u8n(t),o=u8n(t),i=0,reset=()=>{n.fill(1),o.fill(0),i=0},h=(...t)=>r(o,n,...t),reseed=(t=u8n())=>{o=h(u8fr([0]),t),n=h(),0!==t.length&&(o=h(u8fr([1]),t),n=h())},gen=()=>{if(i++>=1e3)throw Error("drbg: tried 1000 values");let t=0,r=[];for(;t<e;){n=h();let e=n.slice();r.push(e),t+=n.length}return concatBytes(...r)};return(t,e)=>{let r;for(reset(),reseed(t);!(r=e(gen()));)reseed();return reset(),r}},e.validateObject=function(t,e,r={}){let checkField=(e,r,n)=>{let o=a[r];if("function"!=typeof o)throw Error(`Invalid validator "${r}", expected function`);let i=t[e];if((!n||void 0!==i)&&!o(i,t))throw Error(`Invalid param ${String(e)}=${i} (${typeof i}), expected ${r}`)};for(let[t,r]of Object.entries(e))checkField(t,r,!1);for(let[t,e]of Object.entries(r))checkField(t,e,!0);return t};/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */let r=BigInt(0),n=BigInt(1),o=BigInt(2);function isBytes(t){return t instanceof Uint8Array||null!=t&&"object"==typeof t&&"Uint8Array"===t.constructor.name}function abytes(t){if(!isBytes(t))throw Error("Uint8Array expected")}let i=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function bytesToHex(t){abytes(t);let e="";for(let r=0;r<t.length;r++)e+=i[t[r]];return e}function numberToHexUnpadded(t){let e=t.toString(16);return 1&e.length?`0${e}`:e}function hexToNumber(t){if("string"!=typeof t)throw Error("hex string expected, got "+typeof t);return BigInt(""===t?"0":`0x${t}`)}let s={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function asciiToBase16(t){return t>=s._0&&t<=s._9?t-s._0:t>=s._A&&t<=s._F?t-(s._A-10):t>=s._a&&t<=s._f?t-(s._a-10):void 0}function hexToBytes(t){if("string"!=typeof t)throw Error("hex string expected, got "+typeof t);let e=t.length,r=e/2;if(e%2)throw Error("padded hex string expected, got unpadded hex of length "+e);let n=new Uint8Array(r);for(let e=0,o=0;e<r;e++,o+=2){let r=asciiToBase16(t.charCodeAt(o)),i=asciiToBase16(t.charCodeAt(o+1));if(void 0===r||void 0===i){let e=t[o]+t[o+1];throw Error('hex string expected, got non-hex character "'+e+'" at index '+o)}n[e]=16*r+i}return n}function numberToBytesBE(t,e){return hexToBytes(t.toString(16).padStart(2*e,"0"))}function concatBytes(...t){let e=0;for(let r=0;r<t.length;r++){let n=t[r];abytes(n),e+=n.length}let r=new Uint8Array(e);for(let e=0,n=0;e<t.length;e++){let o=t[e];r.set(o,n),n+=o.length}return r}e.bitMask=t=>(o<<BigInt(t-1))-n;let u8n=t=>new Uint8Array(t),u8fr=t=>Uint8Array.from(t),a={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||isBytes(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)}},70409:function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.DER=void 0,e.weierstrassPoints=weierstrassPoints,e.weierstrass=function(t){let r=function(t){let e=(0,n.validateBasic)(t);return i.validateObject(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:a,n:l}=r,d=a.BYTES+1,c=2*a.BYTES+1;function modN(t){return o.mod(t,l)}function invN(t){return o.invert(t,l)}let{ProjectivePoint:y,normPrivateKeyToScalar:p,weierstrassEquation:g,isWithinCurveOrder:b}=weierstrassPoints({...r,toBytes(t,e,r){let n=e.toAffine(),o=a.toBytes(n.x),s=i.concatBytes;return r?s(Uint8Array.from([e.hasEvenY()?2:3]),o):s(Uint8Array.from([4]),o,a.toBytes(n.y))},fromBytes(t){let e=t.length,r=t[0],n=t.subarray(1);if(e===d&&(2===r||3===r)){let t;let e=i.bytesToNumberBE(n);if(!(u<e&&e<a.ORDER))throw Error("Point is not on curve");let o=g(e);try{t=a.sqrt(o)}catch(e){let t=e instanceof Error?": "+e.message:"";throw Error("Point is not on curve"+t)}let s=(t&f)===f;return(1&r)==1!==s&&(t=a.neg(t)),{x:e,y:t}}if(e===c&&4===r){let t=a.fromBytes(n.subarray(0,a.BYTES)),e=a.fromBytes(n.subarray(a.BYTES,2*a.BYTES));return{x:t,y:e}}throw Error(`Point of length ${e} was invalid. Expected ${d} compressed bytes or ${c} uncompressed bytes`)}}),numToNByteStr=t=>i.bytesToHex(i.numberToBytesBE(t,r.nByteLength));function isBiggerThanHalfOrder(t){let e=l>>f;return t>e}let slcNum=(t,e,r)=>i.bytesToNumberBE(t.slice(e,r));let Signature=class Signature{constructor(t,e,r){this.r=t,this.s=e,this.recovery=r,this.assertValidity()}static fromCompact(t){let e=r.nByteLength;return t=(0,s.ensureBytes)("compactSignature",t,2*e),new Signature(slcNum(t,0,e),slcNum(t,e,2*e))}static fromDER(t){let{r,s:n}=e.DER.toSig((0,s.ensureBytes)("DER",t));return new Signature(r,n)}assertValidity(){if(!b(this.r))throw Error("r must be 0 < r < CURVE.n");if(!b(this.s))throw Error("s must be 0 < s < CURVE.n")}addRecoveryBit(t){return new Signature(this.r,this.s,t)}recoverPublicKey(t){let{r:e,s:n,recovery:o}=this,i=B((0,s.ensureBytes)("msgHash",t));if(null==o||![0,1,2,3].includes(o))throw Error("recovery id invalid");let l=2===o||3===o?e+r.n:e;if(l>=a.ORDER)throw Error("recovery id 2 or 3 invalid");let u=(1&o)==0?"02":"03",f=y.fromHex(u+numToNByteStr(l)),d=invN(l),c=modN(-i*d),p=modN(n*d),g=y.BASE.multiplyAndAddUnsafe(f,c,p);if(!g)throw Error("point at infinify");return g.assertValidity(),g}hasHighS(){return isBiggerThanHalfOrder(this.s)}normalizeS(){return this.hasHighS()?new Signature(this.r,modN(-this.s),this.recovery):this}toDERRawBytes(){return i.hexToBytes(this.toDERHex())}toDERHex(){return e.DER.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return i.hexToBytes(this.toCompactHex())}toCompactHex(){return numToNByteStr(this.r)+numToNByteStr(this.s)}};function isProbPub(t){let e=i.isBytes(t),r="string"==typeof t,n=(e||r)&&t.length;return e?n===d||n===c:r?n===2*d||n===2*c:t instanceof y}let m=r.bits2int||function(t){let e=i.bytesToNumberBE(t),n=8*t.length-r.nBitLength;return n>0?e>>BigInt(n):e},B=r.bits2int_modN||function(t){return modN(m(t))},w=i.bitMask(r.nBitLength);function int2octets(t){if("bigint"!=typeof t)throw Error("bigint expected");if(!(u<=t&&t<w))throw Error(`bigint expected < 2^${r.nBitLength}`);return i.numberToBytesBE(t,r.nByteLength)}let E={lowS:r.lowS,prehash:!1},S={lowS:r.lowS,prehash:!1};return y.BASE._setWindowSize(8),{CURVE:r,getPublicKey:function(t,e=!0){return y.fromPrivateKey(t).toRawBytes(e)},getSharedSecret:function(t,e,r=!0){if(isProbPub(t))throw Error("first arg must be private key");if(!isProbPub(e))throw Error("second arg must be public key");let n=y.fromHex(e);return n.multiply(p(t)).toRawBytes(r)},sign:function(t,e,n=E){let{seed:o,k2sig:l}=function(t,e,n=E){if(["recovered","canonical"].some(t=>t in n))throw Error("sign() legacy options not supported");let{hash:o,randomBytes:l}=r,{lowS:d,prehash:c,extraEntropy:g}=n;null==d&&(d=!0),t=(0,s.ensureBytes)("msgHash",t),c&&(t=(0,s.ensureBytes)("prehashed msgHash",o(t)));let w=B(t),S=p(e),x=[int2octets(S),int2octets(w)];if(null!=g&&!1!==g){let t=!0===g?l(a.BYTES):g;x.push((0,s.ensureBytes)("extraEntropy",t))}let v=i.concatBytes(...x);return{seed:v,k2sig:function(t){let e=m(t);if(!b(e))return;let r=invN(e),n=y.BASE.multiply(e).toAffine(),o=modN(n.x);if(o===u)return;let i=modN(r*modN(w+o*S));if(i===u)return;let s=(n.x===o?0:2)|Number(n.y&f),a=i;return d&&isBiggerThanHalfOrder(i)&&(a=isBiggerThanHalfOrder(i)?modN(-i):i,s^=1),new Signature(o,a,s)}}}(t,e,n),d=i.createHmacDrbg(r.hash.outputLen,r.nByteLength,r.hmac);return d(o,l)},verify:function(t,n,o,a=S){let l,u;if(n=(0,s.ensureBytes)("msgHash",n),o=(0,s.ensureBytes)("publicKey",o),"strict"in a)throw Error("options.strict was renamed to lowS");let{lowS:f,prehash:d}=a;try{if("string"==typeof t||i.isBytes(t))try{u=Signature.fromDER(t)}catch(r){if(!(r instanceof e.DER.Err))throw r;u=Signature.fromCompact(t)}else if("object"==typeof t&&"bigint"==typeof t.r&&"bigint"==typeof t.s){let{r:e,s:r}=t;u=new Signature(e,r)}else throw Error("PARSE");l=y.fromHex(o)}catch(t){if("PARSE"===t.message)throw Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(f&&u.hasHighS())return!1;d&&(n=r.hash(n));let{r:c,s:p}=u,g=B(n),b=invN(p),m=modN(g*b),w=modN(c*b),E=y.BASE.multiplyAndAddUnsafe(l,m,w)?.toAffine();if(!E)return!1;let x=modN(E.x);return x===c},ProjectivePoint:y,Signature,utils:{isValidPrivateKey(t){try{return p(t),!0}catch(t){return!1}},normPrivateKeyToScalar:p,randomPrivateKey:()=>{let t=o.getMinHashLength(r.n);return o.mapHashToField(r.randomBytes(t),r.n)},precompute:(t=8,e=y.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)}}},e.SWUFpSqrtRatio=SWUFpSqrtRatio,e.mapToCurveSimpleSWU=function(t,e){if(o.validateField(t),!t.isValid(e.A)||!t.isValid(e.B)||!t.isValid(e.Z))throw Error("mapToCurveSimpleSWU: invalid opts");let r=SWUFpSqrtRatio(t,e.Z);if(!t.isOdd)throw Error("Fp.isOdd is not implemented!");return n=>{let o,i,s,a,l,u,f,d;o=t.sqr(n),o=t.mul(o,e.Z),i=t.sqr(o),i=t.add(i,o),s=t.add(i,t.ONE),s=t.mul(s,e.B),a=t.cmov(e.Z,t.neg(i),!t.eql(i,t.ZERO)),a=t.mul(a,e.A),i=t.sqr(s),u=t.sqr(a),l=t.mul(u,e.A),i=t.add(i,l),i=t.mul(i,s),u=t.mul(u,a),l=t.mul(u,e.B),i=t.add(i,l),f=t.mul(o,s);let{isValid:c,value:y}=r(i,u);d=t.mul(o,n),d=t.mul(d,y),f=t.cmov(f,s,c),d=t.cmov(d,y,c);let p=t.isOdd(n)===t.isOdd(d);return d=t.cmov(t.neg(d),d,p),{x:f=t.div(f,a),y:d}}};/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */let n=r(46061),o=r(66998),i=r(4870),s=r(4870),{bytesToNumberBE:a,hexToBytes:l}=i;e.DER={Err:class extends Error{constructor(t=""){super(t)}},_parseInt(t){let{Err:r}=e.DER;if(t.length<2||2!==t[0])throw new r("Invalid signature integer tag");let n=t[1],o=t.subarray(2,n+2);if(!n||o.length!==n)throw new r("Invalid signature integer: wrong length");if(128&o[0])throw new r("Invalid signature integer: negative");if(0===o[0]&&!(128&o[1]))throw new r("Invalid signature integer: unnecessary leading zero");return{d:a(o),l:t.subarray(n+2)}},toSig(t){let{Err:r}=e.DER,n="string"==typeof t?l(t):t;i.abytes(n);let o=n.length;if(o<2||48!=n[0])throw new r("Invalid signature tag");if(n[1]!==o-2)throw new r("Invalid signature: incorrect length");let{d:s,l:a}=e.DER._parseInt(n.subarray(2)),{d:u,l:f}=e.DER._parseInt(a);if(f.length)throw new r("Invalid signature: left bytes after parsing");return{r:s,s:u}},hexFromSig(t){let slice=t=>8&Number.parseInt(t[0],16)?"00"+t:t,h=t=>{let e=t.toString(16);return 1&e.length?`0${e}`:e},e=slice(h(t.s)),r=slice(h(t.r)),n=e.length/2,o=r.length/2,i=h(n),s=h(o);return`30${h(o+n+4)}02${s}${r}02${i}${e}`}};let u=BigInt(0),f=BigInt(1),d=BigInt(2),c=BigInt(3),y=BigInt(4);function weierstrassPoints(t){let e=function(t){let e=(0,n.validateBasic)(t);i.validateObject(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});let{endo:r,Fp:o,a:s}=e;if(r){if(!o.eql(s,o.ZERO))throw Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof r||"bigint"!=typeof r.beta||"function"!=typeof r.splitScalar)throw Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}(t),{Fp:r}=e,a=e.toBytes||((t,e,n)=>{let o=e.toAffine();return i.concatBytes(Uint8Array.from([4]),r.toBytes(o.x),r.toBytes(o.y))}),l=e.fromBytes||(t=>{let e=t.subarray(1),n=r.fromBytes(e.subarray(0,r.BYTES)),o=r.fromBytes(e.subarray(r.BYTES,2*r.BYTES));return{x:n,y:o}});function weierstrassEquation(t){let{a:n,b:o}=e,i=r.sqr(t),s=r.mul(i,t);return r.add(r.add(s,r.mul(t,n)),o)}if(!r.eql(r.sqr(e.Gy),weierstrassEquation(e.Gx)))throw Error("bad generator point: equation left != right");function isWithinCurveOrder(t){return"bigint"==typeof t&&u<t&&t<e.n}function assertGE(t){if(!isWithinCurveOrder(t))throw Error("Expected valid bigint: 0 < bigint < curve.n")}function normPrivateKeyToScalar(t){let r;let{allowedPrivateKeyLengths:n,nByteLength:a,wrapPrivateKey:l,n:u}=e;if(n&&"bigint"!=typeof t){if(i.isBytes(t)&&(t=i.bytesToHex(t)),"string"!=typeof t||!n.includes(t.length))throw Error("Invalid key");t=t.padStart(2*a,"0")}try{r="bigint"==typeof t?t:i.bytesToNumberBE((0,s.ensureBytes)("private key",t,a))}catch(e){throw Error(`private key must be ${a} bytes, hex or bigint, not ${typeof t}`)}return l&&(r=o.mod(r,u)),assertGE(r),r}let d=new Map;function assertPrjPoint(t){if(!(t instanceof Point))throw Error("ProjectivePoint expected")}let Point=class Point{constructor(t,e,n){if(this.px=t,this.py=e,this.pz=n,null==t||!r.isValid(t))throw Error("x required");if(null==e||!r.isValid(e))throw Error("y required");if(null==n||!r.isValid(n))throw Error("z required")}static fromAffine(t){let{x:e,y:n}=t||{};if(!t||!r.isValid(e)||!r.isValid(n))throw Error("invalid affine point");if(t instanceof Point)throw Error("projective point not allowed");let is0=t=>r.eql(t,r.ZERO);return is0(e)&&is0(n)?Point.ZERO:new Point(e,n,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){let e=r.invertBatch(t.map(t=>t.pz));return t.map((t,r)=>t.toAffine(e[r])).map(Point.fromAffine)}static fromHex(t){let e=Point.fromAffine(l((0,s.ensureBytes)("pointHex",t)));return e.assertValidity(),e}static fromPrivateKey(t){return Point.BASE.multiply(normPrivateKeyToScalar(t))}_setWindowSize(t){this._WINDOW_SIZE=t,d.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!r.is0(this.py))return;throw Error("bad point: ZERO")}let{x:t,y:n}=this.toAffine();if(!r.isValid(t)||!r.isValid(n))throw Error("bad point: x or y not FE");let o=r.sqr(n),i=weierstrassEquation(t);if(!r.eql(o,i))throw Error("bad point: equation left != right");if(!this.isTorsionFree())throw Error("bad point: not in prime-order subgroup")}hasEvenY(){let{y:t}=this.toAffine();if(r.isOdd)return!r.isOdd(t);throw Error("Field doesn't support isOdd")}equals(t){assertPrjPoint(t);let{px:e,py:n,pz:o}=this,{px:i,py:s,pz:a}=t,l=r.eql(r.mul(e,a),r.mul(i,o)),u=r.eql(r.mul(n,a),r.mul(s,o));return l&&u}negate(){return new Point(this.px,r.neg(this.py),this.pz)}double(){let{a:t,b:n}=e,o=r.mul(n,c),{px:i,py:s,pz:a}=this,l=r.ZERO,u=r.ZERO,f=r.ZERO,d=r.mul(i,i),y=r.mul(s,s),p=r.mul(a,a),g=r.mul(i,s);return g=r.add(g,g),f=r.mul(i,a),f=r.add(f,f),l=r.mul(t,f),u=r.mul(o,p),u=r.add(l,u),l=r.sub(y,u),u=r.add(y,u),u=r.mul(l,u),l=r.mul(g,l),f=r.mul(o,f),p=r.mul(t,p),g=r.sub(d,p),g=r.mul(t,g),g=r.add(g,f),f=r.add(d,d),d=r.add(f,d),d=r.add(d,p),d=r.mul(d,g),u=r.add(u,d),p=r.mul(s,a),p=r.add(p,p),d=r.mul(p,g),l=r.sub(l,d),f=r.mul(p,y),f=r.add(f,f),f=r.add(f,f),new Point(l,u,f)}add(t){assertPrjPoint(t);let{px:n,py:o,pz:i}=this,{px:s,py:a,pz:l}=t,u=r.ZERO,f=r.ZERO,d=r.ZERO,y=e.a,p=r.mul(e.b,c),g=r.mul(n,s),b=r.mul(o,a),m=r.mul(i,l),B=r.add(n,o),w=r.add(s,a);B=r.mul(B,w),w=r.add(g,b),B=r.sub(B,w),w=r.add(n,i);let E=r.add(s,l);return w=r.mul(w,E),E=r.add(g,m),w=r.sub(w,E),E=r.add(o,i),u=r.add(a,l),E=r.mul(E,u),u=r.add(b,m),E=r.sub(E,u),d=r.mul(y,w),u=r.mul(p,m),d=r.add(u,d),u=r.sub(b,d),d=r.add(b,d),f=r.mul(u,d),b=r.add(g,g),b=r.add(b,g),m=r.mul(y,m),w=r.mul(p,w),b=r.add(b,m),m=r.sub(g,m),m=r.mul(y,m),w=r.add(w,m),g=r.mul(b,w),f=r.add(f,g),g=r.mul(E,w),u=r.mul(B,u),u=r.sub(u,g),g=r.mul(B,b),d=r.mul(E,d),d=r.add(d,g),new Point(u,f,d)}subtract(t){return this.add(t.negate())}is0(){return this.equals(Point.ZERO)}wNAF(t){return p.wNAFCached(this,d,t,t=>{let e=r.invertBatch(t.map(t=>t.pz));return t.map((t,r)=>t.toAffine(e[r])).map(Point.fromAffine)})}multiplyUnsafe(t){let n=Point.ZERO;if(t===u)return n;if(assertGE(t),t===f)return this;let{endo:o}=e;if(!o)return p.unsafeLadder(this,t);let{k1neg:i,k1:s,k2neg:a,k2:l}=o.splitScalar(t),d=n,c=n,y=this;for(;s>u||l>u;)s&f&&(d=d.add(y)),l&f&&(c=c.add(y)),y=y.double(),s>>=f,l>>=f;return i&&(d=d.negate()),a&&(c=c.negate()),c=new Point(r.mul(c.px,o.beta),c.py,c.pz),d.add(c)}multiply(t){let n,o;assertGE(t);let{endo:i}=e;if(i){let{k1neg:e,k1:s,k2neg:a,k2:l}=i.splitScalar(t),{p:u,f:f}=this.wNAF(s),{p:d,f:c}=this.wNAF(l);u=p.constTimeNegate(e,u),d=p.constTimeNegate(a,d),d=new Point(r.mul(d.px,i.beta),d.py,d.pz),n=u.add(d),o=f.add(c)}else{let{p:e,f:r}=this.wNAF(t);n=e,o=r}return Point.normalizeZ([n,o])[0]}multiplyAndAddUnsafe(t,e,r){let n=Point.BASE,mul=(t,e)=>e!==u&&e!==f&&t.equals(n)?t.multiply(e):t.multiplyUnsafe(e),o=mul(this,e).add(mul(t,r));return o.is0()?void 0:o}toAffine(t){let{px:e,py:n,pz:o}=this,i=this.is0();null==t&&(t=i?r.ONE:r.inv(o));let s=r.mul(e,t),a=r.mul(n,t),l=r.mul(o,t);if(i)return{x:r.ZERO,y:r.ZERO};if(!r.eql(l,r.ONE))throw Error("invZ was invalid");return{x:s,y:a}}isTorsionFree(){let{h:t,isTorsionFree:r}=e;if(t===f)return!0;if(r)return r(Point,this);throw Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){let{h:t,clearCofactor:r}=e;return t===f?this:r?r(Point,this):this.multiplyUnsafe(e.h)}toRawBytes(t=!0){return this.assertValidity(),a(Point,this,t)}toHex(t=!0){return i.bytesToHex(this.toRawBytes(t))}};Point.BASE=new Point(e.Gx,e.Gy,r.ONE),Point.ZERO=new Point(r.ZERO,r.ONE,r.ZERO);let y=e.nBitLength,p=(0,n.wNAF)(Point,e.endo?Math.ceil(y/2):y);return{CURVE:e,ProjectivePoint:Point,normPrivateKeyToScalar,weierstrassEquation,isWithinCurveOrder}}function SWUFpSqrtRatio(t,e){let r=t.ORDER,n=u;for(let t=r-f;t%d===u;t/=d)n+=f;let o=n,i=d<<o-f-f,s=i*d,a=(r-f)/s,l=(a-f)/d,p=s-f,g=t.pow(e,a),b=t.pow(e,(a+f)/d),sqrtRatio=(e,r)=>{let n=g,s=t.pow(r,p),a=t.sqr(s);a=t.mul(a,r);let u=t.mul(e,a);u=t.pow(u,l),u=t.mul(u,s),s=t.mul(u,r),a=t.mul(u,e);let c=t.mul(a,s);u=t.pow(c,i);let y=t.eql(u,t.ONE);s=t.mul(a,b),u=t.mul(c,n),a=t.cmov(s,a,y),c=t.cmov(u,c,y);for(let e=o;e>f;e--){let r=e-d;r=d<<r-f;let o=t.pow(c,r),i=t.eql(o,t.ONE);s=t.mul(a,n),n=t.mul(n,n),o=t.mul(c,n),a=t.cmov(s,a,i),c=t.cmov(o,c,i)}return{isValid:y,value:a}};if(t.ORDER%y===c){let r=(t.ORDER-c)/y,n=t.sqrt(t.neg(e));sqrtRatio=(e,o)=>{let i=t.sqr(o),s=t.mul(e,o);i=t.mul(i,s);let a=t.pow(i,r);a=t.mul(a,s);let l=t.mul(a,n),u=t.mul(t.sqr(a),o),f=t.eql(u,e),d=t.cmov(l,a,f);return{isValid:f,value:d}}}return sqrtRatio}},70041:function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.encodeToCurve=e.hashToCurve=e.schnorr=e.secp256k1=void 0;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */let n=r(10820),o=r(23037),i=r(37270),s=r(31315),a=r(66998),l=r(4870),u=r(70409),f=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),d=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),c=BigInt(1),y=BigInt(2),divNearest=(t,e)=>(t+e/y)/e;function sqrtMod(t){let e=BigInt(3),r=BigInt(6),n=BigInt(11),o=BigInt(22),i=BigInt(23),s=BigInt(44),l=BigInt(88),u=t*t*t%f,d=u*u*t%f,c=(0,a.pow2)(d,e,f)*d%f,g=(0,a.pow2)(c,e,f)*d%f,b=(0,a.pow2)(g,y,f)*u%f,m=(0,a.pow2)(b,n,f)*b%f,B=(0,a.pow2)(m,o,f)*m%f,w=(0,a.pow2)(B,s,f)*B%f,E=(0,a.pow2)(w,l,f)*w%f,S=(0,a.pow2)(E,s,f)*B%f,x=(0,a.pow2)(S,e,f)*d%f,v=(0,a.pow2)(x,i,f)*m%f,H=(0,a.pow2)(v,r,f)*u%f,L=(0,a.pow2)(H,y,f);if(!p.eql(p.sqr(L),t))throw Error("Cannot find square root");return L}let p=(0,a.Field)(f,void 0,void 0,{sqrt:sqrtMod});e.secp256k1=(0,i.createCurve)({a:BigInt(0),b:BigInt(7),Fp:p,n:d,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{let e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-c*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),n=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=BigInt("0x100000000000000000000000000000000"),i=divNearest(e*t,d),s=divNearest(-r*t,d),l=(0,a.mod)(t-i*e-s*n,d),u=(0,a.mod)(-i*r-s*e,d),f=l>o,y=u>o;if(f&&(l=d-l),y&&(u=d-u),l>o||u>o)throw Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:f,k1:l,k2neg:y,k2:u}}}},n.sha256);let g=BigInt(0),fe=t=>"bigint"==typeof t&&g<t&&t<f,ge=t=>"bigint"==typeof t&&g<t&&t<d,b={};function taggedHash(t,...e){let r=b[t];if(void 0===r){let e=(0,n.sha256)(Uint8Array.from(t,t=>t.charCodeAt(0)));r=(0,l.concatBytes)(e,e),b[t]=r}return(0,n.sha256)((0,l.concatBytes)(r,...e))}let pointToBytes=t=>t.toRawBytes(!0).slice(1),numTo32b=t=>(0,l.numberToBytesBE)(t,32),modP=t=>(0,a.mod)(t,f),modN=t=>(0,a.mod)(t,d),m=e.secp256k1.ProjectivePoint,GmulAdd=(t,e,r)=>m.BASE.multiplyAndAddUnsafe(t,e,r);function schnorrGetExtPubKey(t){let r=e.secp256k1.utils.normPrivateKeyToScalar(t),n=m.fromPrivateKey(r),o=n.hasEvenY()?r:modN(-r);return{scalar:o,bytes:pointToBytes(n)}}function lift_x(t){if(!fe(t))throw Error("bad x: need 0 < x < p");let e=modP(t*t),r=modP(e*t+BigInt(7)),n=sqrtMod(r);n%y!==g&&(n=modP(-n));let o=new m(t,n,c);return o.assertValidity(),o}function challenge(...t){return modN((0,l.bytesToNumberBE)(taggedHash("BIP0340/challenge",...t)))}function schnorrVerify(t,e,r){let n=(0,l.ensureBytes)("signature",t,64),o=(0,l.ensureBytes)("message",e),i=(0,l.ensureBytes)("publicKey",r,32);try{let t=lift_x((0,l.bytesToNumberBE)(i)),e=(0,l.bytesToNumberBE)(n.subarray(0,32));if(!fe(e))return!1;let r=(0,l.bytesToNumberBE)(n.subarray(32,64));if(!ge(r))return!1;let s=challenge(numTo32b(e),pointToBytes(t),o),a=GmulAdd(t,r,modN(-s));if(!a||!a.hasEvenY()||a.toAffine().x!==e)return!1;return!0}catch(t){return!1}}e.schnorr={getPublicKey:function(t){return schnorrGetExtPubKey(t).bytes},sign:function(t,e,r=(0,o.randomBytes)(32)){let n=(0,l.ensureBytes)("message",t),{bytes:i,scalar:s}=schnorrGetExtPubKey(e),a=(0,l.ensureBytes)("auxRand",r,32),u=numTo32b(s^(0,l.bytesToNumberBE)(taggedHash("BIP0340/aux",a))),f=taggedHash("BIP0340/nonce",u,i,n),d=modN((0,l.bytesToNumberBE)(f));if(d===g)throw Error("sign failed: k is zero");let{bytes:c,scalar:y}=schnorrGetExtPubKey(d),p=challenge(c,i,n),b=new Uint8Array(64);if(b.set(c,0),b.set(numTo32b(modN(y+p*s)),32),!schnorrVerify(b,n,i))throw Error("sign: Invalid signature produced");return b},verify:schnorrVerify,utils:{randomPrivateKey:e.secp256k1.utils.randomPrivateKey,lift_x,pointToBytes,numberToBytesBE:l.numberToBytesBE,bytesToNumberBE:l.bytesToNumberBE,taggedHash,mod:a.mod}};let B=(0,s.isogenyMap)(p,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(t=>BigInt(t)))),w=(0,u.mapToCurveSimpleSWU)(p,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:p.create(BigInt("-11"))}),E=(0,s.createHasher)(e.secp256k1.ProjectivePoint,t=>{let{x:e,y:r}=w(p.create(t[0]));return B(e,r)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:p.ORDER,m:1,k:128,expand:"xmd",hash:n.sha256});e.hashToCurve=E.hashToCurve,e.encodeToCurve=E.encodeToCurve},79131:function(t,e){function number(t){if(!Number.isSafeInteger(t)||t<0)throw Error(`positive integer expected, not ${t}`)}function bool(t){if("boolean"!=typeof t)throw Error(`boolean expected, not ${t}`)}function isBytes(t){return t instanceof Uint8Array||null!=t&&"object"==typeof t&&"Uint8Array"===t.constructor.name}function bytes(t,...e){if(!isBytes(t))throw Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw Error(`Uint8Array expected of length ${e}, not of length=${t.length}`)}function hash(t){if("function"!=typeof t||"function"!=typeof t.create)throw Error("Hash should be wrapped by utils.wrapConstructor");number(t.outputLen),number(t.blockLen)}function exists(t,e=!0){if(t.destroyed)throw Error("Hash instance has been destroyed");if(e&&t.finished)throw Error("Hash#digest() has already been called")}function output(t,e){bytes(t);let r=e.outputLen;if(t.length<r)throw Error(`digestInto() expects output buffer of length at least ${r}`)}Object.defineProperty(e,"__esModule",{value:!0}),e.output=e.exists=e.hash=e.bytes=e.bool=e.number=e.isBytes=void 0,e.number=number,e.bool=bool,e.isBytes=isBytes,e.bytes=bytes,e.hash=hash,e.exists=exists,e.output=output,e.default={number,bool,bytes,hash,exists,output}},98331:function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.HashMD=e.Maj=e.Chi=void 0;let n=r(79131),o=r(23037);e.Chi=(t,e,r)=>t&e^~t&r,e.Maj=(t,e,r)=>t&e^t&r^e&r;let HashMD=class HashMD extends o.Hash{constructor(t,e,r,n){super(),this.blockLen=t,this.outputLen=e,this.padOffset=r,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=(0,o.createView)(this.buffer)}update(t){(0,n.exists)(this);let{view:e,buffer:r,blockLen:i}=this;t=(0,o.toBytes)(t);let s=t.length;for(let n=0;n<s;){let a=Math.min(i-this.pos,s-n);if(a===i){let e=(0,o.createView)(t);for(;i<=s-n;n+=i)this.process(e,n);continue}r.set(t.subarray(n,n+a),this.pos),this.pos+=a,n+=a,this.pos===i&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){(0,n.exists)(this),(0,n.output)(t,this),this.finished=!0;let{buffer:e,view:r,blockLen:i,isLE:s}=this,{pos:a}=this;e[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>i-a&&(this.process(r,0),a=0);for(let t=a;t<i;t++)e[t]=0;!function(t,e,r,n){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,r,n);let o=BigInt(32),i=BigInt(4294967295),s=Number(r>>o&i),a=Number(r&i),l=n?4:0,u=n?0:4;t.setUint32(e+l,s,n),t.setUint32(e+u,a,n)}(r,i-8,BigInt(8*this.length),s),this.process(r,0);let l=(0,o.createView)(t),u=this.outputLen;if(u%4)throw Error("_sha2: outputLen should be aligned to 32bit");let f=u/4,d=this.get();if(f>d.length)throw Error("_sha2: outputLen bigger than state");for(let t=0;t<f;t++)l.setUint32(4*t,d[t],s)}digest(){let{buffer:t,outputLen:e}=this;this.digestInto(t);let r=t.slice(0,e);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());let{blockLen:e,buffer:r,length:n,finished:o,destroyed:i,pos:s}=this;return t.length=n,t.pos=s,t.finished=o,t.destroyed=i,n%e&&t.buffer.set(r),t}};e.HashMD=HashMD},97946:function(t,e){Object.defineProperty(e,"__esModule",{value:!0}),e.add5L=e.add5H=e.add4H=e.add4L=e.add3H=e.add3L=e.add=e.rotlBL=e.rotlBH=e.rotlSL=e.rotlSH=e.rotr32L=e.rotr32H=e.rotrBL=e.rotrBH=e.rotrSL=e.rotrSH=e.shrSL=e.shrSH=e.toBig=e.split=e.fromBig=void 0;let r=BigInt(4294967296-1),n=BigInt(32);function fromBig(t,e=!1){return e?{h:Number(t&r),l:Number(t>>n&r)}:{h:0|Number(t>>n&r),l:0|Number(t&r)}}function split(t,e=!1){let r=new Uint32Array(t.length),n=new Uint32Array(t.length);for(let o=0;o<t.length;o++){let{h:i,l:s}=fromBig(t[o],e);[r[o],n[o]]=[i,s]}return[r,n]}e.fromBig=fromBig,e.split=split;let toBig=(t,e)=>BigInt(t>>>0)<<n|BigInt(e>>>0);e.toBig=toBig;let shrSH=(t,e,r)=>t>>>r;e.shrSH=shrSH;let shrSL=(t,e,r)=>t<<32-r|e>>>r;e.shrSL=shrSL;let rotrSH=(t,e,r)=>t>>>r|e<<32-r;e.rotrSH=rotrSH;let rotrSL=(t,e,r)=>t<<32-r|e>>>r;e.rotrSL=rotrSL;let rotrBH=(t,e,r)=>t<<64-r|e>>>r-32;e.rotrBH=rotrBH;let rotrBL=(t,e,r)=>t>>>r-32|e<<64-r;e.rotrBL=rotrBL;let rotr32H=(t,e)=>e;e.rotr32H=rotr32H;let rotr32L=(t,e)=>t;e.rotr32L=rotr32L;let rotlSH=(t,e,r)=>t<<r|e>>>32-r;e.rotlSH=rotlSH;let rotlSL=(t,e,r)=>e<<r|t>>>32-r;e.rotlSL=rotlSL;let rotlBH=(t,e,r)=>e<<r-32|t>>>64-r;e.rotlBH=rotlBH;let rotlBL=(t,e,r)=>t<<r-32|e>>>64-r;function add(t,e,r,n){let o=(e>>>0)+(n>>>0);return{h:t+r+(o/4294967296|0)|0,l:0|o}}e.rotlBL=rotlBL,e.add=add;let add3L=(t,e,r)=>(t>>>0)+(e>>>0)+(r>>>0);e.add3L=add3L;let add3H=(t,e,r,n)=>e+r+n+(t/4294967296|0)|0;e.add3H=add3H;let add4L=(t,e,r,n)=>(t>>>0)+(e>>>0)+(r>>>0)+(n>>>0);e.add4L=add4L;let add4H=(t,e,r,n,o)=>e+r+n+o+(t/4294967296|0)|0;e.add4H=add4H;let add5L=(t,e,r,n,o)=>(t>>>0)+(e>>>0)+(r>>>0)+(n>>>0)+(o>>>0);e.add5L=add5L;let add5H=(t,e,r,n,o,i)=>e+r+n+o+i+(t/4294967296|0)|0;e.add5H=add5H,e.default={fromBig,split,toBig,shrSH,shrSL,rotrSH,rotrSL,rotrBH,rotrBL,rotr32H,rotr32L,rotlSH,rotlSL,rotlBH,rotlBL,add,add3L,add3H,add4L,add4H,add5H,add5L}},38378:function(t,e){Object.defineProperty(e,"__esModule",{value:!0}),e.crypto=void 0,e.crypto="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0},45238:function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.hmac=e.HMAC=void 0;let n=r(79131),o=r(23037);let HMAC=class HMAC extends o.Hash{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,(0,n.hash)(t);let r=(0,o.toBytes)(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let i=this.blockLen,s=new Uint8Array(i);s.set(r.length>i?t.create().update(r).digest():r);for(let t=0;t<s.length;t++)s[t]^=54;this.iHash.update(s),this.oHash=t.create();for(let t=0;t<s.length;t++)s[t]^=106;this.oHash.update(s),s.fill(0)}update(t){return(0,n.exists)(this),this.iHash.update(t),this}digestInto(t){(0,n.exists)(this),(0,n.bytes)(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){let t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));let{oHash:e,iHash:r,finished:n,destroyed:o,blockLen:i,outputLen:s}=this;return t.finished=n,t.destroyed=o,t.blockLen=i,t.outputLen=s,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}};e.HMAC=HMAC,e.hmac=(t,e,r)=>new HMAC(t,e).update(r).digest(),e.hmac.create=(t,e)=>new HMAC(t,e)},10820:function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.sha224=e.sha256=void 0;let n=r(98331),o=r(23037),i=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),s=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),a=new Uint32Array(64);let SHA256=class SHA256 extends n.HashMD{constructor(){super(64,32,8,!1),this.A=0|s[0],this.B=0|s[1],this.C=0|s[2],this.D=0|s[3],this.E=0|s[4],this.F=0|s[5],this.G=0|s[6],this.H=0|s[7]}get(){let{A:t,B:e,C:r,D:n,E:o,F:i,G:s,H:a}=this;return[t,e,r,n,o,i,s,a]}set(t,e,r,n,o,i,s,a){this.A=0|t,this.B=0|e,this.C=0|r,this.D=0|n,this.E=0|o,this.F=0|i,this.G=0|s,this.H=0|a}process(t,e){for(let r=0;r<16;r++,e+=4)a[r]=t.getUint32(e,!1);for(let t=16;t<64;t++){let e=a[t-15],r=a[t-2],n=(0,o.rotr)(e,7)^(0,o.rotr)(e,18)^e>>>3,i=(0,o.rotr)(r,17)^(0,o.rotr)(r,19)^r>>>10;a[t]=i+a[t-7]+n+a[t-16]|0}let{A:r,B:s,C:l,D:u,E:f,F:d,G:c,H:y}=this;for(let t=0;t<64;t++){let e=(0,o.rotr)(f,6)^(0,o.rotr)(f,11)^(0,o.rotr)(f,25),p=y+e+(0,n.Chi)(f,d,c)+i[t]+a[t]|0,g=(0,o.rotr)(r,2)^(0,o.rotr)(r,13)^(0,o.rotr)(r,22),b=g+(0,n.Maj)(r,s,l)|0;y=c,c=d,d=f,f=u+p|0,u=l,l=s,s=r,r=p+b|0}r=r+this.A|0,s=s+this.B|0,l=l+this.C|0,u=u+this.D|0,f=f+this.E|0,d=d+this.F|0,c=c+this.G|0,y=y+this.H|0,this.set(r,s,l,u,f,d,c,y)}roundClean(){a.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};let SHA224=class SHA224 extends SHA256{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}};e.sha256=(0,o.wrapConstructor)(()=>new SHA256),e.sha224=(0,o.wrapConstructor)(()=>new SHA224)},84589:function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.shake256=e.shake128=e.keccak_512=e.keccak_384=e.keccak_256=e.keccak_224=e.sha3_512=e.sha3_384=e.sha3_256=e.sha3_224=e.Keccak=e.keccakP=void 0;let n=r(79131),o=r(97946),i=r(23037),s=[],a=[],l=[],u=BigInt(0),f=BigInt(1),d=BigInt(2),c=BigInt(7),y=BigInt(256),p=BigInt(113);for(let t=0,e=f,r=1,n=0;t<24;t++){[r,n]=[n,(2*r+3*n)%5],s.push(2*(5*n+r)),a.push((t+1)*(t+2)/2%64);let o=u;for(let t=0;t<7;t++)(e=(e<<f^(e>>c)*p)%y)&d&&(o^=f<<(f<<BigInt(t))-f);l.push(o)}let[g,b]=(0,o.split)(l,!0),rotlH=(t,e,r)=>r>32?(0,o.rotlBH)(t,e,r):(0,o.rotlSH)(t,e,r),rotlL=(t,e,r)=>r>32?(0,o.rotlBL)(t,e,r):(0,o.rotlSL)(t,e,r);function keccakP(t,e=24){let r=new Uint32Array(10);for(let n=24-e;n<24;n++){for(let e=0;e<10;e++)r[e]=t[e]^t[e+10]^t[e+20]^t[e+30]^t[e+40];for(let e=0;e<10;e+=2){let n=(e+8)%10,o=(e+2)%10,i=r[o],s=r[o+1],a=rotlH(i,s,1)^r[n],l=rotlL(i,s,1)^r[n+1];for(let r=0;r<50;r+=10)t[e+r]^=a,t[e+r+1]^=l}let e=t[2],o=t[3];for(let r=0;r<24;r++){let n=a[r],i=rotlH(e,o,n),l=rotlL(e,o,n),u=s[r];e=t[u],o=t[u+1],t[u]=i,t[u+1]=l}for(let e=0;e<50;e+=10){for(let n=0;n<10;n++)r[n]=t[e+n];for(let n=0;n<10;n++)t[e+n]^=~r[(n+2)%10]&r[(n+4)%10]}t[0]^=g[n],t[1]^=b[n]}r.fill(0)}e.keccakP=keccakP;let Keccak=class Keccak extends i.Hash{constructor(t,e,r,o=!1,s=24){if(super(),this.blockLen=t,this.suffix=e,this.outputLen=r,this.enableXOF=o,this.rounds=s,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,(0,n.number)(r),0>=this.blockLen||this.blockLen>=200)throw Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=(0,i.u32)(this.state)}keccak(){i.isLE||(0,i.byteSwap32)(this.state32),keccakP(this.state32,this.rounds),i.isLE||(0,i.byteSwap32)(this.state32),this.posOut=0,this.pos=0}update(t){(0,n.exists)(this);let{blockLen:e,state:r}=this;t=(0,i.toBytes)(t);let o=t.length;for(let n=0;n<o;){let i=Math.min(e-this.pos,o-n);for(let e=0;e<i;e++)r[this.pos++]^=t[n++];this.pos===e&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;let{state:t,suffix:e,pos:r,blockLen:n}=this;t[r]^=e,(128&e)!=0&&r===n-1&&this.keccak(),t[n-1]^=128,this.keccak()}writeInto(t){(0,n.exists)(this,!1),(0,n.bytes)(t),this.finish();let e=this.state,{blockLen:r}=this;for(let n=0,o=t.length;n<o;){this.posOut>=r&&this.keccak();let i=Math.min(r-this.posOut,o-n);t.set(e.subarray(this.posOut,this.posOut+i),n),this.posOut+=i,n+=i}return t}xofInto(t){if(!this.enableXOF)throw Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return(0,n.number)(t),this.xofInto(new Uint8Array(t))}digestInto(t){if((0,n.output)(t,this),this.finished)throw Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){let{blockLen:e,suffix:r,outputLen:n,rounds:o,enableXOF:i}=this;return t||(t=new Keccak(e,r,n,i,o)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=o,t.suffix=r,t.outputLen=n,t.enableXOF=i,t.destroyed=this.destroyed,t}};e.Keccak=Keccak;let gen=(t,e,r)=>(0,i.wrapConstructor)(()=>new Keccak(e,t,r));e.sha3_224=gen(6,144,28),e.sha3_256=gen(6,136,32),e.sha3_384=gen(6,104,48),e.sha3_512=gen(6,72,64),e.keccak_224=gen(1,144,28),e.keccak_256=gen(1,136,32),e.keccak_384=gen(1,104,48),e.keccak_512=gen(1,72,64);let genShake=(t,e,r)=>(0,i.wrapXOFConstructorWithOpts)((n={})=>new Keccak(e,t,void 0===n.dkLen?r:n.dkLen,!0));e.shake128=genShake(31,168,16),e.shake256=genShake(31,136,32)},23037:function(t,e,r){/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */Object.defineProperty(e,"__esModule",{value:!0}),e.randomBytes=e.wrapXOFConstructorWithOpts=e.wrapConstructorWithOpts=e.wrapConstructor=e.checkOpts=e.Hash=e.concatBytes=e.toBytes=e.utf8ToBytes=e.asyncLoop=e.nextTick=e.hexToBytes=e.bytesToHex=e.byteSwap32=e.byteSwapIfBE=e.byteSwap=e.isLE=e.rotl=e.rotr=e.createView=e.u32=e.u8=e.isBytes=void 0;let n=r(38378),o=r(79131);e.isBytes=function(t){return t instanceof Uint8Array||null!=t&&"object"==typeof t&&"Uint8Array"===t.constructor.name},e.u8=t=>new Uint8Array(t.buffer,t.byteOffset,t.byteLength),e.u32=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4)),e.createView=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),e.rotr=(t,e)=>t<<32-e|t>>>e,e.rotl=(t,e)=>t<<e|t>>>32-e>>>0,e.isLE=68===new Uint8Array(new Uint32Array([287454020]).buffer)[0],e.byteSwap=t=>t<<24&4278190080|t<<8&16711680|t>>>8&65280|t>>>24&255,e.byteSwapIfBE=e.isLE?t=>t:t=>(0,e.byteSwap)(t),e.byteSwap32=function(t){for(let r=0;r<t.length;r++)t[r]=(0,e.byteSwap)(t[r])};let i=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));e.bytesToHex=function(t){(0,o.bytes)(t);let e="";for(let r=0;r<t.length;r++)e+=i[t[r]];return e};let s={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function asciiToBase16(t){return t>=s._0&&t<=s._9?t-s._0:t>=s._A&&t<=s._F?t-(s._A-10):t>=s._a&&t<=s._f?t-(s._a-10):void 0}e.hexToBytes=function(t){if("string"!=typeof t)throw Error("hex string expected, got "+typeof t);let e=t.length,r=e/2;if(e%2)throw Error("padded hex string expected, got unpadded hex of length "+e);let n=new Uint8Array(r);for(let e=0,o=0;e<r;e++,o+=2){let r=asciiToBase16(t.charCodeAt(o)),i=asciiToBase16(t.charCodeAt(o+1));if(void 0===r||void 0===i){let e=t[o]+t[o+1];throw Error('hex string expected, got non-hex character "'+e+'" at index '+o)}n[e]=16*r+i}return n};let nextTick=async()=>{};async function asyncLoop(t,r,n){let o=Date.now();for(let i=0;i<t;i++){n(i);let t=Date.now()-o;t>=0&&t<r||(await (0,e.nextTick)(),o+=t)}}function utf8ToBytes(t){if("string"!=typeof t)throw Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function toBytes(t){return"string"==typeof t&&(t=utf8ToBytes(t)),(0,o.bytes)(t),t}e.nextTick=nextTick,e.asyncLoop=asyncLoop,e.utf8ToBytes=utf8ToBytes,e.toBytes=toBytes,e.concatBytes=function(...t){let e=0;for(let r=0;r<t.length;r++){let n=t[r];(0,o.bytes)(n),e+=n.length}let r=new Uint8Array(e);for(let e=0,n=0;e<t.length;e++){let o=t[e];r.set(o,n),n+=o.length}return r},e.Hash=class{clone(){return this._cloneInto()}};let a={}.toString;e.checkOpts=function(t,e){if(void 0!==e&&"[object Object]"!==a.call(e))throw Error("Options should be object or undefined");let r=Object.assign(t,e);return r},e.wrapConstructor=function(t){let hashC=e=>t().update(toBytes(e)).digest(),e=t();return hashC.outputLen=e.outputLen,hashC.blockLen=e.blockLen,hashC.create=()=>t(),hashC},e.wrapConstructorWithOpts=function(t){let hashC=(e,r)=>t(r).update(toBytes(e)).digest(),e=t({});return hashC.outputLen=e.outputLen,hashC.blockLen=e.blockLen,hashC.create=e=>t(e),hashC},e.wrapXOFConstructorWithOpts=function(t){let hashC=(e,r)=>t(r).update(toBytes(e)).digest(),e=t({});return hashC.outputLen=e.outputLen,hashC.blockLen=e.blockLen,hashC.create=e=>t(e),hashC},e.randomBytes=function(t=32){if(n.crypto&&"function"==typeof n.crypto.getRandomValues)return n.crypto.getRandomValues(new Uint8Array(t));throw Error("crypto.getRandomValues must be defined")}},95053:function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.secp256k1=void 0;var n=r(70041);Object.defineProperty(e,"secp256k1",{enumerable:!0,get:function(){return n.secp256k1}})},58040:function(t,e,r){t=r.nmd(t);var n=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.crypto=e.utf8ToBytes=e.createView=e.concatBytes=e.toHex=e.bytesToHex=e.assertBytes=e.assertBool=void 0,e.bytesToUtf8=function(t){if(!(t instanceof Uint8Array))throw TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof t}`);return new TextDecoder().decode(t)},e.hexToBytes=function(t){let e=t.startsWith("0x")?t.substring(2):t;return(0,i.hexToBytes)(e)},e.equalsBytes=function(t,e){if(t.length!==e.length)return!1;for(let r=0;r<t.length;r++)if(t[r]!==e[r])return!1;return!0},e.wrapHash=function(t){return e=>(o.default.bytes(e),t(e))};let o=n(r(79131)),i=r(23037),s=o.default.bool;e.assertBool=s;let a=o.default.bytes;e.assertBytes=a;var l=r(23037);Object.defineProperty(e,"bytesToHex",{enumerable:!0,get:function(){return l.bytesToHex}}),Object.defineProperty(e,"toHex",{enumerable:!0,get:function(){return l.bytesToHex}}),Object.defineProperty(e,"concatBytes",{enumerable:!0,get:function(){return l.concatBytes}}),Object.defineProperty(e,"createView",{enumerable:!0,get:function(){return l.createView}}),Object.defineProperty(e,"utf8ToBytes",{enumerable:!0,get:function(){return l.utf8ToBytes}}),e.crypto=(()=>{let e="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0,r="function"==typeof t.require&&t.require.bind(t);return{node:r&&!e?r("crypto"):void 0,web:e}})()}}]);
//# sourceMappingURL=5983.8025ae224e2f8ae7.js.map