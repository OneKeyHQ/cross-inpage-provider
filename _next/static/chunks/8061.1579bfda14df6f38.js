"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[8061],{78061:function(e,t,r){r.r(t),r.d(t,{SetupWorkerApi:function(){return em},setupWorker:function(){return setupWorker}});var s=r(80912),n=r(59336),until=async e=>{try{let t=await e().catch(e=>{throw e});return{error:null,data:t}}catch(e){return{error:e,data:null}}};let executeHandlers=async({request:e,requestId:t,handlers:r,resolutionContext:s})=>{let n=null,o=null;for(let i of r)if(null!==(o=await i.run({request:e,requestId:t,resolutionContext:s}))&&(n=i),o?.response)break;return n?{handler:n,parsedResult:o?.parsedResult,response:o?.response}:null};var o=r(83866);async function onUnhandledRequest(e,t="warn"){let r=new URL(e.url),n=(0,o.F)(r)+r.search,i="HEAD"===e.method||"GET"===e.method?null:await e.clone().text(),a=`

  \u2022 ${e.method} ${n}

${i?`  \u2022 Request body: ${i}

`:""}`,l=`intercepted a request without a matching request handler:${a}If you still wish to intercept this unhandled request, please create a request handler for it.
Read more: https://mswjs.io/docs/getting-started/mocks`;function applyStrategy(e){switch(e){case"error":throw s.e.error("Error: %s",l),new s.A(s.e.formatMessage('Cannot bypass a request when using the "error" strategy for the "onUnhandledRequest" option.'));case"warn":s.e.warn("Warning: %s",l);break;case"bypass":break;default:throw new s.A(s.e.formatMessage('Failed to react to an unhandled request: unknown strategy "%s". Please provide one of the supported strategies ("bypass", "warn", "error") or a custom callback function as the value of the "onUnhandledRequest" option.',e))}}if("function"==typeof t){t(e,{warning:applyStrategy.bind(null,"warn"),error:applyStrategy.bind(null,"error")});return}"file:"!==r.protocol&&applyStrategy(t)}var i=r(28303),a=r(20148);async function handleRequest(e,t,r,s,n,o){if(n.emit("request:start",{request:e,requestId:t}),e.headers.get("accept")?.includes("msw/passthrough")){n.emit("request:end",{request:e,requestId:t}),o?.onPassthroughResponse?.(e);return}let l=await until(()=>executeHandlers({request:e,requestId:t,handlers:r,resolutionContext:o?.resolutionContext}));if(l.error)throw n.emit("unhandledException",{error:l.error,request:e,requestId:t}),l.error;if(!l.data){await onUnhandledRequest(e,s.onUnhandledRequest),n.emit("request:unhandled",{request:e,requestId:t}),n.emit("request:end",{request:e,requestId:t}),o?.onPassthroughResponse?.(e);return}let{response:c}=l.data;if(!c||302===c.status&&"passthrough"===c.headers.get("x-msw-intention")){n.emit("request:end",{request:e,requestId:t}),o?.onPassthroughResponse?.(e);return}!function(e,t){let r=Reflect.get(t,a.x3);r&&i.k.setCookie(r,e.url)}(e,c),n.emit("request:match",{request:e,requestId:t});let u=l.data;return o?.onMockedResponse?.(c,u),n.emit("request:end",{request:e,requestId:t}),c}function isHandlerKind(e){return t=>null!=t&&"object"==typeof t&&"__kind"in t&&t.__kind===e}var l=r(95002),c=r(36726);let Disposable=class Disposable{subscriptions=[];dispose(){let e;for(;e=this.subscriptions.shift();)e()}};let InMemoryHandlersController=class InMemoryHandlersController{constructor(e){this.initialHandlers=e,this.handlers=[...e]}handlers;prepend(e){this.handlers.unshift(...e)}reset(e){this.handlers=e.length>0?[...e]:[...this.initialHandlers]}currentHandlers(){return this.handlers}};let SetupApi=class SetupApi extends Disposable{handlersController;emitter;publicEmitter;events;constructor(...e){super(),(0,l.kG)(this.validateHandlers(e),s.e.formatMessage("Failed to apply given request handlers: invalid input. Did you forget to spread the request handlers Array?")),this.handlersController=new InMemoryHandlersController(e),this.emitter=new c.Q,this.publicEmitter=new c.Q,function(e,t){let r=e.emit;if(r._isPiped)return;let sourceEmit=function(e,...s){return t.emit(e,...s),r.call(this,e,...s)};sourceEmit._isPiped=!0,e.emit=sourceEmit}(this.emitter,this.publicEmitter),this.events=this.createLifeCycleEvents(),this.subscriptions.push(()=>{this.emitter.removeAllListeners(),this.publicEmitter.removeAllListeners()})}validateHandlers(e){return e.every(e=>!Array.isArray(e))}use(...e){(0,l.kG)(this.validateHandlers(e),s.e.formatMessage('Failed to call "use()" with the given request handlers: invalid input. Did you forget to spread the array of request handlers?')),this.handlersController.prepend(e)}restoreHandlers(){this.handlersController.currentHandlers().forEach(e=>{"isUsed"in e&&(e.isUsed=!1)})}resetHandlers(...e){this.handlersController.reset(e)}listHandlers(){return function(e){let t=[...e];return Object.freeze(t),t}(this.handlersController.currentHandlers())}createLifeCycleEvents(){return{on:(...e)=>this.publicEmitter.on(...e),removeListener:(...e)=>this.publicEmitter.removeListener(...e),removeAllListeners:(...e)=>this.publicEmitter.removeAllListeners(...e)}}};function isObject(e){return null!=e&&"object"==typeof e&&!Array.isArray(e)}var u=r(32753),h=class extends Promise{#e;resolve;reject;constructor(e=null){let t=function(){let executor=(e,t)=>{executor.state="pending",executor.resolve=t=>"pending"!==executor.state?void 0:(executor.result=t,e(t instanceof Promise?t:Promise.resolve(t).then(e=>(executor.state="fulfilled",e)))),executor.reject=e=>{if("pending"===executor.state)return queueMicrotask(()=>{executor.state="rejected"}),t(executor.rejectionReason=e)}};return executor}();super((r,s)=>{t(r,s),e?.(t.resolve,t.reject)}),this.#e=t,this.resolve=this.#e.resolve,this.reject=this.#e.reject}get state(){return this.#e.state}get rejectionReason(){return this.#e.rejectionReason}then(e,t){return this.#t(super.then(e,t))}catch(e){return this.#t(super.catch(e))}finally(e){return this.#t(super.finally(e))}#t(e){return Object.defineProperties(e,{resolve:{configurable:!0,value:this.resolve},reject:{configurable:!0,value:this.reject}})}};function bindEvent(e,t){return Object.defineProperties(t,{target:{value:e,enumerable:!0,writable:!0},currentTarget:{value:e,enumerable:!0,writable:!0}}),t}var d=Symbol("kCancelable"),p=Symbol("kDefaultPrevented"),g=class extends MessageEvent{constructor(e,t){super(e,t),this[d]=!!t.cancelable,this[p]=!1}get cancelable(){return this[d]}set cancelable(e){this[d]=e}get defaultPrevented(){return this[p]}set defaultPrevented(e){this[p]=e}preventDefault(){this.cancelable&&!this[p]&&(this[p]=!0)}},f=class extends Event{constructor(e,t={}){super(e,t),this.code=void 0===t.code?0:t.code,this.reason=void 0===t.reason?"":t.reason,this.wasClean=void 0!==t.wasClean&&t.wasClean}},m=class extends f{constructor(e,t={}){super(e,t),this[d]=!!t.cancelable,this[p]=!1}get cancelable(){return this[d]}set cancelable(e){this[d]=e}get defaultPrevented(){return this[p]}set defaultPrevented(e){this[p]=e}preventDefault(){this.cancelable&&!this[p]&&(this[p]=!0)}},v=Symbol("kEmitter"),y=Symbol("kBoundListener"),b=class{constructor(e,t){this.socket=e,this.transport=t,this.id=(0,u.AZ)(),this.url=new URL(e.url),this[v]=new EventTarget,this.transport.addEventListener("outgoing",e=>{let t=bindEvent(this.socket,new g("message",{data:e.data,origin:e.origin,cancelable:!0}));this[v].dispatchEvent(t),t.defaultPrevented&&e.preventDefault()}),this.transport.addEventListener("close",e=>{this[v].dispatchEvent(bindEvent(this.socket,new f("close",e)))})}addEventListener(e,t,r){if(!Reflect.has(t,y)){let e=t.bind(this.socket);Object.defineProperty(t,y,{value:e,enumerable:!1,configurable:!1})}this[v].addEventListener(e,Reflect.get(t,y),r)}removeEventListener(e,t,r){this[v].removeEventListener(e,Reflect.get(t,y),r)}send(e){this.transport.send(e)}close(e,t){this.transport.close(e,t)}},w="InvalidAccessError: close code out of user configurable range",E=Symbol("kPassthroughPromise"),k=Symbol("kOnSend"),S=Symbol("kClose"),q=class extends EventTarget{constructor(e,t){super(),this.CONNECTING=0,this.OPEN=1,this.CLOSING=2,this.CLOSED=3,this._onopen=null,this._onmessage=null,this._onerror=null,this._onclose=null,this.url=e.toString(),this.protocol="",this.extensions="",this.binaryType="blob",this.readyState=this.CONNECTING,this.bufferedAmount=0,this[E]=new h,queueMicrotask(async()=>{await this[E]||(this.protocol="string"==typeof t?t:Array.isArray(t)&&t.length>0?t[0]:"",this.readyState===this.CONNECTING&&(this.readyState=this.OPEN,this.dispatchEvent(bindEvent(this,new Event("open")))))})}set onopen(e){this.removeEventListener("open",this._onopen),this._onopen=e,null!==e&&this.addEventListener("open",e)}get onopen(){return this._onopen}set onmessage(e){this.removeEventListener("message",this._onmessage),this._onmessage=e,null!==e&&this.addEventListener("message",e)}get onmessage(){return this._onmessage}set onerror(e){this.removeEventListener("error",this._onerror),this._onerror=e,null!==e&&this.addEventListener("error",e)}get onerror(){return this._onerror}set onclose(e){this.removeEventListener("close",this._onclose),this._onclose=e,null!==e&&this.addEventListener("close",e)}get onclose(){return this._onclose}send(e){if(this.readyState===this.CONNECTING)throw this.close(),new DOMException("InvalidStateError");if(this.readyState!==this.CLOSING&&this.readyState!==this.CLOSED)this.bufferedAmount+="string"==typeof e?e.length:e instanceof Blob?e.size:e.byteLength,queueMicrotask(()=>{var t;this.bufferedAmount=0,null==(t=this[k])||t.call(this,e)})}close(e=1e3,t){(0,l.kG)(e,w),(0,l.kG)(1e3===e||e>=3e3&&e<=4999,w),this[S](e,t)}[S](e=1e3,t,r=!0){this.readyState!==this.CLOSING&&this.readyState!==this.CLOSED&&(this.readyState=this.CLOSING,queueMicrotask(()=>{this.readyState=this.CLOSED,this.dispatchEvent(bindEvent(this,new f("close",{code:e,reason:t,wasClean:r}))),this._onopen=null,this._onmessage=null,this._onerror=null,this._onclose=null}))}addEventListener(e,t,r){return super.addEventListener(e,t,r)}removeEventListener(e,t,r){return super.removeEventListener(e,t,r)}};q.CONNECTING=0,q.OPEN=1,q.CLOSING=2,q.CLOSED=3;var R=Symbol("kEmitter"),L=Symbol("kBoundListener"),x=Symbol("kSend"),C=class{constructor(e,t,r){this.client=e,this.transport=t,this.createConnection=r,this[R]=new EventTarget,this.mockCloseController=new AbortController,this.realCloseController=new AbortController,this.transport.addEventListener("outgoing",e=>{void 0!==this.realWebSocket&&queueMicrotask(()=>{e.defaultPrevented||this[x](e.data)})}),this.transport.addEventListener("incoming",this.handleIncomingMessage.bind(this))}get socket(){return(0,l.kG)(this.realWebSocket,'Cannot access "socket" on the original WebSocket server object: the connection is not open. Did you forget to call `server.connect()`?'),this.realWebSocket}connect(){(0,l.kG)(!this.realWebSocket||this.realWebSocket.readyState!==WebSocket.OPEN,'Failed to call "connect()" on the original WebSocket instance: the connection already open');let e=this.createConnection();e.binaryType=this.client.binaryType,e.addEventListener("open",e=>{this[R].dispatchEvent(bindEvent(this.realWebSocket,new Event("open",e)))},{once:!0}),e.addEventListener("message",e=>{this.transport.dispatchEvent(bindEvent(this.realWebSocket,new MessageEvent("incoming",{data:e.data,origin:e.origin})))}),this.client.addEventListener("close",e=>{this.handleMockClose(e)},{signal:this.mockCloseController.signal}),e.addEventListener("close",e=>{this.handleRealClose(e)},{signal:this.realCloseController.signal}),e.addEventListener("error",()=>{let t=bindEvent(e,new Event("error",{cancelable:!0}));this[R].dispatchEvent(t),t.defaultPrevented||this.client.dispatchEvent(bindEvent(this.client,new Event("error")))}),this.realWebSocket=e}addEventListener(e,t,r){if(!Reflect.has(t,L)){let e=t.bind(this.client);Object.defineProperty(t,L,{value:e,enumerable:!1})}this[R].addEventListener(e,Reflect.get(t,L),r)}removeEventListener(e,t,r){this[R].removeEventListener(e,Reflect.get(t,L),r)}send(e){this[x](e)}[x](e){let{realWebSocket:t}=this;if((0,l.kG)(t,'Failed to call "server.send()" for "%s": the connection is not open. Did you forget to call "server.connect()"?',this.client.url),t.readyState!==WebSocket.CLOSING&&t.readyState!==WebSocket.CLOSED){if(t.readyState===WebSocket.CONNECTING){t.addEventListener("open",()=>{t.send(e)},{once:!0});return}t.send(e)}}close(){let{realWebSocket:e}=this;(0,l.kG)(e,'Failed to close server connection for "%s": the connection is not open. Did you forget to call "server.connect()"?',this.client.url),this.realCloseController.abort(),e.readyState!==WebSocket.CLOSING&&e.readyState!==WebSocket.CLOSED&&(e.close(),queueMicrotask(()=>{this[R].dispatchEvent(bindEvent(this.realWebSocket,new m("close",{code:1e3,cancelable:!0})))}))}handleIncomingMessage(e){let t=bindEvent(e.target,new g("message",{data:e.data,origin:e.origin,cancelable:!0}));this[R].dispatchEvent(t),t.defaultPrevented||this.client.dispatchEvent(bindEvent(this.client,new MessageEvent("message",{data:e.data,origin:e.origin})))}handleMockClose(e){this.realWebSocket&&this.realWebSocket.close()}handleRealClose(e){this.mockCloseController.abort();let t=bindEvent(this.realWebSocket,new m("close",{code:e.code,reason:e.reason,wasClean:e.wasClean,cancelable:!0}));this[R].dispatchEvent(t),t.defaultPrevented||this.client[S](e.code,e.reason)}},T=class extends EventTarget{constructor(e){super(),this.socket=e,this.socket.addEventListener("close",e=>{this.dispatchEvent(bindEvent(this.socket,new f("close",e)))}),this.socket[k]=e=>{this.dispatchEvent(bindEvent(this.socket,new g("outgoing",{data:e,origin:this.socket.url,cancelable:!0})))}}addEventListener(e,t,r){return super.addEventListener(e,t,r)}dispatchEvent(e){return super.dispatchEvent(e)}send(e){queueMicrotask(()=>{if(this.socket.readyState===this.socket.CLOSING||this.socket.readyState===this.socket.CLOSED)return;let dispatchEvent=()=>{this.socket.dispatchEvent(bindEvent(this.socket,new MessageEvent("message",{data:e,origin:this.socket.url})))};this.socket.readyState===this.socket.CONNECTING?this.socket.addEventListener("open",()=>{dispatchEvent()},{once:!0}):dispatchEvent()})}close(e,t){this.socket[S](e,t)}},P=class extends u.nK{constructor(){super(P.symbol)}checkEnvironment(){return function(e){let t=Object.getOwnPropertyDescriptor(globalThis,e);return void 0!==t&&("function"!=typeof t.get||void 0!==t.get())&&(void 0!==t.get||null!=t.value)&&(void 0!==t.set||!!t.configurable||(console.error(`[MSW] Failed to apply interceptor: the global \`${e}\` property is non-configurable. This is likely an issue with your environment. If you are using a framework, please open an issue about this in their repository.`),!1))}("WebSocket")}setup(){let e=Object.getOwnPropertyDescriptor(globalThis,"WebSocket"),t=new Proxy(globalThis.WebSocket,{construct:(e,t,r)=>{let[s,n]=t,createConnection=()=>Reflect.construct(e,t,r),o=new q(s,n),i=new T(o);return queueMicrotask(()=>{try{let e=new C(o,i,createConnection),t=this.emitter.emit("connection",{client:new b(o,i),server:e,info:{protocols:n}});t?o[E].resolve(!1):(o[E].resolve(!0),e.connect(),e.addEventListener("open",()=>{o.dispatchEvent(bindEvent(o,new Event("open"))),e.realWebSocket&&(o.protocol=e.realWebSocket.protocol)}))}catch(e){e instanceof Error&&(o.dispatchEvent(new Event("error")),o.readyState!==WebSocket.CLOSING&&o.readyState!==WebSocket.CLOSED&&o[S](1011,e.message,!1),console.error(e))}}),o}});Object.defineProperty(globalThis,"WebSocket",{value:t,configurable:!0}),this.subscriptions.push(()=>{Object.defineProperty(globalThis,"WebSocket",e)})}};P.symbol=Symbol("websocket");let M=new P;r(6291),Symbol("kEmitter");let O=Symbol("kDispatchEvent");Symbol("kSender"),Symbol("kStopPropagationPatched"),Symbol("KOnStopPropagation");var I=r(26157);function getMessageLength(e){return e instanceof Blob?e.size:e instanceof ArrayBuffer?e.byteLength:new Blob([e]).size}function truncateMessage(e){return e.length<=24?e:`${e.slice(0,24)}\u2026`}async function getPublicData(e){if(e instanceof Blob){let t=await e.text();return`Blob(${truncateMessage(t)})`}if("object"==typeof e&&"byteLength"in e){let t=new TextDecoder().decode(e);return`ArrayBuffer(${truncateMessage(t)})`}return truncateMessage(e)}let A={system:"#3b82f6",outgoing:"#22c55e",incoming:"#ef4444",mocked:"#ff6a33"};async function logOutgoingClientMessage(e){let t=getMessageLength(e.data),r=await getPublicData(e.data),n=e.defaultPrevented?"⇡":"⬆";console.groupCollapsed(s.e.formatMessage(`${(0,I.u)({milliseconds:!0})} %c${n}%c ${r} %c${t}%c`),`color:${A.outgoing}`,"color:inherit","color:gray;font-weight:normal","color:inherit;font-weight:inherit"),console.log(e),console.groupEnd()}async function logOutgoingMockedClientMessage(e){let t=getMessageLength(e.data),r=await getPublicData(e.data);console.groupCollapsed(s.e.formatMessage(`${(0,I.u)({milliseconds:!0})} %c\u2B06%c ${r} %c${t}%c`),`color:${A.mocked}`,"color:inherit","color:gray;font-weight:normal","color:inherit;font-weight:inherit"),console.log(e),console.groupEnd()}async function logIncomingMockedClientMessage(e){let t=getMessageLength(e.data),r=await getPublicData(e.data);console.groupCollapsed(s.e.formatMessage(`${(0,I.u)({milliseconds:!0})} %c\u2B07%c ${r} %c${t}%c`),`color:${A.mocked}`,"color:inherit","color:gray;font-weight:normal","color:inherit;font-weight:inherit"),console.log(e),console.groupEnd()}async function logIncomingServerMessage(e){let t=getMessageLength(e.data),r=await getPublicData(e.data),n=e.defaultPrevented?"⇣":"⬇";console.groupCollapsed(s.e.formatMessage(`${(0,I.u)({milliseconds:!0})} %c${n}%c ${r} %c${t}%c`),`color:${A.incoming}`,"color:inherit","color:gray;font-weight:normal","color:inherit;font-weight:inherit"),console.log(e),console.groupEnd()}var W=r(34155),j=/(%?)(%([sdijo]))/g;function format(e,...t){if(0===t.length)return e;let r=0,s=e.replace(j,(e,s,n,o)=>{let i=t[r],a=function(e,t){switch(t){case"s":return e;case"d":case"i":return Number(e);case"j":return JSON.stringify(e);case"o":{if("string"==typeof e)return e;let t=JSON.stringify(e);if("{}"===t||"[]"===t||/^\[object .+?\]$/.test(t))return e;return t}}}(i,o);return s?e:(r++,a)});return r<t.length&&(s+=` ${t.slice(r).join(" ")}`),s=s.replace(/%{2,2}/g,"%")}var N=class extends Error{constructor(e,...t){super(e),this.message=e,this.name="Invariant Violation",this.message=format(e,...t),function(e){if(!e.stack)return;let t=e.stack.split("\n");t.splice(1,2),e.stack=t.join("\n")}(this)}},invariant=(e,t,...r)=>{if(!e)throw new N(t,...r)};function isNodeProcess(){if("undefined"!=typeof navigator&&"ReactNative"===navigator.product)return!0;if(void 0!==W){let e=W.type;return"renderer"!==e&&"worker"!==e&&!!(W.versions&&W.versions.node)}return!1}invariant.as=(e,t,r,...s)=>{if(!t){let t;let n=0===s.length?r:format(r,...s);try{t=Reflect.construct(e,[n])}catch(r){t=e(n)}throw t}};var browser_until=async e=>{try{let t=await e().catch(e=>{throw e});return{error:null,data:t}}catch(e){return{error:e,data:null}}};function getWorkerByRegistration(e,t,r){let s=[e.active,e.installing,e.waiting],n=s.filter(e=>null!=e),o=n.find(e=>r(e.scriptURL,t));return o||null}var getWorkerInstance=async(e,t={},r)=>{let n=new URL(e,location.href).href,o=await navigator.serviceWorker.getRegistrations().then(e=>e.filter(e=>getWorkerByRegistration(e,n,r)));!navigator.serviceWorker.controller&&o.length>0&&location.reload();let[i]=o;if(i)return i.update(),[getWorkerByRegistration(i,n,r),i];let a=await browser_until(async()=>{let s=await navigator.serviceWorker.register(e,t);return[getWorkerByRegistration(s,n,r),s]});if(a.error){let e=a.error.message.includes("(404)");if(e){let e=new URL(t?.scope||"/",location.href);throw Error(s.e.formatMessage(`Failed to register a Service Worker for scope ('${e.href}') with script ('${n}'): Service Worker script does not exist at the given path.

Did you forget to run "npx msw init <PUBLIC_DIR>"?

Learn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`))}throw Error(s.e.formatMessage("Failed to register the Service Worker:\n\n%s",a.error.message))}return a.data};function printStartMessage(e={}){if(e.quiet)return;let t=e.message||"Mocking enabled.";console.groupCollapsed(`%c${s.e.formatMessage(t)}`,"color:orangered;font-weight:bold;"),console.log("%cDocumentation: %chttps://mswjs.io/docs","font-weight:bold","font-weight:normal"),console.log("Found an issue? https://github.com/mswjs/msw/issues"),e.workerUrl&&console.log("Worker script URL:",e.workerUrl),e.workerScope&&console.log("Worker scope:",e.workerScope),e.client&&console.log("Client ID: %s (%s)",e.client.id,e.client.frameType),console.groupEnd()}async function enableMocking(e,t){e.workerChannel.send("MOCK_ACTIVATE");let{payload:r}=await e.events.once("MOCKING_ENABLED");if(e.isMockingEnabled){s.e.warn('Found a redundant "worker.start()" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this "worker.start()" call.');return}e.isMockingEnabled=!0,printStartMessage({quiet:t.quiet,workerScope:e.registration?.scope,workerUrl:e.worker?.scriptURL,client:r.client})}var H=class{constructor(e){this.port=e}postMessage(e,...t){let[r,s]=t;this.port.postMessage({type:e,data:r},{transfer:s})}},createRequestListener=(e,t)=>async(r,o)=>{var i;let a=new H(r.ports[0]),l=o.payload.id,c=(i=o.payload,new Request(i.url,{...i,body:function(e){if(!["HEAD","GET"].includes(e.method))return e.body}(i)})),u=c.clone(),h=c.clone();n.Z.cache.set(c,h),e.requests.set(l,h);try{await handleRequest(c,l,e.getRequestHandlers().filter(isHandlerKind("RequestHandler")),t,e.emitter,{onPassthroughResponse(){a.postMessage("PASSTHROUGH")},async onMockedResponse(r,{handler:s,parsedResult:n}){let o=r.clone(),i=r.clone(),l={status:r.status,statusText:r.statusText,headers:Object.fromEntries(r.headers.entries())};if(e.supports.readableStreamTransfer){let e=r.body;a.postMessage("MOCK_RESPONSE",{...l,body:e},e?[e]:void 0)}else{let e=null===r.body?null:await o.arrayBuffer();a.postMessage("MOCK_RESPONSE",{...l,body:e})}t.quiet||e.emitter.once("response:mocked",()=>{s.log({request:u,response:i,parsedResult:n})})}})}catch(e){e instanceof Error&&(s.e.error(`Uncaught exception in the request handler for "%s %s":

%s

This exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error, as it indicates a mistake in your code. If you wish to mock an error response, please see this guide: https://mswjs.io/docs/recipes/mocking-error-responses`,c.method,c.url,e.stack??e),a.postMessage("MOCK_RESPONSE",{status:500,statusText:"Request Handler Error",headers:{"Content-Type":"application/json"},body:JSON.stringify({name:e.name,message:e.message,stack:e.stack})}))}};async function checkWorkerIntegrity(e){e.workerChannel.send("INTEGRITY_CHECK_REQUEST");let{payload:t}=await e.events.once("INTEGRITY_CHECK_RESPONSE");"00729d72e3b82faf54ca8b9621dbb96f"!==t.checksum&&s.e.warn(`The currently registered Service Worker has been generated by a different version of MSW (${t.packageVersion}) and may not be fully compatible with the installed version.

It's recommended you update your worker script by running this command:

  \u2022 npx msw init <PUBLIC_DIR>

You can also automate this process and make the worker script update automatically upon the library installations. Read more: https://mswjs.io/docs/cli/init.`)}var _=new TextEncoder,D=Symbol("isPatchedModule"),$=class extends Response{static isConfigurableStatusCode(e){return e>=200&&e<=599}static isRedirectResponse(e){return $.STATUS_CODES_WITH_REDIRECT.includes(e)}static isResponseWithBody(e){return!$.STATUS_CODES_WITHOUT_BODY.includes(e)}static setUrl(e,t){e&&""==t.url&&Object.defineProperty(t,"url",{value:e,enumerable:!0,configurable:!0,writable:!1})}constructor(e,t={}){var r;let s=null!=(r=t.status)?r:200,n=$.isConfigurableStatusCode(s)?s:200,o=$.isResponseWithBody(s)?e:null;if(super(o,{...t,status:n}),s!==n){let e=Object.getOwnPropertySymbols(this).find(e=>"state"===e.description);if(e){let t=Reflect.get(this,e);Reflect.set(t,"status",s)}else Object.defineProperty(this,"status",{value:s,enumerable:!0,configurable:!0,writable:!1})}$.setUrl(t.url,this)}};$.STATUS_CODES_WITHOUT_BODY=[101,103,204,205,304],$.STATUS_CODES_WITH_REDIRECT=[301,302,303,307,308];var U=Object.defineProperty,B={};function yellow(e){return`\x1b[33m${e}\x1b[0m`}function blue(e){return`\x1b[34m${e}\x1b[0m`}function gray(e){return`\x1b[90m${e}\x1b[0m`}function red(e){return`\x1b[31m${e}\x1b[0m`}function green(e){return`\x1b[32m${e}\x1b[0m`}((e,t)=>{for(var r in t)U(e,r,{get:t[r],enumerable:!0})})(B,{blue:()=>blue,gray:()=>gray,green:()=>green,red:()=>red,yellow:()=>yellow});var G=isNodeProcess(),F=class{constructor(e){this.name=e,this.prefix=`[${this.name}]`;let t=getVariable("DEBUG"),r=getVariable("LOG_LEVEL"),s="1"===t||"true"===t||void 0!==t&&this.name.startsWith(t);s?(this.debug=isDefinedAndNotEquals(r,"debug")?noop:this.debug,this.info=isDefinedAndNotEquals(r,"info")?noop:this.info,this.success=isDefinedAndNotEquals(r,"success")?noop:this.success,this.warning=isDefinedAndNotEquals(r,"warning")?noop:this.warning,this.error=isDefinedAndNotEquals(r,"error")?noop:this.error):(this.info=noop,this.success=noop,this.warning=noop,this.error=noop,this.only=noop)}prefix;extend(e){return new F(`${this.name}:${e}`)}debug(e,...t){this.logEntry({level:"debug",message:gray(e),positionals:t,prefix:this.prefix,colors:{prefix:"gray"}})}info(e,...t){this.logEntry({level:"info",message:e,positionals:t,prefix:this.prefix,colors:{prefix:"blue"}});let r=new X;return(e,...t)=>{r.measure(),this.logEntry({level:"info",message:`${e} ${gray(`${r.deltaTime}ms`)}`,positionals:t,prefix:this.prefix,colors:{prefix:"blue"}})}}success(e,...t){this.logEntry({level:"info",message:e,positionals:t,prefix:`\u2714 ${this.prefix}`,colors:{timestamp:"green",prefix:"green"}})}warning(e,...t){this.logEntry({level:"warning",message:e,positionals:t,prefix:`\u26A0 ${this.prefix}`,colors:{timestamp:"yellow",prefix:"yellow"}})}error(e,...t){this.logEntry({level:"error",message:e,positionals:t,prefix:`\u2716 ${this.prefix}`,colors:{timestamp:"red",prefix:"red"}})}only(e){e()}createEntry(e,t){return{timestamp:new Date,level:e,message:t}}logEntry(e){let{level:t,message:r,prefix:s,colors:n,positionals:o=[]}=e,i=this.createEntry(t,r),a=n?.timestamp||"gray",l=n?.prefix||"gray",c={timestamp:B[a],prefix:B[l]},u=this.getWriter(t);u([c.timestamp(this.formatTimestamp(i.timestamp))].concat(null!=s?c.prefix(s):[]).concat(serializeInput(r)).join(" "),...o.map(serializeInput))}formatTimestamp(e){return`${e.toLocaleTimeString("en-GB")}:${e.getMilliseconds()}`}getWriter(e){switch(e){case"debug":case"success":case"info":return log;case"warning":return warn;case"error":return error}}},X=class{startTime;endTime;deltaTime;constructor(){this.startTime=performance.now()}measure(){this.endTime=performance.now();let e=this.endTime-this.startTime;this.deltaTime=e.toFixed(2)}},noop=()=>void 0;function log(e,...t){if(G){W.stdout.write(format(e,...t)+"\n");return}console.log(e,...t)}function warn(e,...t){if(G){W.stderr.write(format(e,...t)+"\n");return}console.warn(e,...t)}function error(e,...t){if(G){W.stderr.write(format(e,...t)+"\n");return}console.error(e,...t)}function getVariable(e){return G?W.env[e]:globalThis[e]?.toString()}function isDefinedAndNotEquals(e,t){return void 0!==e&&e!==t}function serializeInput(e){return void 0===e?"undefined":null===e?"null":"string"==typeof e?e:"object"==typeof e?JSON.stringify(e):e.toString()}var z=class extends Error{constructor(e,t,r){super(`Possible EventEmitter memory leak detected. ${r} ${t.toString()} listeners added. Use emitter.setMaxListeners() to increase limit`),this.emitter=e,this.type=t,this.count=r,this.name="MaxListenersExceededWarning"}},K=class{static listenerCount(e,t){return e.listenerCount(t)}constructor(){this.events=new Map,this.maxListeners=K.defaultMaxListeners,this.hasWarnedAboutPotentialMemoryLeak=!1}_emitInternalEvent(e,t,r){this.emit(e,...[t,r])}_getListeners(e){return Array.prototype.concat.apply([],this.events.get(e))||[]}_removeListener(e,t){let r=e.indexOf(t);return r>-1&&e.splice(r,1),[]}_wrapOnceListener(e,t){let onceListener=(...r)=>(this.removeListener(e,onceListener),t.apply(this,r));return Object.defineProperty(onceListener,"name",{value:t.name}),onceListener}setMaxListeners(e){return this.maxListeners=e,this}getMaxListeners(){return this.maxListeners}eventNames(){return Array.from(this.events.keys())}emit(e,...t){let r=this._getListeners(e);return r.forEach(e=>{e.apply(this,t)}),r.length>0}addListener(e,t){this._emitInternalEvent("newListener",e,t);let r=this._getListeners(e).concat(t);if(this.events.set(e,r),this.maxListeners>0&&this.listenerCount(e)>this.maxListeners&&!this.hasWarnedAboutPotentialMemoryLeak){this.hasWarnedAboutPotentialMemoryLeak=!0;let t=new z(this,e,this.listenerCount(e));console.warn(t)}return this}on(e,t){return this.addListener(e,t)}once(e,t){return this.addListener(e,this._wrapOnceListener(e,t))}prependListener(e,t){let r=this._getListeners(e);if(r.length>0){let s=[t].concat(r);this.events.set(e,s)}else this.events.set(e,r.concat(t));return this}prependOnceListener(e,t){return this.prependListener(e,this._wrapOnceListener(e,t))}removeListener(e,t){let r=this._getListeners(e);return r.length>0&&(this._removeListener(r,t),this.events.set(e,r),this._emitInternalEvent("removeListener",e,t)),this}off(e,t){return this.removeListener(e,t)}removeAllListeners(e){return e?this.events.delete(e):this.events.clear(),this}listeners(e){return Array.from(this._getListeners(e))}listenerCount(e){return this._getListeners(e).length}rawListeners(e){return this.listeners(e)}};function getGlobalSymbol(e){return globalThis[e]||void 0}K.defaultMaxListeners=10;var V=class{constructor(e){this.symbol=e,this.readyState="INACTIVE",this.emitter=new K,this.subscriptions=[],this.logger=new F(e.description),this.emitter.setMaxListeners(0),this.logger.info("constructing the interceptor...")}checkEnvironment(){return!0}apply(){let e=this.logger.extend("apply");if(e.info("applying the interceptor..."),"APPLIED"===this.readyState){e.info("intercepted already applied!");return}let t=this.checkEnvironment();if(!t){e.info("the interceptor cannot be applied in this environment!");return}this.readyState="APPLYING";let r=this.getInstance();if(r){e.info("found a running instance, reusing..."),this.on=(t,s)=>(e.info('proxying the "%s" listener',t),r.emitter.addListener(t,s),this.subscriptions.push(()=>{r.emitter.removeListener(t,s),e.info('removed proxied "%s" listener!',t)}),this),this.readyState="APPLIED";return}e.info("no running instance found, setting up a new instance..."),this.setup(),this.setInstance(),this.readyState="APPLIED"}setup(){}on(e,t){let r=this.logger.extend("on");return"DISPOSING"===this.readyState||"DISPOSED"===this.readyState?r.info("cannot listen to events, already disposed!"):(r.info('adding "%s" event listener:',e,t),this.emitter.on(e,t)),this}once(e,t){return this.emitter.once(e,t),this}off(e,t){return this.emitter.off(e,t),this}removeAllListeners(e){return this.emitter.removeAllListeners(e),this}dispose(){let e=this.logger.extend("dispose");if("DISPOSED"===this.readyState){e.info("cannot dispose, already disposed!");return}if(e.info("disposing the interceptor..."),this.readyState="DISPOSING",!this.getInstance()){e.info("no interceptors running, skipping dispose...");return}if(this.clearInstance(),e.info("global symbol deleted:",getGlobalSymbol(this.symbol)),this.subscriptions.length>0){for(let t of(e.info("disposing of %d subscriptions...",this.subscriptions.length),this.subscriptions))t();this.subscriptions=[],e.info("disposed of all subscriptions!",this.subscriptions.length)}this.emitter.removeAllListeners(),e.info("destroyed the listener!"),this.readyState="DISPOSED"}getInstance(){var e;let t=getGlobalSymbol(this.symbol);return this.logger.info("retrieved global instance:",null==(e=null==t?void 0:t.constructor)?void 0:e.name),t}setInstance(){var e;e=this.symbol,globalThis[e]=this,this.logger.info("set global instance!",this.symbol.description)}clearInstance(){var e;e=this.symbol,delete globalThis[e],this.logger.info("cleared global instance!",this.symbol.description)}};function browser_createRequestId(){return Math.random().toString(16).slice(2)}var J=class extends V{constructor(e){J.symbol=Symbol(e.name),super(J.symbol),this.interceptors=e.interceptors}setup(){let e=this.logger.extend("setup");for(let t of(e.info("applying all %d interceptors...",this.interceptors.length),this.interceptors))e.info('applying "%s" interceptor...',t.constructor.name),t.apply(),e.info("adding interceptor dispose subscription"),this.subscriptions.push(()=>t.dispose())}on(e,t){for(let r of this.interceptors)r.on(e,t);return this}once(e,t){for(let r of this.interceptors)r.once(e,t);return this}off(e,t){for(let r of this.interceptors)r.off(e,t);return this}removeAllListeners(e){for(let t of this.interceptors)t.removeAllListeners(e);return this}},createStartHandler=e=>function(t,r){let startWorkerInstance=async()=>{var n;e.events.removeAllListeners(),e.workerChannel.on("REQUEST",createRequestListener(e,t)),e.workerChannel.on("RESPONSE",(t,r)=>{let{payload:s}=r,{requestId:n}=s,o=e.requests.get(n);if(e.requests.delete(n),s.type?.includes("opaque"))return;let i=0===s.status?Response.error():new $($.isResponseWithBody(s.status)?s.body:null,{...s,url:o.url});e.emitter.emit(s.isMockedResponse?"response:mocked":"response:bypass",{response:i,request:o,requestId:s.requestId})});let o=await getWorkerInstance(t.serviceWorker.url,t.serviceWorker.options,t.findWorker),[i,a]=o;if(!i){let e=r?.findWorker?s.e.formatMessage(`Failed to locate the Service Worker registration using a custom "findWorker" predicate.

Please ensure that the custom predicate properly locates the Service Worker registration at "%s".
More details: https://mswjs.io/docs/api/setup-worker/start#findworker
`,t.serviceWorker.url):s.e.formatMessage(`Failed to locate the Service Worker registration.

This most likely means that the worker script URL "%s" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.

Please consider using a custom "serviceWorker.url" option to point to the actual worker script location, or a custom "findWorker" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`,t.serviceWorker.url,location.host);throw Error(e)}return e.worker=i,e.registration=a,e.events.addListener(window,"beforeunload",()=>{"redundant"!==i.state&&e.workerChannel.send("CLIENT_CLOSED"),window.clearInterval(e.keepAliveInterval),window.postMessage({type:"msw/worker:stop"})}),await checkWorkerIntegrity(e).catch(e=>{s.e.error("Error while checking the worker script integrity. Please report this on GitHub (https://github.com/mswjs/msw/issues), including the original error below."),console.error(e)}),e.keepAliveInterval=window.setInterval(()=>e.workerChannel.send("KEEPALIVE_REQUEST"),5e3),n=e.startOptions,n?.quiet||location.href.startsWith(a.scope)||s.e.warn(`Cannot intercept requests on this page because it's outside of the worker's scope ("${a.scope}"). If you wish to mock API requests on this page, you must resolve this scope issue.

- (Recommended) Register the worker at the root level ("/") of your application.
- Set the "Service-Worker-Allowed" response header to allow out-of-scope workers.`),a},n=startWorkerInstance().then(async r=>{let s=r.installing||r.waiting;return s&&await new Promise(e=>{s.addEventListener("statechange",()=>{if("activated"===s.state)return e()})}),await enableMocking(e,t).catch(e=>{throw Error(`Failed to enable mocking: ${e?.message}`)}),r});return n};function printStopMessage(e={}){e.quiet||console.log(`%c${s.e.formatMessage("Mocking disabled.")}`,"color:orangered;font-weight:bold;")}var createStop=e=>function(){if(!e.isMockingEnabled){s.e.warn('Found a redundant "worker.stop()" call. Note that stopping the worker while mocking already stopped has no effect. Consider removing this "worker.stop()" call.');return}e.workerChannel.send("MOCK_DEACTIVATE"),e.isMockingEnabled=!1,window.clearInterval(e.keepAliveInterval),window.postMessage({type:"msw/worker:stop"}),printStopMessage({quiet:e.startOptions?.quiet})},Y={serviceWorker:{url:"/mockServiceWorker.js",options:null},quiet:!1,waitUntilReady:!0,onUnhandledRequest:"warn",findWorker:(e,t)=>e===t},Q=class extends Promise{#e;resolve;reject;constructor(e=null){let t=function(){let executor=(e,t)=>{executor.state="pending",executor.resolve=t=>"pending"!==executor.state?void 0:(executor.result=t,e(t instanceof Promise?t:Promise.resolve(t).then(e=>(executor.state="fulfilled",e)))),executor.reject=e=>{if("pending"===executor.state)return queueMicrotask(()=>{executor.state="rejected"}),t(executor.rejectionReason=e)}};return executor}();super((r,s)=>{t(r,s),e?.(t.resolve,t.reject)}),this.#e=t,this.resolve=this.#e.resolve,this.reject=this.#e.reject}get state(){return this.#e.state}get rejectionReason(){return this.#e.rejectionReason}then(e,t){return this.#t(super.then(e,t))}catch(e){return this.#t(super.catch(e))}finally(e){return this.#t(super.finally(e))}#t(e){return Object.defineProperties(e,{resolve:{configurable:!0,value:this.resolve},reject:{configurable:!0,value:this.reject}})}},Z=class extends Error{constructor(e){super(e),this.name="InterceptorError",Object.setPrototypeOf(this,Z.prototype)}},ee=Symbol("kRequestHandled"),et=Symbol("kResponsePromise"),er=class{constructor(e){this.request=e,this[ee]=!1,this[et]=new Q}respondWith(e){invariant.as(Z,!this[ee],'Failed to respond to the "%s %s" request: the "request" event has already been handled.',this.request.method,this.request.url),this[ee]=!0,this[et].resolve(e)}errorWith(e){invariant.as(Z,!this[ee],'Failed to error the "%s %s" request: the "request" event has already been handled.',this.request.method,this.request.url),this[ee]=!0,this[et].resolve(e)}};async function emitAsync(e,t,...r){let s=e.listeners(t);if(0!==s.length)for(let t of s)await t.apply(e,r)}async function handleRequest2(e){let handleResponse=async t=>(t instanceof Error?e.onError(t):function(e,t){try{return e[t],!0}catch(e){return!1}}(t,"type")&&"error"===t.type?e.onRequestError(t):await e.onResponse(t),!0),handleResponseError=async t=>{if(t instanceof Z)throw r.error;return null!=t&&t instanceof Error&&"code"in t&&"errno"in t?(e.onError(t),!0):t instanceof Response&&await handleResponse(t)};e.emitter.once("request",({requestId:t})=>{t===e.requestId&&"pending"===e.controller[et].state&&e.controller[et].resolve(void 0)});let t=new Q;e.request.signal&&(e.request.signal.aborted?t.reject(e.request.signal.reason):e.request.signal.addEventListener("abort",()=>{t.reject(e.request.signal.reason)},{once:!0}));let r=await browser_until(async()=>{let r=emitAsync(e.emitter,"request",{requestId:e.requestId,request:e.request,controller:e.controller});await Promise.race([t,r,e.controller[et]]);let s=await e.controller[et];return s});if("rejected"===t.state)return e.onError(t.rejectionReason),!0;if(r.error){var s;if(await handleResponseError(r.error))return!0;if(e.emitter.listenerCount("unhandledException")>0){let t=new er(e.request);await emitAsync(e.emitter,"unhandledException",{error:r.error,request:e.request,requestId:e.requestId,controller:t}).then(()=>{"pending"===t[et].state&&t[et].resolve(void 0)});let s=await browser_until(()=>t[et]);if(s.error)return handleResponseError(s.error);if(s.data)return handleResponse(s.data)}return e.onResponse((s=r.error,new Response(JSON.stringify(s instanceof Error?{name:s.name,message:s.message,stack:s.stack}:s),{status:500,statusText:"Unhandled Exception",headers:{"Content-Type":"application/json"}}))),!0}return!!r.data&&handleResponse(r.data)}function browser_hasConfigurableGlobal(e){let t=Object.getOwnPropertyDescriptor(globalThis,e);return void 0!==t&&("function"!=typeof t.get||void 0!==t.get())&&(void 0!==t.get||null!=t.value)&&(void 0!==t.set||!!t.configurable||(console.error(`[MSW] Failed to apply interceptor: the global \`${e}\` property is non-configurable. This is likely an issue with your environment. If you are using a framework, please open an issue about this in their repository.`),!1))}function createNetworkError(e){return Object.assign(TypeError("Failed to fetch"),{cause:e})}var es=["content-encoding","content-language","content-location","content-type","content-length"],en=Symbol("kRedirectCount");async function followFetchRedirect(e,t){let r;if(303!==t.status&&null!=e.body)return Promise.reject(createNetworkError());let s=new URL(e.url);try{r=new URL(t.headers.get("location"),e.url)}catch(e){return Promise.reject(createNetworkError(e))}if(!("http:"===r.protocol||"https:"===r.protocol))return Promise.reject(createNetworkError("URL scheme must be a HTTP(S) scheme"));if(Reflect.get(e,en)>20)return Promise.reject(createNetworkError("redirect count exceeded"));if(Object.defineProperty(e,en,{value:(Reflect.get(e,en)||0)+1}),"cors"===e.mode&&(r.username||r.password)&&!sameOrigin(s,r))return Promise.reject(createNetworkError('cross origin not allowed for request mode "cors"'));let n={};return([301,302].includes(t.status)&&"POST"===e.method||303===t.status&&!["HEAD","GET"].includes(e.method))&&(n.method="GET",n.body=null,es.forEach(t=>{e.headers.delete(t)})),sameOrigin(s,r)||(e.headers.delete("authorization"),e.headers.delete("proxy-authorization"),e.headers.delete("cookie"),e.headers.delete("host")),n.headers=e.headers,fetch(new Request(r,n))}function sameOrigin(e,t){return e.origin===t.origin&&"null"===e.origin||e.protocol===t.protocol&&e.hostname===t.hostname&&e.port===t.port}var eo=class extends TransformStream{constructor(){console.warn("[Interceptors]: Brotli decompression of response streams is not supported in the browser"),super({transform(e,t){t.enqueue(e)}})}},ei=class extends TransformStream{constructor(e,...t){super({},...t);let r=[super.readable,...e].reduce((e,t)=>e.pipeThrough(t));Object.defineProperty(this,"readable",{get:()=>r})}},ea=class extends V{constructor(){super(ea.symbol)}checkEnvironment(){return browser_hasConfigurableGlobal("fetch")}async setup(){let e=globalThis.fetch;invariant(!e[D],'Failed to patch the "fetch" module: already patched.'),globalThis.fetch=async(t,r)=>{let s=browser_createRequestId(),n="string"!=typeof t||"undefined"==typeof location||function(e){try{return new URL(e),!0}catch(e){return!1}}(t)?t:new URL(t,location.origin),o=new Request(n,r),i=new Q,a=new er(o);this.logger.info("[%s] %s",o.method,o.url),this.logger.info("awaiting for the mocked response..."),this.logger.info('emitting the "request" event for %s listener(s)...',this.emitter.listenerCount("request"));let l=await handleRequest2({request:o,requestId:s,emitter:this.emitter,controller:a,onResponse:async e=>{this.logger.info("received mocked response!",{rawResponse:e});let t=function(e){if(null===e.body)return null;let t=function(e){if(""===e)return null;let t=e.toLowerCase().split(",").map(e=>e.trim());if(0===t.length)return null;let r=t.reduceRight((e,t)=>"gzip"===t||"x-gzip"===t?e.concat(new DecompressionStream("gzip")):"deflate"===t?e.concat(new DecompressionStream("deflate")):"br"===t?e.concat(new eo):(e.length=0,e),[]);return new ei(r)}(e.headers.get("content-encoding")||"");return t?(e.body.pipeTo(t.writable),t.readable):null}(e),r=null===t?e:new $(t,e);if($.setUrl(o.url,r),$.isRedirectResponse(r.status)){if("error"===o.redirect){i.reject(createNetworkError("unexpected redirect"));return}if("follow"===o.redirect){followFetchRedirect(o,r).then(e=>{i.resolve(e)},e=>{i.reject(e)});return}}this.emitter.listenerCount("response")>0&&(this.logger.info('emitting the "response" event...'),await emitAsync(this.emitter,"response",{response:r.clone(),isMockedResponse:!0,request:o,requestId:s})),i.resolve(r)},onRequestError:e=>{this.logger.info("request has errored!",{response:e}),i.reject(createNetworkError(e))},onError:e=>{this.logger.info("request has been aborted!",{error:e}),i.reject(e)}});return l?(this.logger.info("request has been handled, returning mock promise..."),i):(this.logger.info("no mocked response received, performing request as-is..."),e(o).then(async e=>{if(this.logger.info("original fetch performed",e),this.emitter.listenerCount("response")>0){this.logger.info('emitting the "response" event...');let t=e.clone();await emitAsync(this.emitter,"response",{response:t,isMockedResponse:!1,request:o,requestId:s})}return e}))},Object.defineProperty(globalThis.fetch,D,{enumerable:!0,configurable:!0,value:!0}),this.subscriptions.push(()=>{Object.defineProperty(globalThis.fetch,D,{value:void 0}),globalThis.fetch=e,this.logger.info('restored native "globalThis.fetch"!',globalThis.fetch.name)})}};ea.symbol=Symbol("fetch");var el=class{constructor(e,t){this.NONE=0,this.CAPTURING_PHASE=1,this.AT_TARGET=2,this.BUBBLING_PHASE=3,this.type="",this.srcElement=null,this.currentTarget=null,this.eventPhase=0,this.isTrusted=!0,this.composed=!1,this.cancelable=!0,this.defaultPrevented=!1,this.bubbles=!0,this.lengthComputable=!0,this.loaded=0,this.total=0,this.cancelBubble=!1,this.returnValue=!0,this.type=e,this.target=(null==t?void 0:t.target)||null,this.currentTarget=(null==t?void 0:t.currentTarget)||null,this.timeStamp=Date.now()}composedPath(){return[]}initEvent(e,t,r){this.type=e,this.bubbles=!!t,this.cancelable=!!r}preventDefault(){this.defaultPrevented=!0}stopPropagation(){}stopImmediatePropagation(){}},ec=class extends el{constructor(e,t){super(e),this.lengthComputable=(null==t?void 0:t.lengthComputable)||!1,this.composed=(null==t?void 0:t.composed)||!1,this.loaded=(null==t?void 0:t.loaded)||0,this.total=(null==t?void 0:t.total)||0}},eu="undefined"!=typeof ProgressEvent;function createProxy(e,t){let r=new Proxy(e,function(e){let{constructorCall:t,methodCall:r,getProperty:s,setProperty:n}=e,o={};return void 0!==t&&(o.construct=function(e,r,s){let n=Reflect.construct.bind(null,e,r,s);return t.call(s,r,n)}),o.set=function(e,t,r){let next=()=>{let s=function findPropertySource(e,t){if(!(t in e))return null;let r=Object.prototype.hasOwnProperty.call(e,t);if(r)return e;let s=Reflect.getPrototypeOf(e);return s?findPropertySource(s,t):null}(e,t)||e,n=Reflect.getOwnPropertyDescriptor(s,t);return void 0!==(null==n?void 0:n.set)?(n.set.apply(e,[r]),!0):Reflect.defineProperty(s,t,{writable:!0,enumerable:!0,configurable:!0,value:r})};return void 0!==n?n.call(e,[t,r],next):next()},o.get=function(e,t,n){let next=()=>e[t],o=void 0!==s?s.call(e,[t,n],next):next();return"function"==typeof o?(...s)=>{let n=o.bind(e,...s);return void 0!==r?r.call(e,[t,s],n):n()}:o},o}(t));return r}async function getBodyByteLength(e){let t=e.headers.get("content-length");if(null!=t&&""!==t)return Number(t);let r=await e.arrayBuffer();return r.byteLength}var eh=Symbol("kIsRequestHandled"),ed=isNodeProcess(),ep=Symbol("kFetchRequest"),eg=class{constructor(e,t){this.initialRequest=e,this.logger=t,this.method="GET",this.url=null,this[eh]=!1,this.events=new Map,this.uploadEvents=new Map,this.requestId=browser_createRequestId(),this.requestHeaders=new Headers,this.responseBuffer=new Uint8Array,this.request=createProxy(e,{setProperty:([e,t],r)=>{if("ontimeout"===e){let s=e.slice(2);return this.request.addEventListener(s,t),r()}return r()},methodCall:([e,t],r)=>{var s;switch(e){case"open":{let[e,s]=t;return void 0===s?(this.method="GET",this.url=toAbsoluteUrl(e)):(this.method=e,this.url=toAbsoluteUrl(s)),this.logger=this.logger.extend(`${this.method} ${this.url.href}`),this.logger.info("open",this.method,this.url.href),r()}case"addEventListener":{let[e,s]=t;return this.registerEvent(e,s),this.logger.info("addEventListener",e,s),r()}case"setRequestHeader":{let[e,s]=t;return this.requestHeaders.set(e,s),this.logger.info("setRequestHeader",e,s),r()}case"send":{let[e]=t;this.request.addEventListener("load",()=>{if(void 0!==this.onResponse){let e=function(e,t){let r=$.isResponseWithBody(e.status)?t:null;return new $(r,{url:e.responseURL,status:e.status,statusText:e.statusText,headers:function(e){let t=new Headers,r=e.split(/[\r\n]+/);for(let e of r){if(""===e.trim())continue;let[r,...s]=e.split(": "),n=s.join(": ");t.append(r,n)}return t}(e.getAllResponseHeaders())})}(this.request,this.request.response);this.onResponse.call(this,{response:e,isMockedResponse:this[eh],request:o,requestId:this.requestId})}});let n="string"==typeof e?_.encode(e):e,o=this.toFetchApiRequest(n);this[ep]=o.clone();let i=(null==(s=this.onRequest)?void 0:s.call(this,{request:o,requestId:this.requestId}))||Promise.resolve();i.finally(()=>{if(!this[eh])return this.logger.info("request callback settled but request has not been handled (readystate %d), performing as-is...",this.request.readyState),ed&&this.request.setRequestHeader("x-interceptors-internal-request-id",this.requestId),r()});break}default:return r()}}}),browser_define(this.request,"upload",createProxy(this.request.upload,{setProperty:([e,t],r)=>{switch(e){case"onloadstart":case"onprogress":case"onaboart":case"onerror":case"onload":case"ontimeout":case"onloadend":{let r=e.slice(2);this.registerUploadEvent(r,t)}}return r()},methodCall:([e,t],r)=>{if("addEventListener"===e){let[e,s]=t;return this.registerUploadEvent(e,s),this.logger.info("upload.addEventListener",e,s),r()}}}))}registerEvent(e,t){let r=this.events.get(e)||[],s=r.concat(t);this.events.set(e,s),this.logger.info('registered event "%s"',e,t)}registerUploadEvent(e,t){let r=this.uploadEvents.get(e)||[],s=r.concat(t);this.uploadEvents.set(e,s),this.logger.info('registered upload event "%s"',e,t)}async respondWith(e){if(this[eh]=!0,this[ep]){let e=await getBodyByteLength(this[ep]);this.trigger("loadstart",this.request.upload,{loaded:0,total:e}),this.trigger("progress",this.request.upload,{loaded:e,total:e}),this.trigger("load",this.request.upload,{loaded:e,total:e}),this.trigger("loadend",this.request.upload,{loaded:e,total:e})}this.logger.info("responding with a mocked response: %d %s",e.status,e.statusText),browser_define(this.request,"status",e.status),browser_define(this.request,"statusText",e.statusText),browser_define(this.request,"responseURL",this.url.href),this.request.getResponseHeader=new Proxy(this.request.getResponseHeader,{apply:(t,r,s)=>{if(this.logger.info("getResponseHeader",s[0]),this.request.readyState<this.request.HEADERS_RECEIVED)return this.logger.info("headers not received yet, returning null"),null;let n=e.headers.get(s[0]);return this.logger.info('resolved response header "%s" to',s[0],n),n}}),this.request.getAllResponseHeaders=new Proxy(this.request.getAllResponseHeaders,{apply:()=>{if(this.logger.info("getAllResponseHeaders"),this.request.readyState<this.request.HEADERS_RECEIVED)return this.logger.info("headers not received yet, returning empty string"),"";let t=Array.from(e.headers.entries()),r=t.map(([e,t])=>`${e}: ${t}`).join("\r\n");return this.logger.info("resolved all response headers to",r),r}}),Object.defineProperties(this.request,{response:{enumerable:!0,configurable:!1,get:()=>this.response},responseText:{enumerable:!0,configurable:!1,get:()=>this.responseText},responseXML:{enumerable:!0,configurable:!1,get:()=>this.responseXML}});let t=await getBodyByteLength(e.clone());this.logger.info("calculated response body length",t),this.trigger("loadstart",this.request,{loaded:0,total:t}),this.setReadyState(this.request.HEADERS_RECEIVED),this.setReadyState(this.request.LOADING);let finalizeResponse=()=>{this.logger.info("finalizing the mocked response..."),this.setReadyState(this.request.DONE),this.trigger("load",this.request,{loaded:this.responseBuffer.byteLength,total:t}),this.trigger("loadend",this.request,{loaded:this.responseBuffer.byteLength,total:t})};if(e.body){this.logger.info("mocked response has body, streaming...");let r=e.body.getReader(),readNextResponseBodyChunk=async()=>{let{value:e,done:s}=await r.read();if(s){this.logger.info("response body stream done!"),finalizeResponse();return}e&&(this.logger.info("read response body chunk:",e),this.responseBuffer=function(e,t){let r=new Uint8Array(e.byteLength+t.byteLength);return r.set(e,0),r.set(t,e.byteLength),r}(this.responseBuffer,e),this.trigger("progress",this.request,{loaded:this.responseBuffer.byteLength,total:t})),readNextResponseBodyChunk()};readNextResponseBodyChunk()}else finalizeResponse()}responseBufferToText(){return function(e,t){let r=new TextDecoder(void 0);return r.decode(e)}(this.responseBuffer)}get response(){if(this.logger.info("getResponse (responseType: %s)",this.request.responseType),this.request.readyState!==this.request.DONE)return null;switch(this.request.responseType){case"json":{let e=function(e){try{let t=JSON.parse(e);return t}catch(e){return null}}(this.responseBufferToText());return this.logger.info("resolved response JSON",e),e}case"arraybuffer":{var e;let t=(e=this.responseBuffer).buffer.slice(e.byteOffset,e.byteOffset+e.byteLength);return this.logger.info("resolved response ArrayBuffer",t),t}case"blob":{let e=this.request.getResponseHeader("Content-Type")||"text/plain",t=new Blob([this.responseBufferToText()],{type:e});return this.logger.info("resolved response Blob (mime type: %s)",t,e),t}default:{let e=this.responseBufferToText();return this.logger.info('resolving "%s" response type as text',this.request.responseType,e),e}}}get responseText(){if(invariant(""===this.request.responseType||"text"===this.request.responseType,"InvalidStateError: The object is in invalid state."),this.request.readyState!==this.request.LOADING&&this.request.readyState!==this.request.DONE)return"";let e=this.responseBufferToText();return this.logger.info('getResponseText: "%s"',e),e}get responseXML(){if(invariant(""===this.request.responseType||"document"===this.request.responseType,"InvalidStateError: The object is in invalid state."),this.request.readyState!==this.request.DONE)return null;let e=this.request.getResponseHeader("Content-Type")||"";return"undefined"==typeof DOMParser?(console.warn("Cannot retrieve XMLHttpRequest response body as XML: DOMParser is not defined. You are likely using an environment that is not browser or does not polyfill browser globals correctly."),null):["application/xhtml+xml","application/xml","image/svg+xml","text/html","text/xml"].some(t=>e.startsWith(t))?new DOMParser().parseFromString(this.responseBufferToText(),e):null}errorWith(e){this[eh]=!0,this.logger.info("responding with an error"),this.setReadyState(this.request.DONE),this.trigger("error",this.request),this.trigger("loadend",this.request)}setReadyState(e){if(this.logger.info("setReadyState: %d -> %d",this.request.readyState,e),this.request.readyState===e){this.logger.info("ready state identical, skipping transition...");return}browser_define(this.request,"readyState",e),this.logger.info("set readyState to: %d",e),e!==this.request.UNSENT&&(this.logger.info('triggerring "readystatechange" event...'),this.trigger("readystatechange",this.request))}trigger(e,t,r){let s=t[`on${e}`],n=function(e,t,r){let s=eu?ProgressEvent:ec,n=["error","progress","loadstart","loadend","load","timeout","abort"].includes(t)?new s(t,{lengthComputable:!0,loaded:(null==r?void 0:r.loaded)||0,total:(null==r?void 0:r.total)||0}):new el(t,{target:e,currentTarget:e});return n}(t,e,r);this.logger.info('trigger "%s"',e,r||""),"function"==typeof s&&(this.logger.info('found a direct "%s" callback, calling...',e),s.call(t,n));let o=t instanceof XMLHttpRequestUpload?this.uploadEvents:this.events;for(let[r,s]of o)r===e&&(this.logger.info('found %d listener(s) for "%s" event, calling...',s.length,e),s.forEach(e=>e.call(t,n)))}toFetchApiRequest(e){this.logger.info("converting request to a Fetch API Request...");let t=e instanceof Document?e.documentElement.innerText:e,r=new Request(this.url.href,{method:this.method,headers:this.requestHeaders,credentials:this.request.withCredentials?"include":"same-origin",body:["GET","HEAD"].includes(this.method.toUpperCase())?null:t}),s=createProxy(r.headers,{methodCall:([e,t],s)=>{switch(e){case"append":case"set":{let[e,r]=t;this.request.setRequestHeader(e,r);break}case"delete":{let[e]=t;console.warn(`XMLHttpRequest: Cannot remove a "${e}" header from the Fetch API representation of the "${r.method} ${r.url}" request. XMLHttpRequest headers cannot be removed.`)}}return s()}});return browser_define(r,"headers",s),this.logger.info("converted request to a Fetch API Request!",r),r}};function toAbsoluteUrl(e){return"undefined"==typeof location?new URL(e):new URL(e.toString(),location.href)}function browser_define(e,t,r){Reflect.defineProperty(e,t,{writable:!0,enumerable:!0,value:r})}var ef=class extends V{constructor(){super(ef.interceptorSymbol)}checkEnvironment(){return browser_hasConfigurableGlobal("XMLHttpRequest")}setup(){let e=this.logger.extend("setup");e.info('patching "XMLHttpRequest" module...');let t=globalThis.XMLHttpRequest;invariant(!t[D],'Failed to patch the "XMLHttpRequest" module: already patched.'),globalThis.XMLHttpRequest=function({emitter:e,logger:t}){let r=new Proxy(globalThis.XMLHttpRequest,{construct(r,s,n){t.info("constructed new XMLHttpRequest");let o=Reflect.construct(r,s,n),i=Object.getOwnPropertyDescriptors(r.prototype);for(let e in i)Reflect.defineProperty(o,e,i[e]);let a=new eg(o,t);return a.onRequest=async function({request:t,requestId:r}){let s=new er(t);this.logger.info("awaiting mocked response..."),this.logger.info('emitting the "request" event for %s listener(s)...',e.listenerCount("request"));let n=await handleRequest2({request:t,requestId:r,controller:s,emitter:e,onResponse:async e=>{await this.respondWith(e)},onRequestError:()=>{this.errorWith(TypeError("Network error"))},onError:e=>{this.logger.info("request errored!",{error:e}),e instanceof Error&&this.errorWith(e)}});n||this.logger.info("no mocked response received, performing request as-is...")},a.onResponse=async function({response:t,isMockedResponse:r,request:s,requestId:n}){this.logger.info('emitting the "response" event for %s listener(s)...',e.listenerCount("response")),e.emit("response",{response:t,isMockedResponse:r,request:s,requestId:n})},a.request}});return r}({emitter:this.emitter,logger:this.logger}),e.info('native "XMLHttpRequest" module patched!',globalThis.XMLHttpRequest.name),Object.defineProperty(globalThis.XMLHttpRequest,D,{enumerable:!0,configurable:!0,value:!0}),this.subscriptions.push(()=>{Object.defineProperty(globalThis.XMLHttpRequest,D,{value:void 0}),globalThis.XMLHttpRequest=t,e.info('native "XMLHttpRequest" module restored!',globalThis.XMLHttpRequest.name)})}};ef.interceptorSymbol=Symbol("xhr");var em=class extends SetupApi{context;startHandler=null;stopHandler=null;listeners;constructor(...e){super(...e),invariant(!isNodeProcess(),s.e.formatMessage("Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.")),this.listeners=[],this.context=this.createWorkerContext()}createWorkerContext(){let e={isMockingEnabled:!1,startOptions:null,worker:null,getRequestHandlers:()=>this.handlersController.currentHandlers(),registration:null,requests:new Map,emitter:this.emitter,workerChannel:{on:(e,t)=>{this.context.events.addListener(navigator.serviceWorker,"message",r=>{if(r.source!==this.context.worker)return;let s=r.data;s&&s.type===e&&t(r,s)})},send:e=>{this.context.worker?.postMessage(e)}},events:{addListener:(e,t,r)=>(e.addEventListener(t,r),this.listeners.push({eventType:t,target:e,callback:r}),()=>{e.removeEventListener(t,r)}),removeAllListeners:()=>{for(let{target:e,eventType:t,callback:r}of this.listeners)e.removeEventListener(t,r);this.listeners=[]},once:e=>{let t=[];return new Promise((r,s)=>{t.push(this.context.events.addListener(navigator.serviceWorker,"message",t=>{try{let s=t.data;s.type===e&&r(s)}catch(e){s(e)}}),this.context.events.addListener(navigator.serviceWorker,"messageerror",s))}).finally(()=>{t.forEach(e=>e())})}},supports:{serviceWorkerApi:!("serviceWorker"in navigator)||"file:"===location.protocol,readableStreamTransfer:function(){try{let e=new ReadableStream({start:e=>e.close()}),t=new MessageChannel;return t.port1.postMessage(e,[e]),!0}catch{return!1}}()}};return this.startHandler=e.supports.serviceWorkerApi?async function(t){e.fallbackInterceptor=function(e,t){let r=new J({name:"fallback",interceptors:[new ea,new ef]});return r.on("request",async({request:r,requestId:s,controller:n})=>{let o=r.clone(),i=await handleRequest(r,s,e.getRequestHandlers().filter(isHandlerKind("RequestHandler")),t,e.emitter,{onMockedResponse(r,{handler:s,parsedResult:n}){t.quiet||e.emitter.once("response:mocked",({response:e})=>{s.log({request:o,response:e,parsedResult:n})})}});i&&n.respondWith(i)}),r.on("response",({response:t,isMockedResponse:r,request:s,requestId:n})=>{e.emitter.emit(r?"response:mocked":"response:bypass",{response:t,request:s,requestId:n})}),r.apply(),r}(e,t),printStartMessage({message:"Mocking enabled (fallback mode).",quiet:t.quiet})}:createStartHandler(e),this.stopHandler=e.supports.serviceWorkerApi?function(){e.fallbackInterceptor?.dispose(),printStopMessage({quiet:e.startOptions?.quiet})}:createStop(e),e}async start(e={}){var t;return!0===e.waitUntilReady&&s.e.warn('The "waitUntilReady" option has been deprecated. Please remove it from this "worker.start()" call. Follow the recommended Browser integration (https://mswjs.io/docs/integrations/browser) to eliminate any race conditions between the Service Worker registration and any requests made by your application on initial render.'),this.context.startOptions=function mergeRight(e,t){return Object.entries(t).reduce((e,[t,r])=>{let s=e[t];return Array.isArray(s)&&Array.isArray(r)?e[t]=s.concat(r):isObject(s)&&isObject(r)?e[t]=mergeRight(s,r):e[t]=r,e},Object.assign({},e))}(Y,e),t={getUnhandledRequestStrategy:()=>this.context.startOptions.onUnhandledRequest,getHandlers:()=>this.handlersController.currentHandlers(),onMockedConnection:e=>{this.context.startOptions.quiet||function(e){let{client:t,server:r}=e;(function(e){let t=(0,o.F)(e.url);console.groupCollapsed(s.e.formatMessage(`${(0,I.u)()} %c\u25B6%c ${t}`),`color:${A.system}`,"color:inherit"),console.log("Client:",e.socket),console.groupEnd()})(t),t.addEventListener("message",e=>{logOutgoingClientMessage(e)}),t.addEventListener("close",e=>{(function(e){let t=e.target,r=(0,o.F)(t.url);console.groupCollapsed(s.e.formatMessage(`${(0,I.u)({milliseconds:!0})} %c\u25A0%c ${r}`),`color:${A.system}`,"color:inherit"),console.log(e),console.groupEnd()})(e)}),t.socket.addEventListener("error",e=>{(function(e){let t=e.target,r=(0,o.F)(t.url);console.groupCollapsed(s.e.formatMessage(`${(0,I.u)({milliseconds:!0})} %c\xd7%c ${r}`),`color:${A.system}`,"color:inherit"),console.log(e),console.groupEnd()})(e)}),t.send=new Proxy(t.send,{apply(e,r,s){let[n]=s,o=new MessageEvent("message",{data:n});return Object.defineProperties(o,{currentTarget:{enumerable:!0,writable:!1,value:t.socket},target:{enumerable:!0,writable:!1,value:t.socket}}),queueMicrotask(()=>{logIncomingMockedClientMessage(o)}),Reflect.apply(e,r,s)}}),r.addEventListener("open",()=>{r.addEventListener("message",e=>{logIncomingServerMessage(e)})},{once:!0}),r.send=new Proxy(r.send,{apply(e,t,s){let[n]=s,o=new MessageEvent("message",{data:n});return Object.defineProperties(o,{currentTarget:{enumerable:!0,writable:!1,value:r.socket},target:{enumerable:!0,writable:!1,value:r.socket}}),logOutgoingMockedClientMessage(o),Reflect.apply(e,t,s)}})}(e)},onPassthroughConnection(){}},M.on("connection",async e=>{let r=t.getHandlers(),s=new MessageEvent("connection",{data:e}),n=[];for(let e of r)isHandlerKind("EventHandler")(e)&&e.predicate({event:s,parsedResult:e.parse({event:s})})&&n.push(e);if(n.length>0)for(let r of(t?.onMockedConnection(e),n))r[O](s);else{let r=new Request(e.client.url,{headers:{upgrade:"websocket",connection:"upgrade"}});await onUnhandledRequest(r,t.getUnhandledRequestStrategy()).catch(t=>{let r=new Event("error");Object.defineProperty(r,"cause",{enumerable:!0,configurable:!1,value:t}),e.client.socket.dispatchEvent(r)}),t?.onPassthroughConnection(e),e.server.connect()}}),M.apply(),this.subscriptions.push(()=>{M.dispose()}),await this.startHandler(this.context.startOptions,e)}stop(){super.dispose(),this.context.events.removeAllListeners(),this.context.emitter.removeAllListeners(),this.stopHandler()}};function setupWorker(...e){return new em(...e)}}}]);
//# sourceMappingURL=8061.1579bfda14df6f38.js.map