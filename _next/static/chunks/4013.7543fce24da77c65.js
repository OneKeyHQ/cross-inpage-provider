"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[4013],{9905:function(t,e,r){r.d(e,{b:function(){return hmac}});var i=r(93527),n=r(66409);let HMAC=class HMAC extends n.kb{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,(0,i.z3)(t);let r=(0,n.O0)(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let o=this.blockLen,s=new Uint8Array(o);s.set(r.length>o?t.create().update(r).digest():r);for(let t=0;t<s.length;t++)s[t]^=54;this.iHash.update(s),this.oHash=t.create();for(let t=0;t<s.length;t++)s[t]^=106;this.oHash.update(s),s.fill(0)}update(t){return(0,i.$h)(this),this.iHash.update(t),this}digestInto(t){(0,i.$h)(this),(0,i.gk)(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){let t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));let{oHash:e,iHash:r,finished:i,destroyed:n,blockLen:o,outputLen:s}=this;return t.finished=i,t.destroyed=n,t.blockLen=o,t.outputLen=s,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}};let hmac=(t,e,r)=>new HMAC(t,e).update(r).digest();hmac.create=(t,e)=>new HMAC(t,e)},4013:function(t,e,r){r.d(e,{B:function(){return HDKey}});var i=r(9905),n=r(4359),o=r(66409);let s=new Uint8Array([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),a=new Uint8Array(Array(16).fill(0).map((t,e)=>e)),l=a.map(t=>(9*t+5)%16),h=[a],u=[l];for(let t=0;t<4;t++)for(let e of[h,u])e.push(e[t].map(t=>s[t]));let d=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(t=>new Uint8Array(t)),c=h.map((t,e)=>t.map(t=>d[e][t])),p=u.map((t,e)=>t.map(t=>d[e][t])),y=new Uint32Array([0,1518500249,1859775393,2400959708,2840853838]),g=new Uint32Array([1352829926,1548603684,1836072691,2053994217,0]);function f(t,e,r,i){return 0===t?e^r^i:1===t?e&r|~e&i:2===t?(e|~r)^i:3===t?e&i|r&~i:e^(r|~i)}let m=new Uint32Array(16);let RIPEMD160=class RIPEMD160 extends n.VR{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){let{h0:t,h1:e,h2:r,h3:i,h4:n}=this;return[t,e,r,i,n]}set(t,e,r,i,n){this.h0=0|t,this.h1=0|e,this.h2=0|r,this.h3=0|i,this.h4=0|n}process(t,e){for(let r=0;r<16;r++,e+=4)m[r]=t.getUint32(e,!0);let r=0|this.h0,i=r,n=0|this.h1,s=n,a=0|this.h2,l=a,d=0|this.h3,w=d,b=0|this.h4,v=b;for(let t=0;t<5;t++){let e=4-t,E=y[t],B=g[t],K=h[t],x=u[t],P=c[t],S=p[t];for(let e=0;e<16;e++){let i=(0,o.XG)(r+f(t,n,a,d)+m[K[e]]+E,P[e])+b|0;r=b,b=d,d=0|(0,o.XG)(a,10),a=n,n=i}for(let t=0;t<16;t++){let r=(0,o.XG)(i+f(e,s,l,w)+m[x[t]]+B,S[t])+v|0;i=v,v=w,w=0|(0,o.XG)(l,10),l=s,s=r}}this.set(this.h1+a+w|0,this.h2+d+v|0,this.h3+b+i|0,this.h4+r+s|0,this.h0+n+l|0)}roundClean(){m.fill(0)}destroy(){this.destroyed=!0,this.buffer.fill(0),this.set(0,0,0,0,0)}};let w=(0,o.hE)(()=>new RIPEMD160);var b=r(17748),v=r(74736),E=r(93527),B=r(57010),K=r(55525),x=r(27499);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function validateSigVerOpts(t){void 0!==t.lowS&&(0,x.uw)("lowS",t.lowS),void 0!==t.prehash&&(0,x.uw)("prehash",t.prehash)}let{bytesToNumberBE:P,hexToBytes:S}=x,N={Err:class extends Error{constructor(t=""){super(t)}},_tlv:{encode:(t,e)=>{let{Err:r}=N;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(1&e.length)throw new r("tlv.encode: unpadded data");let i=e.length/2,n=x.uz(i);if(n.length/2&128)throw new r("tlv.encode: long form length too big");let o=i>127?x.uz(n.length/2|128):"",s=x.uz(t);return s+o+n+e},decode(t,e){let{Err:r}=N,i=0;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(e.length<2||e[i++]!==t)throw new r("tlv.decode: wrong tlv");let n=e[i++],o=!!(128&n),s=0;if(o){let t=127&n;if(!t)throw new r("tlv.decode(long): indefinite length not supported");if(t>4)throw new r("tlv.decode(long): byte length is too big");let o=e.subarray(i,i+t);if(o.length!==t)throw new r("tlv.decode: length bytes not complete");if(0===o[0])throw new r("tlv.decode(long): zero leftmost byte");for(let t of o)s=s<<8|t;if(i+=t,s<128)throw new r("tlv.decode(long): not minimal encoding")}else s=n;let a=e.subarray(i,i+s);if(a.length!==s)throw new r("tlv.decode: wrong value length");return{v:a,l:e.subarray(i+s)}}},_int:{encode(t){let{Err:e}=N;if(t<A)throw new e("integer: negative integers are not allowed");let r=x.uz(t);if(8&Number.parseInt(r[0],16)&&(r="00"+r),1&r.length)throw new e("unexpected DER parsing assertion: unpadded hex");return r},decode(t){let{Err:e}=N;if(128&t[0])throw new e("invalid signature integer: negative");if(0===t[0]&&!(128&t[1]))throw new e("invalid signature integer: unnecessary leading zero");return P(t)}},toSig(t){let{Err:e,_int:r,_tlv:i}=N,n="string"==typeof t?S(t):t;x.gk(n);let{v:o,l:s}=i.decode(48,n);if(s.length)throw new e("invalid signature: left bytes after parsing");let{v:a,l:l}=i.decode(2,o),{v:h,l:u}=i.decode(2,l);if(u.length)throw new e("invalid signature: left bytes after parsing");return{r:r.decode(a),s:r.decode(h)}},hexFromSig(t){let{_tlv:e,_int:r}=N,i=e.encode(2,r.encode(t.r)),n=e.encode(2,r.encode(t.s));return e.encode(48,i+n)}},A=BigInt(0),H=BigInt(1),O=(BigInt(2),BigInt(3));BigInt(4);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */let I=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),R=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),T=BigInt(1),q=BigInt(2),divNearest=(t,e)=>(t+e/q)/e,U=(0,K.gN)(I,void 0,void 0,{sqrt:function(t){let e=BigInt(3),r=BigInt(6),i=BigInt(11),n=BigInt(22),o=BigInt(23),s=BigInt(44),a=BigInt(88),l=t*t*t%I,h=l*l*t%I,u=(0,K.oA)(h,e,I)*h%I,d=(0,K.oA)(u,e,I)*h%I,c=(0,K.oA)(d,q,I)*l%I,p=(0,K.oA)(c,i,I)*c%I,y=(0,K.oA)(p,n,I)*p%I,g=(0,K.oA)(y,s,I)*y%I,m=(0,K.oA)(g,a,I)*g%I,w=(0,K.oA)(m,s,I)*y%I,b=(0,K.oA)(w,e,I)*h%I,v=(0,K.oA)(b,o,I)*p%I,E=(0,K.oA)(v,r,I)*l%I,B=(0,K.oA)(E,q,I);if(!U.eql(U.sqr(B),t))throw Error("Cannot find square root");return B}}),C=function(t,e){let create=e=>(function(t){let e=function(t){let e=(0,B.Kd)(t);return x.FF(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:r,n:i}=e,n=r.BYTES+1,o=2*r.BYTES+1;function modN(t){return(0,K.wQ)(t,i)}function invN(t){return(0,K.U_)(t,i)}let{ProjectivePoint:s,normPrivateKeyToScalar:a,weierstrassEquation:l,isWithinCurveOrder:h}=function(t){let e=function(t){let e=(0,B.Kd)(t);x.FF(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});let{endo:r,Fp:i,a:n}=e;if(r){if(!i.eql(n,i.ZERO))throw Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if("object"!=typeof r||"bigint"!=typeof r.beta||"function"!=typeof r.splitScalar)throw Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...e})}(t),{Fp:r}=e,i=(0,K.gN)(e.n,e.nBitLength),n=e.toBytes||((t,e,i)=>{let n=e.toAffine();return x.eV(Uint8Array.from([4]),r.toBytes(n.x),r.toBytes(n.y))}),o=e.fromBytes||(t=>{let e=t.subarray(1),i=r.fromBytes(e.subarray(0,r.BYTES)),n=r.fromBytes(e.subarray(r.BYTES,2*r.BYTES));return{x:i,y:n}});function weierstrassEquation(t){let{a:i,b:n}=e,o=r.sqr(t),s=r.mul(o,t);return r.add(r.add(s,r.mul(t,i)),n)}if(!r.eql(r.sqr(e.Gy),weierstrassEquation(e.Gx)))throw Error("bad generator point: equation left != right");function normPrivateKeyToScalar(t){let r;let{allowedPrivateKeyLengths:i,nByteLength:n,wrapPrivateKey:o,n:s}=e;if(i&&"bigint"!=typeof t){if(x._t(t)&&(t=x.ci(t)),"string"!=typeof t||!i.includes(t.length))throw Error("invalid private key");t=t.padStart(2*n,"0")}try{r="bigint"==typeof t?t:x.bytesToNumberBE((0,x.ql)("private key",t,n))}catch(e){throw Error("invalid private key, expected hex or "+n+" bytes, got "+typeof t)}return o&&(r=(0,K.wQ)(r,s)),x.Fy("private key",r,H,s),r}function assertPrjPoint(t){if(!(t instanceof Point))throw Error("ProjectivePoint expected")}let s=(0,x.H9)((t,e)=>{let{px:i,py:n,pz:o}=t;if(r.eql(o,r.ONE))return{x:i,y:n};let s=t.is0();null==e&&(e=s?r.ONE:r.inv(o));let a=r.mul(i,e),l=r.mul(n,e),h=r.mul(o,e);if(s)return{x:r.ZERO,y:r.ZERO};if(!r.eql(h,r.ONE))throw Error("invZ was invalid");return{x:a,y:l}}),a=(0,x.H9)(t=>{if(t.is0()){if(e.allowInfinityPoint&&!r.is0(t.py))return;throw Error("bad point: ZERO")}let{x:i,y:n}=t.toAffine();if(!r.isValid(i)||!r.isValid(n))throw Error("bad point: x or y not FE");let o=r.sqr(n),s=weierstrassEquation(i);if(!r.eql(o,s))throw Error("bad point: equation left != right");if(!t.isTorsionFree())throw Error("bad point: not in prime-order subgroup");return!0});let Point=class Point{constructor(t,e,i){if(this.px=t,this.py=e,this.pz=i,null==t||!r.isValid(t))throw Error("x required");if(null==e||!r.isValid(e))throw Error("y required");if(null==i||!r.isValid(i))throw Error("z required");Object.freeze(this)}static fromAffine(t){let{x:e,y:i}=t||{};if(!t||!r.isValid(e)||!r.isValid(i))throw Error("invalid affine point");if(t instanceof Point)throw Error("projective point not allowed");let is0=t=>r.eql(t,r.ZERO);return is0(e)&&is0(i)?Point.ZERO:new Point(e,i,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){let e=r.invertBatch(t.map(t=>t.pz));return t.map((t,r)=>t.toAffine(e[r])).map(Point.fromAffine)}static fromHex(t){let e=Point.fromAffine(o((0,x.ql)("pointHex",t)));return e.assertValidity(),e}static fromPrivateKey(t){return Point.BASE.multiply(normPrivateKeyToScalar(t))}static msm(t,e){return(0,B.D1)(Point,i,t,e)}_setWindowSize(t){h.setWindowSize(this,t)}assertValidity(){a(this)}hasEvenY(){let{y:t}=this.toAffine();if(r.isOdd)return!r.isOdd(t);throw Error("Field doesn't support isOdd")}equals(t){assertPrjPoint(t);let{px:e,py:i,pz:n}=this,{px:o,py:s,pz:a}=t,l=r.eql(r.mul(e,a),r.mul(o,n)),h=r.eql(r.mul(i,a),r.mul(s,n));return l&&h}negate(){return new Point(this.px,r.neg(this.py),this.pz)}double(){let{a:t,b:i}=e,n=r.mul(i,O),{px:o,py:s,pz:a}=this,l=r.ZERO,h=r.ZERO,u=r.ZERO,d=r.mul(o,o),c=r.mul(s,s),p=r.mul(a,a),y=r.mul(o,s);return y=r.add(y,y),u=r.mul(o,a),u=r.add(u,u),l=r.mul(t,u),h=r.mul(n,p),h=r.add(l,h),l=r.sub(c,h),h=r.add(c,h),h=r.mul(l,h),l=r.mul(y,l),u=r.mul(n,u),p=r.mul(t,p),y=r.sub(d,p),y=r.mul(t,y),y=r.add(y,u),u=r.add(d,d),d=r.add(u,d),d=r.add(d,p),d=r.mul(d,y),h=r.add(h,d),p=r.mul(s,a),p=r.add(p,p),d=r.mul(p,y),l=r.sub(l,d),u=r.mul(p,c),u=r.add(u,u),u=r.add(u,u),new Point(l,h,u)}add(t){assertPrjPoint(t);let{px:i,py:n,pz:o}=this,{px:s,py:a,pz:l}=t,h=r.ZERO,u=r.ZERO,d=r.ZERO,c=e.a,p=r.mul(e.b,O),y=r.mul(i,s),g=r.mul(n,a),m=r.mul(o,l),w=r.add(i,n),b=r.add(s,a);w=r.mul(w,b),b=r.add(y,g),w=r.sub(w,b),b=r.add(i,o);let v=r.add(s,l);return b=r.mul(b,v),v=r.add(y,m),b=r.sub(b,v),v=r.add(n,o),h=r.add(a,l),v=r.mul(v,h),h=r.add(g,m),v=r.sub(v,h),d=r.mul(c,b),h=r.mul(p,m),d=r.add(h,d),h=r.sub(g,d),d=r.add(g,d),u=r.mul(h,d),g=r.add(y,y),g=r.add(g,y),m=r.mul(c,m),b=r.mul(p,b),g=r.add(g,m),m=r.sub(y,m),m=r.mul(c,m),b=r.add(b,m),y=r.mul(g,b),u=r.add(u,y),y=r.mul(v,b),h=r.mul(w,h),h=r.sub(h,y),y=r.mul(w,g),d=r.mul(v,d),d=r.add(d,y),new Point(h,u,d)}subtract(t){return this.add(t.negate())}is0(){return this.equals(Point.ZERO)}wNAF(t){return h.wNAFCached(this,t,Point.normalizeZ)}multiplyUnsafe(t){let{endo:i,n:n}=e;x.Fy("scalar",t,A,n);let o=Point.ZERO;if(t===A)return o;if(this.is0()||t===H)return this;if(!i||h.hasPrecomputes(this))return h.wNAFCachedUnsafe(this,t,Point.normalizeZ);let{k1neg:s,k1:a,k2neg:l,k2:u}=i.splitScalar(t),d=o,c=o,p=this;for(;a>A||u>A;)a&H&&(d=d.add(p)),u&H&&(c=c.add(p)),p=p.double(),a>>=H,u>>=H;return s&&(d=d.negate()),l&&(c=c.negate()),c=new Point(r.mul(c.px,i.beta),c.py,c.pz),d.add(c)}multiply(t){let i,n;let{endo:o,n:s}=e;if(x.Fy("scalar",t,H,s),o){let{k1neg:e,k1:s,k2neg:a,k2:l}=o.splitScalar(t),{p:u,f:d}=this.wNAF(s),{p:c,f:p}=this.wNAF(l);u=h.constTimeNegate(e,u),c=h.constTimeNegate(a,c),c=new Point(r.mul(c.px,o.beta),c.py,c.pz),i=u.add(c),n=d.add(p)}else{let{p:e,f:r}=this.wNAF(t);i=e,n=r}return Point.normalizeZ([i,n])[0]}multiplyAndAddUnsafe(t,e,r){let i=Point.BASE,mul=(t,e)=>e!==A&&e!==H&&t.equals(i)?t.multiply(e):t.multiplyUnsafe(e),n=mul(this,e).add(mul(t,r));return n.is0()?void 0:n}toAffine(t){return s(this,t)}isTorsionFree(){let{h:t,isTorsionFree:r}=e;if(t===H)return!0;if(r)return r(Point,this);throw Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){let{h:t,clearCofactor:r}=e;return t===H?this:r?r(Point,this):this.multiplyUnsafe(e.h)}toRawBytes(t=!0){return(0,x.uw)("isCompressed",t),this.assertValidity(),n(Point,this,t)}toHex(t=!0){return(0,x.uw)("isCompressed",t),x.ci(this.toRawBytes(t))}};Point.BASE=new Point(e.Gx,e.Gy,r.ONE),Point.ZERO=new Point(r.ZERO,r.ONE,r.ZERO);let l=e.nBitLength,h=(0,B.Mx)(Point,e.endo?Math.ceil(l/2):l);return{CURVE:e,ProjectivePoint:Point,normPrivateKeyToScalar,weierstrassEquation,isWithinCurveOrder:function(t){return x.Z2(t,H,e.n)}}}({...e,toBytes(t,e,i){let n=e.toAffine(),o=r.toBytes(n.x),s=x.eV;return((0,x.uw)("isCompressed",i),i)?s(Uint8Array.from([e.hasEvenY()?2:3]),o):s(Uint8Array.from([4]),o,r.toBytes(n.y))},fromBytes(t){let e=t.length,i=t[0],s=t.subarray(1);if(e===n&&(2===i||3===i)){let t;let e=x.bytesToNumberBE(s);if(!x.Z2(e,H,r.ORDER))throw Error("Point is not on curve");let n=l(e);try{t=r.sqrt(n)}catch(e){let t=e instanceof Error?": "+e.message:"";throw Error("Point is not on curve"+t)}let o=(t&H)===H;return(1&i)==1!==o&&(t=r.neg(t)),{x:e,y:t}}if(e===o&&4===i){let t=r.fromBytes(s.subarray(0,r.BYTES)),e=r.fromBytes(s.subarray(r.BYTES,2*r.BYTES));return{x:t,y:e}}throw Error("invalid Point, expected length of "+n+", or uncompressed "+o+", got "+e)}}),numToNByteStr=t=>x.ci(x.tL(t,e.nByteLength));function isBiggerThanHalfOrder(t){let e=i>>H;return t>e}let slcNum=(t,e,r)=>x.bytesToNumberBE(t.slice(e,r));let Signature=class Signature{constructor(t,e,r){this.r=t,this.s=e,this.recovery=r,this.assertValidity()}static fromCompact(t){let r=e.nByteLength;return t=(0,x.ql)("compactSignature",t,2*r),new Signature(slcNum(t,0,r),slcNum(t,r,2*r))}static fromDER(t){let{r:e,s:r}=N.toSig((0,x.ql)("DER",t));return new Signature(e,r)}assertValidity(){x.Fy("r",this.r,H,i),x.Fy("s",this.s,H,i)}addRecoveryBit(t){return new Signature(this.r,this.s,t)}recoverPublicKey(t){let{r:i,s:n,recovery:o}=this,a=d((0,x.ql)("msgHash",t));if(null==o||![0,1,2,3].includes(o))throw Error("recovery id invalid");let l=2===o||3===o?i+e.n:i;if(l>=r.ORDER)throw Error("recovery id 2 or 3 invalid");let h=(1&o)==0?"02":"03",u=s.fromHex(h+numToNByteStr(l)),c=invN(l),p=modN(-a*c),y=modN(n*c),g=s.BASE.multiplyAndAddUnsafe(u,p,y);if(!g)throw Error("point at infinify");return g.assertValidity(),g}hasHighS(){return isBiggerThanHalfOrder(this.s)}normalizeS(){return this.hasHighS()?new Signature(this.r,modN(-this.s),this.recovery):this}toDERRawBytes(){return x.hexToBytes(this.toDERHex())}toDERHex(){return N.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return x.hexToBytes(this.toCompactHex())}toCompactHex(){return numToNByteStr(this.r)+numToNByteStr(this.s)}};function isProbPub(t){let e=x._t(t),r="string"==typeof t,i=(e||r)&&t.length;return e?i===n||i===o:r?i===2*n||i===2*o:t instanceof s}let u=e.bits2int||function(t){if(t.length>8192)throw Error("input is too large");let r=x.bytesToNumberBE(t),i=8*t.length-e.nBitLength;return i>0?r>>BigInt(i):r},d=e.bits2int_modN||function(t){return modN(u(t))},c=x.dQ(e.nBitLength);function int2octets(t){return x.Fy("num < 2^"+e.nBitLength,t,A,c),x.tL(t,e.nByteLength)}let p={lowS:e.lowS,prehash:!1},y={lowS:e.lowS,prehash:!1};return s.BASE._setWindowSize(8),{CURVE:e,getPublicKey:function(t,e=!0){return s.fromPrivateKey(t).toRawBytes(e)},getSharedSecret:function(t,e,r=!0){if(isProbPub(t))throw Error("first arg must be private key");if(!isProbPub(e))throw Error("second arg must be public key");let i=s.fromHex(e);return i.multiply(a(t)).toRawBytes(r)},sign:function(t,i,n=p){let{seed:o,k2sig:l}=function(t,i,n=p){if(["recovered","canonical"].some(t=>t in n))throw Error("sign() legacy options not supported");let{hash:o,randomBytes:l}=e,{lowS:c,prehash:y,extraEntropy:g}=n;null==c&&(c=!0),t=(0,x.ql)("msgHash",t),validateSigVerOpts(n),y&&(t=(0,x.ql)("prehashed msgHash",o(t)));let m=d(t),w=a(i),b=[int2octets(w),int2octets(m)];if(null!=g&&!1!==g){let t=!0===g?l(r.BYTES):g;b.push((0,x.ql)("extraEntropy",t))}let v=x.eV(...b);return{seed:v,k2sig:function(t){let e=u(t);if(!h(e))return;let r=invN(e),i=s.BASE.multiply(e).toAffine(),n=modN(i.x);if(n===A)return;let o=modN(r*modN(m+n*w));if(o===A)return;let a=(i.x===n?0:2)|Number(i.y&H),l=o;return c&&isBiggerThanHalfOrder(o)&&(l=isBiggerThanHalfOrder(o)?modN(-o):o,a^=1),new Signature(n,l,a)}}}(t,i,n),c=x.n$(e.hash.outputLen,e.nByteLength,e.hmac);return c(o,l)},verify:function(t,r,i,n=y){let o,a;r=(0,x.ql)("msgHash",r),i=(0,x.ql)("publicKey",i);let{lowS:l,prehash:h,format:u}=n;if(validateSigVerOpts(n),"strict"in n)throw Error("options.strict was renamed to lowS");if(void 0!==u&&"compact"!==u&&"der"!==u)throw Error("format must be compact or der");let c="string"==typeof t||x._t(t),p=!c&&!u&&"object"==typeof t&&null!==t&&"bigint"==typeof t.r&&"bigint"==typeof t.s;if(!c&&!p)throw Error("invalid signature, expected Uint8Array, hex string or Signature instance");try{if(p&&(a=new Signature(t.r,t.s)),c){try{"compact"!==u&&(a=Signature.fromDER(t))}catch(t){if(!(t instanceof N.Err))throw t}a||"der"===u||(a=Signature.fromCompact(t))}o=s.fromHex(i)}catch(t){return!1}if(!a||l&&a.hasHighS())return!1;h&&(r=e.hash(r));let{r:g,s:m}=a,w=d(r),b=invN(m),v=modN(w*b),E=modN(g*b),B=s.BASE.multiplyAndAddUnsafe(o,v,E)?.toAffine();if(!B)return!1;let K=modN(B.x);return K===g},ProjectivePoint:s,Signature,utils:{isValidPrivateKey(t){try{return a(t),!0}catch(t){return!1}},normPrivateKeyToScalar:a,randomPrivateKey:()=>{let t=(0,K.PS)(e.n);return(0,K.Us)(e.randomBytes(t),e.n)},precompute:(t=8,e=s.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)}}})({...t,hash:e,hmac:(t,...r)=>(0,i.b)(e,t,(0,o.eV)(...r)),randomBytes:o.O6});return{...create(e),create}}({a:BigInt(0),b:BigInt(7),Fp:U,n:R,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{let e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-T*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),n=BigInt("0x100000000000000000000000000000000"),o=divNearest(e*t,R),s=divNearest(-r*t,R),a=(0,K.wQ)(t-o*e-s*i,R),l=(0,K.wQ)(-o*r-s*e,R),h=a>n,u=l>n;if(h&&(a=R-a),u&&(l=R-l),a>n||l>n)throw Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:h,k1:a,k2neg:u,k2:l}}}},b.JQ);BigInt(0),C.ProjectivePoint;var z=r(47410);/*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */let k=C.ProjectivePoint,F=(0,z.Xd)(b.JQ);function bytesToNumber(t){(0,E.gk)(t);let e=0===t.length?"0":(0,o.ci)(t);return BigInt("0x"+e)}let V=(0,o.iY)("Bitcoin seed"),L={private:76066276,public:76067358},hash160=t=>w((0,b.JQ)(t)),fromU32=t=>(0,o.GL)(t).getUint32(0,!1),toU32=t=>{if(!Number.isSafeInteger(t)||t<0||t>4294967296-1)throw Error("invalid number, should be from 0 to 2**32-1, got "+t);let e=new Uint8Array(4);return(0,o.GL)(e).setUint32(0,t,!1),e};let HDKey=class HDKey{get fingerprint(){if(!this.pubHash)throw Error("No publicKey set!");return fromU32(this.pubHash)}get identifier(){return this.pubHash}get pubKeyHash(){return this.pubHash}get privateKey(){return this.privKeyBytes||null}get publicKey(){return this.pubKey||null}get privateExtendedKey(){let t=this.privateKey;if(!t)throw Error("No private key");return F.encode(this.serialize(this.versions.private,(0,o.eV)(new Uint8Array([0]),t)))}get publicExtendedKey(){if(!this.pubKey)throw Error("No public key");return F.encode(this.serialize(this.versions.public,this.pubKey))}static fromMasterSeed(t,e=L){if((0,E.gk)(t),8*t.length<128||8*t.length>512)throw Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got "+t.length);let r=(0,i.b)(v.o,V,t);return new HDKey({versions:e,chainCode:r.slice(32),privateKey:r.slice(0,32)})}static fromExtendedKey(t,e=L){let r=F.decode(t),i=(0,o.GL)(r),n=i.getUint32(0,!1),s={versions:e,depth:r[4],parentFingerprint:i.getUint32(5,!1),index:i.getUint32(9,!1),chainCode:r.slice(13,45)},a=r.slice(45),l=0===a[0];if(n!==e[l?"private":"public"])throw Error("Version mismatch");return new HDKey(l?{...s,privateKey:a.slice(1)}:{...s,publicKey:a})}static fromJSON(t){return HDKey.fromExtendedKey(t.xpriv)}constructor(t){if(this.depth=0,this.index=0,this.chainCode=null,this.parentFingerprint=0,!t||"object"!=typeof t)throw Error("HDKey.constructor must not be called directly");if(this.versions=t.versions||L,this.depth=t.depth||0,this.chainCode=t.chainCode||null,this.index=t.index||0,this.parentFingerprint=t.parentFingerprint||0,!this.depth&&(this.parentFingerprint||this.index))throw Error("HDKey: zero depth with non-zero index/parent fingerprint");if(t.publicKey&&t.privateKey)throw Error("HDKey: publicKey and privateKey at same time.");if(t.privateKey){if(!C.utils.isValidPrivateKey(t.privateKey))throw Error("Invalid private key");this.privKey="bigint"==typeof t.privateKey?t.privateKey:bytesToNumber(t.privateKey),this.privKeyBytes=function(t){if("bigint"!=typeof t)throw Error("bigint expected");return(0,o.nr)(t.toString(16).padStart(64,"0"))}(this.privKey),this.pubKey=C.getPublicKey(t.privateKey,!0)}else if(t.publicKey)this.pubKey=k.fromHex(t.publicKey).toRawBytes(!0);else throw Error("HDKey: no public or private key provided");this.pubHash=hash160(this.pubKey)}derive(t){if(!/^[mM]'?/.test(t))throw Error('Path must start with "m" or "M"');if(/^[mM]'?$/.test(t))return this;let e=t.replace(/^[mM]'?\//,"").split("/"),r=this;for(let t of e){let e=/^(\d+)('?)$/.exec(t),i=e&&e[1];if(!e||3!==e.length||"string"!=typeof i)throw Error("invalid child index: "+t);let n=+i;if(!Number.isSafeInteger(n)||n>=2147483648)throw Error("Invalid index");"'"===e[2]&&(n+=2147483648),r=r.deriveChild(n)}return r}deriveChild(t){if(!this.pubKey||!this.chainCode)throw Error("No publicKey or chainCode set");let e=toU32(t);if(t>=2147483648){let t=this.privateKey;if(!t)throw Error("Could not derive hardened child key");e=(0,o.eV)(new Uint8Array([0]),t,e)}else e=(0,o.eV)(this.pubKey,e);let r=(0,i.b)(v.o,this.chainCode,e),n=bytesToNumber(r.slice(0,32)),s=r.slice(32);if(!C.utils.isValidPrivateKey(n))throw Error("Tweak bigger than curve order");let a={versions:this.versions,chainCode:s,depth:this.depth+1,parentFingerprint:this.fingerprint,index:t};try{if(this.privateKey){let t=(0,K.wQ)(this.privKey+n,C.CURVE.n);if(!C.utils.isValidPrivateKey(t))throw Error("The tweak was out of range or the resulted private key is invalid");a.privateKey=t}else{let t=k.fromHex(this.pubKey).add(k.fromPrivateKey(n));if(t.equals(k.ZERO))throw Error("The tweak was equal to negative P, which made the result key invalid");a.publicKey=t.toRawBytes(!0)}return new HDKey(a)}catch(e){return this.deriveChild(t+1)}}sign(t){if(!this.privateKey)throw Error("No privateKey set!");return(0,E.gk)(t,32),C.sign(t,this.privKey).toCompactRawBytes()}verify(t,e){let r;if((0,E.gk)(t,32),(0,E.gk)(e,64),!this.publicKey)throw Error("No publicKey set!");try{r=C.Signature.fromCompact(e)}catch(t){return!1}return C.verify(r,t,this.publicKey)}wipePrivateData(){return this.privKey=void 0,this.privKeyBytes&&(this.privKeyBytes.fill(0),this.privKeyBytes=void 0),this}toJSON(){return{xpriv:this.privateExtendedKey,xpub:this.publicExtendedKey}}serialize(t,e){if(!this.chainCode)throw Error("No chainCode set");return(0,E.gk)(e,33),(0,o.eV)(toU32(t),new Uint8Array([this.depth]),toU32(this.parentFingerprint),toU32(this.index),this.chainCode,e)}}}}]);
//# sourceMappingURL=4013.7543fce24da77c65.js.map