{"version":3,"file":"static/chunks/6835.391bae2d5e123f74.js","mappings":"mGAOA,IAAAA,EAAcC,EAAA,OAAAC,MAAA,CA+GdC,EAAAC,OAAA,CA9GA,SAAAC,CAAA,EACA,GAAAA,EAAAC,MAAA,MAAgC,qCAEhC,QADAC,EAAA,IAAAC,WAAA,KACAC,EAAA,EAAkBA,EAAAF,EAAAD,MAAA,CAAqBG,IACvCF,CAAA,CAAAE,EAAA,KAEA,QAAAC,EAAA,EAAkBA,EAAAL,EAAAC,MAAA,CAAqBI,IAAA,CACvC,IAAAC,EAAAN,EAAAO,MAAA,CAAAF,GACAG,EAAAF,EAAAG,UAAA,IACA,GAAAP,MAAAA,CAAA,CAAAM,EAAA,CAAgC,gBAAAF,EAAA,gBAChCJ,CAAAA,CAAA,CAAAM,EAAA,CAAAH,CACA,CATA,IAUAK,EAAAV,EAAAC,MAAA,CACAU,EAAAX,EAAAO,MAAA,IACAK,EAAAC,KAAAC,GAAA,CAAAJ,GAAAG,KAAAC,GAAA,MACAC,EAAAF,KAAAC,GAAA,MAAAD,KAAAC,GAAA,CAAAJ,GAyCA,SAAAM,aAAAC,CAAA,EACA,oBAAAA,EAAsC,mCACtC,GAAAA,IAAAA,EAAAhB,MAAA,CAA+B,OAAAN,EAAAuB,KAAA,IAK/B,IAJA,IAAAC,EAAA,EAEAC,EAAA,EACAnB,EAAA,EACAgB,CAAA,CAAAE,EAAA,GAAAR,GACAS,IACAD,IAMA,IAHA,IAAAE,EAAA,CAAAJ,EAAAhB,MAAA,CAAAkB,CAAA,EAAAP,EAAA,MACAU,EAAA,IAAAnB,WAAAkB,GAEAF,EAAAF,EAAAhB,MAAA,GAEA,IAAAsB,EAAArB,CAAA,CAAAe,EAAAR,UAAA,CAAAU,GAAA,CAEA,GAAAI,MAAAA,EAA2B,OAE3B,QADAlB,EAAA,EACAmB,EAAAH,EAAA,EAA+B,CAAAE,IAAAA,GAAAlB,EAAAJ,CAAA,GAAAuB,KAAAA,EAA6CA,IAAAnB,IAC5EkB,GAAA,EAAAD,CAAA,CAAAE,EAAA,KACAF,CAAA,CAAAE,EAAA,WACAD,EAAA,UAEA,GAAAA,IAAAA,EAAyB,8BACzBtB,EAAAI,EACAc,GACA,CAGA,IADA,IAAAM,EAAAJ,EAAApB,EACAwB,IAAAJ,GAAAC,IAAAA,CAAA,CAAAG,EAAA,EACAA,IAEA,IAAAC,EAAA/B,EAAAgC,WAAA,CAAAP,EAAAC,CAAAA,EAAAI,CAAA,GACAC,EAAAE,IAAA,KAAAR,GAEA,IADA,IAAAhB,EAAAgB,EACAK,IAAAJ,GACAK,CAAA,CAAAtB,IAAA,CAAAkB,CAAA,CAAAG,IAAA,CAEA,OAAAC,CACA,CAMA,OACAG,OAzFA,SAAAZ,CAAA,EAEA,GADAa,CAAAA,MAAAC,OAAA,CAAAd,IAAAA,aAAAd,UAAA,GAAiEc,CAAAA,EAAAtB,EAAAqC,IAAA,CAAAf,EAAA,EACjE,CAAAtB,EAAAsC,QAAA,CAAAhB,GAAqC,mCACrC,GAAAA,IAAAA,EAAAhB,MAAA,CAA+B,SAM/B,IAJA,IAAAmB,EAAA,EACAnB,EAAA,EACAiC,EAAA,EACAC,EAAAlB,EAAAhB,MAAA,CACAiC,IAAAC,GAAAlB,IAAAA,CAAA,CAAAiB,EAAA,EACAA,IACAd,IAMA,IAHA,IAAAC,EAAA,CAAAc,EAAAD,CAAA,EAAAnB,EAAA,MACAqB,EAAA,IAAAjC,WAAAkB,GAEAa,IAAAC,GAAA,CAIA,QAHAZ,EAAAN,CAAA,CAAAiB,EAAA,CAEA7B,EAAA,EACAgC,EAAAhB,EAAA,EAA+B,CAAAE,IAAAA,GAAAlB,EAAAJ,CAAA,GAAAoC,KAAAA,EAA6CA,IAAAhC,IAC5EkB,GAAA,IAAAa,CAAA,CAAAC,EAAA,KACAD,CAAA,CAAAC,EAAA,GAAA3B,IAAA,EACAa,EAAA,EAAAb,IAAA,EAEA,GAAAa,IAAAA,EAAyB,8BACzBtB,EAAAI,EACA6B,GACA,CAGA,IADA,IAAAI,EAAAjB,EAAApB,EACAqC,IAAAjB,GAAAe,IAAAA,CAAA,CAAAE,EAAA,EACAA,IAIA,IADA,IAAAC,EAAA5B,EAAA6B,MAAA,CAAApB,GACWkB,EAAAjB,EAAY,EAAAiB,EAASC,GAAAvC,EAAAO,MAAA,CAAA6B,CAAA,CAAAE,EAAA,EAChC,OAAAC,CACA,EAmDAvB,aAAAA,aACAyB,OARA,SAAAC,CAAA,EACA,IAAAC,EAAA3B,aAAA0B,GACA,GAAAC,EAAkB,OAAAA,CAClB,wBAAAjC,EAAA,aACA,CAKA,CACA,yBCrHA,oFAEA,IAAAiC,EAAa/C,EAAQ,OACrBC,EAAA8C,EAAA9C,MAAA,CAGA,SAAA+C,UAAAC,CAAA,CAAAC,CAAA,EACA,QAAAC,KAAAF,EACAC,CAAA,CAAAC,EAAA,CAAAF,CAAA,CAAAE,EAAA,CAWA,SAAAC,WAAAC,CAAA,CAAAC,CAAA,CAAAjD,CAAA,EACA,OAAAJ,EAAAoD,EAAAC,EAAAjD,EACA,CAVAJ,EAAAmC,IAAA,EAAAnC,EAAAqB,KAAA,EAAArB,EAAA8B,WAAA,EAAA9B,EAAAsD,eAAA,CACArD,EAAAC,OAAA,CAAA4C,GAGAC,UAAAD,EAAA5C,GACEA,EAAAF,MAAc,CAAAmD,YAOhBA,WAAAI,SAAA,CAAAC,OAAAC,MAAA,CAAAzD,EAAAuD,SAAA,EAGAR,UAAA/C,EAAAmD,YAEAA,WAAAhB,IAAA,UAAAiB,CAAA,CAAAC,CAAA,CAAAjD,CAAA,EACA,oBAAAgD,EACA,iDAEA,OAAApD,EAAAoD,EAAAC,EAAAjD,EACA,EAEA+C,WAAA9B,KAAA,UAAAG,CAAA,CAAAO,CAAA,CAAA2B,CAAA,EACA,oBAAAlC,EACA,6CAEA,IAAAmC,EAAA3D,EAAAwB,GAUA,OATAO,KAAA6B,IAAA7B,EACA,iBAAA2B,EACAC,EAAA5B,IAAA,CAAAA,EAAA2B,GAEAC,EAAA5B,IAAA,CAAAA,GAGA4B,EAAA5B,IAAA,IAEA4B,CACA,EAEAR,WAAArB,WAAA,UAAAN,CAAA,EACA,oBAAAA,EACA,6CAEA,OAAAxB,EAAAwB,EACA,EAEA2B,WAAAG,eAAA,UAAA9B,CAAA,EACA,oBAAAA,EACA,6CAEA,OAAAsB,EAAAe,UAAA,CAAArC,EACA,sCCjDA,SAAAsC,QAAAC,CAAA,CAAAC,CAAA,CAAAC,CAAA,EACA,OAAAD,GAAAD,GAAAA,GAAAE,CACA,CAMA,SAAAC,aAAAC,CAAA,EACA,GAAAA,KAAAP,IAAAO,EAAA,SACA,GAAAA,IAAAX,OAAAW,GAAA,OAAAA,CACA,OAAAC,UAAA,2CACA,CA+HA,SAAAC,OAAAC,CAAA,EAEA,KAAAA,MAAA,IAAAC,KAAA,CAAAC,IAAA,CAAAF,EACA,CAyEA,SAAAG,aAAAC,CAAA,CAAAC,CAAA,EACA,GAAAD,EACA,MAAAN,UAAA,iBACA,OAAAO,GAAA,KACA,uGA3EAN,OAAAd,SAAA,EAIAqB,YAAA,WACA,YAAAN,MAAA,CAAAlE,MAAA,EAWAyE,KAAA,kBACA,KAAAP,MAAA,CAAAlE,MAAA,CAEA,KAAAkE,MAAA,CAAAQ,KAAA,GAjCA,EAkCA,EASAC,QAAA,SAAAC,CAAA,EACA,GAAA/C,MAAAC,OAAA,CAAA8C,GAEA,KAAAV,EAAAlE,MAAA,EACA,KAAAkE,MAAA,CAAAW,OAAA,CAAAX,EAAAY,GAAA,SAEA,KAAAZ,MAAA,CAAAW,OAAA,CAAAD,EAEA,EASAG,KAAA,SAAAH,CAAA,EACA,GAAA/C,MAAAC,OAAA,CAAA8C,GAEA,KAAAV,EAAAlE,MAAA,EACA,KAAAkE,MAAA,CAAAa,IAAA,CAAAb,EAAAQ,KAAA,SAEA,KAAAR,MAAA,CAAAa,IAAA,CAAAH,EAEA,CACA,EAkDA,IAAAI,EAAA,QAUA,SAAAC,YAAA3B,CAAA,CAAA4B,CAAA,EACA,qBAAAD,WAAA,EACA,WAAAA,YAAA3B,EAAA4B,GAGA,GAAA5B,CADAA,EAAAA,KAAAE,IAAAF,EAAA6B,OAAA7B,GAAA8B,WAAA,GAAAJ,CAAA,IACAA,EACA,+DAEAE,EAAApB,aAAAoB,GAGA,KAAAG,UAAA,IAEA,KAAAC,QAAA,IAEA,KAAAC,QAAA,MAEA,KAAAC,MAAA,CAAAC,CAAAA,CAAAP,EAAA,MAEA,KAAAQ,UAAA,CAAAD,CAAAA,CAAAP,EAAA,UAEA9B,OAAAuC,cAAA,kBAA2CC,MAAA,UAC3CxC,OAAAuC,cAAA,eAAwCC,MAAA,KAAAJ,MAAA,GACxCpC,OAAAuC,cAAA,mBAA4CC,MAAA,KAAAF,UAAA,EAC5C,CA4FA,SAAAG,YAAAvC,CAAA,CAAA4B,CAAA,EACA,qBAAAW,WAAA,EACA,WAAAA,YAAAvC,EAAA4B,GAEA,GAAA5B,CADAA,EAAAA,KAAAE,IAAAF,EAAA6B,OAAA7B,GAAA8B,WAAA,GAAAJ,CAAA,IACAA,EACA,+DAEAE,EAAApB,aAAAoB,GAGA,KAAAG,UAAA,IAEA,KAAAS,QAAA,MAEA,KAAAC,QAAA,EAAmBzB,MAAAmB,CAAAA,CAAAP,EAAA,OAEnB9B,OAAAuC,cAAA,kBAA2CC,MAAA,SAC3C,CA2DA,SAAAI,YAAAd,CAAA,EACA,IAAAZ,EAAAY,EAAAZ,KAAA,CAMyB2B,EAAA,EACAC,EAAA,EACAC,EAAA,EACAC,EAAA,IACAC,EAAA,GASzB,MAAAC,OAAA,UAAAC,CAAA,CAAAC,CAAA,EAGA,GAAAA,KAAAA,GAAAL,IAAAA,EAEA,OADAA,EAAA,EACA9B,aAAAC,GAIA,GAAAkC,KAAAA,EACA,OAjRA,GAoRA,GAAAL,IAAAA,EAAA,CAGA,GAAAzC,QAAA8C,EAAA,OAEA,OAAAA,EAIA,GAAA9C,QAAA8C,EAAA,SAGAL,EAAA,EACAF,EAAAO,EAAA,SAIA,GAAA9C,QAAA8C,EAAA,SAEA,MAAAA,GACAJ,CAAAA,EAAA,KAEA,MAAAI,GACAH,CAAAA,EAAA,KAGAF,EAAA,EACAF,EAAAO,EAAA,SAIA,IAAA9C,QAAA8C,EAAA,SAgBA,OAAAnC,aAAAC,EAdA,OAAAkC,GACAJ,CAAAA,EAAA,KAEA,MAAAI,GACAH,CAAAA,EAAA,KAGAF,EAAA,EACAF,EAAAO,EAAA,IAaA,OADAP,IAAA,EAAAE,EACA,IACA,CAIA,IAAAzC,QAAA8C,EAAAJ,EAAAC,GAaA,OARAJ,EAAAE,EAAAD,EAAA,EACAE,EAAA,IACAC,EAAA,IAGAE,EAAA5B,OAAA,CAAA6B,GAGAnC,aAAAC,GAgBA,GAXA8B,EAAA,IACAC,EAAA,IAKAH,GAAA,EACAD,GAAA,SAAAE,CAAAA,EAAAD,CAAA,EAIAA,IAAAC,EACA,YAGA,IAAAM,EAAAR,EAOA,OAHAA,EAAAE,EAAAD,EAAA,EAGAO,CACA,CACA,CAOA,SAAAC,YAAAxB,CAAA,EACAA,EAAAZ,KAAA,CAMA,KAAAgC,OAAA,UAAAC,CAAA,CAAAE,CAAA,EAEA,GAAAA,KAAAA,EACA,OA1YA,GA8YA,GAAA/C,QAAA+C,EAAA,OACA,OAAAA,EAKA/C,QAAA+C,EAAA,WACAE,EAAA,EACAC,EAAA,KAGAlD,QAAA+C,EAAA,aACAE,EAAA,EACAC,EAAA,KAGAlD,QAAA+C,EAAA,iBACAE,EAAA,EACAC,EAAA,KAQA,IAHA,IAnBAD,EAAAC,EAmBAC,EAAA,EAAAJ,GAAA,EAAAE,CAAA,EAAAC,EAAA,CAGAD,EAAA,IAGA,IAAAG,EAAAL,GAAA,EAAAE,CAAAA,EAAA,GAGAE,EAAA9B,IAAA,KAAA+B,GAAAA,GAGAH,GAAA,CACA,CAGA,OAAAE,CACA,CACA,CA1WA5B,YAAA9B,SAAA,EAMAX,OAAA,SAAAuE,CAAA,CAAA7B,CAAA,EAGA2B,EADA,iBAAAE,GAAAA,aAAAC,YACA,IAAA9G,WAAA6G,GACM,iBAAAA,GAAA,WAAAA,GACNA,EAAArE,MAAA,YAAAsE,YACA,IAAA9G,WAAA6G,EAAArE,MAAA,CACAqE,EAAAE,UAAA,CACAF,EAAAG,UAAA,EAEA,IAAAhH,WAAA,GAGAgF,EAAApB,aAAAoB,GAEA,KAAAG,UAAA,GACA,KAAAE,QAAA,KAAAS,YAAA,CAAuC1B,MAAA,KAAAkB,MAAA,GACvC,KAAAF,QAAA,KAEA,KAAAD,UAAA,CAAAI,CAAAA,CAAAP,EAAA,OASA,IAPA,IApBA2B,EAyBAM,EALAC,EAAA,IAAAnD,OAAA4C,GAEAQ,EAAA,GAOA,CAFAD,EAAA5C,WAAA,IAEA2C,KADAA,CAAAA,EAAA,KAAA5B,QAAA,CAAAe,OAAA,CAAAc,EAAAA,EAAA3C,IAAA,MAGA,OAAA0C,IAEAtF,MAAAC,OAAA,CAAAqF,GACAE,EAAAtC,IAAA,CAAAuC,KAAA,CAAAD,EAAsEF,GAEtEE,EAAAtC,IAAA,CAAAoC,IAEA,SAAA9B,UAAA,EACA,GAEA,GAAA8B,KADAA,CAAAA,EAAA,KAAA5B,QAAA,CAAAe,OAAA,CAAAc,EAAAA,EAAA3C,IAAA,KAEA,MACA,GAAA0C,OAAAA,EACA,SACAtF,MAAAC,OAAA,CAAAqF,GACAE,EAAAtC,IAAA,CAAAuC,KAAA,CAAAD,EAAwEF,GAExEE,EAAAtC,IAAA,CAAAoC,EACA,OAAQ,CAAAC,EAAA5C,WAAA,IACR,KAAAe,QAAA,KACA,CAoBA,OAlBA8B,EAAArH,MAAA,EAIA,eAAAuH,OAAA,MAAAjE,QAAA,GACA,KAAAoC,UAAA,OAAAJ,QAAA,GAEA+B,QAAAA,CAAA,KACA,KAAA/B,QAAA,IACA+B,EAAA3C,KAAA,IAIA,KAAAY,QAAA,KAKAkC,SAtQAH,CAAA,EAEA,QADAI,EAAA,GACArH,EAAA,EAAkBA,EAAAiH,EAAArH,MAAA,CAAwB,EAAAI,EAAA,CAC1C,IAAAsH,EAAAL,CAAA,CAAAjH,EAAA,CACAsH,GAAA,MACAD,GAAAtC,OAAAwC,YAAA,CAAAD,IAEAA,GAAA,MACAD,GAAAtC,OAAAwC,YAAA,EAAAD,GAAA,UACA,CAAAA,KAAAA,CAAA,SAEA,CACA,OAAAD,CACA,EAyPAJ,EACA,CACA,EA6BAxB,YAAA1C,SAAA,EAMAvB,OAAA,SAAAgG,CAAA,CAAA1C,CAAA,EACA0C,EAAAA,EAAAzC,OAAAyC,GAAA,GACA1C,EAAApB,aAAAoB,GAKA,KAAAG,UAAA,EACA,MAAAS,QAAA,KAAAY,YAAA,KAAAX,QAAA,GACA,KAAAV,UAAA,CAAAI,CAAAA,CAAAP,EAAA,OAMA,IAJA,IAGAiC,EAHAN,EAAA,GACAO,EAAA,IAAAnD,OAAA4D,SA1YApF,CAAA,EAgBA,IAZA,IAAAgF,EAAAtC,OAAA1C,GAGAqF,EAAAL,EAAAzH,MAAA,CAGAI,EAAA,EAGA2H,EAAA,GAGA3H,EAAA0H,GAAA,CAGA,IAAAE,EAAAP,EAAAjH,UAAA,CAAAJ,GAKA,GAAA4H,EAAA,OAAAA,EAAA,MAEAD,EAAAhD,IAAA,CAAAiD,QAIA,UAAAA,GAAAA,GAAA,MAEAD,EAAAhD,IAAA,aAIA,UAAAiD,GAAAA,GAAA,OAGA,GAAA5H,IAAA0H,EAAA,EACAC,EAAAhD,IAAA,YAGA,CAEA,IAAAkD,EAAAxF,EAAAjC,UAAA,CAAAJ,EAAA,GAGA,UAAA6H,GAAAA,GAAA,OAEA,IAAAtE,EAAAqE,KAAAA,EAGAE,EAAAD,KAAAA,EAIAF,EAAAhD,IAAA,OAAApB,CAAAA,GAAA,IAAAuE,GAGA9H,GAAA,CACA,MAKA2H,EAAAhD,IAAA,OAEA,EAIA3E,GAAA,CACA,CAGA,OAAA2H,CACA,EA6TAH,IAKA,CAFAR,EAAA5C,WAAA,IAEA2C,KADAA,CAAAA,EAAA,KAAArB,QAAA,CAAAQ,OAAA,CAAAc,EAAAA,EAAA3C,IAAA,MAGA5C,MAAAC,OAAA,CAAAqF,GACAN,EAAA9B,IAAA,CAAAuC,KAAA,CAAAT,EAA0DM,GAE1DN,EAAA9B,IAAA,CAAAoC,GAEA,SAAA9B,UAAA,EACA,KAEA8B,KADAA,CAAAA,EAAA,KAAArB,QAAA,CAAAQ,OAAA,CAAAc,EAAAA,EAAA3C,IAAA,MAGA5C,MAAAC,OAAA,CAAAqF,GACAN,EAAA9B,IAAA,CAAAuC,KAAA,CAAAT,EAA4DM,GAE5DN,EAAA9B,IAAA,CAAAoC,EAEA,MAAArB,QAAA,KACA,CACA,WAAA5F,WAAA2G,EACA,CACA","sources":["webpack://_N_E/./node_modules/base-x/src/index.js","webpack://_N_E/./node_modules/safe-buffer/index.js","webpack://_N_E/./node_modules/text-encoding-utf-8/lib/encoding.lib.mjs","webpack://_N_E/<anon>"],"sourcesContent":["'use strict'\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n// @ts-ignore\nvar _Buffer = require('safe-buffer').Buffer\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }\n    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return _Buffer.alloc(0) }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (psz < source.length) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = _Buffer.allocUnsafe(zeroes + (size - it4))\n    vch.fill(0x00, 0, zeroes)\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n","/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","'use strict';\n\n// This is free and unencumbered software released into the public domain.\n// See LICENSE.md for more information.\n\n//\n// Utilities\n//\n\n/**\n * @param {number} a The number to test.\n * @param {number} min The minimum value in the range, inclusive.\n * @param {number} max The maximum value in the range, inclusive.\n * @return {boolean} True if a >= min and a <= max.\n */\nfunction inRange(a, min, max) {\n  return min <= a && a <= max;\n}\n\n/**\n * @param {*} o\n * @return {Object}\n */\nfunction ToDictionary(o) {\n  if (o === undefined) return {};\n  if (o === Object(o)) return o;\n  throw TypeError('Could not convert argument to dictionary');\n}\n\n/**\n * @param {string} string Input string of UTF-16 code units.\n * @return {!Array.<number>} Code points.\n */\nfunction stringToCodePoints(string) {\n  // https://heycam.github.io/webidl/#dfn-obtain-unicode\n\n  // 1. Let S be the DOMString value.\n  var s = String(string);\n\n  // 2. Let n be the length of S.\n  var n = s.length;\n\n  // 3. Initialize i to 0.\n  var i = 0;\n\n  // 4. Initialize U to be an empty sequence of Unicode characters.\n  var u = [];\n\n  // 5. While i < n:\n  while (i < n) {\n\n    // 1. Let c be the code unit in S at index i.\n    var c = s.charCodeAt(i);\n\n    // 2. Depending on the value of c:\n\n    // c < 0xD800 or c > 0xDFFF\n    if (c < 0xD800 || c > 0xDFFF) {\n      // Append to U the Unicode character with code point c.\n      u.push(c);\n    }\n\n    // 0xDC00 ≤ c ≤ 0xDFFF\n    else if (0xDC00 <= c && c <= 0xDFFF) {\n      // Append to U a U+FFFD REPLACEMENT CHARACTER.\n      u.push(0xFFFD);\n    }\n\n    // 0xD800 ≤ c ≤ 0xDBFF\n    else if (0xD800 <= c && c <= 0xDBFF) {\n      // 1. If i = n−1, then append to U a U+FFFD REPLACEMENT\n      // CHARACTER.\n      if (i === n - 1) {\n        u.push(0xFFFD);\n      }\n      // 2. Otherwise, i < n−1:\n      else {\n        // 1. Let d be the code unit in S at index i+1.\n        var d = string.charCodeAt(i + 1);\n\n        // 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:\n        if (0xDC00 <= d && d <= 0xDFFF) {\n          // 1. Let a be c & 0x3FF.\n          var a = c & 0x3FF;\n\n          // 2. Let b be d & 0x3FF.\n          var b = d & 0x3FF;\n\n          // 3. Append to U the Unicode character with code point\n          // 2^16+2^10*a+b.\n          u.push(0x10000 + (a << 10) + b);\n\n          // 4. Set i to i+1.\n          i += 1;\n        }\n\n        // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a\n        // U+FFFD REPLACEMENT CHARACTER.\n        else  {\n          u.push(0xFFFD);\n        }\n      }\n    }\n\n    // 3. Set i to i+1.\n    i += 1;\n  }\n\n  // 6. Return U.\n  return u;\n}\n\n/**\n * @param {!Array.<number>} code_points Array of code points.\n * @return {string} string String of UTF-16 code units.\n */\nfunction codePointsToString(code_points) {\n  var s = '';\n  for (var i = 0; i < code_points.length; ++i) {\n    var cp = code_points[i];\n    if (cp <= 0xFFFF) {\n      s += String.fromCharCode(cp);\n    } else {\n      cp -= 0x10000;\n      s += String.fromCharCode((cp >> 10) + 0xD800,\n                               (cp & 0x3FF) + 0xDC00);\n    }\n  }\n  return s;\n}\n\n\n//\n// Implementation of Encoding specification\n// https://encoding.spec.whatwg.org/\n//\n\n//\n// 3. Terminology\n//\n\n/**\n * End-of-stream is a special token that signifies no more tokens\n * are in the stream.\n * @const\n */ var end_of_stream = -1;\n\n/**\n * A stream represents an ordered sequence of tokens.\n *\n * @constructor\n * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide the\n * stream.\n */\nfunction Stream(tokens) {\n  /** @type {!Array.<number>} */\n  this.tokens = [].slice.call(tokens);\n}\n\nStream.prototype = {\n  /**\n   * @return {boolean} True if end-of-stream has been hit.\n   */\n  endOfStream: function() {\n    return !this.tokens.length;\n  },\n\n  /**\n   * When a token is read from a stream, the first token in the\n   * stream must be returned and subsequently removed, and\n   * end-of-stream must be returned otherwise.\n   *\n   * @return {number} Get the next token from the stream, or\n   * end_of_stream.\n   */\n   read: function() {\n    if (!this.tokens.length)\n      return end_of_stream;\n     return this.tokens.shift();\n   },\n\n  /**\n   * When one or more tokens are prepended to a stream, those tokens\n   * must be inserted, in given order, before the first token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.\n   */\n  prepend: function(token) {\n    if (Array.isArray(token)) {\n      var tokens = /**@type {!Array.<number>}*/(token);\n      while (tokens.length)\n        this.tokens.unshift(tokens.pop());\n    } else {\n      this.tokens.unshift(token);\n    }\n  },\n\n  /**\n   * When one or more tokens are pushed to a stream, those tokens\n   * must be inserted, in given order, after the last token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.\n   */\n  push: function(token) {\n    if (Array.isArray(token)) {\n      var tokens = /**@type {!Array.<number>}*/(token);\n      while (tokens.length)\n        this.tokens.push(tokens.shift());\n    } else {\n      this.tokens.push(token);\n    }\n  }\n};\n\n//\n// 4. Encodings\n//\n\n// 4.1 Encoders and decoders\n\n/** @const */\nvar finished = -1;\n\n/**\n * @param {boolean} fatal If true, decoding errors raise an exception.\n * @param {number=} opt_code_point Override the standard fallback code point.\n * @return {number} The code point to insert on a decoding error.\n */\nfunction decoderError(fatal, opt_code_point) {\n  if (fatal)\n    throw TypeError('Decoder error');\n  return opt_code_point || 0xFFFD;\n}\n\n/** @interface */\nfunction Decoder() {}\nDecoder.prototype = {\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point, or |finished|.\n   */\n  handler: function(stream, bite) {}\n};\n\n/** @interface */\nfunction Encoder() {}\nEncoder.prototype = {\n  /**\n   * @param {Stream} stream The stream of code points being encoded.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.\n   */\n  handler: function(stream, code_point) {}\n};\n\n//\n// 7. API\n//\n\n/** @const */ var DEFAULT_ENCODING = 'utf-8';\n\n// 7.1 Interface TextDecoder\n\n/**\n * @constructor\n * @param {string=} encoding The label of the encoding;\n *     defaults to 'utf-8'.\n * @param {Object=} options\n */\nfunction TextDecoder(encoding, options) {\n  if (!(this instanceof TextDecoder)) {\n    return new TextDecoder(encoding, options);\n  }\n  encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;\n  if (encoding !== DEFAULT_ENCODING) {\n    throw new Error('Encoding not supported. Only utf-8 is supported');\n  }\n  options = ToDictionary(options);\n\n  /** @private @type {boolean} */\n  this._streaming = false;\n  /** @private @type {boolean} */\n  this._BOMseen = false;\n  /** @private @type {?Decoder} */\n  this._decoder = null;\n  /** @private @type {boolean} */\n  this._fatal = Boolean(options['fatal']);\n  /** @private @type {boolean} */\n  this._ignoreBOM = Boolean(options['ignoreBOM']);\n\n  Object.defineProperty(this, 'encoding', {value: 'utf-8'});\n  Object.defineProperty(this, 'fatal', {value: this._fatal});\n  Object.defineProperty(this, 'ignoreBOM', {value: this._ignoreBOM});\n}\n\nTextDecoder.prototype = {\n  /**\n   * @param {ArrayBufferView=} input The buffer of bytes to decode.\n   * @param {Object=} options\n   * @return {string} The decoded string.\n   */\n  decode: function decode(input, options) {\n    var bytes;\n    if (typeof input === 'object' && input instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input);\n    } else if (typeof input === 'object' && 'buffer' in input &&\n               input.buffer instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input.buffer,\n                             input.byteOffset,\n                             input.byteLength);\n    } else {\n      bytes = new Uint8Array(0);\n    }\n\n    options = ToDictionary(options);\n\n    if (!this._streaming) {\n      this._decoder = new UTF8Decoder({fatal: this._fatal});\n      this._BOMseen = false;\n    }\n    this._streaming = Boolean(options['stream']);\n\n    var input_stream = new Stream(bytes);\n\n    var code_points = [];\n\n    /** @type {?(number|!Array.<number>)} */\n    var result;\n\n    while (!input_stream.endOfStream()) {\n      result = this._decoder.handler(input_stream, input_stream.read());\n      if (result === finished)\n        break;\n      if (result === null)\n        continue;\n      if (Array.isArray(result))\n        code_points.push.apply(code_points, /**@type {!Array.<number>}*/(result));\n      else\n        code_points.push(result);\n    }\n    if (!this._streaming) {\n      do {\n        result = this._decoder.handler(input_stream, input_stream.read());\n        if (result === finished)\n          break;\n        if (result === null)\n          continue;\n        if (Array.isArray(result))\n          code_points.push.apply(code_points, /**@type {!Array.<number>}*/(result));\n        else\n          code_points.push(result);\n      } while (!input_stream.endOfStream());\n      this._decoder = null;\n    }\n\n    if (code_points.length) {\n      // If encoding is one of utf-8, utf-16be, and utf-16le, and\n      // ignore BOM flag and BOM seen flag are unset, run these\n      // subsubsteps:\n      if (['utf-8'].indexOf(this.encoding) !== -1 &&\n          !this._ignoreBOM && !this._BOMseen) {\n        // If token is U+FEFF, set BOM seen flag.\n        if (code_points[0] === 0xFEFF) {\n          this._BOMseen = true;\n          code_points.shift();\n        } else {\n          // Otherwise, if token is not end-of-stream, set BOM seen\n          // flag and append token to output.\n          this._BOMseen = true;\n        }\n      }\n    }\n\n    return codePointsToString(code_points);\n  }\n};\n\n// 7.2 Interface TextEncoder\n\n/**\n * @constructor\n * @param {string=} encoding The label of the encoding;\n *     defaults to 'utf-8'.\n * @param {Object=} options\n */\nfunction TextEncoder(encoding, options) {\n  if (!(this instanceof TextEncoder))\n    return new TextEncoder(encoding, options);\n  encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;\n  if (encoding !== DEFAULT_ENCODING) {\n    throw new Error('Encoding not supported. Only utf-8 is supported');\n  }\n  options = ToDictionary(options);\n\n  /** @private @type {boolean} */\n  this._streaming = false;\n  /** @private @type {?Encoder} */\n  this._encoder = null;\n  /** @private @type {{fatal: boolean}} */\n  this._options = {fatal: Boolean(options['fatal'])};\n\n  Object.defineProperty(this, 'encoding', {value: 'utf-8'});\n}\n\nTextEncoder.prototype = {\n  /**\n   * @param {string=} opt_string The string to encode.\n   * @param {Object=} options\n   * @return {Uint8Array} Encoded bytes, as a Uint8Array.\n   */\n  encode: function encode(opt_string, options) {\n    opt_string = opt_string ? String(opt_string) : '';\n    options = ToDictionary(options);\n\n    // NOTE: This option is nonstandard. None of the encodings\n    // permitted for encoding (i.e. UTF-8, UTF-16) are stateful,\n    // so streaming is not necessary.\n    if (!this._streaming)\n      this._encoder = new UTF8Encoder(this._options);\n    this._streaming = Boolean(options['stream']);\n\n    var bytes = [];\n    var input_stream = new Stream(stringToCodePoints(opt_string));\n    /** @type {?(number|!Array.<number>)} */\n    var result;\n    while (!input_stream.endOfStream()) {\n      result = this._encoder.handler(input_stream, input_stream.read());\n      if (result === finished)\n        break;\n      if (Array.isArray(result))\n        bytes.push.apply(bytes, /**@type {!Array.<number>}*/(result));\n      else\n        bytes.push(result);\n    }\n    if (!this._streaming) {\n      while (true) {\n        result = this._encoder.handler(input_stream, input_stream.read());\n        if (result === finished)\n          break;\n        if (Array.isArray(result))\n          bytes.push.apply(bytes, /**@type {!Array.<number>}*/(result));\n        else\n          bytes.push(result);\n      }\n      this._encoder = null;\n    }\n    return new Uint8Array(bytes);\n  }\n};\n\n//\n// 8. The encoding\n//\n\n// 8.1 utf-8\n\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction UTF8Decoder(options) {\n  var fatal = options.fatal;\n\n  // utf-8's decoder's has an associated utf-8 code point, utf-8\n  // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8\n  // lower boundary (initially 0x80), and a utf-8 upper boundary\n  // (initially 0xBF).\n  var /** @type {number} */ utf8_code_point = 0,\n      /** @type {number} */ utf8_bytes_seen = 0,\n      /** @type {number} */ utf8_bytes_needed = 0,\n      /** @type {number} */ utf8_lower_boundary = 0x80,\n      /** @type {number} */ utf8_upper_boundary = 0xBF;\n\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function(stream, bite) {\n    // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,\n    // set utf-8 bytes needed to 0 and return error.\n    if (bite === end_of_stream && utf8_bytes_needed !== 0) {\n      utf8_bytes_needed = 0;\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream, return finished.\n    if (bite === end_of_stream)\n      return finished;\n\n    // 3. If utf-8 bytes needed is 0, based on byte:\n    if (utf8_bytes_needed === 0) {\n\n      // 0x00 to 0x7F\n      if (inRange(bite, 0x00, 0x7F)) {\n        // Return a code point whose value is byte.\n        return bite;\n      }\n\n      // 0xC2 to 0xDF\n      if (inRange(bite, 0xC2, 0xDF)) {\n        // Set utf-8 bytes needed to 1 and utf-8 code point to byte\n        // − 0xC0.\n        utf8_bytes_needed = 1;\n        utf8_code_point = bite - 0xC0;\n      }\n\n      // 0xE0 to 0xEF\n      else if (inRange(bite, 0xE0, 0xEF)) {\n        // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.\n        if (bite === 0xE0)\n          utf8_lower_boundary = 0xA0;\n        // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.\n        if (bite === 0xED)\n          utf8_upper_boundary = 0x9F;\n        // 3. Set utf-8 bytes needed to 2 and utf-8 code point to\n        // byte − 0xE0.\n        utf8_bytes_needed = 2;\n        utf8_code_point = bite - 0xE0;\n      }\n\n      // 0xF0 to 0xF4\n      else if (inRange(bite, 0xF0, 0xF4)) {\n        // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.\n        if (bite === 0xF0)\n          utf8_lower_boundary = 0x90;\n        // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.\n        if (bite === 0xF4)\n          utf8_upper_boundary = 0x8F;\n        // 3. Set utf-8 bytes needed to 3 and utf-8 code point to\n        // byte − 0xF0.\n        utf8_bytes_needed = 3;\n        utf8_code_point = bite - 0xF0;\n      }\n\n      // Otherwise\n      else {\n        // Return error.\n        return decoderError(fatal);\n      }\n\n      // Then (byte is in the range 0xC2 to 0xF4) set utf-8 code\n      // point to utf-8 code point << (6 × utf-8 bytes needed) and\n      // return continue.\n      utf8_code_point = utf8_code_point << (6 * utf8_bytes_needed);\n      return null;\n    }\n\n    // 4. If byte is not in the range utf-8 lower boundary to utf-8\n    // upper boundary, run these substeps:\n    if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {\n\n      // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8\n      // bytes seen to 0, set utf-8 lower boundary to 0x80, and set\n      // utf-8 upper boundary to 0xBF.\n      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n      utf8_lower_boundary = 0x80;\n      utf8_upper_boundary = 0xBF;\n\n      // 2. Prepend byte to stream.\n      stream.prepend(bite);\n\n      // 3. Return error.\n      return decoderError(fatal);\n    }\n\n    // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary\n    // to 0xBF.\n    utf8_lower_boundary = 0x80;\n    utf8_upper_boundary = 0xBF;\n\n    // 6. Increase utf-8 bytes seen by one and set utf-8 code point\n    // to utf-8 code point + (byte − 0x80) << (6 × (utf-8 bytes\n    // needed − utf-8 bytes seen)).\n    utf8_bytes_seen += 1;\n    utf8_code_point += (bite - 0x80) << (6 * (utf8_bytes_needed - utf8_bytes_seen));\n\n    // 7. If utf-8 bytes seen is not equal to utf-8 bytes needed,\n    // continue.\n    if (utf8_bytes_seen !== utf8_bytes_needed)\n      return null;\n\n    // 8. Let code point be utf-8 code point.\n    var code_point = utf8_code_point;\n\n    // 9. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes\n    // seen to 0.\n    utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n\n    // 10. Return a code point whose value is code point.\n    return code_point;\n  };\n}\n\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction UTF8Encoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream)\n      return finished;\n\n    // 2. If code point is in the range U+0000 to U+007F, return a\n    // byte whose value is code point.\n    if (inRange(code_point, 0x0000, 0x007f))\n      return code_point;\n\n    // 3. Set count and offset based on the range code point is in:\n    var count, offset;\n    // U+0080 to U+07FF:    1 and 0xC0\n    if (inRange(code_point, 0x0080, 0x07FF)) {\n      count = 1;\n      offset = 0xC0;\n    }\n    // U+0800 to U+FFFF:    2 and 0xE0\n    else if (inRange(code_point, 0x0800, 0xFFFF)) {\n      count = 2;\n      offset = 0xE0;\n    }\n    // U+10000 to U+10FFFF: 3 and 0xF0\n    else if (inRange(code_point, 0x10000, 0x10FFFF)) {\n      count = 3;\n      offset = 0xF0;\n    }\n\n    // 4.Let bytes be a byte sequence whose first byte is (code\n    // point >> (6 × count)) + offset.\n    var bytes = [(code_point >> (6 * count)) + offset];\n\n    // 5. Run these substeps while count is greater than 0:\n    while (count > 0) {\n\n      // 1. Set temp to code point >> (6 × (count − 1)).\n      var temp = code_point >> (6 * (count - 1));\n\n      // 2. Append to bytes 0x80 | (temp & 0x3F).\n      bytes.push(0x80 | (temp & 0x3F));\n\n      // 3. Decrease count by one.\n      count -= 1;\n    }\n\n    // 6. Return bytes bytes, in order.\n    return bytes;\n  };\n}\n\nexport {TextEncoder, TextDecoder};\n"],"names":["_Buffer","__webpack_require__","Buffer","module","exports","ALPHABET","length","BASE_MAP","Uint8Array","j","i","x","charAt","xc","charCodeAt","BASE","LEADER","FACTOR","Math","log","iFACTOR","decodeUnsafe","source","alloc","psz","zeroes","size","b256","carry","it3","it4","vch","allocUnsafe","fill","encode","Array","isArray","from","isBuffer","pbegin","pend","b58","it1","it2","str","repeat","decode","string","buffer","copyProps","src","dst","key","SafeBuffer","arg","encodingOrOffset","allocUnsafeSlow","prototype","Object","create","encoding","buf","undefined","SlowBuffer","inRange","a","min","max","ToDictionary","o","TypeError","Stream","tokens","slice","call","decoderError","fatal","opt_code_point","endOfStream","read","shift","prepend","token","unshift","pop","push","DEFAULT_ENCODING","TextDecoder","options","String","toLowerCase","_streaming","_BOMseen","_decoder","_fatal","Boolean","_ignoreBOM","defineProperty","value","TextEncoder","_encoder","_options","UTF8Decoder","utf8_code_point","utf8_bytes_seen","utf8_bytes_needed","utf8_lower_boundary","utf8_upper_boundary","handler","stream","bite","code_point","UTF8Encoder","count","offset","bytes","temp","input","ArrayBuffer","byteOffset","byteLength","result","input_stream","code_points","apply","indexOf","codePointsToString","s","cp","fromCharCode","opt_string","stringToCodePoints","n","u","c","d","b"],"sourceRoot":""}