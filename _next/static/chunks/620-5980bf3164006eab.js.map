{"version":3,"file":"static/chunks/620-5980bf3164006eab.js","mappings":"gJAAA;;;;;CAKA,EAIA,IAAAA,EAAqB,GAAAC,EAAAC,CAAA,EAAgB,gBACrC,WAAeC,GAAA,IAAAC,GAAA,KAAAC,EAAA,IAAAC,IAAA,UAA0C,CACzD,WAAeH,GAAA,IAAAC,GAAA,IAAAC,EAAA,IAAAC,IAAA,UAAyC,CACxD,WAAeH,GAAA,IAAAC,GAAA,KAAAC,EAAA,IAAAC,IAAA,UAA0C,CACzD,WAAeH,GAAA,KAAAC,GAAA,KAAAC,EAAA,IAAAC,IAAA,UAA2C,CAC1D,WAAeH,GAAA,KAAAC,GAAA,IAAAC,EAAA,IAAAC,IAAA,UAA0C,CACzD,WAAeH,GAAA,KAAAC,GAAA,KAAAC,EAAA,IAAAC,IAAA,UAA2C,CAC1D,4BCmKAC,oHA7KA,IACAC,cAAAA,CAAA,CACAC,cAAAA,CAAA,CACAC,UAAAA,CAAA,CACAC,WAAAA,CAAA,CACAC,YAAAA,CAAA,CACAC,WAAAA,CAAA,CACAC,UAAAA,CAAA,CACAC,oBAAAA,CAAA,CACAC,gBAAAA,CAAA,CACAC,QAAAA,CAAA,CACAC,OAAAA,CAAA,CACAC,SAAAA,CAAA,CACA,CAAIC,GAAAA,CAAAA,EAAAC,EAAAC,CAAA,CAAAC,EAAA,IAGJC,EAAc,CAAAJ,GAAAA,CAAAA,EAAAC,EAAAC,CAAA,CAAAC,EAAA,IAAK,SAASE,KAAAC,MAAA,GAAc,EAAAC,KAAA,OAK1CC,EAAAnB,EAAA,KACAmB,CAAAA,EAAAC,WAAA,qBAIA,IAAAC,EAAA,mBAAAN,EAAAA,EAAA,SACAO,EAAA,EACA,SAAAC,YAAAC,EAAA,MACA,IAAAC,EAAAJ,IACAK,EAAAjB,EAAAe,GAAAC,GAAA,MAIA,OAHA,OAAAC,EAAAC,OAAA,EACAD,CAAAA,EAAAC,OAAA,IAAAL,GAAA,EAEAE,MAAAA,EAAAA,EAAAE,EAAAC,OAAA,CAGA,SAAAC,sBAAA,CACAC,SAAAA,CAAA,CACAC,UAAAC,EAAA,GACAC,cAAAA,CAAA,CACAC,YAAAA,CAAA,CACAC,YAAAA,CAAA,CACAC,aAAAA,CAAA,CACAC,GAAAC,CAAA,CACAC,QAAAA,CAAA,CACAC,QAAAA,CAAA,CACAC,WAAAA,CAAA,CACAC,SAAAA,CAAA,CACAC,SAAAA,CAAA,CACAC,MAAAA,CAAA,CACAC,MAAAC,CAAA,CACAC,QAAAC,EAAA,MACA,GAAAC,EACC,EACD,IAAAC,EAAA7C,EAAAe,GACA,GAAA8B,OAAAA,EACA,MAAAC,MAAA,mEAEA,IACAC,cAAAA,CAAA,CACAC,YAAAA,CAAA,CACAC,aAAAA,CAAA,CACAC,cAAAA,CAAA,CACAC,QAAAA,CAAA,CACAC,iBAAAA,CAAA,CACAC,2BAAAA,CAAA,CACAC,cAAAA,CAAA,CACAC,YAAAA,CAAA,CACAC,gBAAAA,CAAA,CACA,CAAIX,EACJY,EAAAtC,YAAAc,GACAyB,EAAArD,EAAA,CACAsD,UAAA,CACAvB,WAAAA,EACAC,SAAAA,EACAC,SAAAA,CACA,EACAsB,YAAA,CACAhC,cAAAA,EACAC,YAAAA,EACAC,YAAAA,EACAI,QAAAA,EACAC,QAAAA,CACA,EACAH,GAAAyB,EACAI,cAAA5B,KAAA6B,IAAA7B,EACAM,MAAAA,CACA,GACAlC,EAAA,CACA0D,gCAAA,EACA,GACAC,EAAA,KACA,IACAL,UAAAA,CAAA,CACAC,YAAAA,CAAA,CACA,CAAMF,EAAAnC,OAAA,CACN0C,EAAA,CACA,GAAAL,CAAA,CAEAF,CAAAA,EAAAnC,OAAA,CAAAS,EAAA,CAAAyB,EACAC,EAAAnC,OAAA,CAAAsC,aAAA,CAAA5B,KAAA6B,IAAA7B,EACAyB,EAAAnC,OAAA,CAAAgB,KAAA,CAAAA,EACAoB,EAAAvB,UAAA,CAAAA,EACAuB,EAAAtB,QAAA,CAAAA,EACAsB,EAAArB,QAAA,CAAAA,EACAsB,EAAAhC,aAAA,CAAAA,EACAgC,EAAA/B,WAAA,CAAAA,EACA+B,EAAA9B,WAAA,CAAAA,EACA8B,EAAA1B,OAAA,CAAAA,EACA0B,EAAAzB,OAAA,CAAAA,EAIA8B,CAAAA,EAAArC,aAAA,GAAAgC,EAAAhC,aAAA,EAAAqC,EAAApC,WAAA,GAAA+B,EAAA/B,WAAA,EAAAoC,EAAA/B,OAAA,GAAA0B,EAAA1B,OAAA,EAAA+B,EAAA9B,OAAA,GAAAyB,EAAAzB,OAAA,GACAkB,EAAAK,EAAAnC,OAAA,CAAA0C,EAEA,GACAD,EAAA,KACA,IAAAE,EAAAR,EAAAnC,OAAA,CAEA,OADA+B,EAAAY,GACA,KACAV,EAAAU,EACA,CACA,EAAG,CAAA3B,EAAAkB,EAAAH,EAAAE,EAAA,EACHtD,EAAA6B,EAAA,MACAoC,SAAA,KACApB,EAAAW,EAAAnC,OAAA,CACA,EACA6C,OAAAjC,IACAa,EAAAU,EAAAnC,OAAA,CAAAY,EACA,EACAkC,MAAAA,IACAZ,EAEAa,QAAAA,IACArB,EAAAS,EAAAnC,OAAA,EAEAgD,YAAAA,IACAnB,EAAAM,EAAAnC,OAAA,EAEAiD,WAAAA,IACA,CAAApB,EAAAM,EAAAnC,OAAA,EAEAkD,OAAAC,IACAnB,EAAAG,EAAAnC,OAAA,CAAAmD,EACA,CACA,GAAG,CAAA3B,EAAAC,EAAAC,EAAAG,EAAAK,EAAAF,EAAA,EACH,IAAAf,EAAAU,EAAAQ,EAAAnC,OAAA,CAAAO,GACA,OAAAnC,EAAAgD,EAAA,CACA,GAAAC,CAAA,CACAnB,SAAAA,EACAC,UAAAC,EACAK,GAAAC,EACAO,MAAA,CACA,GAAAA,CAAA,CACA,GAAAC,CAAA,EAGA,gBACA,yBAAAZ,GAAAiC,KAAAA,EACA,sBAAAX,EACA,gBAAAM,EACA,kBAAAkB,WAAA,GAAAnC,EAAAoC,QAAA,EAAAC,OAAA,GACA,EACA,CACA,IAAAC,EAAAhF,EAAA,CAAAiF,EAAAC,IAAArF,EAAA6B,sBAAA,CACA,GAAAuD,CAAA,CACAhD,aAAAiD,CACA,GACAxD,CAAAA,sBAAAR,WAAA,SACA8D,EAAA9D,WAAA,qBAUA,IAAAiE,EAAA,KAEAC,EAAA,KAmDA,SAAAC,qBAAAC,CAAA,CAAAC,CAAA,EAIA,IAAA7C,EAAA8C,SAhDAF,CAAA,CAAAC,CAAA,EACA,GAAAA,EAAA,CACA,IAAAE,EAAA,CAAAF,EAAAG,CAAA,KACAC,EAAA,CAAAJ,EAAAK,CAAA,KACAC,EAAA,CAAAN,EAAAO,CAAA,KACAC,EAAA,CAAAR,EAAAS,CAAA,KACA,GAAAP,SACA,EACA,YACQM,EACR,YAEA,WAEM,GAAAJ,SACN,EACA,YACQI,EACR,YAEA,WAEM,GAAAF,EACN,iBACM,GAAAE,EACN,gBAEA,CACA,OAAAT,GACA,iBACA,iBACA,oBACA,YACA,gBACA,iBACA,CACA,EAYAA,EAAAC,GACAJ,IAAAzC,IAGAyC,EAAAzC,EACA,OAAA0C,IACAA,EAAAa,SAAApG,aAAA,UArEAD,GAwEAwF,EAAAc,YAAA,SAxEAtG,GA0EAqG,SAAAE,IAAA,CAAAC,WAAA,CAAAhB,IAEAA,EAAAiB,SAAA,YAA8B,EAAU3D,EAAM,YAAY,EAC1D,CAEA,SAAA4D,UAAAC,CAAA,EACA,MAAAA,YAAAA,EAAAC,IAAA,CAEA,SAAAC,eAAAF,CAAA,EACA,OAAAA,EAAAC,IAAA,CAAAE,UAAA,WACA,CACA,SAAAC,aAAAJ,CAAA,EACA,OAAAA,EAAAC,IAAA,CAAAE,UAAA,SACA,CAEA,SAAAE,0BAAAL,CAAA,EACA,GAAAE,eAAAF,GACA,IAAAA,EAAAM,SAAA,CACA,OACAC,EAAAP,EAAAQ,OAAA,CACAC,EAAAT,EAAAU,OAAA,CAEA,MACI,GAAAN,aAAAJ,GACJ,OACAO,EAAAP,EAAAQ,OAAA,CACAC,EAAAT,EAAAU,OAAA,EAGA,OACAH,EAAAI,IACAF,EAAAE,GACA,CACA,CA0DA,IAAAjC,EAAA,uGAoCA,SAAAkC,sBAAAC,CAAA,EACA,IAAAC,EAAAD,EAAAE,MAAA,CACA,KAAAD,KAAA,CACA,IAAAE,EAAAH,CAAA,CAAAC,EAAA,CAEA,GADAG,OAAAD,EAAA,gBACAE,SA9BAF,CAAA,EACA,IAAA7E,EAAAgF,iBAAAH,YAGA,UAAA7E,EAAAiF,QAAA,EAMAjF,SAAAA,EAAAkF,MAAA,EAAAlF,CAAAA,WAAAA,EAAAiF,QAAA,EAAAE,SAlBAN,CAAA,EACA,IAAAO,EAEA,IAAAC,EAAAL,iBAAA,OAAAI,CAAAA,EAAAE,WAAAT,EAAA,GAAAO,KAAA,IAAAA,EAAAA,EAAAP,GAAAQ,OAAA,CACA,MAAAA,SAAAA,GAAAA,gBAAAA,CACA,EAaAR,EAAA,GACA,GAAA7E,EAAAuF,OAAA,EACA,cAAAvF,GAAAA,SAAAA,EAAAwF,SAAA,EACA,oBAAAxF,GAAAA,SAAAA,EAAAyF,eAAA,EACA,iBAAAzF,GAAAA,WAAAA,EAAA0F,YAAA,EACA,WAAA1F,GAAAA,SAAAA,EAAA2F,MAAA,EACA,iBAAA3F,GAAAA,SAAAA,EAAA4F,YAAA,EACA,cAAA5F,GAAAA,YAAAA,EAAA6F,SAAA,EACAtD,EAAAuD,IAAA,CAAA9F,EAAA+F,UAAA,IAEA/F,UAAAA,EAAAgG,uBAAA,EAUAnB,GAAA,OAAAA,CACA,CACA,WACA,CAGA,SAAAoB,YAAApB,CAAA,EACA,OAAAA,GAAAqB,OAAAlB,iBAAAH,GAAAK,MAAA,IACA,CAGA,SAAAiB,cAAAtB,CAAA,EACA,IAAAuB,EAAA,GACA,KAAAvB,GACAuB,EAAAC,IAAA,CAAAxB,GAEAA,EAAAS,WAAAT,GAEA,OAAAuB,CACA,CAGA,SAAAd,WAAAT,CAAA,EACA,IACAyB,WAAAA,CAAA,CACA,CAAIzB,SACJ,GAAAyB,aAAAC,WACAD,EAAAE,IAAA,CAEAF,CACA,CAEA,IAAAtD,EAAA,EACAE,EAAA,EACAE,EAAA,EACAE,EAAA,EACAmD,EAAAC,WAAAA,WApIA,sBAAAC,WACA,OAAAA,WAAA,oBAAAC,OAAA,gBAEA,IAkIAC,EAAA,GACAC,EAAA,GACAC,EAAA,IAAAC,IACAC,EAAA,IAAAD,IACAE,EAAA,IAAAC,IA0CA,SAAAC,kBAAAvD,CAAA,EACA,IACAwD,OAAAA,CAAA,CACA,CAAIxD,EACJ,CACAO,EAAAA,CAAA,CACAE,EAAAA,CAAA,CACA,CAAIJ,0BAAAL,GACJiD,EAAA,GACAQ,+BAAA,CACAD,OAAAA,EACAjD,EAAAA,EACAE,EAAAA,CACA,GACAiD,kBACAV,EAAAjC,MAAA,KACA4C,0BAAA,OAAA3D,GACAA,EAAA4D,cAAA,GACA5D,EAAA6D,eAAA,GAEA,CACA,SAAAC,kBAAA9D,CAAA,EACA,IACAO,EAAAA,CAAA,CACAE,EAAAA,CAAA,CACA,CAAIJ,0BAAAL,GAQJ,GAJAiD,GAAAjD,IAAAA,EAAA+D,OAAA,GACAd,EAAA,GACAU,0BAAA,KAAA3D,IAEA,CAAAiD,EAAA,CACA,IACAO,OAAAA,CAAA,CACA,CAAMxD,EAKNyD,+BAAA,CACAD,OAAAA,EACAjD,EAAAA,EACAE,EAAAA,CACA,EACA,CACAkD,0BAAA,OAAA3D,GAGAgE,eACAhB,EAAAjC,MAAA,IACAf,EAAA4D,cAAA,EAEA,CACA,SAAAK,gBAAAjE,CAAA,EACA,IACAwD,OAAAA,CAAA,CACA,CAAIxD,EACJ,CACAO,EAAAA,CAAA,CACAE,EAAAA,CAAA,CACA,CAAIJ,0BAAAL,GACJoD,EAAAc,KAAA,GACAjB,EAAA,GACAD,EAAAjC,MAAA,IACAf,EAAA4D,cAAA,GAEAD,0BAAA,KAAA3D,GACAyD,+BAAA,CACAD,OAAAA,EACAjD,EAAAA,EACAE,EAAAA,CACA,GACAuD,eACAN,iBACA,CACA,SAAAD,+BAAA,CACAD,OAAAA,CAAA,CACAjD,EAAAA,CAAA,CACAE,EAAAA,CAAA,CACC,EACDuC,EAAAmB,MAAA,IACA,IAAAC,EAAA,KACAZ,CAAAA,aAAAa,aAAAb,aAAAc,UAAA,GACAF,CAAAA,EAAAZ,CAAA,EAEAH,EAAAkB,OAAA,CAAAC,IACA,IACAC,QAAAC,CAAA,CACAC,eAAAA,CAAA,CACA,CAAMH,EACNI,EAAAF,EAAAG,qBAAA,GACA,CACAC,OAAAA,CAAA,CACAC,KAAAA,CAAA,CACAC,MAAAA,CAAA,CACAC,IAAAA,CAAA,CACA,CAAML,EACNM,EAAAtC,EAAA+B,EAAAQ,MAAA,CAAAR,EAAAS,IAAA,CAEA,GADA7E,GAAAwE,EAAAG,GAAA3E,GAAAyE,EAAAE,GAAAzE,GAAAwE,EAAAC,GAAAzE,GAAAqE,EAAAI,EACA,CAOA,GAAAd,OAAAA,GAAA1E,SAAA2F,QAAA,CAAAjB,IAAAM,IAAAN,GAAA,CAAAM,EAAAW,QAAA,CAAAjB,IAAA,CAAAA,EAAAiB,QAAA,CAAAX,IAIAY,SA9QAC,CAAA,CAAAC,CAAA,MAMAC,EALA,GAAAF,IAAAC,EAAA,+CACA,IAAAjD,EAAA,CACAgD,EAAAjD,cAAAiD,GACAC,EAAAlD,cAAAkD,EACA,EAIA,KAAAjD,EAAAgD,CAAA,CAAAG,EAAA,OAAAnD,EAAAiD,CAAA,CAAAE,EAAA,MACAH,EAAAhD,EAAAgD,CAAA,CAAAI,GAAA,GACAH,EAAAjD,EAAAiD,CAAA,CAAAG,GAAA,GACAF,EAAAF,EAEAtE,OAAAwE,EAAA,6EACA,IAAAG,EAAA,CACAL,EAAAnD,YAAAxB,sBAAA2B,EAAAgD,CAAA,GACAC,EAAApD,YAAAxB,sBAAA2B,EAAAiD,CAAA,EACA,EACA,GAAAI,EAAAL,CAAA,GAAAK,EAAAJ,CAAA,EACA,IAAApK,EAAAqK,EAAAI,UAAA,CACAC,EAAA,CACAP,EAAAhD,EAAAgD,CAAA,CAAAG,EAAA,KACAF,EAAAjD,EAAAiD,CAAA,CAAAE,EAAA,IACA,EACA5E,EAAA1F,EAAA2F,MAAA,CACA,KAAAD,KAAA,CACA,IAAAiF,EAAA3K,CAAA,CAAA0F,EAAA,CACA,GAAAiF,IAAAD,EAAAP,CAAA,UACA,GAAAQ,IAAAD,EAAAN,CAAA,UACA,CACA,CACA,OAAAjL,KAAAyL,IAAA,CAAAJ,EAAAL,CAAA,CAAAK,EAAAJ,CAAA,CACA,EA6OApB,EAAAM,GAAA,GAOA,IAAAuB,EAAA7B,EACA8B,EAAA,GACA,KAAAD,GAAA,KAvSAE,EAwSA,GAAAF,EAAAZ,QAAA,CAAAX,GACA,MACY,GAxSZyB,CAFAA,EA0SYF,EAAApB,qBAAA,IAxSZtE,CAAA,CAAA6F,EAAA7F,CAAA,CAAA6F,EAAAC,KAAA,EAAAF,EAAA5F,CAAA,CAAA4F,EAAAE,KAAA,CAAAD,EAAA7F,CAAA,EAAA4F,EAAA1F,CAAA,CAAA2F,EAAA3F,CAAA,CAAA2F,EAAAE,MAAA,EAAAH,EAAA1F,CAAA,CAAA0F,EAAAG,MAAA,CAAAF,EAAA3F,CAAA,CAwSY,CACZyF,EAAA,GACA,KACA,CACAD,EAAAA,EAAAM,aAAA,CAEA,GAAAL,EACA,MAEA,CACAlD,EAAAR,IAAA,CAAAgC,EACA,CACA,EACA,CAIA,SAAAR,eACA,IAAAwC,EAAA,GACAC,EAAA,GACAzD,EAAAuB,OAAA,CAAAC,IACA,IACAkC,UAAAA,CAAA,CACA,CAAMlC,CACNkC,CAAA,eAAAA,EACAF,EAAA,GAEAC,EAAA,EAEA,GACA,IAAAzH,EAAA,EACAoE,EAAAmB,OAAA,CAAAoC,IACA3H,GAAA2H,CACA,GACAH,GAAAC,EACA3H,qBAAA,eAAAE,GACIwH,EACJ1H,qBAAA,aAAAE,GACIyH,EACJ3H,qBAAA,WAAAE,GA/YA,OAAAH,IACAa,SAAAE,IAAA,CAAAgH,WAAA,CAAA/H,GACAD,EAAA,KACAC,EAAA,KAgZA,CACA,SAAA6E,kBACAR,EAAAqB,OAAA,EAAAsC,EAAAC,KACA,IACAC,KAAAA,CAAA,CACA,CAAMD,EACNC,EAAAC,mBAAA,eAAA/C,iBACA8C,EAAAC,mBAAA,eAAAzD,mBACAwD,EAAAC,mBAAA,gBAAAlD,mBACAiD,EAAAC,mBAAA,eAAAlD,kBACA,GACAmD,OAAAD,mBAAA,aAAA/C,iBACAgD,OAAAD,mBAAA,iBAAA/C,iBACAZ,EAAAhF,IAAA,KACA4E,GACAD,EAAAjC,MAAA,IACAmC,EAAAqB,OAAA,EAAA2C,EAAAJ,KACA,IACAC,KAAAA,CAAA,CACA,CAAYD,EACZI,EAAA,IACAH,EAAAI,gBAAA,eAAAlD,iBACA8C,EAAAI,gBAAA,gBAAArD,mBACAiD,EAAAI,gBAAA,eAAArD,mBAEA,GAEAmD,OAAAE,gBAAA,aAAAlD,iBACAgD,OAAAE,gBAAA,iBAAAlD,kBAEAf,EAAAqB,OAAA,EAAA2C,EAAAJ,KACA,IACAC,KAAAA,CAAA,CACA,CAAUD,EACVI,EAAA,IACAH,EAAAI,gBAAA,eAAA5D,kBAAA,CACA6D,QAAA,EACA,GACAL,EAAAI,gBAAA,eAAArD,mBAEA,GAGA,CACA,SAAAH,0BAAA0D,CAAA,CAAArH,CAAA,EACAqD,EAAAkB,OAAA,CAAAC,IACA,IACA8C,sBAAAA,CAAA,CACA,CAAM9C,EACN+C,EAAAvE,EAAAwE,QAAA,CAAAhD,GACA8C,EAAAD,EAAAE,EAAAvH,EACA,EACA,CAOA,SAAAiB,OAAAwG,CAAA,CAAAC,CAAA,EACA,IAAAD,EAEA,MADAE,QAAAC,KAAA,CAAAF,GACAjL,MAAAiL,EAEA,CAIA,SAAAG,oBAAAC,CAAA,CAAAC,CAAA,CAAAC,EAFA,EAEA,SACA,EAAAxJ,OAAA,CAAAwJ,KAAAD,EAAAvJ,OAAA,CAAAwJ,GACA,EAEAF,EAAAC,EAAA,IAEA,CACA,SAAAE,oBAAAH,CAAA,CAAAC,CAAA,CAAAC,EATA,EASA,EACA,OAAAH,IAAAA,oBAAAC,EAAAC,EAAAC,EACA,CAEA,SAAAE,kBAAAJ,CAAA,CAAAC,CAAA,CAAAC,CAAA,EACA,OAAAH,IAAAA,oBAAAC,EAAAC,EAAAC,EACA,CAiBA,SAAA9K,YAAA,CACAiL,iBAAAC,CAAA,CACAC,WAAAA,CAAA,CACAhK,KAAAA,CAAA,CACC,EACD,IAAA8J,EAAAC,CAAA,CAAAC,EAAA,CACApH,OAAAkH,MAAAA,EAAA,yCAA4EE,EAAW,GACvF,IACA9M,cAAAA,EAAA,EACAC,YAAAA,CAAA,CACAK,QAAAA,EAAA,IACAC,QAAAA,EAAA,EACA,CAAIqM,EACJ,GAAAN,EAAAA,oBAAAxJ,EAAAvC,IACA,GAAAN,EAAA,CAEA,IAAA8M,EAAA,CAAA/M,EAAAO,CAAA,IAEAuC,EADAwJ,EAAAA,oBAAAxJ,EAAAiK,GACA/M,EAEAO,CAEA,MACAuC,EAAAvC,EAKA,OADAuC,EAAAC,WAAAD,CADAA,EAAA9D,KAAAgO,GAAA,CAAA1M,EAAAwC,EAAA,EACAG,OAAA,CA3DA,IA6DA,CAGA,SAAAgK,oBAAA,CACAC,MAAAA,CAAA,CACAC,cAAAA,CAAA,CACAP,iBAAAC,CAAA,CACAO,aAAAA,CAAA,CACAC,WAAAA,CAAA,CACAC,QAAAA,CAAA,CACC,EACD,GAAAX,kBAAAO,EAAA,GACA,OAAAC,EAEA,IAAAI,EAAA,IAAAJ,EAAA,CACA,CAAAK,EAAAC,EAAA,CAAAL,EACA1H,OAAA8H,MAAAA,EAAA,6BACA9H,OAAA+H,MAAAA,EAAA,8BACA,IAAAC,EAAA,EAsBA,GAAAJ,aAAAA,EAAA,CACA,CAEA,IAAAK,EAAAT,EAAA,EAAAO,EAAAD,EACAZ,EAAAC,CAAA,CAAAc,EAAA,CACAjI,OAAAkH,EAAA,yCAA0Ee,EAAM,GAChF,IACA3N,cAAAA,EAAA,EACAC,YAAAA,CAAA,CACAM,QAAAA,EAAA,EACA,CAAUqM,EAIV,GAAA3M,EAAA,CACA,IAAA2N,EAAAT,CAAA,CAAAQ,EAAA,CAEA,GADAjI,OAAAkI,MAAAA,EAAA,6CAAgFD,EAAM,GACtFhB,kBAAAiB,EAAA5N,GAAA,CACA,IAAA6N,EAAAtN,EAAAqN,EAGAtB,oBAAAuB,EAAA7O,KAAA8O,GAAA,CAAAZ,IAAA,GACAA,CAAAA,EAAAA,EAAA,IAAAW,EAAAA,CAAA,CAGA,CACA,CACA,CAEA,CAEA,IAAAF,EAAAT,EAAA,EAAAM,EAAAC,EACAb,EAAAC,CAAA,CAAAc,EAAA,CACAjI,OAAAkH,EAAA,wCAAyEe,EAAM,GAC/E,IACA3N,cAAAA,EAAA,EACAC,YAAAA,CAAA,CACAM,QAAAA,EAAA,EACA,CAAUqM,EAIV,GAAA3M,EAAA,CACA,IAAA2N,EAAAT,CAAA,CAAAQ,EAAA,CAEA,GADAjI,OAAAkI,MAAAA,EAAA,6CAAgFD,EAAM,GACtFhB,kBAAAiB,EAAArN,GAAA,CACA,IAAAsN,EAAAD,EAAA5N,EAGAsM,oBAAAuB,EAAA7O,KAAA8O,GAAA,CAAAZ,IAAA,GACAA,CAAAA,EAAAA,EAAA,IAAAW,EAAAA,CAAA,CAGA,CACA,CACA,CACA,CAIA,CAOA,IAAAE,EAAAb,EAAA,OACAS,EAAAT,EAAA,EAAAO,EAAAD,EACAQ,EAAA,EAGA,QACA,IAAAJ,EAAAT,CAAA,CAAAQ,EAAA,CACAjI,OAAAkI,MAAAA,EAAA,6CAA4ED,EAAM,GAClF,IAAAM,EAAAtM,YAAA,CACAiL,iBAAAC,EACAC,WAAAa,EACA7K,KAAA,GACA,GACAoK,EAAAe,EAAAL,EAKA,GAFAI,GAAAd,EAEAS,CADAA,GAAAI,CAAA,EACA,GAAAJ,GAAAd,EAAArH,MAAA,CACA,KAEA,CAGA,IAAA0I,EAAAlP,KAAAgO,GAAA,CAAAhO,KAAA8O,GAAA,CAAAZ,GAAAlO,KAAA8O,GAAA,CAAAE,IACAd,EAAAA,EAAA,IAAAgB,EAAAA,CAGA,CAEA,CAGA,IAAAC,EAAAjB,EAAA,EAAAM,EAAAC,EACAE,EAAAQ,EACA,KAAAR,GAAA,GAAAA,EAAAd,EAAArH,MAAA,GACA,IAAA4I,EAAApP,KAAA8O,GAAA,CAAAZ,GAAAlO,KAAA8O,GAAA,CAAAJ,GACAE,EAAAT,CAAA,CAAAQ,EAAA,CACAjI,OAAAkI,MAAAA,EAAA,6CAA4ED,EAAM,GAClF,IAAAU,EAAAT,EAAAQ,EACAE,EAAA3M,YAAA,CACAiL,iBAAAC,EACAC,WAAAa,EACA7K,KAAAuL,CACA,GACA,IAAA1B,kBAAAiB,EAAAU,KACAZ,GAAAE,EAAAU,EACAf,CAAA,CAAAI,EAAA,CAAAW,EACAZ,EAAAa,WAAA,IAAAC,aAAA,CAAAxP,KAAA8O,GAAA,CAAAZ,GAAAqB,WAAA,IAAArM,KAAAA,EAAA,CACAuM,QAAA,EACA,IAAS,GACT,KAGAvB,CAAAA,EAAA,EACAS,IAEAA,GAEA,CACA,CAOA,GAAAe,SA1NAnC,CAAA,CAAAC,CAAA,CAAAC,CAAA,EACA,GAAAF,EAAA/G,MAAA,GAAAgH,EAAAhH,MAAA,CACA,SAEA,QAAAmI,EAAA,EAAsBA,EAAApB,EAAA/G,MAAA,CAAuBmI,IAAA,CAC7C,IAAAgB,EAAApC,CAAA,CAAAoB,EAAA,CACAiB,EAAApC,CAAA,CAAAmB,EAAA,CACA,IAAAhB,kBAAAgC,EAAAC,EAPAnC,KAAAA,GAQA,QAEA,CACA,QACA,EA8MAY,EAAAE,GAIA,OAAAF,CAEA,EAEA,IAAAc,EAAAjB,EAAA,EAAAO,EAAAD,EACAI,EAAAT,CAAA,CAAAgB,EAAA,CACAzI,OAAAkI,MAAAA,EAAA,6CAA0EO,EAAW,GACrF,IAAAE,EAAAT,EAAAF,EACAY,EAAA3M,YAAA,CACAiL,iBAAAC,EACAC,WAAAqB,EACArL,KAAAuL,CACA,GAMA,GAHAd,CAAA,CAAAY,EAAA,CAAAG,EAGA,CAAA3B,kBAAA2B,EAAAD,GAAA,CACA,IAAAD,EAAAC,EAAAC,EACAH,EAAAjB,EAAA,EAAAO,EAAAD,EACAG,EAAAQ,EACA,KAAAR,GAAA,GAAAA,EAAAd,EAAArH,MAAA,GACA,IAAAoI,EAAAL,CAAA,CAAAI,EAAA,CACAjI,OAAAkI,MAAAA,EAAA,6CAA8ED,EAAM,GACpF,IAAAU,EAAAT,EAAAQ,EACAE,EAAA3M,YAAA,CACAiL,iBAAAC,EACAC,WAAAa,EACA7K,KAAAuL,CACA,GAKA,GAJA1B,kBAAAiB,EAAAU,KACAF,GAAAE,EAAAV,EACAL,CAAA,CAAAI,EAAA,CAAAW,GAEA3B,kBAAAyB,EAAA,GACA,KAEAlB,CAAAA,EAAA,EACAS,IAEAA,GAEA,CACA,CACA,CAKA,IAAAkB,EAAAtB,EAAAuB,MAAA,EAAAC,EAAAjM,IAAAA,EAAAiM,EAAA,UAKA,kBAAAF,EAAA,KAQAtB,EAJAF,CAKA,CAyCA,SAAA2B,gCAAAzN,CAAA,CAAA0N,EAAA9K,QAAA,EACA,OAAA+K,MAAAC,IAAA,CAAAF,EAAAG,gBAAA,uDAAiG7N,EAAQ,KACzG,CAEA,SAAA8N,4BAAA9N,CAAA,CAAAnB,CAAA,CAAA6O,EAAA9K,QAAA,EACA,IAAAmL,EAAAN,gCAAAzN,EAAA0N,GACAtB,EAAA2B,EAAAC,SAAA,CAAAC,GAAAA,EAAAC,YAAA,kCAAArP,GACA,OAAAuN,MAAAA,EAAAA,EAAA,IACA,CAEA,SAAA+B,sBAAAnO,CAAA,CAAAoO,CAAA,CAAAC,CAAA,EACA,IAAAjC,EAAA0B,4BAAA9N,EAAAoO,EAAAC,GACA,OAAAjC,MAAAA,EAAA,CAAAA,EAAAA,EAAA,WAGA,SAAAkC,qBAAAzP,CAAA,CAAA0P,EAAA3L,QAAA,EACA,IAAA4L,EAEA,GAAAD,aAAAhH,aAAA,CAAAgH,MAAAA,EAAA,cAAAC,CAAAA,EAAAD,EAAAE,OAAA,GAAAD,KAAA,IAAAA,EAAA,OAAAA,EAAAE,YAAA,GAAA7P,EACA,OAAA0P,EAIA,IAAA5G,EAAA4G,EAAAI,aAAA,4CAAuF9P,EAAG,YAC1F,GAGA,IACA,CAEA,SAAA+P,uBAAA/P,CAAA,CAAA6O,EAAA9K,QAAA,EACA,IAAA+E,EAAA+F,EAAAiB,aAAA,kCAAuE9P,EAAG,YAC1E,GAGA,IACA,CA+HA,SAAAgQ,SAAAC,CAAA,CAAAC,CAAA,EACA,GAAAD,EAAA7K,MAAA,GAAA8K,EAAA9K,MAAA,CACA,SAEA,QAAAmI,EAAA,EAAsBA,EAAA0C,EAAA7K,MAAA,CAAuBmI,IAC7C,GAAA0C,CAAA,CAAA1C,EAAA,GAAA2C,CAAA,CAAA3C,EAAA,CACA,SAGA,QACA,CAEA,SAAA4C,6BAAApF,CAAA,CAAA1G,CAAA,EAEA,IACAO,EAAAA,CAAA,CACAE,EAAAA,CAAA,CACA,CAAIJ,0BAAAL,GACJ,MAAA+L,eALArF,EAKAnG,EAAAE,CACA,CAyGA,SAAAuL,mBAAAC,CAAA,CAAAC,CAAA,CAAAC,CAAA,EACAD,EAAA3H,OAAA,EAAAlG,EAAA6K,KACA,IAAArL,EAAAoO,CAAA,CAAA/C,EAAA,CACAjI,OAAApD,EAAA,kCAAwDqL,EAAM,GAC9D,IACA5L,UAAAA,CAAA,CACAC,YAAAA,CAAA,CACA5B,GAAAyB,CAAA,CACA,CAAMS,EACN,CACAtC,cAAAA,EAAA,EACAC,YAAAA,CAAA,CACA,CAAM+B,EACN6O,EAAAD,CAAA,CAAA/O,EAAA,CACA,GAAAgP,MAAAA,GAAA/N,IAAA+N,EAAA,CACAD,CAAA,CAAA/O,EAAA,CAAAiB,EACA,IACAtC,WAAAA,CAAA,CACAC,SAAAA,CAAA,CACAC,SAAAA,CAAA,CACA,CAAQqB,EACRrB,GACAA,EAAAoC,EAAA+N,GAEA5Q,GAAAO,CAAAA,GAAAC,CAAA,IACAA,GAAAoQ,CAAAA,MAAAA,GAAAnE,oBAAAmE,EAAA7Q,EAAA,IAAA0M,oBAAA5J,EAAA9C,IACAS,IAEAD,GAAAqQ,CAAAA,MAAAA,GAAA,CAAAnE,oBAAAmE,EAAA7Q,EAAA,GAAA0M,oBAAA5J,EAAA9C,IACAQ,IAGA,CACA,EACA,CAEA,SAAAsQ,eAAA9G,CAAA,CAAAC,CAAA,EACA,GAAAD,EAAAxE,MAAA,GAAAyE,EAAAzE,MAAA,CACA,SAEA,QAAAmI,EAAA,EAAwBA,EAAA3D,EAAAxE,MAAA,CAAkBmI,IAC1C,GAAA3D,CAAA,CAAA2D,EAAA,EAAA1D,CAAA,CAAA0D,EAAA,CACA,SAIA,QACA,CAsDA,SAAAoD,yBAAAC,CAAA,EACA,IACA,uBAAAC,aAEAD,EAAAE,OAAA,CAAAC,GACAF,aAAAC,OAAA,CAAAC,GAEAH,EAAAI,OAAA,EAAAD,EAAAE,KACAJ,aAAAG,OAAA,CAAAD,EAAAE,EACA,OAEA,6DAEA,CAAI,MAAAhF,EAAA,CACJD,QAAAC,KAAA,CAAAA,GACA2E,EAAAE,OAAA,UACAF,EAAAI,OAAA,OACA,CACA,CAEA,SAAAE,iBAAAC,CAAA,EACA,gCAAmCA,EAAW,EAO9C,SAAAC,YAAAC,CAAA,EACA,OAAAA,EAAAC,GAAA,CAAAC,IACA,IACA3P,YAAAA,CAAA,CACA5B,GAAAA,CAAA,CACA6B,cAAAA,CAAA,CACAtB,MAAAA,CAAA,CACA,CAAMgR,SACN,EACAvR,EAEAO,EAAA,GAAwBA,EAAM,GAAGiR,KAAAC,SAAA,CAAA7P,GAA4B,EAAA4P,KAAAC,SAAA,CAAA7P,EAE7D,GAAG8P,IAAA,EAAA9H,EAAAC,IAAAD,EAAAwE,aAAA,CAAAvE,IAAA8H,IAAA,KACH,CACA,SAAAC,8BAAAT,CAAA,CAAAU,CAAA,EACA,IACA,IAAAC,EAAAZ,iBAAAC,GACAY,EAAAF,EAAAf,OAAA,CAAAgB,GACA,GAAAC,EAAA,CACA,IAAAC,EAAAR,KAAAS,KAAA,CAAAF,GACA,oBAAAC,GAAAA,MAAAA,EACA,OAAAA,CAEA,CACA,CAAI,MAAA/F,EAAA,EACJ,WACA,CAOA,SAAAiG,oBAAAf,CAAA,CAAAE,CAAA,CAAAc,CAAA,CAAAC,CAAA,CAAAP,CAAA,EACA,IAAAQ,EACA,IAAAP,EAAAZ,iBAAAC,GACAmB,EAAAlB,YAAAC,GACAjO,EAAA,OAAAiP,CAAAA,EAAAT,8BAAAT,EAAAU,EAAA,GAAAQ,KAAA,IAAAA,EAAAA,EAAA,EACAjP,CAAAA,CAAA,CAAAkP,EAAA,EACAC,cAAAC,OAAAC,WAAA,CAAAN,EAAAO,OAAA,IACAnC,OAAA6B,CACA,EACA,IACAP,EAAAb,OAAA,CAAAc,EAAAN,KAAAC,SAAA,CAAArO,GACA,CAAI,MAAA6I,EAAA,CACJD,QAAAC,KAAA,CAAAA,EACA,CACA,CAGA,SAAA0G,yBAAA,CACApC,OAAAtD,CAAA,CACAT,iBAAAA,CAAA,CACC,EACD,IAAAW,EAAA,IAAAF,EAAA,CACA2F,EAAAzF,EAAAuB,MAAA,EAAAmE,EAAAtT,IAAAsT,EAAAtT,EAAA,GAGA,GAAA4N,EAAA/H,MAAA,GAAAoH,EAAApH,MAAA,CACA,MAAAtE,MAAA,WAA2B0L,EAAApH,MAAA,gBAAyB,EAAgB+H,EAAAmE,GAAA,CAAA5O,GAAA,GAA0BA,EAAK,IAAAiP,IAAA,OAAe,GAC9G,IAAApF,kBAAAqG,EAAA,MAAAzF,EAAA/H,MAAA,GACJ,QAAAmI,EAAA,EAAwBA,EAAAf,EAAApH,MAAA,CAAiCmI,IAAA,CACzD,IAAAU,EAAAd,CAAA,CAAAI,EAAA,CACAjI,OAAA2I,MAAAA,EAAA,kCAAmEV,EAAM,GACzE,IAAAW,EAAA,IAAA0E,EAAA3E,CACAd,CAAAA,CAAA,CAAAI,EAAA,CAAAW,CACA,CAEA,IAAA4E,EAAA,EAGA,QAAAvF,EAAA,EAAsBA,EAAAf,EAAApH,MAAA,CAAiCmI,IAAA,CACvD,IAAAU,EAAAd,CAAA,CAAAI,EAAA,CACAjI,OAAA2I,MAAAA,EAAA,kCAAiEV,EAAM,GACvE,IAAAW,EAAA3M,YAAA,CACAiL,iBAAAA,EACAE,WAAAa,EACA7K,KAAAuL,CACA,GACAA,GAAAC,IACA4E,GAAA7E,EAAAC,EACAf,CAAA,CAAAI,EAAA,CAAAW,EAEA,CAIA,IAAA3B,kBAAAuG,EAAA,GACA,QAAAvF,EAAA,EAAwBA,EAAAf,EAAApH,MAAA,CAAiCmI,IAAA,CACzD,IAAAC,EAAAL,CAAA,CAAAI,EAAA,CACAjI,OAAAkI,MAAAA,EAAA,kCAAiED,EAAM,GACvE,IAAAU,EAAAT,EAAAsF,EACA5E,EAAA3M,YAAA,CACAiL,iBAAAA,EACAE,WAAAa,EACA7K,KAAAuL,CACA,GACA,GAAAT,IAAAU,IACA4E,GAAA5E,EAAAV,EACAL,CAAA,CAAAI,EAAA,CAAAW,EAGA3B,kBAAAuG,EAAA,IACA,KAGA,CAEA,OAAA3F,CACA,CAGA,IAAA4F,EAAA,CACAjC,QAAAC,IACAJ,yBAAAoC,GACAA,EAAAjC,OAAA,CAAAC,IAEAC,QAAA,CAAAD,EAAAE,KACAN,yBAAAoC,GACAA,EAAA/B,OAAA,CAAAD,EAAAE,EACA,CACA,EACA+B,EAAA,GACA,SAAAC,2BAAA,CACA9B,WAAAA,EAAA,KACA1R,SAAAA,CAAA,CACAC,UAAAC,EAAA,GACAoL,UAAAA,CAAA,CACAhL,aAAAA,CAAA,CACAC,GAAAC,EAAA,KACAiT,SAAAA,EAAA,KACAC,iBAAAA,EAAA,KACAtB,QAAAA,EAAAkB,CAAA,CACAvS,MAAAC,CAAA,CACAC,QAAAC,EAAA,MACA,GAAAC,EACC,EACD,IAAAO,EAAAhC,YAAAc,GACAmT,EAAA/U,EAAA,MACA,CAAAgV,EAAAC,EAAA,CAAAhV,EAAA,MACA,CAAAiS,EAAAgD,EAAA,CAAAjV,EAAA,IACAkV,EAAAC,WAj5BA,IAAAvI,EAAAwI,EAAA,CAAApV,EAAA,GACA,OAAAP,EAAA,IAAA2V,EAAAC,GAAAA,EAAA,MACA,IAg5BAC,EAAAvV,EAAA,IACAwV,EAAAxV,EAAA,IAAAmJ,KACAsM,EAAAzV,EAAA,GACA0V,EAAA1V,EAAA,CACA8S,WAAAA,EACApG,UAAAA,EACAsI,UAAAA,EACArT,GAAAmB,EACAgS,iBAAAA,EACAD,SAAAA,EACArB,QAAAA,CACA,GACAmC,EAAA3V,EAAA,CACAkS,OAAAA,EACA0D,eAAA,GACAC,sBAAA,EACA,GACA7V,EAAA,CACA8V,wBAAA,GACAC,8BAAA,GACAC,aAAA,KAEAnW,EAAA6B,EAAA,MACAsC,MAAA,IAAA0R,EAAAxU,OAAA,CAAAS,EAAA,CACAsU,UAAA,KACA,IACA/D,OAAAA,CAAA,CACA,CAAQyD,EAAAzU,OAAA,CACR,OAAAgR,CACA,EACAgD,UAAAgB,IACA,IACArB,SAAAA,CAAA,CACA,CAAQa,EAAAxU,OAAA,CACR,CACAgR,OAAAtD,CAAA,CACAgH,eAAAA,CAAA,CACA,CAAQD,EAAAzU,OAAA,CACRiV,EAAA7B,yBAAA,CACApC,OAAAgE,EACA/H,iBAAAyH,EAAA3C,GAAA,CAAApP,GAAAA,EAAAN,WAAA,CACA,GACAoO,SAAA/C,EAAAuH,KACAjB,EAAAiB,GACAR,EAAAzU,OAAA,CAAAgR,MAAA,CAAAiE,EACAtB,GACAA,EAAAsB,GAEAnE,mBAAA4D,EAAAO,EAAAZ,EAAArU,OAAA,EAEA,CACA,GAAG,IACHyC,EAAA,KACA+R,EAAAxU,OAAA,CAAA4R,UAAA,CAAAA,EACA4C,EAAAxU,OAAA,CAAAwL,SAAA,CAAAA,EACAgJ,EAAAxU,OAAA,CAAA8T,SAAA,CAAAA,EACAU,EAAAxU,OAAA,CAAAS,EAAA,CAAAmB,EACA4S,EAAAxU,OAAA,CAAA2T,QAAA,CAAAA,EACAa,EAAAxU,OAAA,CAAAsS,OAAA,CAAAA,CACA,GACA4C,SAzjBA,CACAV,mBAAAA,CAAA,CACAC,eAAAA,CAAA,CACA7S,QAAAA,CAAA,CACAoP,OAAAA,CAAA,CACA0D,eAAAA,CAAA,CACAzE,kBAAAA,CAAA,CACA+D,UAAAA,CAAA,CACC,EACDlV,EAAA,CACAqW,gCAAA,EACA,GACA1S,EAAA,KACA,IAAAwN,EACA,OAEA,IAAAmF,EAAA/F,gCAAAzN,EAAAqO,GACA,QAAAjC,EAAA,EAAwBA,EAAA0G,EAAA7O,MAAA,GAAmCmI,IAAA,CAC3D,IACAqH,SAAAA,CAAA,CACAC,SAAAA,CAAA,CACAC,SAAAA,CAAA,CACA,CAAQC,SA/GR,CACAxE,OAAAA,CAAA,CACAD,YAAAA,CAAA,CACAtD,aAAAA,CAAA,CACC,EACD,IAAAgI,EAAA,EACAC,EAAA,IACAC,EAAA,EACAC,EAAA,EACAC,EAAApI,CAAA,IACA1H,OAAA8P,MAAAA,EAAA,wBAGA9E,EAAA1H,OAAA,EAAA1G,EAAAqL,KACA,IACA3L,YAAAA,CAAA,CACA,CAAMM,EACN,CACAhC,QAAAA,EAAA,IACAC,QAAAA,EAAA,EACA,CAAMyB,CACN2L,CAAAA,IAAA6H,GACAJ,EAAA7U,EACA8U,EAAA/U,IAEAgV,GAAA/U,EACAgV,GAAAjV,EAEA,GACA,IAAA0U,EAAAhW,KAAAgO,GAAA,CAAAqI,EAAA,IAAAC,GACAL,EAAAjW,KAAAyW,GAAA,CAAAL,EAAA,IAAAG,GACAL,EAAAvE,CAAA,CAAA6E,EAAA,CACA,OACAR,SAAAA,EACAC,SAAAA,EACAC,SAAAA,CACA,CACA,EA0EQ,CACRvE,OAAAA,EACAD,YAAA2D,EACAjH,aAAA,CAAAO,EAAAA,EAAA,KAEA+H,EAAAX,CAAA,CAAApH,EAAA,CACA,GAAA+H,MAAAA,OAAyC,CACzC,IAAApT,EAAA+R,CAAA,CAAA1G,EAAA,CACAjI,OAAApD,EAAA,kCAA4DqL,EAAM,IAClE+H,EAAAtR,YAAA,iBAAA9B,EAAAlC,EAAA,EACAsV,EAAAtR,YAAA,oBAAApF,KAAA2W,KAAA,CAAAX,IACAU,EAAAtR,YAAA,oBAAApF,KAAA2W,KAAA,CAAAV,IACAS,EAAAtR,YAAA,iBAAA8Q,MAAAA,EAAA,GAAAlW,KAAA2W,KAAA,CAAAT,GAAA,GACA,CACA,CACA,WACAH,EAAA/L,OAAA,EAAA0M,EAAA/H,KACA+H,EAAAE,eAAA,kBACAF,EAAAE,eAAA,kBACAF,EAAAE,eAAA,kBACAF,EAAAE,eAAA,iBACA,EACA,CACA,EAAG,CAAArU,EAAAoP,EAAA0D,EAAAzE,EAAA,EACHvR,EAAA,KACA,IAAAuR,EACA,OAEA,IAAAiG,EAAAzB,EAAAzU,OAAA,CACA+F,OAAAmQ,EAAA,0BACA,IACAxB,eAAAA,CAAA,CACA,CAAMwB,EACNC,EAAAjG,qBAAAtO,EAAAqO,GACAlK,OAAAoQ,MAAAA,EAAA,0BAA2DvU,EAAQ,IACnE,IAAA+N,EAAAN,gCAAAzN,EAAAqO,GACAlK,OAAA4J,EAAA,yCAA6D/N,EAAQ,IACrE,IAAAwU,EAAAzG,EAAAoC,GAAA,CAAAlC,IACA,IAAAwG,EAAAxG,EAAAC,YAAA,gCACA/J,OAAAsQ,EAAA,oDACA,IAAAC,EAAAC,EAAA,CAAAC,SA1EA5U,CAAA,CAAAyU,CAAA,CAAAtF,CAAA,CAAAzB,EAAA9K,QAAA,EACA,IAAAiS,EAAAC,EAAAC,EAAAC,EACA,IAAA/G,EAAAW,uBAAA6F,EAAA/G,GACAK,EAAAN,gCAAAzN,EAAA0N,GACAtB,EAAA6B,EAAAF,EAAAkH,OAAA,CAAAhH,GAAA,GACAyG,EAAA,OAAAG,CAAAA,EAAA,OAAAC,CAAAA,EAAA3F,CAAA,CAAA/C,EAAA,GAAA0I,KAAA,IAAAA,EAAA,OAAAA,EAAAjW,EAAA,GAAAgW,KAAA,IAAAA,EAAAA,EAAA,KACAF,EAAA,OAAAI,CAAAA,EAAA,OAAAC,CAAAA,EAAA7F,CAAA,CAAA/C,EAAA,KAAA4I,KAAA,IAAAA,EAAA,OAAAA,EAAAnW,EAAA,GAAAkW,KAAA,IAAAA,EAAAA,EAAA,KACA,OAAAL,EAAAC,EAAA,EAmEA3U,EAAAyU,EAAA3B,EAAAzE,GACA,GAAAqG,MAAAA,GAAAC,MAAAA,EACA,aAEA,IAAAO,UAAAhS,IACA,IAAAA,EAAAiS,gBAAA,EAIA,UADAjS,EAAA5G,GAAA,CAEA,CACA4G,EAAA4D,cAAA,GACA,IAAAsF,EAAA0G,EAAA9E,SAAA,CAAAjN,GAAAA,EAAAlC,EAAA,GAAA6V,GACA,GAAAtI,GAAA,GACA,IAAArL,EAAA+R,CAAA,CAAA1G,EAAA,CACAjI,OAAApD,EAAA,iCAAmEqL,EAAM,GACzE,IAAA7K,EAAA6N,CAAA,CAAAhD,EAAA,CACA,CACA3N,cAAAA,EAAA,EACAC,YAAAA,CAAA,CACAM,QAAAA,EAAA,EACA,CAAkB+B,EAAAN,WAAA,CAClB,GAAAc,MAAAA,GAAA7C,EAAA,CACA,IAAAsN,EAAAN,oBAAA,CACAC,MAAAP,kBAAA7J,EAAA9C,GAAAO,EAAAP,EAAAA,EAAA8C,EACAqK,cAAAwD,EACA/D,iBAAAyH,EAAA3C,GAAA,CAAApP,GAAAA,EAAAN,WAAA,EACAoL,aAAAsC,sBAAAnO,EAAAyU,EAAApG,GACAvC,WAAAsD,EACArD,QAAA,UACA,GACAqD,IAAApD,GACAoG,EAAApG,EAEA,CACA,CAEA,CAEA,EAEA,OADAiC,EAAA5D,gBAAA,WAAA6K,WACA,KACAjH,EAAA/D,mBAAA,WAAAgL,UACA,CACA,GACA,WACAV,EAAA/M,OAAA,CAAA2N,GAAAA,IACA,CACA,EAAG,CAAA/G,EAAAuE,EAAAC,EAAA7S,EAAAoP,EAAA0D,EAAAV,EAAA,CACH,EA0cA,CACAQ,mBAAAA,EACAC,eAAAA,EACA7S,QAAAA,EACAoP,OAAAA,EACA0D,eAAAD,EAAAzU,OAAA,CAAA0U,cAAA,CACAV,UAAAA,EACA/D,kBAAA4D,EAAA7T,OAAA,GAEAtB,EAAA,KACA,IACAgW,eAAAA,CAAA,CACA,CAAMD,EAAAzU,OAAA,CAGN,GAAA4R,EAAA,CACA,GAAAZ,IAAAA,EAAAnL,MAAA,EAAAmL,EAAAnL,MAAA,GAAA6O,EAAA7O,MAAA,CACA,OAEA,IAAAoR,EAAAxD,CAAA,CAAA7B,EAAA,OAGAqF,IACAA,EAAAC,SA/QAC,CAAA,CAAAC,EAAA,IACA,IAAAC,EAAA,KASA,MARA,IAAAC,KACA,OAAAD,GACAE,aAAAF,GAEAA,EAAAG,WAAA,KACAL,KAAAG,EACA,EAAKF,EACL,CAEA,EAoQAzE,oBAlHA,KAmHAc,CAAA,CAAA7B,EAAA,CAAAqF,GAKA,IAAAQ,EAAA,IAAA/C,EAAA,CACAgD,EAAA,IAAAzP,IAAAqM,EAAAtU,OAAA,EACAiX,EAAArF,EAAA6F,EAAAC,EAAA1G,EAAAsB,EACA,CACA,EAAG,CAAAV,EAAAZ,EAAAsB,EAAA,EAGH5T,EAAA,KACA,GAGA,IAAA8C,EAAAhD,EAAAmE,IACA,IACAgR,SAAAA,CAAA,CACA,CAAMa,EAAAxU,OAAA,CACN,CACAgR,OAAAtD,CAAA,CACAgH,eAAAA,CAAA,CACA,CAAMD,EAAAzU,OAAA,CACN,GAAA2C,EAAAN,WAAA,CAAA/B,WAAA,EACA,IAAA4M,EAAAwH,EAAA3C,GAAA,CAAApP,GAAAA,EAAAN,WAAA,EACA,CACAhC,cAAAA,EAAA,EACAsX,UAAAA,CAAA,CACAlK,aAAAA,CAAA,CACA,CAAQmK,gBAAAlD,EAAA/R,EAAA+K,GAER,GADA3H,OAAA4R,MAAAA,EAAA,mCAAmEhV,EAAAlC,EAAA,CAAa,IAChF,CAAAsM,oBAAA4K,EAAAtX,GAAA,CAGAiU,EAAAtU,OAAA,CAAA6X,GAAA,CAAAlV,EAAAlC,EAAA,CAAAkX,GACA,IAAAG,EAAAC,mBAAArD,EAAA/R,KAAA+R,EAAA7O,MAAA,GACA0H,EAAAuK,EAAAH,EAAAtX,EAAAA,EAAAsX,EACA/J,EAAAN,oBAAA,CACAC,MAAAA,EACAC,cAAAE,EACAT,iBAAAC,EACAO,aAAAA,EACAC,WAAAA,EACAC,QAAA,gBACA,GACAwD,eAAAzD,EAAAE,KACAoG,EAAApG,GACA6G,EAAAzU,OAAA,CAAAgR,MAAA,CAAApD,EACA+F,GACAA,EAAA/F,GAEAkD,mBAAA4D,EAAA9G,EAAAyG,EAAArU,OAAA,EAEA,CACA,CACA,EAAG,IAGHyB,EAAAjD,EAAA,CAAAmE,EAAAqV,KACA,IACArE,SAAAA,CAAA,CACA,CAAMa,EAAAxU,OAAA,CACN,CACAgR,OAAAtD,CAAA,CACAgH,eAAAA,CAAA,CACA,CAAMD,EAAAzU,OAAA,CACN,GAAA2C,EAAAN,WAAA,CAAA/B,WAAA,EACA,IAAA4M,EAAAwH,EAAA3C,GAAA,CAAApP,GAAAA,EAAAN,WAAA,EACA,CACAhC,cAAAA,EAAA,EACAsX,UAAAA,EAAA,EACA/W,QAAAqX,EAAA,EACAxK,aAAAA,CAAA,CACA,CAAQmK,gBAAAlD,EAAA/R,EAAA+K,GACR9M,EAAAoX,MAAAA,EAAAA,EAAAC,EACA,GAAAlL,oBAAA4K,EAAAtX,GAAA,CAEA,IAAA6X,EAAA5D,EAAAtU,OAAA,CAAAmY,GAAA,CAAAxV,EAAAlC,EAAA,EACA2X,EAAAF,MAAAA,GAAAA,GAAAtX,EAAAsX,EAAAtX,EACAkX,EAAAC,mBAAArD,EAAA/R,KAAA+R,EAAA7O,MAAA,GACA0H,EAAAuK,EAAAH,EAAAS,EAAAA,EAAAT,EACA/J,EAAAN,oBAAA,CACAC,MAAAA,EACAC,cAAAE,EACAT,iBAAAC,EACAO,aAAAA,EACAC,WAAAA,EACAC,QAAA,gBACA,GACAwD,eAAAzD,EAAAE,KACAoG,EAAApG,GACA6G,EAAAzU,OAAA,CAAAgR,MAAA,CAAApD,EACA+F,GACAA,EAAA/F,GAEAkD,mBAAA4D,EAAA9G,EAAAyG,EAAArU,OAAA,EAEA,CACA,CACA,EAAG,IAGH0B,EAAAlD,EAAAmE,IACA,IACAqO,OAAAA,CAAA,CACA0D,eAAAA,CAAA,CACA,CAAMD,EAAAzU,OAAA,CACN,CACA2X,UAAAA,CAAA,CACA,CAAMC,gBAAAlD,EAAA/R,EAAAqO,GAEN,OADAjL,OAAA4R,MAAAA,EAAA,mCAAiEhV,EAAAlC,EAAA,CAAa,IAC9EkX,CACA,EAAG,IAGHhW,EAAAnD,EAAA,CAAAmE,EAAApC,KACA,IACAmU,eAAAA,CAAA,CACA,CAAMD,EAAAzU,OAAA,CACNmN,EAAA4K,mBAAArD,EAAA/R,GACA,OAAA0V,SAzaA,CACA9X,YAAAA,CAAA,CACAuT,UAAAA,CAAA,CACA9C,OAAAA,CAAA,CACArO,UAAAA,CAAA,CACAwK,WAAAA,CAAA,CACAmL,UAAAA,EAAA,EACC,EACD,IAAAnV,EAAA6N,CAAA,CAAA7D,EAAA,CAYA,OACAoL,UAAA,EACAlV,QAAA,CAZAF,MAAAA,EAGA5C,KAAAgC,GAAAhC,EAAAA,EAAAqO,WAAA,CAAA0J,GAAA,IACI3V,IAAAA,EAAAkD,MAAA,CAEJ,IAEA1C,EAAAyL,WAAA,CAAA0J,GAKAE,WAAA,EAEAC,SAAA,SAGAC,cAAA5E,OAAAA,EAAA,OAAAvR,KAAAA,CACA,CACA,EA2YA,CACAhC,YAAAA,EACAuT,UAAAA,EACA9C,OAAAA,EACArO,UAAA+R,EACAvH,WAAAA,CACA,EACA,EAAG,CAAA2G,EAAA9C,EAAA,EAGHnP,EAAArD,EAAAmE,IACA,IACAqO,OAAAA,CAAA,CACA0D,eAAAA,CAAA,CACA,CAAMD,EAAAzU,OAAA,CACN,CACAK,cAAAA,EAAA,EACAC,YAAAA,CAAA,CACAqX,UAAAA,CAAA,CACA,CAAMC,gBAAAlD,EAAA/R,EAAAqO,GAEN,OADAjL,OAAA4R,MAAAA,EAAA,mCAAiEhV,EAAAlC,EAAA,CAAa,IAC9EH,CAAA,IAAAA,GAAAyM,oBAAA4K,EAAAtX,EACA,EAAG,IAGHsY,EAAAna,EAAAmE,IACA,IACAqO,OAAAA,CAAA,CACA0D,eAAAA,CAAA,CACA,CAAMD,EAAAzU,OAAA,CACN,CACAK,cAAAA,EAAA,EACAC,YAAAA,CAAA,CACAqX,UAAAA,CAAA,CACA,CAAMC,gBAAAlD,EAAA/R,EAAAqO,GAEN,OADAjL,OAAA4R,MAAAA,EAAA,mCAAiEhV,EAAAlC,EAAA,CAAa,IAC9E,CAAAH,GAAAqM,oBAAAgL,EAAAtX,GAAA,CACA,EAAG,IACH0B,EAAAvD,EAAAmE,IACA,IACA+R,eAAAA,CAAA,CACA,CAAMD,EAAAzU,OAAA,CACN0U,EAAApN,IAAA,CAAA3E,GACA+R,EAAAvC,IAAA,EAAAyG,EAAAC,KACA,IAAAC,EAAAF,EAAA5X,KAAA,CACA+X,EAAAF,EAAA7X,KAAA,QACA,MAAA8X,GAAAC,MAAAA,EACA,EACQD,MAAAA,EACR,GACQC,MAAAA,EACR,EAEAD,EAAAC,CAEA,GACAtE,EAAAzU,OAAA,CAAA2U,qBAAA,IACAV,GACA,EAAG,CAAAA,EAAA,EAIHxR,EAAA,KACA,GAAAgS,EAAAzU,OAAA,CAAA2U,qBAAA,EACAF,EAAAzU,OAAA,CAAA2U,qBAAA,IACA,IACA/C,WAAAA,CAAA,CACA+B,SAAAA,CAAA,CACArB,QAAAA,CAAA,CACA,CAAQkC,EAAAxU,OAAA,CACR,CACAgR,OAAAtD,CAAA,CACAgH,eAAAA,CAAA,CACA,CAAQD,EAAAzU,OAAA,CAIRgV,EAAA,KACA,GAAApD,EAAA,CACA,IAAA/N,EAAAmV,SA/YApH,CAAA,CAAAE,CAAA,CAAAQ,CAAA,EACA,IAAA2G,EAAAC,EACA,IAAArV,EAAA,OAAAoV,CAAAA,EAAA5G,8BAAAT,EAAAU,EAAA,GAAA2G,KAAA,IAAAA,EAAAA,EAAA,GACAlG,EAAAlB,YAAAC,GACA,cAAAoH,CAAAA,EAAArV,CAAA,CAAAkP,EAAA,GAAAmG,KAAA,IAAAA,EAAAA,EAAA,IACA,EA0YAtH,EAAA8C,EAAApC,GACAzO,IACAyQ,EAAAtU,OAAA,KAAAiI,IAAAgL,OAAAE,OAAA,CAAAtP,EAAAmP,aAAA,GACAgC,EAAAnR,EAAAmN,MAAA,CAEA,CACA,MAAAgE,GACAA,CAAAA,EAAAmE,SA7lBA,CACAzE,eAAAA,CAAA,CACC,EACD,IAAA1D,EAAAzB,MAAAmF,EAAA7O,MAAA,EACAqH,EAAAwH,EAAA3C,GAAA,CAAApP,GAAAA,EAAAN,WAAA,EACA+W,EAAA,EACA7F,EAAA,IAGA,QAAAvF,EAAA,EAAsBA,EAAA0G,EAAA7O,MAAA,CAA+BmI,IAAA,CACrD,IAAAf,EAAAC,CAAA,CAAAc,EAAA,CACAjI,OAAAkH,EAAA,yCAAsEe,EAAM,GAC5E,IACAzN,YAAAA,CAAA,CACA,CAAM0M,CACN,OAAA1M,IACA6Y,IACApI,CAAA,CAAAhD,EAAA,CAAAzN,EACAgT,GAAAhT,EAEA,CAGA,QAAAyN,EAAA,EAAsBA,EAAA0G,EAAA7O,MAAA,CAA+BmI,IAAA,CACrD,IAAAf,EAAAC,CAAA,CAAAc,EAAA,CACAjI,OAAAkH,EAAA,yCAAsEe,EAAM,GAC5E,IACAzN,YAAAA,CAAA,CACA,CAAM0M,EACN,GAAA1M,MAAAA,EACA,SAEA,IAAA8Y,EAAA3E,EAAA7O,MAAA,CAAAuT,EACAjW,EAAAoQ,EAAA8F,CACAD,CAAAA,IACApI,CAAA,CAAAhD,EAAA,CAAA7K,EACAoQ,GAAApQ,CACA,CACA,OAAA6N,CACA,EAsjBA,CACA0D,eAAAA,CACA,EAAS,EAKT,IAAA9G,EAAAwF,yBAAA,CACApC,OAAAgE,EACA/H,iBAAAyH,EAAA3C,GAAA,CAAApP,GAAAA,EAAAN,WAAA,CACA,GACAoO,SAAA/C,EAAAE,KACAoG,EAAApG,GACA6G,EAAAzU,OAAA,CAAAgR,MAAA,CAAApD,EACA+F,GACAA,EAAA/F,GAEAkD,mBAAA4D,EAAA9G,EAAAyG,EAAArU,OAAA,EAEA,CACA,GAGAyC,EAAA,KACA,IAAAyT,EAAAzB,EAAAzU,OAAA,CACA,WACAkW,EAAAlF,MAAA,IAEA,EAAG,IACH,IAAAsI,EAAA9a,EAAAwR,IACA,IAAAuJ,EAAA,GACAtJ,EAAA4D,EAAA7T,OAAA,CACA,GAAAiQ,EAAA,CACA,IAAAhP,EAAA8K,OAAA9F,gBAAA,CAAAgK,EAAA,KACA,SAAAhP,EAAAuY,gBAAA,eACAD,CAAAA,EAAA,GAEA,CACA,gBAAAzU,CAAA,EACAA,EAAA4D,cAAA,GACA,IAAAuH,EAAA4D,EAAA7T,OAAA,CACA,IAAAiQ,EACA,eAEA,IACAzE,UAAAA,CAAA,CACAsI,UAAAA,CAAA,CACArT,GAAAmB,CAAA,CACAgS,iBAAAA,CAAA,CACAD,SAAAA,CAAA,CACA,CAAQa,EAAAxU,OAAA,CACR,CACAgR,OAAAtD,CAAA,CACAgH,eAAAA,CAAA,CACA,CAAQD,EAAAzU,OAAA,CACR,CACAwN,cAAAA,CAAA,CACA,CAAQsG,MAAAA,EAAAA,EAAA,GACRrG,EAAAsC,sBAAAnO,EAAAoO,EAAAC,GACA1C,EAAAkM,SAjsBA3U,CAAA,CAAAkL,CAAA,CAAAxE,CAAA,CAAAkO,CAAA,CAAA9F,CAAA,CAAA3D,CAAA,EACA,GAAApL,UAAAC,GAAA,CACA,IAAA+L,EAAArF,eAAAA,EACA+B,EAAA,EAEAA,EADAzI,EAAA6U,QAAA,CACA,IACM/F,MAAAA,EACNA,EAEA,GAEA,IAAAgG,EAAA,EACA,OAAA9U,EAAA5G,GAAA,EACA,gBACA0b,EAAA/I,EAAA,EAAAtD,EACA,KACA,iBACAqM,EAAA/I,EAAA,CAAAtD,EAAA,EACA,KACA,kBACAqM,EAAA/I,EAAAtD,EAAA,EACA,KACA,eACAqM,EAAA/I,EAAA,GAAAtD,EACA,KACA,WACAqM,EAAA,IACA,KACA,YACAA,EAAA,IAEA,CACA,OAAAA,CACA,QACA,MAAAF,EACA,EAEAG,SAzDA/U,CAAA,CAAAkL,CAAA,CAAAxE,CAAA,CAAAkO,CAAA,CAAAzJ,CAAA,EACA,IAAAY,EAAArF,eAAAA,EACAsO,EAAAtJ,uBAAAR,EAAAC,GACAlK,OAAA+T,EAAA,0CAAkE9J,EAAa,IAC/E,IAAApO,EAAAkY,EAAAhK,YAAA,wBACA/J,OAAAnE,EAAA,mDACA,IACAmY,sBAAAA,CAAA,CACA,CAAIL,EACJM,EAAApJ,6BAAApF,EAAA1G,GACAqR,EAAAjG,qBAAAtO,EAAAqO,GACAlK,OAAAoQ,EAAA,kCAAyDvU,EAAQ,IACjE,IAAAqY,EAAA9D,EAAAxM,qBAAA,GACAuQ,EAAArJ,EAAAoJ,EAAA9O,KAAA,CAAA8O,EAAA7O,MAAA,CAGA,MADA+O,CADAH,EAAAD,CAAA,EACAG,EAAA,GAEA,EAwCApV,EAAAkL,EAAAxE,EAAAkO,EAAAzJ,EAEA,EA0pBAnL,EAAAkL,EAAAxE,EAAAsI,EAAAF,EAAA3D,GACAY,EAAArF,eAAAA,EACAqF,GAAA0I,GACAhM,CAAAA,EAAA,CAAAA,CAAA,EAEA,IAAAN,EAAAyH,EAAA3C,GAAA,CAAApP,GAAAA,EAAAN,WAAA,EACAuL,EAAAN,oBAAA,CACAC,MAAAA,EACAC,cAAAA,MAAAA,EAAAA,EAAAE,EACAT,iBAAAA,EACAQ,aAAAA,EACAC,WAAAA,EACAC,QAAA9I,UAAAC,GAAA,2BACA,GACAsV,EAAA,CAAAjJ,eAAAzD,EAAAE,GAIA,GAAA5I,CAAAA,eAAAF,IAAAI,aAAAJ,EAAA,GAIAyP,EAAAvU,OAAA,EAAAuN,OA11CA9B,EAAAA,GA21CA8I,EAAAvU,OAAA,CAAAuN,EACA,GAAAA,IAAAA,GA31CArF,EAAA2P,GAAA,CAo2CA7H,EAAA,GANAa,GA/1CApF,EAg2CA8B,EAAA,EAAAtJ,EAAAE,EA/1CA+D,EAAA2P,GAAA,CA+1CA7H,EA/1CAvE,KADAA,EAk2CA8B,EAAA,EAAAlJ,EAAAE,EAj2CA2D,EAAA2P,GAAA,CAi2CA7H,EAj2CAvE,IAw2CA2O,IACApG,EAAApG,GACA6G,EAAAzU,OAAA,CAAAgR,MAAA,CAAApD,EACA+F,GACAA,EAAA/F,GAEAkD,mBAAA4D,EAAA9G,EAAAyG,EAAArU,OAAA,EAEA,CACA,EAAG,IAGHgC,EAAAxD,EAAA,CAAAmE,EAAA0X,KACA,IACA1G,SAAAA,CAAA,CACA,CAAMa,EAAAxU,OAAA,CACN,CACAgR,OAAAtD,CAAA,CACAgH,eAAAA,CAAA,CACA,CAAMD,EAAAzU,OAAA,CACNkN,EAAAwH,EAAA3C,GAAA,CAAApP,GAAAA,EAAAN,WAAA,EACA,CACAsV,UAAAA,CAAA,CACAlK,aAAAA,CAAA,CACA,CAAMmK,gBAAAlD,EAAA/R,EAAA+K,GACN3H,OAAA4R,MAAAA,EAAA,mCAAiEhV,EAAAlC,EAAA,CAAa,IAC9E,IAAAqX,EAAAC,mBAAArD,EAAA/R,KAAA+R,EAAA7O,MAAA,GACA0H,EAAAuK,EAAAH,EAAA0C,EAAAA,EAAA1C,EACA/J,EAAAN,oBAAA,CACAC,MAAAA,EACAC,cAAAE,EACAT,iBAAAC,EACAO,aAAAA,EACAC,WAAAA,EACAC,QAAA,gBACA,GACAwD,eAAAzD,EAAAE,KACAoG,EAAApG,GACA6G,EAAAzU,OAAA,CAAAgR,MAAA,CAAApD,EACA+F,GACAA,EAAA/F,GAEAkD,mBAAA4D,EAAA9G,EAAAyG,EAAArU,OAAA,EAEA,EAAG,IACH8B,EAAAtD,EAAA,CAAAmE,EAAAD,KACA,IACAsO,OAAAA,CAAA,CACA0D,eAAAA,CAAA,CACA,CAAMD,EAAAzU,OAAA,CACN,CACAK,cAAAia,EAAA,EACAha,YAAAia,CAAA,CACA,CAAM7X,EACN,CACArC,cAAAma,EAAA,EACAla,YAAAma,CAAA,CACA9Z,QAAA+Z,EAAA,IACA9Z,QAAA+Z,EAAA,EACA,CAAMhY,EAAAN,WAAA,CACN,CACAsV,UAAAO,CAAA,CACA,CAAMN,gBAAAlD,EAAA/R,EAAAqO,EACN,OAAAkH,IAIAqC,GAAAE,GAAA1N,oBAAAmL,EAAAoC,GACAvN,oBAAAuN,EAAAE,IACAxY,EAAAW,EAAA6X,GAEMtC,EAAAyC,EACN3Y,EAAAW,EAAAgY,GACMzC,EAAAwC,GACN1Y,EAAAW,EAAA+X,GAEA,EAAG,CAAA1Y,EAAA,EAGH4Y,EAAApc,EAAA,CAAAwR,EAAAlL,KACA,IACA0G,UAAAA,CAAA,CACA,CAAMgJ,EAAAxU,OAAA,CACN,CACAgR,OAAAA,CAAA,CACA,CAAMyD,EAAAzU,OAAA,CACN,IAAA6T,EAAA7T,OAAA,CACA,OAEA,IAAA8Z,EAAAtJ,uBAAAR,EAAA6D,EAAA7T,OAAA,EACA+F,OAAA+T,EAAA,yCAAmE9J,EAAa,IAChF,IAAA+J,EAAAnJ,6BAAApF,EAAA1G,GACAiP,EAAA,CACA/D,aAAAA,EACAtG,eAAAoQ,EAAAnQ,qBAAA,GACAoQ,sBAAAA,EACAvM,cAAAwD,CACA,EACA,EAAG,IACH6J,EAAArc,EAAA,KACAuV,EAAA,KACA,EAAG,IACH9R,EAAAzD,EAAAmE,IACA,IACA+R,eAAAA,CAAA,CACA,CAAMD,EAAAzU,OAAA,CACNgO,EAAA+J,mBAAArD,EAAA/R,GACAqL,GAAA,IACA0G,EAAAzL,MAAA,CAAA+E,EAAA,GAMA,OAAAqG,EAAArU,OAAA,CAAA2C,EAAAlC,EAAA,EACAgU,EAAAzU,OAAA,CAAA2U,qBAAA,IACAV,IAEA,EAAG,CAAAA,EAAA,EACH3S,EAAAzC,EAAA,MACA2C,cAAAA,EACAgK,UAAAA,EACAsI,UAAAA,EACArS,YAAAA,EACAC,aAAAA,EACAC,cAAAA,EACAC,QAAAA,EACAC,iBAAAA,EACA8W,gBAAAA,EACA7W,2BAAAA,EACAC,cAAAA,EACAuX,qBAAAA,EACAtX,YAAAA,EACA4Y,cAAAA,EACAC,aAAAA,EACA5Y,gBAAAA,EACAgO,kBAAA4D,EAAA7T,OAAA,CACA,EAAG,CAAAwB,EAAAsS,EAAAtI,EAAA/J,EAAAC,EAAAC,EAAAC,EAAAC,EAAA8W,EAAA7W,EAAAC,EAAAuX,EAAAtX,EAAA4Y,EAAAC,EAAA5Y,EAAA,EAQH,OAAA7D,EAAAoB,EAAAsb,QAAA,EACApJ,MAAApQ,CACA,EAAGlD,EAAAgD,EAAA,CACH,GAAAC,CAAA,CACAnB,SAAAA,EACAC,UAAAC,EACAK,GAAAC,EACA+C,IAAAoQ,EACA5S,MAAA,CAdAqF,QAAA,OACAyU,cAAAvP,eAAAA,EAAA,eACAJ,OAAA,OACAqN,SAAA,SACAtN,MAAA,OAYA,GAAAjK,CAAA,EAGA,sBACA,6BAAAsK,EACA,sBAAA5J,CACA,GACA,CACA,IAAAoZ,EAAAzc,EAAA,CAAAiF,EAAAC,IAAArF,EAAAsV,2BAAA,CACA,GAAAlQ,CAAA,CACAhD,aAAAiD,CACA,IAGA,SAAAsU,mBAAArD,CAAA,CAAA/R,CAAA,EACA,OAAA+R,EAAA9E,SAAA,CAAAqL,GAAAA,IAAAtY,GAAAsY,EAAAxa,EAAA,GAAAkC,EAAAlC,EAAA,CACA,CACA,SAAAmX,gBAAAlD,CAAA,CAAA/R,CAAA,CAAAqO,CAAA,EACA,IAAA7D,EAAA4K,mBAAArD,EAAA/R,GACAmV,EAAA3K,IAAAuH,EAAA7O,MAAA,GAEA8R,EAAA3G,CAAA,CAAA7D,EAAA,CACA,OACA,GAAAxK,EAAAN,WAAA,CACAsV,UAAAA,EACAlK,aALAqK,EAAA,CAAA3K,EAAA,EAAAA,EAAA,EAAAA,EAAAA,EAAA,GAOA,CAwDA,SAAA+N,kBAAA,CACAhb,SAAAA,EAAA,KACAC,UAAAC,EAAA,GACA+a,SAAAA,EAAA,GACA1R,eAAAA,CAAA,CACAhJ,GAAAC,CAAA,CACA0a,OAAAA,CAAA,CACAC,WAAAA,CAAA,CACAC,QAAAA,CAAA,CACAra,MAAAC,EAAA,EAA4B,CAC5Bqa,SAAAA,EAAA,EACApa,QAAAC,EAAA,MACA,GAAAC,EACC,EACD,IAAAma,EAAAC,EACA,IAAAC,EAAA5c,EAAA,MAGA6c,EAAA7c,EAAA,CACAuc,WAAAA,CACA,GACA3c,EAAA,KACAid,EAAA3b,OAAA,CAAAqb,UAAA,CAAAA,CACA,GACA,IAAAO,EAAAnd,EAAAe,GACA,GAAAoc,OAAAA,EACA,MAAAra,MAAA,+EAEA,IACAiK,UAAAA,CAAA,CACA5J,QAAAA,CAAA,CACA0X,qBAAAuC,CAAA,CACAjB,cAAAA,CAAA,CACAC,aAAAA,CAAA,CACA5K,kBAAAA,CAAA,CACA,CAAI2L,EACJE,EAAAlc,YAAAc,GACA,CAAAmD,EAAAkY,EAAA,CAAAhd,EAAA,YACA,CAAAid,EAAAC,EAAA,CAAAld,EAAA,IACA,CAAAmd,EAAAC,EAAA,CAAApd,EAAA,MACAyV,EAAA1V,EAAA,CACA+E,MAAAA,CACA,GACApB,EAAA,KACA+R,EAAAxU,OAAA,CAAA6D,KAAA,CAAAA,CACA,GACAnF,EAAA,KACA,GAAAyc,EACAgB,EAAA,UACM,CACN,IAAAD,EAAAL,EAAAC,GACAK,EAAA,IAAAD,EACA,CACA,EAAG,CAAAf,EAAAW,EAAAD,EAAA,EAIH,IAAAO,EAAA,OAAAZ,CAAAA,EAAA/R,MAAAA,EAAA,OAAAA,EAAAQ,MAAA,GAAAuR,KAAA,IAAAA,EAAAA,EAAA,GACAa,EAAA,OAAAZ,CAAAA,EAAAhS,MAAAA,EAAA,OAAAA,EAAAS,IAAA,GAAAuR,KAAA,IAAAA,EAAAA,EAAA,SACA/c,EAAA,KACA,GAAAyc,GAAAe,MAAAA,EACA,OAEA,IAAA3S,EAAAmS,EAAA1b,OAAA,QACA+F,OAAAwD,EAAA,4BA8CA+P,SAx3DAwC,CAAA,CAAAvS,CAAA,CAAAiC,CAAA,CAAA/B,CAAA,CAAA2C,CAAA,EACA,IAAAkQ,EACA,IACA1Q,cAAAA,CAAA,CACA,CAAIrC,EACJD,EAAA,CACAkC,UAAAA,EACAjC,QAAAA,EACAE,eAAAA,EACA2C,sBAAAA,CACA,EACAJ,EAAA,OAAAsQ,CAAAA,EAAAtU,EAAAmQ,GAAA,CAAAvM,EAAA,GAAA0Q,KAAA,IAAAA,EAAAA,EAAA,EAIA,OAHAtU,EAAA6P,GAAA,CAAAjM,EAAAI,EAAA,GACA7D,EAAAoU,GAAA,CAAAjT,GACAd,kBACA,WACA,IAAAgU,EACAtU,EAAAuU,MAAA,CAAAX,GACA3T,EAAAsU,MAAA,CAAAnT,GACA,IAAA0C,EAAA,OAAAwQ,CAAAA,EAAAxU,EAAAmQ,GAAA,CAAAvM,EAAA,GAAA4Q,KAAA,IAAAA,EAAAA,EAAA,EASA,GARAxU,EAAA6P,GAAA,CAAAjM,EAAAI,EAAA,GACAxD,kBACA,IAAAwD,GACAhE,EAAAyU,MAAA,CAAA7Q,GAKA9D,EAAAwE,QAAA,CAAAhD,GAAA,CACA,IAAA0E,EAAAlG,EAAA+O,OAAA,CAAAvN,GACA0E,GAAA,GACAlG,EAAAmB,MAAA,CAAA+E,EAAA,GAEAlF,eAIAsD,EAAA,aACA,CACA,CACA,EAg1DA0P,EAAAvS,EAAAiC,EAAA,CACAvB,OAAAmS,EACAlS,KAAAmS,CACA,EAhDA,CAAAlQ,EAAAE,EAAAvH,KACA,GAAAuH,EACA,OAAAF,GACA,WACA,CACA4P,EAAA,QACAhW,OAAAjB,EAAA,kDACA8V,EAAAkB,EAAAhX,GACA,IACAuW,WAAAA,CAAA,CACA,CAAgBM,EAAA3b,OAAA,CAChBqb,GACAA,EAAA,IAEA,KACA,CACA,WACA,CACA,IACAxX,MAAAA,CAAA,CACA,CAAgB2Q,EAAAxU,OAAA,CAChB,SAAA6D,GACAkY,EAAA,SAEAhW,OAAAjB,EAAA,kDACAoX,EAAApX,GACA,KACA,CACA,SACA,CACAiX,EAAA,SACAlB,IACA,IACAQ,WAAAA,CAAA,CACA,CAAgBM,EAAA3b,OAAA,CAChBqb,GACAA,EAAA,GAGA,CACA,MAEAU,EAAA,WAEA,EAKA,EAAG,CAAAK,EAAA5Q,EAAA2P,EAAAkB,EAAAR,EAAAC,EAAAI,EAAAtB,EAAAC,EAAA,GACH6B,SAvKA,CACAvB,SAAAA,CAAA,CACA9E,SAAAA,CAAA,CACA6F,cAAAA,CAAA,CACAjM,kBAAAA,CAAA,CACC,EACDvR,EAAA,KACA,GAAAyc,GAAAe,MAAAA,GAAAjM,MAAAA,EACA,OAEA,IAAA6J,EAAAtJ,uBAAA6F,EAAApG,GACA,GAAA6J,MAAAA,EACA,OAEA,IAAAhD,UAAAhS,IACA,IAAAA,EAAAiS,gBAAA,CAGA,OAAAjS,EAAA5G,GAAA,EACA,gBACA,gBACA,iBACA,cACA,UACA,WAEA4G,EAAA4D,cAAA,GACAwT,EAAApX,GACA,KAEA,UACA,CACAA,EAAA4D,cAAA,GACA,IAAA9G,EAAAkY,EAAAhK,YAAA,wBACA/J,OAAAnE,EAAA,kCAA8DA,EAAQ,IACtE,IAAA+N,EAAAN,gCAAAzN,EAAAqO,GACAjC,EAAA0B,4BAAA9N,EAAAyU,EAAApG,GACAlK,OAAAiI,OAAAA,EAAA,mCAAsEqI,EAAS,IAC/E,IAAAsG,EAAA7X,EAAA6U,QAAA,CAAA3L,EAAA,EAAAA,EAAA,EAAA2B,EAAA9J,MAAA,GAAAmI,EAAA,EAAA2B,EAAA9J,MAAA,CAAAmI,EAAA,IACA4O,EAAAjN,CAAA,CAAAgN,EAAA,CACAC,EAAAC,KAAA,EAEA,CACA,CACA,EAEA,OADA/C,EAAA7N,gBAAA,WAAA6K,WACA,KACAgD,EAAAhO,mBAAA,WAAAgL,UACA,CACA,EAAG,CAAA7G,EAAAkL,EAAA9E,EAAA6F,EAAA,CACH,EAqHA,CACAf,SAAAA,EACA9E,SAAAyF,EACAI,cAAAA,EACAjM,kBAAAA,CACA,GAKA7R,EAAAgD,EAAA,CACA,GAAAC,CAAA,CACAnB,SAAAA,EACAC,UAAAC,EACAK,GAAAC,EACA0a,OAAA,KACAa,EAAA,IACAb,MAAAA,GAAAA,GACA,EACAE,QAAA,KACAW,EAAA,IACAX,MAAAA,GAAAA,GACA,EACA7X,IAAAiY,EACAoB,KAAA,YACA7b,MAAA,CAlBA8b,YAAA,OACAC,WAAA,OAmBA,GAAA9b,CAAA,EAEAqa,SAAAA,EAEA,6BAAA/P,EACA,sBAAA5J,EACA,wBACA,4BAAAiC,SAAAA,EAAA,UAAAmY,EAAA,WAAAzZ,KAAAA,EACA,2BAAAsB,EACA,oCAAAsX,EACA,8BAAAW,CACA,EACA,CAjOApI,2BAAAjU,WAAA,cACAub,EAAAvb,WAAA,0BAiOAyb,kBAAAzb,WAAA","sources":["webpack://_N_E/./node_modules/lucide-react/dist/esm/icons/grip-vertical.js","webpack://_N_E/./node_modules/react-resizable-panels/dist/react-resizable-panels.browser.esm.js","webpack://_N_E/<anon>"],"sourcesContent":["/**\n * @license lucide-react v0.378.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst GripVertical = createLucideIcon(\"GripVertical\", [\n  [\"circle\", { cx: \"9\", cy: \"12\", r: \"1\", key: \"1vctgf\" }],\n  [\"circle\", { cx: \"9\", cy: \"5\", r: \"1\", key: \"hp0tcf\" }],\n  [\"circle\", { cx: \"9\", cy: \"19\", r: \"1\", key: \"fkjjf6\" }],\n  [\"circle\", { cx: \"15\", cy: \"12\", r: \"1\", key: \"1tmaij\" }],\n  [\"circle\", { cx: \"15\", cy: \"5\", r: \"1\", key: \"19l28e\" }],\n  [\"circle\", { cx: \"15\", cy: \"19\", r: \"1\", key: \"f4zoj3\" }]\n]);\n\nexport { GripVertical as default };\n//# sourceMappingURL=grip-vertical.js.map\n","import * as React from 'react';\n\n// This module exists to work around Webpack issue https://github.com/webpack/webpack/issues/14814\n\n// eslint-disable-next-line no-restricted-imports\n\nconst {\n  createElement,\n  createContext,\n  createRef,\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState\n} = React;\n\n// `Math.random()` and `.slice(0, 5)` prevents bundlers from trying to `import { useId } from 'react'`\nconst useId = React[`useId${Math.random()}`.slice(0, 5)];\nconst useLayoutEffect_do_not_use_directly = useLayoutEffect;\n\n// The \"contextmenu\" event is not supported as a PointerEvent in all browsers yet, so MouseEvent still need to be handled\n\nconst PanelGroupContext = createContext(null);\nPanelGroupContext.displayName = \"PanelGroupContext\";\n\nconst useIsomorphicLayoutEffect = useLayoutEffect_do_not_use_directly ;\n\nconst wrappedUseId = typeof useId === \"function\" ? useId : () => null;\nlet counter = 0;\nfunction useUniqueId(idFromParams = null) {\n  const idFromUseId = wrappedUseId();\n  const idRef = useRef(idFromParams || idFromUseId || null);\n  if (idRef.current === null) {\n    idRef.current = \"\" + counter++;\n  }\n  return idFromParams !== null && idFromParams !== void 0 ? idFromParams : idRef.current;\n}\n\nfunction PanelWithForwardedRef({\n  children,\n  className: classNameFromProps = \"\",\n  collapsedSize,\n  collapsible,\n  defaultSize,\n  forwardedRef,\n  id: idFromProps,\n  maxSize,\n  minSize,\n  onCollapse,\n  onExpand,\n  onResize,\n  order,\n  style: styleFromProps,\n  tagName: Type = \"div\",\n  ...rest\n}) {\n  const context = useContext(PanelGroupContext);\n  if (context === null) {\n    throw Error(`Panel components must be rendered within a PanelGroup container`);\n  }\n  const {\n    collapsePanel,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    groupId,\n    isPanelCollapsed,\n    reevaluatePanelConstraints,\n    registerPanel,\n    resizePanel,\n    unregisterPanel\n  } = context;\n  const panelId = useUniqueId(idFromProps);\n  const panelDataRef = useRef({\n    callbacks: {\n      onCollapse,\n      onExpand,\n      onResize\n    },\n    constraints: {\n      collapsedSize,\n      collapsible,\n      defaultSize,\n      maxSize,\n      minSize\n    },\n    id: panelId,\n    idIsFromProps: idFromProps !== undefined,\n    order\n  });\n  useRef({\n    didLogMissingDefaultSizeWarning: false\n  });\n  useIsomorphicLayoutEffect(() => {\n    const {\n      callbacks,\n      constraints\n    } = panelDataRef.current;\n    const prevConstraints = {\n      ...constraints\n    };\n    panelDataRef.current.id = panelId;\n    panelDataRef.current.idIsFromProps = idFromProps !== undefined;\n    panelDataRef.current.order = order;\n    callbacks.onCollapse = onCollapse;\n    callbacks.onExpand = onExpand;\n    callbacks.onResize = onResize;\n    constraints.collapsedSize = collapsedSize;\n    constraints.collapsible = collapsible;\n    constraints.defaultSize = defaultSize;\n    constraints.maxSize = maxSize;\n    constraints.minSize = minSize;\n\n    // If constraints have changed, we should revisit panel sizes.\n    // This is uncommon but may happen if people are trying to implement pixel based constraints.\n    if (prevConstraints.collapsedSize !== constraints.collapsedSize || prevConstraints.collapsible !== constraints.collapsible || prevConstraints.maxSize !== constraints.maxSize || prevConstraints.minSize !== constraints.minSize) {\n      reevaluatePanelConstraints(panelDataRef.current, prevConstraints);\n    }\n  });\n  useIsomorphicLayoutEffect(() => {\n    const panelData = panelDataRef.current;\n    registerPanel(panelData);\n    return () => {\n      unregisterPanel(panelData);\n    };\n  }, [order, panelId, registerPanel, unregisterPanel]);\n  useImperativeHandle(forwardedRef, () => ({\n    collapse: () => {\n      collapsePanel(panelDataRef.current);\n    },\n    expand: minSize => {\n      expandPanel(panelDataRef.current, minSize);\n    },\n    getId() {\n      return panelId;\n    },\n    getSize() {\n      return getPanelSize(panelDataRef.current);\n    },\n    isCollapsed() {\n      return isPanelCollapsed(panelDataRef.current);\n    },\n    isExpanded() {\n      return !isPanelCollapsed(panelDataRef.current);\n    },\n    resize: size => {\n      resizePanel(panelDataRef.current, size);\n    }\n  }), [collapsePanel, expandPanel, getPanelSize, isPanelCollapsed, panelId, resizePanel]);\n  const style = getPanelStyle(panelDataRef.current, defaultSize);\n  return createElement(Type, {\n    ...rest,\n    children,\n    className: classNameFromProps,\n    id: idFromProps,\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    // CSS selectors\n    \"data-panel\": \"\",\n    \"data-panel-collapsible\": collapsible || undefined,\n    \"data-panel-group-id\": groupId,\n    \"data-panel-id\": panelId,\n    \"data-panel-size\": parseFloat(\"\" + style.flexGrow).toFixed(1)\n  });\n}\nconst Panel = forwardRef((props, ref) => createElement(PanelWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelWithForwardedRef.displayName = \"Panel\";\nPanel.displayName = \"forwardRef(Panel)\";\n\nlet nonce;\nfunction getNonce() {\n  return nonce;\n}\nfunction setNonce(value) {\n  nonce = value;\n}\n\nlet currentCursorStyle = null;\nlet enabled = true;\nlet styleElement = null;\nfunction disableGlobalCursorStyles() {\n  enabled = false;\n}\nfunction enableGlobalCursorStyles() {\n  enabled = true;\n}\nfunction getCursorStyle(state, constraintFlags) {\n  if (constraintFlags) {\n    const horizontalMin = (constraintFlags & EXCEEDED_HORIZONTAL_MIN) !== 0;\n    const horizontalMax = (constraintFlags & EXCEEDED_HORIZONTAL_MAX) !== 0;\n    const verticalMin = (constraintFlags & EXCEEDED_VERTICAL_MIN) !== 0;\n    const verticalMax = (constraintFlags & EXCEEDED_VERTICAL_MAX) !== 0;\n    if (horizontalMin) {\n      if (verticalMin) {\n        return \"se-resize\";\n      } else if (verticalMax) {\n        return \"ne-resize\";\n      } else {\n        return \"e-resize\";\n      }\n    } else if (horizontalMax) {\n      if (verticalMin) {\n        return \"sw-resize\";\n      } else if (verticalMax) {\n        return \"nw-resize\";\n      } else {\n        return \"w-resize\";\n      }\n    } else if (verticalMin) {\n      return \"s-resize\";\n    } else if (verticalMax) {\n      return \"n-resize\";\n    }\n  }\n  switch (state) {\n    case \"horizontal\":\n      return \"ew-resize\";\n    case \"intersection\":\n      return \"move\";\n    case \"vertical\":\n      return \"ns-resize\";\n  }\n}\nfunction resetGlobalCursorStyle() {\n  if (styleElement !== null) {\n    document.head.removeChild(styleElement);\n    currentCursorStyle = null;\n    styleElement = null;\n  }\n}\nfunction setGlobalCursorStyle(state, constraintFlags) {\n  if (!enabled) {\n    return;\n  }\n  const style = getCursorStyle(state, constraintFlags);\n  if (currentCursorStyle === style) {\n    return;\n  }\n  currentCursorStyle = style;\n  if (styleElement === null) {\n    styleElement = document.createElement(\"style\");\n    const nonce = getNonce();\n    if (nonce) {\n      styleElement.setAttribute(\"nonce\", nonce);\n    }\n    document.head.appendChild(styleElement);\n  }\n  styleElement.innerHTML = `*{cursor: ${style}!important;}`;\n}\n\nfunction isKeyDown(event) {\n  return event.type === \"keydown\";\n}\nfunction isPointerEvent(event) {\n  return event.type.startsWith(\"pointer\");\n}\nfunction isMouseEvent(event) {\n  return event.type.startsWith(\"mouse\");\n}\n\nfunction getResizeEventCoordinates(event) {\n  if (isPointerEvent(event)) {\n    if (event.isPrimary) {\n      return {\n        x: event.clientX,\n        y: event.clientY\n      };\n    }\n  } else if (isMouseEvent(event)) {\n    return {\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n  return {\n    x: Infinity,\n    y: Infinity\n  };\n}\n\nfunction getInputType() {\n  if (typeof matchMedia === \"function\") {\n    return matchMedia(\"(pointer:coarse)\").matches ? \"coarse\" : \"fine\";\n  }\n}\n\nfunction intersects(rectOne, rectTwo, strict) {\n  if (strict) {\n    return rectOne.x < rectTwo.x + rectTwo.width && rectOne.x + rectOne.width > rectTwo.x && rectOne.y < rectTwo.y + rectTwo.height && rectOne.y + rectOne.height > rectTwo.y;\n  } else {\n    return rectOne.x <= rectTwo.x + rectTwo.width && rectOne.x + rectOne.width >= rectTwo.x && rectOne.y <= rectTwo.y + rectTwo.height && rectOne.y + rectOne.height >= rectTwo.y;\n  }\n}\n\n// Forked from NPM stacking-order@2.0.0\n\n/**\n * Determine which of two nodes appears in front of the other —\n * if `a` is in front, returns 1, otherwise returns -1\n * @param {HTMLElement | SVGElement} a\n * @param {HTMLElement | SVGElement} b\n */\nfunction compare(a, b) {\n  if (a === b) throw new Error(\"Cannot compare node with itself\");\n  const ancestors = {\n    a: get_ancestors(a),\n    b: get_ancestors(b)\n  };\n  let common_ancestor;\n\n  // remove shared ancestors\n  while (ancestors.a.at(-1) === ancestors.b.at(-1)) {\n    a = ancestors.a.pop();\n    b = ancestors.b.pop();\n    common_ancestor = a;\n  }\n  assert(common_ancestor, \"Stacking order can only be calculated for elements with a common ancestor\");\n  const z_indexes = {\n    a: get_z_index(find_stacking_context(ancestors.a)),\n    b: get_z_index(find_stacking_context(ancestors.b))\n  };\n  if (z_indexes.a === z_indexes.b) {\n    const children = common_ancestor.childNodes;\n    const furthest_ancestors = {\n      a: ancestors.a.at(-1),\n      b: ancestors.b.at(-1)\n    };\n    let i = children.length;\n    while (i--) {\n      const child = children[i];\n      if (child === furthest_ancestors.a) return 1;\n      if (child === furthest_ancestors.b) return -1;\n    }\n  }\n  return Math.sign(z_indexes.a - z_indexes.b);\n}\nconst props = /\\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\\b/;\n\n/** @param {HTMLElement | SVGElement} node */\nfunction is_flex_item(node) {\n  var _get_parent;\n  // @ts-ignore\n  const display = getComputedStyle((_get_parent = get_parent(node)) !== null && _get_parent !== void 0 ? _get_parent : node).display;\n  return display === \"flex\" || display === \"inline-flex\";\n}\n\n/** @param {HTMLElement | SVGElement} node */\nfunction creates_stacking_context(node) {\n  const style = getComputedStyle(node);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n  if (style.position === \"fixed\") return true;\n  // Forked to fix upstream bug https://github.com/Rich-Harris/stacking-order/issues/3\n  // if (\n  //   (style.zIndex !== \"auto\" && style.position !== \"static\") ||\n  //   is_flex_item(node)\n  // )\n  if (style.zIndex !== \"auto\" && (style.position !== \"static\" || is_flex_item(node))) return true;\n  if (+style.opacity < 1) return true;\n  if (\"transform\" in style && style.transform !== \"none\") return true;\n  if (\"webkitTransform\" in style && style.webkitTransform !== \"none\") return true;\n  if (\"mixBlendMode\" in style && style.mixBlendMode !== \"normal\") return true;\n  if (\"filter\" in style && style.filter !== \"none\") return true;\n  if (\"webkitFilter\" in style && style.webkitFilter !== \"none\") return true;\n  if (\"isolation\" in style && style.isolation === \"isolate\") return true;\n  if (props.test(style.willChange)) return true;\n  // @ts-expect-error\n  if (style.webkitOverflowScrolling === \"touch\") return true;\n  return false;\n}\n\n/** @param {(HTMLElement| SVGElement)[]} nodes */\nfunction find_stacking_context(nodes) {\n  let i = nodes.length;\n  while (i--) {\n    const node = nodes[i];\n    assert(node, \"Missing node\");\n    if (creates_stacking_context(node)) return node;\n  }\n  return null;\n}\n\n/** @param {HTMLElement | SVGElement} node */\nfunction get_z_index(node) {\n  return node && Number(getComputedStyle(node).zIndex) || 0;\n}\n\n/** @param {HTMLElement} node */\nfunction get_ancestors(node) {\n  const ancestors = [];\n  while (node) {\n    ancestors.push(node);\n    // @ts-ignore\n    node = get_parent(node);\n  }\n  return ancestors; // [ node, ... <body>, <html>, document ]\n}\n\n/** @param {HTMLElement} node */\nfunction get_parent(node) {\n  const {\n    parentNode\n  } = node;\n  if (parentNode && parentNode instanceof ShadowRoot) {\n    return parentNode.host;\n  }\n  return parentNode;\n}\n\nconst EXCEEDED_HORIZONTAL_MIN = 0b0001;\nconst EXCEEDED_HORIZONTAL_MAX = 0b0010;\nconst EXCEEDED_VERTICAL_MIN = 0b0100;\nconst EXCEEDED_VERTICAL_MAX = 0b1000;\nconst isCoarsePointer = getInputType() === \"coarse\";\nlet intersectingHandles = [];\nlet isPointerDown = false;\nlet ownerDocumentCounts = new Map();\nlet panelConstraintFlags = new Map();\nconst registeredResizeHandlers = new Set();\nfunction registerResizeHandle(resizeHandleId, element, direction, hitAreaMargins, setResizeHandlerState) {\n  var _ownerDocumentCounts$;\n  const {\n    ownerDocument\n  } = element;\n  const data = {\n    direction,\n    element,\n    hitAreaMargins,\n    setResizeHandlerState\n  };\n  const count = (_ownerDocumentCounts$ = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$ !== void 0 ? _ownerDocumentCounts$ : 0;\n  ownerDocumentCounts.set(ownerDocument, count + 1);\n  registeredResizeHandlers.add(data);\n  updateListeners();\n  return function unregisterResizeHandle() {\n    var _ownerDocumentCounts$2;\n    panelConstraintFlags.delete(resizeHandleId);\n    registeredResizeHandlers.delete(data);\n    const count = (_ownerDocumentCounts$2 = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$2 !== void 0 ? _ownerDocumentCounts$2 : 1;\n    ownerDocumentCounts.set(ownerDocument, count - 1);\n    updateListeners();\n    if (count === 1) {\n      ownerDocumentCounts.delete(ownerDocument);\n    }\n\n    // If the resize handle that is currently unmounting is intersecting with the pointer,\n    // update the global pointer to account for the change\n    if (intersectingHandles.includes(data)) {\n      const index = intersectingHandles.indexOf(data);\n      if (index >= 0) {\n        intersectingHandles.splice(index, 1);\n      }\n      updateCursor();\n\n      // Also instruct the handle to stop dragging; this prevents the parent group from being left in an inconsistent state\n      // See github.com/bvaughn/react-resizable-panels/issues/402\n      setResizeHandlerState(\"up\", true, null);\n    }\n  };\n}\nfunction handlePointerDown(event) {\n  const {\n    target\n  } = event;\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  isPointerDown = true;\n  recalculateIntersectingHandles({\n    target,\n    x,\n    y\n  });\n  updateListeners();\n  if (intersectingHandles.length > 0) {\n    updateResizeHandlerStates(\"down\", event);\n    event.preventDefault();\n    event.stopPropagation();\n  }\n}\nfunction handlePointerMove(event) {\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n\n  // Edge case (see #340)\n  // Detect when the pointer has been released outside an iframe on a different domain\n  if (isPointerDown && event.buttons === 0) {\n    isPointerDown = false;\n    updateResizeHandlerStates(\"up\", event);\n  }\n  if (!isPointerDown) {\n    const {\n      target\n    } = event;\n\n    // Recalculate intersecting handles whenever the pointer moves, except if it has already been pressed\n    // at that point, the handles may not move with the pointer (depending on constraints)\n    // but the same set of active handles should be locked until the pointer is released\n    recalculateIntersectingHandles({\n      target,\n      x,\n      y\n    });\n  }\n  updateResizeHandlerStates(\"move\", event);\n\n  // Update cursor based on return value(s) from active handles\n  updateCursor();\n  if (intersectingHandles.length > 0) {\n    event.preventDefault();\n  }\n}\nfunction handlePointerUp(event) {\n  const {\n    target\n  } = event;\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  panelConstraintFlags.clear();\n  isPointerDown = false;\n  if (intersectingHandles.length > 0) {\n    event.preventDefault();\n  }\n  updateResizeHandlerStates(\"up\", event);\n  recalculateIntersectingHandles({\n    target,\n    x,\n    y\n  });\n  updateCursor();\n  updateListeners();\n}\nfunction recalculateIntersectingHandles({\n  target,\n  x,\n  y\n}) {\n  intersectingHandles.splice(0);\n  let targetElement = null;\n  if (target instanceof HTMLElement || target instanceof SVGElement) {\n    targetElement = target;\n  }\n  registeredResizeHandlers.forEach(data => {\n    const {\n      element: dragHandleElement,\n      hitAreaMargins\n    } = data;\n    const dragHandleRect = dragHandleElement.getBoundingClientRect();\n    const {\n      bottom,\n      left,\n      right,\n      top\n    } = dragHandleRect;\n    const margin = isCoarsePointer ? hitAreaMargins.coarse : hitAreaMargins.fine;\n    const eventIntersects = x >= left - margin && x <= right + margin && y >= top - margin && y <= bottom + margin;\n    if (eventIntersects) {\n      // TRICKY\n      // We listen for pointers events at the root in order to support hit area margins\n      // (determining when the pointer is close enough to an element to be considered a \"hit\")\n      // Clicking on an element \"above\" a handle (e.g. a modal) should prevent a hit though\n      // so at this point we need to compare stacking order of a potentially intersecting drag handle,\n      // and the element that was actually clicked/touched\n      if (targetElement !== null && document.contains(targetElement) && dragHandleElement !== targetElement && !dragHandleElement.contains(targetElement) && !targetElement.contains(dragHandleElement) &&\n      // Calculating stacking order has a cost, so we should avoid it if possible\n      // That is why we only check potentially intersecting handles,\n      // and why we skip if the event target is within the handle's DOM\n      compare(targetElement, dragHandleElement) > 0) {\n        // If the target is above the drag handle, then we also need to confirm they overlap\n        // If they are beside each other (e.g. a panel and its drag handle) then the handle is still interactive\n        //\n        // It's not enough to compare only the target\n        // The target might be a small element inside of a larger container\n        // (For example, a SPAN or a DIV inside of a larger modal dialog)\n        let currentElement = targetElement;\n        let didIntersect = false;\n        while (currentElement) {\n          if (currentElement.contains(dragHandleElement)) {\n            break;\n          } else if (intersects(currentElement.getBoundingClientRect(), dragHandleRect, true)) {\n            didIntersect = true;\n            break;\n          }\n          currentElement = currentElement.parentElement;\n        }\n        if (didIntersect) {\n          return;\n        }\n      }\n      intersectingHandles.push(data);\n    }\n  });\n}\nfunction reportConstraintsViolation(resizeHandleId, flag) {\n  panelConstraintFlags.set(resizeHandleId, flag);\n}\nfunction updateCursor() {\n  let intersectsHorizontal = false;\n  let intersectsVertical = false;\n  intersectingHandles.forEach(data => {\n    const {\n      direction\n    } = data;\n    if (direction === \"horizontal\") {\n      intersectsHorizontal = true;\n    } else {\n      intersectsVertical = true;\n    }\n  });\n  let constraintFlags = 0;\n  panelConstraintFlags.forEach(flag => {\n    constraintFlags |= flag;\n  });\n  if (intersectsHorizontal && intersectsVertical) {\n    setGlobalCursorStyle(\"intersection\", constraintFlags);\n  } else if (intersectsHorizontal) {\n    setGlobalCursorStyle(\"horizontal\", constraintFlags);\n  } else if (intersectsVertical) {\n    setGlobalCursorStyle(\"vertical\", constraintFlags);\n  } else {\n    resetGlobalCursorStyle();\n  }\n}\nfunction updateListeners() {\n  ownerDocumentCounts.forEach((_, ownerDocument) => {\n    const {\n      body\n    } = ownerDocument;\n    body.removeEventListener(\"contextmenu\", handlePointerUp);\n    body.removeEventListener(\"pointerdown\", handlePointerDown);\n    body.removeEventListener(\"pointerleave\", handlePointerMove);\n    body.removeEventListener(\"pointermove\", handlePointerMove);\n  });\n  window.removeEventListener(\"pointerup\", handlePointerUp);\n  window.removeEventListener(\"pointercancel\", handlePointerUp);\n  if (registeredResizeHandlers.size > 0) {\n    if (isPointerDown) {\n      if (intersectingHandles.length > 0) {\n        ownerDocumentCounts.forEach((count, ownerDocument) => {\n          const {\n            body\n          } = ownerDocument;\n          if (count > 0) {\n            body.addEventListener(\"contextmenu\", handlePointerUp);\n            body.addEventListener(\"pointerleave\", handlePointerMove);\n            body.addEventListener(\"pointermove\", handlePointerMove);\n          }\n        });\n      }\n      window.addEventListener(\"pointerup\", handlePointerUp);\n      window.addEventListener(\"pointercancel\", handlePointerUp);\n    } else {\n      ownerDocumentCounts.forEach((count, ownerDocument) => {\n        const {\n          body\n        } = ownerDocument;\n        if (count > 0) {\n          body.addEventListener(\"pointerdown\", handlePointerDown, {\n            capture: true\n          });\n          body.addEventListener(\"pointermove\", handlePointerMove);\n        }\n      });\n    }\n  }\n}\nfunction updateResizeHandlerStates(action, event) {\n  registeredResizeHandlers.forEach(data => {\n    const {\n      setResizeHandlerState\n    } = data;\n    const isActive = intersectingHandles.includes(data);\n    setResizeHandlerState(action, isActive, event);\n  });\n}\n\nfunction useForceUpdate() {\n  const [_, setCount] = useState(0);\n  return useCallback(() => setCount(prevCount => prevCount + 1), []);\n}\n\nfunction assert(expectedCondition, message) {\n  if (!expectedCondition) {\n    console.error(message);\n    throw Error(message);\n  }\n}\n\nconst PRECISION = 10;\n\nfunction fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {\n  if (actual.toFixed(fractionDigits) === expected.toFixed(fractionDigits)) {\n    return 0;\n  } else {\n    return actual > expected ? 1 : -1;\n  }\n}\nfunction fuzzyNumbersEqual$1(actual, expected, fractionDigits = PRECISION) {\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\n\nfunction fuzzyNumbersEqual(actual, expected, fractionDigits) {\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\n\nfunction fuzzyLayoutsEqual(actual, expected, fractionDigits) {\n  if (actual.length !== expected.length) {\n    return false;\n  }\n  for (let index = 0; index < actual.length; index++) {\n    const actualSize = actual[index];\n    const expectedSize = expected[index];\n    if (!fuzzyNumbersEqual(actualSize, expectedSize, fractionDigits)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Panel size must be in percentages; pixel values should be pre-converted\nfunction resizePanel({\n  panelConstraints: panelConstraintsArray,\n  panelIndex,\n  size\n}) {\n  const panelConstraints = panelConstraintsArray[panelIndex];\n  assert(panelConstraints != null, `Panel constraints not found for index ${panelIndex}`);\n  let {\n    collapsedSize = 0,\n    collapsible,\n    maxSize = 100,\n    minSize = 0\n  } = panelConstraints;\n  if (fuzzyCompareNumbers(size, minSize) < 0) {\n    if (collapsible) {\n      // Collapsible panels should snap closed or open only once they cross the halfway point between collapsed and min size.\n      const halfwayPoint = (collapsedSize + minSize) / 2;\n      if (fuzzyCompareNumbers(size, halfwayPoint) < 0) {\n        size = collapsedSize;\n      } else {\n        size = minSize;\n      }\n    } else {\n      size = minSize;\n    }\n  }\n  size = Math.min(maxSize, size);\n  size = parseFloat(size.toFixed(PRECISION));\n  return size;\n}\n\n// All units must be in percentages; pixel values should be pre-converted\nfunction adjustLayoutByDelta({\n  delta,\n  initialLayout,\n  panelConstraints: panelConstraintsArray,\n  pivotIndices,\n  prevLayout,\n  trigger\n}) {\n  if (fuzzyNumbersEqual(delta, 0)) {\n    return initialLayout;\n  }\n  const nextLayout = [...initialLayout];\n  const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n  assert(firstPivotIndex != null, \"Invalid first pivot index\");\n  assert(secondPivotIndex != null, \"Invalid second pivot index\");\n  let deltaApplied = 0;\n\n  // const DEBUG = [];\n  // DEBUG.push(`adjustLayoutByDelta()`);\n  // DEBUG.push(`  initialLayout: ${initialLayout.join(\", \")}`);\n  // DEBUG.push(`  prevLayout: ${prevLayout.join(\", \")}`);\n  // DEBUG.push(`  delta: ${delta}`);\n  // DEBUG.push(`  pivotIndices: ${pivotIndices.join(\", \")}`);\n  // DEBUG.push(`  trigger: ${trigger}`);\n  // DEBUG.push(\"\");\n\n  // A resizing panel affects the panels before or after it.\n  //\n  // A negative delta means the panel(s) immediately after the resize handle should grow/expand by decreasing its offset.\n  // Other panels may also need to shrink/contract (and shift) to make room, depending on the min weights.\n  //\n  // A positive delta means the panel(s) immediately before the resize handle should \"expand\".\n  // This is accomplished by shrinking/contracting (and shifting) one or more of the panels after the resize handle.\n\n  {\n    // If this is a resize triggered by a keyboard event, our logic for expanding/collapsing is different.\n    // We no longer check the halfway threshold because this may prevent the panel from expanding at all.\n    if (trigger === \"keyboard\") {\n      {\n        // Check if we should expand a collapsed panel\n        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const panelConstraints = panelConstraintsArray[index];\n        assert(panelConstraints, `Panel constraints not found for index ${index}`);\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panelConstraints;\n\n        // DEBUG.push(`edge case check 1: ${index}`);\n        // DEBUG.push(`  -> collapsible? ${collapsible}`);\n        if (collapsible) {\n          const prevSize = initialLayout[index];\n          assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize, collapsedSize)) {\n            const localDelta = minSize - prevSize;\n            // DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n              // DEBUG.push(`  -> delta: ${delta}`);\n            }\n          }\n        }\n      }\n\n      {\n        // Check if we should collapse a panel at its minimum size\n        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        const panelConstraints = panelConstraintsArray[index];\n        assert(panelConstraints, `No panel constraints found for index ${index}`);\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panelConstraints;\n\n        // DEBUG.push(`edge case check 2: ${index}`);\n        // DEBUG.push(`  -> collapsible? ${collapsible}`);\n        if (collapsible) {\n          const prevSize = initialLayout[index];\n          assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize, minSize)) {\n            const localDelta = prevSize - collapsedSize;\n            // DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n              // DEBUG.push(`  -> delta: ${delta}`);\n            }\n          }\n        }\n      }\n    }\n    // DEBUG.push(\"\");\n  }\n\n  {\n    // Pre-calculate max available delta in the opposite direction of our pivot.\n    // This will be the maximum amount we're allowed to expand/contract the panels in the primary direction.\n    // If this amount is less than the requested delta, adjust the requested delta.\n    // If this amount is greater than the requested delta, that's useful information too–\n    // as an expanding panel might change from collapsed to min size.\n\n    const increment = delta < 0 ? 1 : -1;\n    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    let maxAvailableDelta = 0;\n\n    // DEBUG.push(\"pre calc...\");\n    while (true) {\n      const prevSize = initialLayout[index];\n      assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n      const maxSafeSize = resizePanel({\n        panelConstraints: panelConstraintsArray,\n        panelIndex: index,\n        size: 100\n      });\n      const delta = maxSafeSize - prevSize;\n      // DEBUG.push(`  ${index}: ${prevSize} -> ${maxSafeSize}`);\n\n      maxAvailableDelta += delta;\n      index += increment;\n      if (index < 0 || index >= panelConstraintsArray.length) {\n        break;\n      }\n    }\n\n    // DEBUG.push(`  -> max available delta: ${maxAvailableDelta}`);\n    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n    // DEBUG.push(`  -> adjusted delta: ${delta}`);\n    // DEBUG.push(\"\");\n  }\n\n  {\n    // Delta added to a panel needs to be subtracted from other panels (within the constraints that those panels allow).\n\n    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n    let index = pivotIndex;\n    while (index >= 0 && index < panelConstraintsArray.length) {\n      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n      const prevSize = initialLayout[index];\n      assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n      const unsafeSize = prevSize - deltaRemaining;\n      const safeSize = resizePanel({\n        panelConstraints: panelConstraintsArray,\n        panelIndex: index,\n        size: unsafeSize\n      });\n      if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n        deltaApplied += prevSize - safeSize;\n        nextLayout[index] = safeSize;\n        if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), undefined, {\n          numeric: true\n        }) >= 0) {\n          break;\n        }\n      }\n      if (delta < 0) {\n        index--;\n      } else {\n        index++;\n      }\n    }\n  }\n  // DEBUG.push(`after 1: ${nextLayout.join(\", \")}`);\n  // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  // DEBUG.push(\"\");\n\n  // If we were unable to resize any of the panels panels, return the previous state.\n  // This will essentially bailout and ignore e.g. drags past a panel's boundaries\n  if (fuzzyLayoutsEqual(prevLayout, nextLayout)) {\n    // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\n    // console.log(DEBUG.join(\"\\n\"));\n\n    return prevLayout;\n  }\n  {\n    // Now distribute the applied delta to the panels in the other direction\n    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    const prevSize = initialLayout[pivotIndex];\n    assert(prevSize != null, `Previous layout not found for panel index ${pivotIndex}`);\n    const unsafeSize = prevSize + deltaApplied;\n    const safeSize = resizePanel({\n      panelConstraints: panelConstraintsArray,\n      panelIndex: pivotIndex,\n      size: unsafeSize\n    });\n\n    // Adjust the pivot panel before, but only by the amount that surrounding panels were able to shrink/contract.\n    nextLayout[pivotIndex] = safeSize;\n\n    // Edge case where expanding or contracting one panel caused another one to change collapsed state\n    if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {\n      let deltaRemaining = unsafeSize - safeSize;\n      const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n      let index = pivotIndex;\n      while (index >= 0 && index < panelConstraintsArray.length) {\n        const prevSize = nextLayout[index];\n        assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n        const unsafeSize = prevSize + deltaRemaining;\n        const safeSize = resizePanel({\n          panelConstraints: panelConstraintsArray,\n          panelIndex: index,\n          size: unsafeSize\n        });\n        if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n          deltaRemaining -= safeSize - prevSize;\n          nextLayout[index] = safeSize;\n        }\n        if (fuzzyNumbersEqual(deltaRemaining, 0)) {\n          break;\n        }\n        if (delta > 0) {\n          index--;\n        } else {\n          index++;\n        }\n      }\n    }\n  }\n  // DEBUG.push(`after 2: ${nextLayout.join(\", \")}`);\n  // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  // DEBUG.push(\"\");\n\n  const totalSize = nextLayout.reduce((total, size) => size + total, 0);\n  // DEBUG.push(`total size: ${totalSize}`);\n\n  // If our new layout doesn't add up to 100%, that means the requested delta can't be applied\n  // In that case, fall back to our most recent valid layout\n  if (!fuzzyNumbersEqual(totalSize, 100)) {\n    // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\n    // console.log(DEBUG.join(\"\\n\"));\n\n    return prevLayout;\n  }\n\n  // console.log(DEBUG.join(\"\\n\"));\n  return nextLayout;\n}\n\nfunction calculateAriaValues({\n  layout,\n  panelsArray,\n  pivotIndices\n}) {\n  let currentMinSize = 0;\n  let currentMaxSize = 100;\n  let totalMinSize = 0;\n  let totalMaxSize = 0;\n  const firstIndex = pivotIndices[0];\n  assert(firstIndex != null, \"No pivot index found\");\n\n  // A panel's effective min/max sizes also need to account for other panel's sizes.\n  panelsArray.forEach((panelData, index) => {\n    const {\n      constraints\n    } = panelData;\n    const {\n      maxSize = 100,\n      minSize = 0\n    } = constraints;\n    if (index === firstIndex) {\n      currentMinSize = minSize;\n      currentMaxSize = maxSize;\n    } else {\n      totalMinSize += minSize;\n      totalMaxSize += maxSize;\n    }\n  });\n  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);\n  const valueNow = layout[firstIndex];\n  return {\n    valueMax,\n    valueMin,\n    valueNow\n  };\n}\n\nfunction getResizeHandleElementsForGroup(groupId, scope = document) {\n  return Array.from(scope.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id=\"${groupId}\"]`));\n}\n\nfunction getResizeHandleElementIndex(groupId, id, scope = document) {\n  const handles = getResizeHandleElementsForGroup(groupId, scope);\n  const index = handles.findIndex(handle => handle.getAttribute(\"data-panel-resize-handle-id\") === id);\n  return index !== null && index !== void 0 ? index : null;\n}\n\nfunction determinePivotIndices(groupId, dragHandleId, panelGroupElement) {\n  const index = getResizeHandleElementIndex(groupId, dragHandleId, panelGroupElement);\n  return index != null ? [index, index + 1] : [-1, -1];\n}\n\nfunction getPanelGroupElement(id, rootElement = document) {\n  var _dataset;\n  //If the root element is the PanelGroup\n  if (rootElement instanceof HTMLElement && (rootElement === null || rootElement === void 0 ? void 0 : (_dataset = rootElement.dataset) === null || _dataset === void 0 ? void 0 : _dataset.panelGroupId) == id) {\n    return rootElement;\n  }\n\n  //Else query children\n  const element = rootElement.querySelector(`[data-panel-group][data-panel-group-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\n\nfunction getResizeHandleElement(id, scope = document) {\n  const element = scope.querySelector(`[data-panel-resize-handle-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\n\nfunction getResizeHandlePanelIds(groupId, handleId, panelsArray, scope = document) {\n  var _panelsArray$index$id, _panelsArray$index, _panelsArray$id, _panelsArray;\n  const handle = getResizeHandleElement(handleId, scope);\n  const handles = getResizeHandleElementsForGroup(groupId, scope);\n  const index = handle ? handles.indexOf(handle) : -1;\n  const idBefore = (_panelsArray$index$id = (_panelsArray$index = panelsArray[index]) === null || _panelsArray$index === void 0 ? void 0 : _panelsArray$index.id) !== null && _panelsArray$index$id !== void 0 ? _panelsArray$index$id : null;\n  const idAfter = (_panelsArray$id = (_panelsArray = panelsArray[index + 1]) === null || _panelsArray === void 0 ? void 0 : _panelsArray.id) !== null && _panelsArray$id !== void 0 ? _panelsArray$id : null;\n  return [idBefore, idAfter];\n}\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nfunction useWindowSplitterPanelGroupBehavior({\n  committedValuesRef,\n  eagerValuesRef,\n  groupId,\n  layout,\n  panelDataArray,\n  panelGroupElement,\n  setLayout\n}) {\n  useRef({\n    didWarnAboutMissingResizeHandle: false\n  });\n  useIsomorphicLayoutEffect(() => {\n    if (!panelGroupElement) {\n      return;\n    }\n    const resizeHandleElements = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n    for (let index = 0; index < panelDataArray.length - 1; index++) {\n      const {\n        valueMax,\n        valueMin,\n        valueNow\n      } = calculateAriaValues({\n        layout,\n        panelsArray: panelDataArray,\n        pivotIndices: [index, index + 1]\n      });\n      const resizeHandleElement = resizeHandleElements[index];\n      if (resizeHandleElement == null) ; else {\n        const panelData = panelDataArray[index];\n        assert(panelData, `No panel data found for index \"${index}\"`);\n        resizeHandleElement.setAttribute(\"aria-controls\", panelData.id);\n        resizeHandleElement.setAttribute(\"aria-valuemax\", \"\" + Math.round(valueMax));\n        resizeHandleElement.setAttribute(\"aria-valuemin\", \"\" + Math.round(valueMin));\n        resizeHandleElement.setAttribute(\"aria-valuenow\", valueNow != null ? \"\" + Math.round(valueNow) : \"\");\n      }\n    }\n    return () => {\n      resizeHandleElements.forEach((resizeHandleElement, index) => {\n        resizeHandleElement.removeAttribute(\"aria-controls\");\n        resizeHandleElement.removeAttribute(\"aria-valuemax\");\n        resizeHandleElement.removeAttribute(\"aria-valuemin\");\n        resizeHandleElement.removeAttribute(\"aria-valuenow\");\n      });\n    };\n  }, [groupId, layout, panelDataArray, panelGroupElement]);\n  useEffect(() => {\n    if (!panelGroupElement) {\n      return;\n    }\n    const eagerValues = eagerValuesRef.current;\n    assert(eagerValues, `Eager values not found`);\n    const {\n      panelDataArray\n    } = eagerValues;\n    const groupElement = getPanelGroupElement(groupId, panelGroupElement);\n    assert(groupElement != null, `No group found for id \"${groupId}\"`);\n    const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n    assert(handles, `No resize handles found for group id \"${groupId}\"`);\n    const cleanupFunctions = handles.map(handle => {\n      const handleId = handle.getAttribute(\"data-panel-resize-handle-id\");\n      assert(handleId, `Resize handle element has no handle id attribute`);\n      const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelDataArray, panelGroupElement);\n      if (idBefore == null || idAfter == null) {\n        return () => {};\n      }\n      const onKeyDown = event => {\n        if (event.defaultPrevented) {\n          return;\n        }\n        switch (event.key) {\n          case \"Enter\":\n            {\n              event.preventDefault();\n              const index = panelDataArray.findIndex(panelData => panelData.id === idBefore);\n              if (index >= 0) {\n                const panelData = panelDataArray[index];\n                assert(panelData, `No panel data found for index ${index}`);\n                const size = layout[index];\n                const {\n                  collapsedSize = 0,\n                  collapsible,\n                  minSize = 0\n                } = panelData.constraints;\n                if (size != null && collapsible) {\n                  const nextLayout = adjustLayoutByDelta({\n                    delta: fuzzyNumbersEqual(size, collapsedSize) ? minSize - collapsedSize : collapsedSize - size,\n                    initialLayout: layout,\n                    panelConstraints: panelDataArray.map(panelData => panelData.constraints),\n                    pivotIndices: determinePivotIndices(groupId, handleId, panelGroupElement),\n                    prevLayout: layout,\n                    trigger: \"keyboard\"\n                  });\n                  if (layout !== nextLayout) {\n                    setLayout(nextLayout);\n                  }\n                }\n              }\n              break;\n            }\n        }\n      };\n      handle.addEventListener(\"keydown\", onKeyDown);\n      return () => {\n        handle.removeEventListener(\"keydown\", onKeyDown);\n      };\n    });\n    return () => {\n      cleanupFunctions.forEach(cleanupFunction => cleanupFunction());\n    };\n  }, [panelGroupElement, committedValuesRef, eagerValuesRef, groupId, layout, panelDataArray, setLayout]);\n}\n\nfunction areEqual(arrayA, arrayB) {\n  if (arrayA.length !== arrayB.length) {\n    return false;\n  }\n  for (let index = 0; index < arrayA.length; index++) {\n    if (arrayA[index] !== arrayB[index]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction getResizeEventCursorPosition(direction, event) {\n  const isHorizontal = direction === \"horizontal\";\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  return isHorizontal ? x : y;\n}\n\nfunction calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement) {\n  const isHorizontal = direction === \"horizontal\";\n  const handleElement = getResizeHandleElement(dragHandleId, panelGroupElement);\n  assert(handleElement, `No resize handle element found for id \"${dragHandleId}\"`);\n  const groupId = handleElement.getAttribute(\"data-panel-group-id\");\n  assert(groupId, `Resize handle element has no group id attribute`);\n  let {\n    initialCursorPosition\n  } = initialDragState;\n  const cursorPosition = getResizeEventCursorPosition(direction, event);\n  const groupElement = getPanelGroupElement(groupId, panelGroupElement);\n  assert(groupElement, `No group element found for id \"${groupId}\"`);\n  const groupRect = groupElement.getBoundingClientRect();\n  const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;\n  const offsetPixels = cursorPosition - initialCursorPosition;\n  const offsetPercentage = offsetPixels / groupSizeInPixels * 100;\n  return offsetPercentage;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nfunction calculateDeltaPercentage(event, dragHandleId, direction, initialDragState, keyboardResizeBy, panelGroupElement) {\n  if (isKeyDown(event)) {\n    const isHorizontal = direction === \"horizontal\";\n    let delta = 0;\n    if (event.shiftKey) {\n      delta = 100;\n    } else if (keyboardResizeBy != null) {\n      delta = keyboardResizeBy;\n    } else {\n      delta = 10;\n    }\n    let movement = 0;\n    switch (event.key) {\n      case \"ArrowDown\":\n        movement = isHorizontal ? 0 : delta;\n        break;\n      case \"ArrowLeft\":\n        movement = isHorizontal ? -delta : 0;\n        break;\n      case \"ArrowRight\":\n        movement = isHorizontal ? delta : 0;\n        break;\n      case \"ArrowUp\":\n        movement = isHorizontal ? 0 : -delta;\n        break;\n      case \"End\":\n        movement = 100;\n        break;\n      case \"Home\":\n        movement = -100;\n        break;\n    }\n    return movement;\n  } else {\n    if (initialDragState == null) {\n      return 0;\n    }\n    return calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement);\n  }\n}\n\nfunction calculateUnsafeDefaultLayout({\n  panelDataArray\n}) {\n  const layout = Array(panelDataArray.length);\n  const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n  let numPanelsWithSizes = 0;\n  let remainingSize = 100;\n\n  // Distribute default sizes first\n  for (let index = 0; index < panelDataArray.length; index++) {\n    const panelConstraints = panelConstraintsArray[index];\n    assert(panelConstraints, `Panel constraints not found for index ${index}`);\n    const {\n      defaultSize\n    } = panelConstraints;\n    if (defaultSize != null) {\n      numPanelsWithSizes++;\n      layout[index] = defaultSize;\n      remainingSize -= defaultSize;\n    }\n  }\n\n  // Remaining size should be distributed evenly between panels without default sizes\n  for (let index = 0; index < panelDataArray.length; index++) {\n    const panelConstraints = panelConstraintsArray[index];\n    assert(panelConstraints, `Panel constraints not found for index ${index}`);\n    const {\n      defaultSize\n    } = panelConstraints;\n    if (defaultSize != null) {\n      continue;\n    }\n    const numRemainingPanels = panelDataArray.length - numPanelsWithSizes;\n    const size = remainingSize / numRemainingPanels;\n    numPanelsWithSizes++;\n    layout[index] = size;\n    remainingSize -= size;\n  }\n  return layout;\n}\n\n// Layout should be pre-converted into percentages\nfunction callPanelCallbacks(panelsArray, layout, panelIdToLastNotifiedSizeMap) {\n  layout.forEach((size, index) => {\n    const panelData = panelsArray[index];\n    assert(panelData, `Panel data not found for index ${index}`);\n    const {\n      callbacks,\n      constraints,\n      id: panelId\n    } = panelData;\n    const {\n      collapsedSize = 0,\n      collapsible\n    } = constraints;\n    const lastNotifiedSize = panelIdToLastNotifiedSizeMap[panelId];\n    if (lastNotifiedSize == null || size !== lastNotifiedSize) {\n      panelIdToLastNotifiedSizeMap[panelId] = size;\n      const {\n        onCollapse,\n        onExpand,\n        onResize\n      } = callbacks;\n      if (onResize) {\n        onResize(size, lastNotifiedSize);\n      }\n      if (collapsible && (onCollapse || onExpand)) {\n        if (onExpand && (lastNotifiedSize == null || fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && !fuzzyNumbersEqual$1(size, collapsedSize)) {\n          onExpand();\n        }\n        if (onCollapse && (lastNotifiedSize == null || !fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && fuzzyNumbersEqual$1(size, collapsedSize)) {\n          onCollapse();\n        }\n      }\n    }\n  });\n}\n\nfunction compareLayouts(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  } else {\n    for (let index = 0; index < a.length; index++) {\n      if (a[index] != b[index]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n// This method returns a number between 1 and 100 representing\n\n// the % of the group's overall space this panel should occupy.\nfunction computePanelFlexBoxStyle({\n  defaultSize,\n  dragState,\n  layout,\n  panelData,\n  panelIndex,\n  precision = 3\n}) {\n  const size = layout[panelIndex];\n  let flexGrow;\n  if (size == null) {\n    // Initial render (before panels have registered themselves)\n    // In order to support server rendering, fall back to default size if provided\n    flexGrow = defaultSize != undefined ? defaultSize.toPrecision(precision) : \"1\";\n  } else if (panelData.length === 1) {\n    // Special case: Single panel group should always fill full width/height\n    flexGrow = \"1\";\n  } else {\n    flexGrow = size.toPrecision(precision);\n  }\n  return {\n    flexBasis: 0,\n    flexGrow,\n    flexShrink: 1,\n    // Without this, Panel sizes may be unintentionally overridden by their content\n    overflow: \"hidden\",\n    // Disable pointer events inside of a panel during resize\n    // This avoid edge cases like nested iframes\n    pointerEvents: dragState !== null ? \"none\" : undefined\n  };\n}\n\nfunction debounce(callback, durationMs = 10) {\n  let timeoutId = null;\n  let callable = (...args) => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => {\n      callback(...args);\n    }, durationMs);\n  };\n  return callable;\n}\n\n// PanelGroup might be rendering in a server-side environment where localStorage is not available\n// or on a browser with cookies/storage disabled.\n// In either case, this function avoids accessing localStorage until needed,\n// and avoids throwing user-visible errors.\nfunction initializeDefaultStorage(storageObject) {\n  try {\n    if (typeof localStorage !== \"undefined\") {\n      // Bypass this check for future calls\n      storageObject.getItem = name => {\n        return localStorage.getItem(name);\n      };\n      storageObject.setItem = (name, value) => {\n        localStorage.setItem(name, value);\n      };\n    } else {\n      throw new Error(\"localStorage not supported in this environment\");\n    }\n  } catch (error) {\n    console.error(error);\n    storageObject.getItem = () => null;\n    storageObject.setItem = () => {};\n  }\n}\n\nfunction getPanelGroupKey(autoSaveId) {\n  return `react-resizable-panels:${autoSaveId}`;\n}\n\n// Note that Panel ids might be user-provided (stable) or useId generated (non-deterministic)\n// so they should not be used as part of the serialization key.\n// Using the min/max size attributes should work well enough as a backup.\n// Pre-sorting by minSize allows remembering layouts even if panels are re-ordered/dragged.\nfunction getPanelKey(panels) {\n  return panels.map(panel => {\n    const {\n      constraints,\n      id,\n      idIsFromProps,\n      order\n    } = panel;\n    if (idIsFromProps) {\n      return id;\n    } else {\n      return order ? `${order}:${JSON.stringify(constraints)}` : JSON.stringify(constraints);\n    }\n  }).sort((a, b) => a.localeCompare(b)).join(\",\");\n}\nfunction loadSerializedPanelGroupState(autoSaveId, storage) {\n  try {\n    const panelGroupKey = getPanelGroupKey(autoSaveId);\n    const serialized = storage.getItem(panelGroupKey);\n    if (serialized) {\n      const parsed = JSON.parse(serialized);\n      if (typeof parsed === \"object\" && parsed != null) {\n        return parsed;\n      }\n    }\n  } catch (error) {}\n  return null;\n}\nfunction loadPanelGroupState(autoSaveId, panels, storage) {\n  var _loadSerializedPanelG, _state$panelKey;\n  const state = (_loadSerializedPanelG = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG !== void 0 ? _loadSerializedPanelG : {};\n  const panelKey = getPanelKey(panels);\n  return (_state$panelKey = state[panelKey]) !== null && _state$panelKey !== void 0 ? _state$panelKey : null;\n}\nfunction savePanelGroupState(autoSaveId, panels, panelSizesBeforeCollapse, sizes, storage) {\n  var _loadSerializedPanelG2;\n  const panelGroupKey = getPanelGroupKey(autoSaveId);\n  const panelKey = getPanelKey(panels);\n  const state = (_loadSerializedPanelG2 = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG2 !== void 0 ? _loadSerializedPanelG2 : {};\n  state[panelKey] = {\n    expandToSizes: Object.fromEntries(panelSizesBeforeCollapse.entries()),\n    layout: sizes\n  };\n  try {\n    storage.setItem(panelGroupKey, JSON.stringify(state));\n  } catch (error) {\n    console.error(error);\n  }\n}\n\n// All units must be in percentages; pixel values should be pre-converted\nfunction validatePanelGroupLayout({\n  layout: prevLayout,\n  panelConstraints\n}) {\n  const nextLayout = [...prevLayout];\n  const nextLayoutTotalSize = nextLayout.reduce((accumulated, current) => accumulated + current, 0);\n\n  // Validate layout expectations\n  if (nextLayout.length !== panelConstraints.length) {\n    throw Error(`Invalid ${panelConstraints.length} panel layout: ${nextLayout.map(size => `${size}%`).join(\", \")}`);\n  } else if (!fuzzyNumbersEqual(nextLayoutTotalSize, 100) && nextLayout.length > 0) {\n    for (let index = 0; index < panelConstraints.length; index++) {\n      const unsafeSize = nextLayout[index];\n      assert(unsafeSize != null, `No layout data found for index ${index}`);\n      const safeSize = 100 / nextLayoutTotalSize * unsafeSize;\n      nextLayout[index] = safeSize;\n    }\n  }\n  let remainingSize = 0;\n\n  // First pass: Validate the proposed layout given each panel's constraints\n  for (let index = 0; index < panelConstraints.length; index++) {\n    const unsafeSize = nextLayout[index];\n    assert(unsafeSize != null, `No layout data found for index ${index}`);\n    const safeSize = resizePanel({\n      panelConstraints,\n      panelIndex: index,\n      size: unsafeSize\n    });\n    if (unsafeSize != safeSize) {\n      remainingSize += unsafeSize - safeSize;\n      nextLayout[index] = safeSize;\n    }\n  }\n\n  // If there is additional, left over space, assign it to any panel(s) that permits it\n  // (It's not worth taking multiple additional passes to evenly distribute)\n  if (!fuzzyNumbersEqual(remainingSize, 0)) {\n    for (let index = 0; index < panelConstraints.length; index++) {\n      const prevSize = nextLayout[index];\n      assert(prevSize != null, `No layout data found for index ${index}`);\n      const unsafeSize = prevSize + remainingSize;\n      const safeSize = resizePanel({\n        panelConstraints,\n        panelIndex: index,\n        size: unsafeSize\n      });\n      if (prevSize !== safeSize) {\n        remainingSize -= safeSize - prevSize;\n        nextLayout[index] = safeSize;\n\n        // Once we've used up the remainder, bail\n        if (fuzzyNumbersEqual(remainingSize, 0)) {\n          break;\n        }\n      }\n    }\n  }\n  return nextLayout;\n}\n\nconst LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;\nconst defaultStorage = {\n  getItem: name => {\n    initializeDefaultStorage(defaultStorage);\n    return defaultStorage.getItem(name);\n  },\n  setItem: (name, value) => {\n    initializeDefaultStorage(defaultStorage);\n    defaultStorage.setItem(name, value);\n  }\n};\nconst debounceMap = {};\nfunction PanelGroupWithForwardedRef({\n  autoSaveId = null,\n  children,\n  className: classNameFromProps = \"\",\n  direction,\n  forwardedRef,\n  id: idFromProps = null,\n  onLayout = null,\n  keyboardResizeBy = null,\n  storage = defaultStorage,\n  style: styleFromProps,\n  tagName: Type = \"div\",\n  ...rest\n}) {\n  const groupId = useUniqueId(idFromProps);\n  const panelGroupElementRef = useRef(null);\n  const [dragState, setDragState] = useState(null);\n  const [layout, setLayout] = useState([]);\n  const forceUpdate = useForceUpdate();\n  const panelIdToLastNotifiedSizeMapRef = useRef({});\n  const panelSizeBeforeCollapseRef = useRef(new Map());\n  const prevDeltaRef = useRef(0);\n  const committedValuesRef = useRef({\n    autoSaveId,\n    direction,\n    dragState,\n    id: groupId,\n    keyboardResizeBy,\n    onLayout,\n    storage\n  });\n  const eagerValuesRef = useRef({\n    layout,\n    panelDataArray: [],\n    panelDataArrayChanged: false\n  });\n  useRef({\n    didLogIdAndOrderWarning: false,\n    didLogPanelConstraintsWarning: false,\n    prevPanelIds: []\n  });\n  useImperativeHandle(forwardedRef, () => ({\n    getId: () => committedValuesRef.current.id,\n    getLayout: () => {\n      const {\n        layout\n      } = eagerValuesRef.current;\n      return layout;\n    },\n    setLayout: unsafeLayout => {\n      const {\n        onLayout\n      } = committedValuesRef.current;\n      const {\n        layout: prevLayout,\n        panelDataArray\n      } = eagerValuesRef.current;\n      const safeLayout = validatePanelGroupLayout({\n        layout: unsafeLayout,\n        panelConstraints: panelDataArray.map(panelData => panelData.constraints)\n      });\n      if (!areEqual(prevLayout, safeLayout)) {\n        setLayout(safeLayout);\n        eagerValuesRef.current.layout = safeLayout;\n        if (onLayout) {\n          onLayout(safeLayout);\n        }\n        callPanelCallbacks(panelDataArray, safeLayout, panelIdToLastNotifiedSizeMapRef.current);\n      }\n    }\n  }), []);\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.autoSaveId = autoSaveId;\n    committedValuesRef.current.direction = direction;\n    committedValuesRef.current.dragState = dragState;\n    committedValuesRef.current.id = groupId;\n    committedValuesRef.current.onLayout = onLayout;\n    committedValuesRef.current.storage = storage;\n  });\n  useWindowSplitterPanelGroupBehavior({\n    committedValuesRef,\n    eagerValuesRef,\n    groupId,\n    layout,\n    panelDataArray: eagerValuesRef.current.panelDataArray,\n    setLayout,\n    panelGroupElement: panelGroupElementRef.current\n  });\n  useEffect(() => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n\n    // If this panel has been configured to persist sizing information, save sizes to local storage.\n    if (autoSaveId) {\n      if (layout.length === 0 || layout.length !== panelDataArray.length) {\n        return;\n      }\n      let debouncedSave = debounceMap[autoSaveId];\n\n      // Limit the frequency of localStorage updates.\n      if (debouncedSave == null) {\n        debouncedSave = debounce(savePanelGroupState, LOCAL_STORAGE_DEBOUNCE_INTERVAL);\n        debounceMap[autoSaveId] = debouncedSave;\n      }\n\n      // Clone mutable data before passing to the debounced function,\n      // else we run the risk of saving an incorrect combination of mutable and immutable values to state.\n      const clonedPanelDataArray = [...panelDataArray];\n      const clonedPanelSizesBeforeCollapse = new Map(panelSizeBeforeCollapseRef.current);\n      debouncedSave(autoSaveId, clonedPanelDataArray, clonedPanelSizesBeforeCollapse, layout, storage);\n    }\n  }, [autoSaveId, layout, storage]);\n\n  // DEV warnings\n  useEffect(() => {\n  });\n\n  // External APIs are safe to memoize via committed values ref\n  const collapsePanel = useCallback(panelData => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    if (panelData.constraints.collapsible) {\n      const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n      const {\n        collapsedSize = 0,\n        panelSize,\n        pivotIndices\n      } = panelDataHelper(panelDataArray, panelData, prevLayout);\n      assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n      if (!fuzzyNumbersEqual$1(panelSize, collapsedSize)) {\n        // Store size before collapse;\n        // This is the size that gets restored if the expand() API is used.\n        panelSizeBeforeCollapseRef.current.set(panelData.id, panelSize);\n        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n        const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;\n        const nextLayout = adjustLayoutByDelta({\n          delta,\n          initialLayout: prevLayout,\n          panelConstraints: panelConstraintsArray,\n          pivotIndices,\n          prevLayout,\n          trigger: \"imperative-api\"\n        });\n        if (!compareLayouts(prevLayout, nextLayout)) {\n          setLayout(nextLayout);\n          eagerValuesRef.current.layout = nextLayout;\n          if (onLayout) {\n            onLayout(nextLayout);\n          }\n          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n        }\n      }\n    }\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const expandPanel = useCallback((panelData, minSizeOverride) => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    if (panelData.constraints.collapsible) {\n      const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n      const {\n        collapsedSize = 0,\n        panelSize = 0,\n        minSize: minSizeFromProps = 0,\n        pivotIndices\n      } = panelDataHelper(panelDataArray, panelData, prevLayout);\n      const minSize = minSizeOverride !== null && minSizeOverride !== void 0 ? minSizeOverride : minSizeFromProps;\n      if (fuzzyNumbersEqual$1(panelSize, collapsedSize)) {\n        // Restore this panel to the size it was before it was collapsed, if possible.\n        const prevPanelSize = panelSizeBeforeCollapseRef.current.get(panelData.id);\n        const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;\n        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n        const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;\n        const nextLayout = adjustLayoutByDelta({\n          delta,\n          initialLayout: prevLayout,\n          panelConstraints: panelConstraintsArray,\n          pivotIndices,\n          prevLayout,\n          trigger: \"imperative-api\"\n        });\n        if (!compareLayouts(prevLayout, nextLayout)) {\n          setLayout(nextLayout);\n          eagerValuesRef.current.layout = nextLayout;\n          if (onLayout) {\n            onLayout(nextLayout);\n          }\n          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n        }\n      }\n    }\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const getPanelSize = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      panelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    return panelSize;\n  }, []);\n\n  // This API should never read from committedValuesRef\n  const getPanelStyle = useCallback((panelData, defaultSize) => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    const panelIndex = findPanelDataIndex(panelDataArray, panelData);\n    return computePanelFlexBoxStyle({\n      defaultSize,\n      dragState,\n      layout,\n      panelData: panelDataArray,\n      panelIndex\n    });\n  }, [dragState, layout]);\n\n  // External APIs are safe to memoize via committed values ref\n  const isPanelCollapsed = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSize = 0,\n      collapsible,\n      panelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    return collapsible === true && fuzzyNumbersEqual$1(panelSize, collapsedSize);\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const isPanelExpanded = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSize = 0,\n      collapsible,\n      panelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    return !collapsible || fuzzyCompareNumbers(panelSize, collapsedSize) > 0;\n  }, []);\n  const registerPanel = useCallback(panelData => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    panelDataArray.push(panelData);\n    panelDataArray.sort((panelA, panelB) => {\n      const orderA = panelA.order;\n      const orderB = panelB.order;\n      if (orderA == null && orderB == null) {\n        return 0;\n      } else if (orderA == null) {\n        return -1;\n      } else if (orderB == null) {\n        return 1;\n      } else {\n        return orderA - orderB;\n      }\n    });\n    eagerValuesRef.current.panelDataArrayChanged = true;\n    forceUpdate();\n  }, [forceUpdate]);\n\n  // (Re)calculate group layout whenever panels are registered or unregistered.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useIsomorphicLayoutEffect(() => {\n    if (eagerValuesRef.current.panelDataArrayChanged) {\n      eagerValuesRef.current.panelDataArrayChanged = false;\n      const {\n        autoSaveId,\n        onLayout,\n        storage\n      } = committedValuesRef.current;\n      const {\n        layout: prevLayout,\n        panelDataArray\n      } = eagerValuesRef.current;\n\n      // If this panel has been configured to persist sizing information,\n      // default size should be restored from local storage if possible.\n      let unsafeLayout = null;\n      if (autoSaveId) {\n        const state = loadPanelGroupState(autoSaveId, panelDataArray, storage);\n        if (state) {\n          panelSizeBeforeCollapseRef.current = new Map(Object.entries(state.expandToSizes));\n          unsafeLayout = state.layout;\n        }\n      }\n      if (unsafeLayout == null) {\n        unsafeLayout = calculateUnsafeDefaultLayout({\n          panelDataArray\n        });\n      }\n\n      // Validate even saved layouts in case something has changed since last render\n      // e.g. for pixel groups, this could be the size of the window\n      const nextLayout = validatePanelGroupLayout({\n        layout: unsafeLayout,\n        panelConstraints: panelDataArray.map(panelData => panelData.constraints)\n      });\n      if (!areEqual(prevLayout, nextLayout)) {\n        setLayout(nextLayout);\n        eagerValuesRef.current.layout = nextLayout;\n        if (onLayout) {\n          onLayout(nextLayout);\n        }\n        callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n      }\n    }\n  });\n\n  // Reset the cached layout if hidden by the Activity/Offscreen API\n  useIsomorphicLayoutEffect(() => {\n    const eagerValues = eagerValuesRef.current;\n    return () => {\n      eagerValues.layout = [];\n    };\n  }, []);\n  const registerResizeHandle = useCallback(dragHandleId => {\n    let isRTL = false;\n    const panelGroupElement = panelGroupElementRef.current;\n    if (panelGroupElement) {\n      const style = window.getComputedStyle(panelGroupElement, null);\n      if (style.getPropertyValue(\"direction\") === \"rtl\") {\n        isRTL = true;\n      }\n    }\n    return function resizeHandler(event) {\n      event.preventDefault();\n      const panelGroupElement = panelGroupElementRef.current;\n      if (!panelGroupElement) {\n        return () => null;\n      }\n      const {\n        direction,\n        dragState,\n        id: groupId,\n        keyboardResizeBy,\n        onLayout\n      } = committedValuesRef.current;\n      const {\n        layout: prevLayout,\n        panelDataArray\n      } = eagerValuesRef.current;\n      const {\n        initialLayout\n      } = dragState !== null && dragState !== void 0 ? dragState : {};\n      const pivotIndices = determinePivotIndices(groupId, dragHandleId, panelGroupElement);\n      let delta = calculateDeltaPercentage(event, dragHandleId, direction, dragState, keyboardResizeBy, panelGroupElement);\n      const isHorizontal = direction === \"horizontal\";\n      if (isHorizontal && isRTL) {\n        delta = -delta;\n      }\n      const panelConstraints = panelDataArray.map(panelData => panelData.constraints);\n      const nextLayout = adjustLayoutByDelta({\n        delta,\n        initialLayout: initialLayout !== null && initialLayout !== void 0 ? initialLayout : prevLayout,\n        panelConstraints,\n        pivotIndices,\n        prevLayout,\n        trigger: isKeyDown(event) ? \"keyboard\" : \"mouse-or-touch\"\n      });\n      const layoutChanged = !compareLayouts(prevLayout, nextLayout);\n\n      // Only update the cursor for layout changes triggered by touch/mouse events (not keyboard)\n      // Update the cursor even if the layout hasn't changed (we may need to show an invalid cursor state)\n      if (isPointerEvent(event) || isMouseEvent(event)) {\n        // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n        // In this case, Panel sizes might not change–\n        // but updating cursor in this scenario would cause a flicker.\n        if (prevDeltaRef.current != delta) {\n          prevDeltaRef.current = delta;\n          if (!layoutChanged && delta !== 0) {\n            // If the pointer has moved too far to resize the panel any further, note this so we can update the cursor.\n            // This mimics VS Code behavior.\n            if (isHorizontal) {\n              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_HORIZONTAL_MIN : EXCEEDED_HORIZONTAL_MAX);\n            } else {\n              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_VERTICAL_MIN : EXCEEDED_VERTICAL_MAX);\n            }\n          } else {\n            reportConstraintsViolation(dragHandleId, 0);\n          }\n        }\n      }\n      if (layoutChanged) {\n        setLayout(nextLayout);\n        eagerValuesRef.current.layout = nextLayout;\n        if (onLayout) {\n          onLayout(nextLayout);\n        }\n        callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n      }\n    };\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const resizePanel = useCallback((panelData, unsafePanelSize) => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n    const {\n      panelSize,\n      pivotIndices\n    } = panelDataHelper(panelDataArray, panelData, prevLayout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n    const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;\n    const nextLayout = adjustLayoutByDelta({\n      delta,\n      initialLayout: prevLayout,\n      panelConstraints: panelConstraintsArray,\n      pivotIndices,\n      prevLayout,\n      trigger: \"imperative-api\"\n    });\n    if (!compareLayouts(prevLayout, nextLayout)) {\n      setLayout(nextLayout);\n      eagerValuesRef.current.layout = nextLayout;\n      if (onLayout) {\n        onLayout(nextLayout);\n      }\n      callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n    }\n  }, []);\n  const reevaluatePanelConstraints = useCallback((panelData, prevConstraints) => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSize: prevCollapsedSize = 0,\n      collapsible: prevCollapsible\n    } = prevConstraints;\n    const {\n      collapsedSize: nextCollapsedSize = 0,\n      collapsible: nextCollapsible,\n      maxSize: nextMaxSize = 100,\n      minSize: nextMinSize = 0\n    } = panelData.constraints;\n    const {\n      panelSize: prevPanelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    if (prevPanelSize == null) {\n      // It's possible that the panels in this group have changed since the last render\n      return;\n    }\n    if (prevCollapsible && nextCollapsible && fuzzyNumbersEqual$1(prevPanelSize, prevCollapsedSize)) {\n      if (!fuzzyNumbersEqual$1(prevCollapsedSize, nextCollapsedSize)) {\n        resizePanel(panelData, nextCollapsedSize);\n      }\n    } else if (prevPanelSize < nextMinSize) {\n      resizePanel(panelData, nextMinSize);\n    } else if (prevPanelSize > nextMaxSize) {\n      resizePanel(panelData, nextMaxSize);\n    }\n  }, [resizePanel]);\n\n  // TODO Multiple drag handles can be active at the same time so this API is a bit awkward now\n  const startDragging = useCallback((dragHandleId, event) => {\n    const {\n      direction\n    } = committedValuesRef.current;\n    const {\n      layout\n    } = eagerValuesRef.current;\n    if (!panelGroupElementRef.current) {\n      return;\n    }\n    const handleElement = getResizeHandleElement(dragHandleId, panelGroupElementRef.current);\n    assert(handleElement, `Drag handle element not found for id \"${dragHandleId}\"`);\n    const initialCursorPosition = getResizeEventCursorPosition(direction, event);\n    setDragState({\n      dragHandleId,\n      dragHandleRect: handleElement.getBoundingClientRect(),\n      initialCursorPosition,\n      initialLayout: layout\n    });\n  }, []);\n  const stopDragging = useCallback(() => {\n    setDragState(null);\n  }, []);\n  const unregisterPanel = useCallback(panelData => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    const index = findPanelDataIndex(panelDataArray, panelData);\n    if (index >= 0) {\n      panelDataArray.splice(index, 1);\n\n      // TRICKY\n      // When a panel is removed from the group, we should delete the most recent prev-size entry for it.\n      // If we don't do this, then a conditionally rendered panel might not call onResize when it's re-mounted.\n      // Strict effects mode makes this tricky though because all panels will be registered, unregistered, then re-registered on mount.\n      delete panelIdToLastNotifiedSizeMapRef.current[panelData.id];\n      eagerValuesRef.current.panelDataArrayChanged = true;\n      forceUpdate();\n    }\n  }, [forceUpdate]);\n  const context = useMemo(() => ({\n    collapsePanel,\n    direction,\n    dragState,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    groupId,\n    isPanelCollapsed,\n    isPanelExpanded,\n    reevaluatePanelConstraints,\n    registerPanel,\n    registerResizeHandle,\n    resizePanel,\n    startDragging,\n    stopDragging,\n    unregisterPanel,\n    panelGroupElement: panelGroupElementRef.current\n  }), [collapsePanel, dragState, direction, expandPanel, getPanelSize, getPanelStyle, groupId, isPanelCollapsed, isPanelExpanded, reevaluatePanelConstraints, registerPanel, registerResizeHandle, resizePanel, startDragging, stopDragging, unregisterPanel]);\n  const style = {\n    display: \"flex\",\n    flexDirection: direction === \"horizontal\" ? \"row\" : \"column\",\n    height: \"100%\",\n    overflow: \"hidden\",\n    width: \"100%\"\n  };\n  return createElement(PanelGroupContext.Provider, {\n    value: context\n  }, createElement(Type, {\n    ...rest,\n    children,\n    className: classNameFromProps,\n    id: idFromProps,\n    ref: panelGroupElementRef,\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    // CSS selectors\n    \"data-panel-group\": \"\",\n    \"data-panel-group-direction\": direction,\n    \"data-panel-group-id\": groupId\n  }));\n}\nconst PanelGroup = forwardRef((props, ref) => createElement(PanelGroupWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelGroupWithForwardedRef.displayName = \"PanelGroup\";\nPanelGroup.displayName = \"forwardRef(PanelGroup)\";\nfunction findPanelDataIndex(panelDataArray, panelData) {\n  return panelDataArray.findIndex(prevPanelData => prevPanelData === panelData || prevPanelData.id === panelData.id);\n}\nfunction panelDataHelper(panelDataArray, panelData, layout) {\n  const panelIndex = findPanelDataIndex(panelDataArray, panelData);\n  const isLastPanel = panelIndex === panelDataArray.length - 1;\n  const pivotIndices = isLastPanel ? [panelIndex - 1, panelIndex] : [panelIndex, panelIndex + 1];\n  const panelSize = layout[panelIndex];\n  return {\n    ...panelData.constraints,\n    panelSize,\n    pivotIndices\n  };\n}\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nfunction useWindowSplitterResizeHandlerBehavior({\n  disabled,\n  handleId,\n  resizeHandler,\n  panelGroupElement\n}) {\n  useEffect(() => {\n    if (disabled || resizeHandler == null || panelGroupElement == null) {\n      return;\n    }\n    const handleElement = getResizeHandleElement(handleId, panelGroupElement);\n    if (handleElement == null) {\n      return;\n    }\n    const onKeyDown = event => {\n      if (event.defaultPrevented) {\n        return;\n      }\n      switch (event.key) {\n        case \"ArrowDown\":\n        case \"ArrowLeft\":\n        case \"ArrowRight\":\n        case \"ArrowUp\":\n        case \"End\":\n        case \"Home\":\n          {\n            event.preventDefault();\n            resizeHandler(event);\n            break;\n          }\n        case \"F6\":\n          {\n            event.preventDefault();\n            const groupId = handleElement.getAttribute(\"data-panel-group-id\");\n            assert(groupId, `No group element found for id \"${groupId}\"`);\n            const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n            const index = getResizeHandleElementIndex(groupId, handleId, panelGroupElement);\n            assert(index !== null, `No resize element found for id \"${handleId}\"`);\n            const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;\n            const nextHandle = handles[nextIndex];\n            nextHandle.focus();\n            break;\n          }\n      }\n    };\n    handleElement.addEventListener(\"keydown\", onKeyDown);\n    return () => {\n      handleElement.removeEventListener(\"keydown\", onKeyDown);\n    };\n  }, [panelGroupElement, disabled, handleId, resizeHandler]);\n}\n\nfunction PanelResizeHandle({\n  children = null,\n  className: classNameFromProps = \"\",\n  disabled = false,\n  hitAreaMargins,\n  id: idFromProps,\n  onBlur,\n  onDragging,\n  onFocus,\n  style: styleFromProps = {},\n  tabIndex = 0,\n  tagName: Type = \"div\",\n  ...rest\n}) {\n  var _hitAreaMargins$coars, _hitAreaMargins$fine;\n  const elementRef = useRef(null);\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef({\n    onDragging\n  });\n  useEffect(() => {\n    callbacksRef.current.onDragging = onDragging;\n  });\n  const panelGroupContext = useContext(PanelGroupContext);\n  if (panelGroupContext === null) {\n    throw Error(`PanelResizeHandle components must be rendered within a PanelGroup container`);\n  }\n  const {\n    direction,\n    groupId,\n    registerResizeHandle: registerResizeHandleWithParentGroup,\n    startDragging,\n    stopDragging,\n    panelGroupElement\n  } = panelGroupContext;\n  const resizeHandleId = useUniqueId(idFromProps);\n  const [state, setState] = useState(\"inactive\");\n  const [isFocused, setIsFocused] = useState(false);\n  const [resizeHandler, setResizeHandler] = useState(null);\n  const committedValuesRef = useRef({\n    state\n  });\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.state = state;\n  });\n  useEffect(() => {\n    if (disabled) {\n      setResizeHandler(null);\n    } else {\n      const resizeHandler = registerResizeHandleWithParentGroup(resizeHandleId);\n      setResizeHandler(() => resizeHandler);\n    }\n  }, [disabled, resizeHandleId, registerResizeHandleWithParentGroup]);\n\n  // Extract hit area margins before passing them to the effect's dependency array\n  // so that inline object values won't trigger re-renders\n  const coarseHitAreaMargins = (_hitAreaMargins$coars = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.coarse) !== null && _hitAreaMargins$coars !== void 0 ? _hitAreaMargins$coars : 15;\n  const fineHitAreaMargins = (_hitAreaMargins$fine = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.fine) !== null && _hitAreaMargins$fine !== void 0 ? _hitAreaMargins$fine : 5;\n  useEffect(() => {\n    if (disabled || resizeHandler == null) {\n      return;\n    }\n    const element = elementRef.current;\n    assert(element, \"Element ref not attached\");\n    const setResizeHandlerState = (action, isActive, event) => {\n      if (isActive) {\n        switch (action) {\n          case \"down\":\n            {\n              setState(\"drag\");\n              assert(event, 'Expected event to be defined for \"down\" action');\n              startDragging(resizeHandleId, event);\n              const {\n                onDragging\n              } = callbacksRef.current;\n              if (onDragging) {\n                onDragging(true);\n              }\n              break;\n            }\n          case \"move\":\n            {\n              const {\n                state\n              } = committedValuesRef.current;\n              if (state !== \"drag\") {\n                setState(\"hover\");\n              }\n              assert(event, 'Expected event to be defined for \"move\" action');\n              resizeHandler(event);\n              break;\n            }\n          case \"up\":\n            {\n              setState(\"hover\");\n              stopDragging();\n              const {\n                onDragging\n              } = callbacksRef.current;\n              if (onDragging) {\n                onDragging(false);\n              }\n              break;\n            }\n        }\n      } else {\n        setState(\"inactive\");\n      }\n    };\n    return registerResizeHandle(resizeHandleId, element, direction, {\n      coarse: coarseHitAreaMargins,\n      fine: fineHitAreaMargins\n    }, setResizeHandlerState);\n  }, [coarseHitAreaMargins, direction, disabled, fineHitAreaMargins, registerResizeHandleWithParentGroup, resizeHandleId, resizeHandler, startDragging, stopDragging]);\n  useWindowSplitterResizeHandlerBehavior({\n    disabled,\n    handleId: resizeHandleId,\n    resizeHandler,\n    panelGroupElement\n  });\n  const style = {\n    touchAction: \"none\",\n    userSelect: \"none\"\n  };\n  return createElement(Type, {\n    ...rest,\n    children,\n    className: classNameFromProps,\n    id: idFromProps,\n    onBlur: () => {\n      setIsFocused(false);\n      onBlur === null || onBlur === void 0 ? void 0 : onBlur();\n    },\n    onFocus: () => {\n      setIsFocused(true);\n      onFocus === null || onFocus === void 0 ? void 0 : onFocus();\n    },\n    ref: elementRef,\n    role: \"separator\",\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    tabIndex,\n    // CSS selectors\n    \"data-panel-group-direction\": direction,\n    \"data-panel-group-id\": groupId,\n    \"data-resize-handle\": \"\",\n    \"data-resize-handle-active\": state === \"drag\" ? \"pointer\" : isFocused ? \"keyboard\" : undefined,\n    \"data-resize-handle-state\": state,\n    \"data-panel-resize-handle-enabled\": !disabled,\n    \"data-panel-resize-handle-id\": resizeHandleId\n  });\n}\nPanelResizeHandle.displayName = \"PanelResizeHandle\";\n\nfunction getPanelElement(id, scope = document) {\n  const element = scope.querySelector(`[data-panel-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\n\nfunction getPanelElementsForGroup(groupId, scope = document) {\n  return Array.from(scope.querySelectorAll(`[data-panel][data-panel-group-id=\"${groupId}\"]`));\n}\n\nfunction getIntersectingRectangle(rectOne, rectTwo, strict) {\n  if (!intersects(rectOne, rectTwo, strict)) {\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n  }\n  return {\n    x: Math.max(rectOne.x, rectTwo.x),\n    y: Math.max(rectOne.y, rectTwo.y),\n    width: Math.min(rectOne.x + rectOne.width, rectTwo.x + rectTwo.width) - Math.max(rectOne.x, rectTwo.x),\n    height: Math.min(rectOne.y + rectOne.height, rectTwo.y + rectTwo.height) - Math.max(rectOne.y, rectTwo.y)\n  };\n}\n\nexport { Panel, PanelGroup, PanelResizeHandle, assert, disableGlobalCursorStyles, enableGlobalCursorStyles, getIntersectingRectangle, getPanelElement, getPanelElementsForGroup, getPanelGroupElement, getResizeHandleElement, getResizeHandleElementIndex, getResizeHandleElementsForGroup, getResizeHandlePanelIds, intersects, setNonce };\n"],"names":["GripVertical","_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__","Z","cx","cy","r","key","nonce","createElement","createContext","createRef","forwardRef","useCallback","useContext","useEffect","useImperativeHandle","useLayoutEffect","useMemo","useRef","useState","react__WEBPACK_IMPORTED_MODULE_0___namespace_cache","__webpack_require__","t","react__WEBPACK_IMPORTED_MODULE_0__","useId","Math","random","slice","PanelGroupContext","displayName","wrappedUseId","counter","useUniqueId","idFromParams","idFromUseId","idRef","current","PanelWithForwardedRef","children","className","classNameFromProps","collapsedSize","collapsible","defaultSize","forwardedRef","id","idFromProps","maxSize","minSize","onCollapse","onExpand","onResize","order","style","styleFromProps","tagName","Type","rest","context","Error","collapsePanel","expandPanel","getPanelSize","getPanelStyle","groupId","isPanelCollapsed","reevaluatePanelConstraints","registerPanel","resizePanel","unregisterPanel","panelId","panelDataRef","callbacks","constraints","idIsFromProps","undefined","didLogMissingDefaultSizeWarning","useIsomorphicLayoutEffect","prevConstraints","panelData","collapse","expand","getId","getSize","isCollapsed","isExpanded","resize","size","parseFloat","flexGrow","toFixed","Panel","props","ref","currentCursorStyle","styleElement","setGlobalCursorStyle","state","constraintFlags","getCursorStyle","horizontalMin","EXCEEDED_HORIZONTAL_MIN","horizontalMax","EXCEEDED_HORIZONTAL_MAX","verticalMin","EXCEEDED_VERTICAL_MIN","verticalMax","EXCEEDED_VERTICAL_MAX","document","setAttribute","head","appendChild","innerHTML","isKeyDown","event","type","isPointerEvent","startsWith","isMouseEvent","getResizeEventCoordinates","isPrimary","x","clientX","y","clientY","Infinity","find_stacking_context","nodes","i","length","node","assert","creates_stacking_context","getComputedStyle","position","zIndex","is_flex_item","_get_parent","display","get_parent","opacity","transform","webkitTransform","mixBlendMode","filter","webkitFilter","isolation","test","willChange","webkitOverflowScrolling","get_z_index","Number","get_ancestors","ancestors","push","parentNode","ShadowRoot","host","isCoarsePointer","getInputType","matchMedia","matches","intersectingHandles","isPointerDown","ownerDocumentCounts","Map","panelConstraintFlags","registeredResizeHandlers","Set","handlePointerDown","target","recalculateIntersectingHandles","updateListeners","updateResizeHandlerStates","preventDefault","stopPropagation","handlePointerMove","buttons","updateCursor","handlePointerUp","clear","splice","targetElement","HTMLElement","SVGElement","forEach","data","element","dragHandleElement","hitAreaMargins","dragHandleRect","getBoundingClientRect","bottom","left","right","top","margin","coarse","fine","contains","compare","a","b","common_ancestor","at","pop","z_indexes","childNodes","furthest_ancestors","child","sign","currentElement","didIntersect","rectOne","rectTwo","width","height","parentElement","intersectsHorizontal","intersectsVertical","direction","flag","removeChild","_","ownerDocument","body","removeEventListener","window","count","addEventListener","capture","action","setResizeHandlerState","isActive","includes","expectedCondition","message","console","error","fuzzyCompareNumbers","actual","expected","fractionDigits","fuzzyNumbersEqual$1","fuzzyNumbersEqual","panelConstraints","panelConstraintsArray","panelIndex","halfwayPoint","min","adjustLayoutByDelta","delta","initialLayout","pivotIndices","prevLayout","trigger","nextLayout","firstPivotIndex","secondPivotIndex","deltaApplied","index","prevSize","localDelta","abs","increment","maxAvailableDelta","maxSafeSize","minAbsDelta","pivotIndex","deltaRemaining","unsafeSize","safeSize","toPrecision","localeCompare","numeric","fuzzyLayoutsEqual","actualSize","expectedSize","totalSize","reduce","total","getResizeHandleElementsForGroup","scope","Array","from","querySelectorAll","getResizeHandleElementIndex","handles","findIndex","handle","getAttribute","determinePivotIndices","dragHandleId","panelGroupElement","getPanelGroupElement","rootElement","_dataset","dataset","panelGroupId","querySelector","getResizeHandleElement","areEqual","arrayA","arrayB","getResizeEventCursorPosition","isHorizontal","callPanelCallbacks","panelsArray","layout","panelIdToLastNotifiedSizeMap","lastNotifiedSize","compareLayouts","initializeDefaultStorage","storageObject","localStorage","getItem","name","setItem","value","getPanelGroupKey","autoSaveId","getPanelKey","panels","map","panel","JSON","stringify","sort","join","loadSerializedPanelGroupState","storage","panelGroupKey","serialized","parsed","parse","savePanelGroupState","panelSizesBeforeCollapse","sizes","_loadSerializedPanelG2","panelKey","expandToSizes","Object","fromEntries","entries","validatePanelGroupLayout","nextLayoutTotalSize","accumulated","remainingSize","defaultStorage","debounceMap","PanelGroupWithForwardedRef","onLayout","keyboardResizeBy","panelGroupElementRef","dragState","setDragState","setLayout","forceUpdate","useForceUpdate","setCount","prevCount","panelIdToLastNotifiedSizeMapRef","panelSizeBeforeCollapseRef","prevDeltaRef","committedValuesRef","eagerValuesRef","panelDataArray","panelDataArrayChanged","didLogIdAndOrderWarning","didLogPanelConstraintsWarning","prevPanelIds","getLayout","unsafeLayout","safeLayout","useWindowSplitterPanelGroupBehavior","didWarnAboutMissingResizeHandle","resizeHandleElements","valueMax","valueMin","valueNow","calculateAriaValues","currentMinSize","currentMaxSize","totalMinSize","totalMaxSize","firstIndex","max","resizeHandleElement","round","removeAttribute","eagerValues","groupElement","cleanupFunctions","handleId","idBefore","idAfter","getResizeHandlePanelIds","_panelsArray$index$id","_panelsArray$index","_panelsArray$id","_panelsArray","indexOf","onKeyDown","defaultPrevented","cleanupFunction","debouncedSave","debounce","callback","durationMs","timeoutId","args","clearTimeout","setTimeout","clonedPanelDataArray","clonedPanelSizesBeforeCollapse","panelSize","panelDataHelper","set","isLastPanel","findPanelDataIndex","minSizeOverride","minSizeFromProps","prevPanelSize","get","baseSize","computePanelFlexBoxStyle","precision","flexBasis","flexShrink","overflow","pointerEvents","isPanelExpanded","panelA","panelB","orderA","orderB","loadPanelGroupState","_loadSerializedPanelG","_state$panelKey","calculateUnsafeDefaultLayout","numPanelsWithSizes","numRemainingPanels","registerResizeHandle","isRTL","getPropertyValue","calculateDeltaPercentage","initialDragState","shiftKey","movement","calculateDragOffsetPercentage","handleElement","initialCursorPosition","cursorPosition","groupRect","groupSizeInPixels","offsetPixels","layoutChanged","unsafePanelSize","prevCollapsedSize","prevCollapsible","nextCollapsedSize","nextCollapsible","nextMaxSize","nextMinSize","startDragging","stopDragging","Provider","flexDirection","PanelGroup","prevPanelData","PanelResizeHandle","disabled","onBlur","onDragging","onFocus","tabIndex","_hitAreaMargins$coars","_hitAreaMargins$fine","elementRef","callbacksRef","panelGroupContext","registerResizeHandleWithParentGroup","resizeHandleId","setState","isFocused","setIsFocused","resizeHandler","setResizeHandler","coarseHitAreaMargins","fineHitAreaMargins","_ownerDocumentCounts$","add","_ownerDocumentCounts$2","delete","useWindowSplitterResizeHandlerBehavior","nextIndex","nextHandle","focus","role","touchAction","userSelect"],"sourceRoot":""}