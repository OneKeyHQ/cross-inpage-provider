{"version":3,"file":"static/chunks/3478.10b15e7aac455731.js","mappings":"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","sources":["webpack://_N_E/./node_modules/@noble/hashes/esm/_u64.js","webpack://_N_E/./node_modules/@scure/base/lib/esm/index.js","webpack://_N_E/<anon>"],"sourcesContent":["/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { fromBig, split, toBig, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotr32H, rotr32L, rotlSH, rotlSL, rotlBH, rotlBL, add, add3L, add3H, add4L, add4H, add5H, add5L, };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\nfunction isArrayOf(isString, arr) {\n    if (!Array.isArray(arr))\n        return false;\n    if (arr.length === 0)\n        return true;\n    if (isString) {\n        return arr.every((item) => typeof item === 'string');\n    }\n    else {\n        return arr.every((item) => Number.isSafeInteger(item));\n    }\n}\n// no abytes: seems to have 10% slowdown. Why?!\nfunction afn(input) {\n    if (typeof input !== 'function')\n        throw new Error('function expected');\n    return true;\n}\nfunction astr(label, input) {\n    if (typeof input !== 'string')\n        throw new Error(`${label}: string expected`);\n    return true;\n}\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`invalid integer: ${n}`);\n}\nexport const assertNumber = anumber;\nfunction aArr(input) {\n    if (!Array.isArray(input))\n        throw new Error('array expected');\n}\nfunction astrArr(label, input) {\n    if (!isArrayOf(true, input))\n        throw new Error(`${label}: array of strings expected`);\n}\nfunction anumArr(label, input) {\n    if (!isArrayOf(false, input))\n        throw new Error(`${label}: array of numbers expected`);\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain(...args) {\n    const id = (a) => a;\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b) => (c) => a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.map((x) => x.decode).reduce(wrap, id);\n    return { encode, decode };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back.\n * Could also be array of strings.\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(letters) {\n    // mapping 1 to \"b\"\n    const lettersA = typeof letters === 'string' ? letters.split('') : letters;\n    const len = lettersA.length;\n    astrArr('alphabet', lettersA);\n    // mapping \"b\" to 1\n    const indexes = new Map(lettersA.map((l, i) => [l, i]));\n    return {\n        encode: (digits) => {\n            aArr(digits);\n            return digits.map((i) => {\n                if (!Number.isSafeInteger(i) || i < 0 || i >= len)\n                    throw new Error(`alphabet.encode: digit index outside alphabet \"${i}\". Allowed: ${letters}`);\n                return lettersA[i];\n            });\n        },\n        decode: (input) => {\n            aArr(input);\n            return input.map((letter) => {\n                astr('alphabet.decode', letter);\n                const i = indexes.get(letter);\n                if (i === undefined)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${letters}`);\n                return i;\n            });\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = '') {\n    astr('join', separator);\n    return {\n        encode: (from) => {\n            astrArr('join.decode', from);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            astr('join.decode', to);\n            return to.split(separator);\n        },\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits, chr = '=') {\n    anumber(bits);\n    astr('padding', chr);\n    return {\n        encode(data) {\n            astrArr('padding.encode', data);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            astrArr('padding.decode', input);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('padding: invalid, string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                const last = end - 1;\n                const byte = last * bits;\n                if (byte % 8 === 0)\n                    throw new Error('padding: invalid, string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize(fn) {\n    afn(fn);\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\n/**\n * Slow: O(n^2) time complexity\n */\nfunction convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2)\n        throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);\n    aArr(data);\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data, (d) => {\n        anumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`invalid integer: ${d}`);\n        return d;\n    });\n    const dlen = digits.length;\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < dlen; i++) {\n            const digit = digits[i];\n            const fromCarry = from * carry;\n            const digitBase = fromCarry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                fromCarry / from !== carry ||\n                digitBase - digit !== fromCarry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            const div = digitBase / to;\n            carry = digitBase % to;\n            const rounded = Math.floor(div);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!rounded)\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));\nconst radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));\nconst powers = /* @__PURE__ */ (() => {\n    let res = [];\n    for (let i = 0; i < 40; i++)\n        res.push(2 ** i);\n    return res;\n})();\n/**\n * Implemented with numbers, because BigInt is 5x slower\n */\nfunction convertRadix2(data, from, to, padding) {\n    aArr(data);\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const max = powers[from];\n    const mask = powers[to] - 1;\n    const res = [];\n    for (const n of data) {\n        anumber(n);\n        if (n >= max)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        const pow = powers[pos];\n        if (pow === undefined)\n            throw new Error('invalid carry');\n        carry &= pow - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry > 0)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n    anumber(num);\n    const _256 = 2 ** 8;\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), _256, num);\n        },\n        decode: (digits) => {\n            anumArr('radix.decode', digits);\n            return Uint8Array.from(convertRadix(digits, num, _256));\n        },\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits, revPadding = false) {\n    anumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            anumArr('radix2.decode', digits);\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\nfunction unsafeWrapper(fn) {\n    afn(fn);\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\nfunction checksum(len, fn) {\n    anumber(len);\n    afn(fn);\n    return {\n        encode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const sum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(sum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const oldChecksum = data.slice(-len);\n            const newChecksum = fn(payload).slice(0, len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\n// prettier-ignore\nexport const utils = {\n    alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\n/**\n * base16 encoding.\n */\nexport const base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nexport const base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nexport const base32nopad = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), join(''));\nexport const base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nexport const base32hexnopad = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), join(''));\nexport const base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\n/**\n * base64 with padding. For no padding, use `base64nopad`.\n * @example\n * const b = base64.decode('A951'); // Uint8Array.from([ 3, 222, 117 ])\n * base64.encode(b); // 'A951'\n */\nexport const base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\n/**\n * base64 without padding.\n */\nexport const base64nopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), join(''));\nexport const base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nexport const base64urlnopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));\n// base58 code\n// -----------\nconst genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc) => chain(radix(58), alphabet(abc), join(''));\n/**\n * Base58: base64 without characters +, /, 0, O, I, l.\n * Quadratic (O(n^2)) - so, can't be used on large inputs.\n */\nexport const base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nexport const base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nexport const base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\n/**\n * XMR version of base58.\n * Done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n * Block encoding significantly reduces quadratic complexity of base58.\n */\nexport const base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nexport const createBase58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);\n/**\n * Use `createBase58check` instead.\n * @deprecated\n */\nexport const base58check = createBase58check;\nconst BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        astr('bech32.encode prefix', prefix);\n        if (isBytes(words))\n            words = Array.from(words);\n        anumArr('bech32.encode', words);\n        const plen = prefix.length;\n        if (plen === 0)\n            throw new TypeError(`Invalid prefix length ${plen}`);\n        const actualLength = plen + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        astr('bech32.decode input', str);\n        const slen = str.length;\n        if (slen < 8 || (limit !== false && slen > limit))\n            throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        const sepIndex = lowered.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = lowered.slice(0, sepIndex);\n        const data = lowered.slice(sepIndex + 1);\n        if (data.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(data).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!data.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    function encodeFromBytes(prefix, bytes) {\n        return encode(prefix, toWords(bytes));\n    }\n    return {\n        encode,\n        decode,\n        encodeFromBytes,\n        decodeToBytes,\n        decodeUnsafe,\n        fromWords,\n        fromWordsUnsafe,\n        toWords,\n    };\n}\n/**\n * Low-level bech32 operations. Operates on words.\n */\nexport const bech32 = genBech32('bech32');\nexport const bech32m = genBech32('bech32m');\n/**\n * UTF-8-to-byte decoder. Uses built-in TextDecoder / TextEncoder.\n * @example\n * const b = utf8.decode(\"hey\"); // => new Uint8Array([ 104, 101, 121 ])\n * const str = utf8.encode(b); // \"hey\"\n */\nexport const utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\n/**\n * hex string decoder.\n * @example\n * const b = hex.decode(\"0102ff\"); // => new Uint8Array([ 1, 2, 255 ])\n * const str = hex.encode(b); // \"0102ff\"\n */\nexport const hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2 !== 0)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n    utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\nconst coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\nexport const bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!isBytes(bytes))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nexport const str = bytesToString; // as in python, but for bytes only\nexport const stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nexport const bytes = stringToBytes;\n//# sourceMappingURL=index.js.map"],"names":["U32_MASK64","BigInt","_32n","fromBig","n","le","h","Number","l","split","lst","Ah","Uint32Array","length","Al","i","rotlSH","s","rotlSL","rotlBH","rotlBL","__webpack_exports__","ZP","toBig","shrSH","_l","shrSL","rotrSH","rotrSL","rotrBH","rotrBL","rotr32H","_h","rotr32L","add","Bh","Bl","add3L","Cl","add3H","low","Ch","add4L","Dl","add4H","Dh","add5H","Eh","add5L","El","isBytes","a","Uint8Array","ArrayBuffer","isView","constructor","name","isArrayOf","isString","arr","Array","isArray","every","item","isSafeInteger","afn","input","astr","label","anumber","aArr","astrArr","anumArr","chain","args","id","wrap","b","c","encode","map","x","reduceRight","decode","reduce","alphabet","letters","lettersA","len","indexes","Map","digits","letter","get","undefined","join","separator","from","to","convertRadix","data","pos","res","d","dlen","carry","done","digit","fromCarry","digitBase","div","rounded","Math","floor","push","reverse","gcd","radix2carry","powers","convertRadix2","padding","max","mask","pow","unsafeWrapper","fn","apply","e","base58","bytes","createBase58check","sha256","sum","slice","set","payload","oldChecksum","newChecksum","BECH_ALPHABET","POLYMOD_GENERATORS","bech32Polymod","pre","chk","bechChecksum","prefix","words","encodingConst","charCodeAt","v","bech32","genBech32","encoding","ENCODING_CONST","_words","radix2","bits","revPadding","fromWords","toWords","fromWordsUnsafe","limit","plen","actualLength","lowered","toLowerCase","str","slen","toUpperCase","sepIndex","lastIndexOf","endsWith","decodeUnsafe","encodeFromBytes","decodeToBytes"],"sourceRoot":""}