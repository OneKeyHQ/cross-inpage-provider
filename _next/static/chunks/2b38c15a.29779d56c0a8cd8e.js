"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[9880],{85582:function(e,t,r){var f=r(48764).Buffer;/*!
 * elliptic.js - elliptic curves for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/elliptic:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/elliptic
 *
 * Formulas from DJB and Tanja Lange [EFD].
 *
 * References:
 *
 *   [GECC] Guide to Elliptic Curve Cryptography
 *     D. Hankerson, A. Menezes, and S. Vanstone
 *     https://tinyurl.com/guide-to-ecc
 *
 *   [GLV] Faster Point Multiplication on Elliptic Curves
 *     R. Gallant, R. Lambert, and S. Vanstone
 *     https://link.springer.com/content/pdf/10.1007/3-540-44647-8_11.pdf
 *
 *   [MONT1] Montgomery curves and the Montgomery ladder
 *     Daniel J. Bernstein, Tanja Lange
 *     https://eprint.iacr.org/2017/293.pdf
 *
 *   [SQUARED] Elligator Squared
 *     Mehdi Tibouchi
 *     https://eprint.iacr.org/2014/043.pdf
 *
 *   [SEC1] SEC 1 - Standards for Efficient Cryptography Group
 *     Certicom Research
 *     https://www.secg.org/sec1-v2.pdf
 *
 *   [SEC2] SEC 2: Recommended Elliptic Curve Domain Parameters
 *     Certicom Research
 *     https://www.secg.org/sec2-v2.pdf
 *
 *   [SIDE1] Elliptic Curves and Side-Channel Attacks
 *     Marc Joye
 *     https://pdfs.semanticscholar.org/8d69/9645033e25d74fcfd4cbf07a770d2e943e14.pdf
 *
 *   [BLIND] Side-Channel Analysis on Blinding Regular Scalar Multiplications
 *     B. Feix, M. Roussellet, A. Venelli
 *     https://eprint.iacr.org/2014/191.pdf
 *
 *   [ALT] Alternative Elliptic Curve Representations
 *     R. Struik
 *     https://tools.ietf.org/id/draft-ietf-lwig-curve-representations-02.html
 *
 *   [ARITH1] Arithmetic of Elliptic Curves
 *     Christophe Doche, Tanja Lange
 *     Handbook of Elliptic and Hyperelliptic Curve Cryptography
 *     Page 267, Section 13 (978-1-58488-518-4)
 *     https://hyperelliptic.org/HEHCC/index.html
 *
 *   [ARITH2] The Arithmetic of Elliptic Curves, 2nd Edition
 *     Joseph H. Silverman
 *     http://www.pdmi.ras.ru/~lowdimma/BSD/Silverman-Arithmetic_of_EC.pdf
 *
 *   [EFD] Explicit-Formulas Database
 *     Daniel J. Bernstein, Tanja Lange
 *     https://hyperelliptic.org/EFD/index.html
 *
 *   [SAFE] SafeCurves: choosing safe curves for elliptic-curve cryptography
 *     Daniel J. Bernstein
 *     https://safecurves.cr.yp.to/
 *
 *   [4GLV] Refinement of the Four-Dimensional GLV Method on Elliptic Curves
 *     Hairong Yi, Yuqing Zhu, and Dongdai Lin
 *     http://www.site.uottawa.ca/~cadams/papers/prepro/paper_19_slides.pdf
 *
 *   [SSWU1] Efficient Indifferentiable Hashing into Ordinary Elliptic Curves
 *     E. Brier, J. Coron, T. Icart, D. Madore, H. Randriam, M. Tibouchi
 *     https://eprint.iacr.org/2009/340.pdf
 *
 *   [SSWU2] Rational points on certain hyperelliptic curves over finite fields
 *     Maciej Ulas
 *     https://arxiv.org/abs/0706.1448
 *
 *   [H2EC] Hashing to Elliptic Curves
 *     A. Faz-Hernandez, S. Scott, N. Sullivan, R. S. Wahby, C. A. Wood
 *     https://git.io/JeWz6
 *     https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve
 *
 *   [SVDW1] Construction of Rational Points on Elliptic Curves
 *     A. Shallue, C. E. van de Woestijne
 *     https://works.bepress.com/andrew_shallue/1/download/
 *
 *   [SVDW2] Indifferentiable Hashing to Barreto-Naehrig Curves
 *     Pierre-Alain Fouque, Mehdi Tibouchi
 *     https://www.di.ens.fr/~fouque/pub/latincrypt12.pdf
 *
 *   [SVDW3] Covert ECDH over secp256k1
 *     Pieter Wuille
 *     https://gist.github.com/sipa/29118d3fcfac69f9930d57433316c039
 *
 *   [MONT2] Montgomery Curve (wikipedia)
 *     https://en.wikipedia.org/wiki/Montgomery_curve
 *
 *   [MONT3] Montgomery Curves and their arithmetic
 *     C. Costello, B. Smith
 *     https://eprint.iacr.org/2017/212.pdf
 *
 *   [ELL2] Elliptic-curve points indistinguishable from uniform random strings
 *     D. Bernstein, M. Hamburg, A. Krasnova, T. Lange
 *     https://elligator.cr.yp.to/elligator-20130828.pdf
 *
 *   [RFC7748] Elliptic Curves for Security
 *     A. Langley, M. Hamburg, S. Turner
 *     https://tools.ietf.org/html/rfc7748
 *
 *   [TWISTED] Twisted Edwards Curves
 *     D. Bernstein, P. Birkner, M. Joye, T. Lange, C. Peters
 *     https://eprint.iacr.org/2008/013.pdf
 *
 *   [ELL1] Injective Encodings to Elliptic Curves
 *     P. Fouque, A. Joux, M. Tibouchi
 *     https://eprint.iacr.org/2013/373.pdf
 *
 *   [ISOGENY] Twisting Edwards curves with isogenies
 *     Mike Hamburg
 *     https://www.shiftleft.org/papers/isogeny/isogeny.pdf
 *
 *   [RFC8032] Edwards-Curve Digital Signature Algorithm (EdDSA)
 *     S. Josefsson, SJD AB, I. Liusvaara
 *     https://tools.ietf.org/html/rfc8032
 *
 *   [SCHNORR] Schnorr Signatures for secp256k1
 *     Pieter Wuille
 *     https://github.com/sipa/bips/blob/d194620/bip-schnorr.mediawiki
 *
 *   [BIP340] Schnorr Signatures for secp256k1
 *     Pieter Wuille, Jonas Nick, Tim Ruffing
 *     https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
 *
 *   [JCEN12] Efficient Software Implementation of Public-Key Cryptography
 *            on Sensor Networks Using the MSP430X Microcontroller
 *     C. P. L. Gouvea, L. B. Oliveira, J. Lopez
 *     http://conradoplg.cryptoland.net/files/2010/12/jcen12.pdf
 *
 *   [FIPS186] Federal Information Processing Standards Publication
 *     National Institute of Standards and Technology
 *     https://tinyurl.com/fips-186-3
 *
 *   [RFC5639] Elliptic Curve Cryptography (ECC) Brainpool
 *             Standard Curves and Curve Generation
 *     M. Lochter, BSI, J. Merkle
 *     https://tools.ietf.org/html/rfc5639
 *
 *   [TWISTEQ] Twisted Edwards & Short Weierstrass Equivalence
 *     Christopher Jeffrey
 *     https://gist.github.com/chjj/16ba7fa08d64e8dda269a9fe5b2a8bbc
 *
 *   [ECPM] Elliptic Curve Point Multiplication (wikipedia)
 *     https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication
 */let{custom:i}=r(51154),s=r(8756),n={AFFINE:0,JACOBIAN:1,PROJECTIVE:2,EXTENDED:3},d=[-3,-1,-5,-7,0,7,5,1,3],o=0;let Curve=class Curve{constructor(e,t,r){this.Point=null,this.id=null,this.uid=o++,this.ossl=null,this.type="base",this.endian="be",this.hash=null,this.prefix=null,this.context=!1,this.prime=null,this.p=null,this.red=null,this.fieldSize=0,this.fieldBits=0,this.adjustedSize=0,this.signBit=0,this.mask=0,this.n=null,this.h=null,this.q=null,this.z=null,this.g=null,this.nh=null,this.scalarSize=0,this.scalarBits=0,this.zero=null,this.one=null,this.two=null,this.three=null,this.four=null,this.i2=null,this.i3=null,this.i4=null,this.i6=null,this.torsion=null,this.endo=null,this.hi=null,this._init(e,t,r)}_init(e,t,r){assert("function"==typeof e),assert("string"==typeof t),assert(r&&"object"==typeof r),assert(null==r.red||r.red instanceof s.Red),assert(null!=r.p,"Must pass a prime."),assert(null==r.id||"string"==typeof r.id),assert(null==r.ossl||"string"==typeof r.ossl),assert(null==r.endian||"string"==typeof r.endian),assert(null==r.hash||"string"==typeof r.hash),assert(null==r.prefix||"string"==typeof r.prefix),assert(null==r.context||"boolean"==typeof r.context),assert(null==r.prime||"string"==typeof r.prime),assert(null==r.torsion||Array.isArray(r.torsion)),this.Point=e,this.id=r.id||null,this.ossl=r.ossl||null,this.type=t,this.endian=r.endian||("short"===t?"be":"le"),this.hash=r.hash||null,this.prefix=r.prefix?f.from(r.prefix,"binary"):null,this.context=r.context||!1,this.prime=r.prime||null,this.p=s.fromJSON(r.p),r.red?this.red=r.red:(this.red=r.prime?s.red(r.prime):s.mont(this.p),this.red.precompute()),this.fieldSize=this.p.byteLength(),this.fieldBits=this.p.bitLength(),this.adjustedSize=this.fieldSize+((7&this.fieldBits)==0),this.signBit=8*this.adjustedSize-1,this.mask=255,(7&this.fieldBits)!=0&&(this.mask=(1<<(7&this.fieldBits))-1),this.n=s.fromJSON(r.n||"0"),this.h=s.fromJSON(r.h||"1"),this.q=this.n.mul(this.h),this.z=s.fromJSON(r.z||"0").toRed(this.red),this.g=null,this.nh=this.n.ushrn(1),this.scalarSize=this.n.byteLength(),this.scalarBits=this.n.bitLength(),this.zero=new s(0).toRed(this.red),this.one=new s(1).toRed(this.red),this.two=new s(2).toRed(this.red),this.three=new s(3).toRed(this.red),this.four=new s(4).toRed(this.red),this.i2=this.two.redInvert(),this.i3=this.three.redInvert(),this.i4=this.i2.redSqr(),this.i6=this.i2.redMul(this.i3),this.torsion=Array(this.h.word(0));for(let e=0;e<this.torsion.length;e++)this.torsion[e]=this.point();return this.endo=null,this.hi=null,this._scale=memoize(this._scale,this),this.isIsomorphic=memoize(this.isIsomorphic,this),this.isIsogenous=memoize(this.isIsogenous,this),assert(this.p.sign()>0&&this.p.isOdd()),assert(this.n.sign()>=0),assert(this.h.sign()>0&&0>=this.h.cmpn(255)),assert("be"===this.endian||"le"===this.endian),this}_finalize(e){if(assert(e&&"object"==typeof e),this.g=e.g?this.pointFromJSON(e.g):this.point(),e.torsion){assert(e.torsion.length===this.torsion.length);for(let t=0;t<this.torsion.length;t++)this.torsion[t]=this.pointFromJSON(e.torsion[t])}return this}_findTorsion(){assert(!this.n.isZero());let e=this.h.word(0),t=this.one.redNeg(),r=[this.point()],f=new Set,i=e;for(;r.length<i;){let e;t.redIAdd(this.one);try{e=this.pointFromX(t.clone())}catch(e){continue}try{e=e.mul(this.n)}catch(e){i=2;continue}if(!e.isInfinity())for(let t of(e.normalize(),[e,e.neg()])){let e=t.key();f.has(e)||(r.push(t),f.add(e))}}for(r.sort((e,t)=>e.cmp(t));r.length<e;)r.push(this.point());return r}_fixedMul(e,t){assert(e instanceof Point),assert(t instanceof s),assert(e.pre&&e.pre.windows);let{width:r,points:f}=e._getWindows(0,0),i=1<<r,n=t.bitLength(),d=(n+r-1)/r>>>0,o=this.jpoint();for(let e=0;e<d;e++){let s=t.bits(e*r,r);o=o.add(f[e*i+s])}return t.isNeg()&&(o=o.neg()),o}_fixedNafMul(e,t){assert(e instanceof Point),assert(t instanceof s),assert(e.pre&&e.pre.doubles);let{step:r,points:f}=e._getDoubles(0,0),i=function(e,t,r,f){assert(f>>>0===f);let i=getNAF(e,2,r),s=Math.ceil(i.length/f),n=Array(s),d=0;for(let e=0;e<i.length;e+=f){let t=0;for(let r=e+f-1;r>=e;r--)t=(t<<1)+i[r];n[d++]=t}return assert(d===s),n}(t,0,t.bitLength()+1,r),n=((1<<r+1)-(r%2==0?2:1))/3,d=this.jpoint(),o=this.jpoint();for(let e=n;e>0;e--){for(let t=0;t<i.length;t++){let r=i[t];r===e?o=o.add(f[t]):r===-e&&(o=o.sub(f[t]))}d=d.add(o)}return d}_wnafMul(e,t,r){assert(t instanceof Point),assert(r instanceof s);let{width:f,points:i}=t._safeNAF(e),n=getNAF(r,f,r.bitLength()+1),d=this.jpoint();for(let e=n.length-1;e>=0;e--){let t=n[e];e!==n.length-1&&(d=d.dbl()),t>0?d=d.add(i[t-1>>1]):t<0&&(d=d.sub(i[-t-1>>1]))}return d}_wnafMulAdd(e,t,r){assert(e>>>0===e),assert(Array.isArray(t)),assert(Array.isArray(r)),assert(t.length===r.length);let f=t.length,i=Array(f),n=Array(f),o=0;for(let e=0;e<f;e++){let f=t[e],d=r[e];if(assert(f instanceof Point),assert(d instanceof s),e>0&&f.type!==t[e-1].type)throw Error("Cannot mix points.");i[e]=null,n[e]=null,o=Math.max(o,d.bitLength()+1)}let h=null,l=null,u=0;for(let e=0;e<f;e++){let f=t[e],a=r[e],c=f._getNAF(0);if(c){i[u]=c.points,n[u]=getNAF(a,c.width,o),u+=1;continue}if(!h){h=f,l=a;continue}i[u]=h._getJNAF(f),n[u]=function(e,t,r){let f=function(e,t,r){assert(e instanceof s),assert(t instanceof s),assert(!e.red),assert(!t.red),assert(r>>>0===r);let f=[Array(r),Array(r)],i=Math.max(e.bitLength(),t.bitLength())+1,n=1|e.sign(),d=1|t.sign();assert(i<=r);let o=0,h=0;for(let r=0;r<i;r++){let i=e.bits(r,3),s=t.bits(r,3),l=(3&i)+o&3,u=(3&s)+h&3,a=0,c=0;if(3===l&&(l=-1),3===u&&(u=-1),1&l){let e=(7&i)+o&7;a=(3===e||5===e)&&2===u?-l:l}if(1&u){let e=(7&s)+h&7;c=(3===e||5===e)&&2===l?-u:u}f[0][r]=a*n,f[1][r]=c*d,2*o===1+a&&(o=1-o),2*h===1+c&&(h=1-h)}for(let e=i;e<r;e++)f[0][e]=0,f[1][e]=0;return f}(e,t,r),i=Array(r);for(let e=0;e<r;e++){let t=f[0][e],r=f[1][e];i[e]=d[(t+1)*3+(r+1)]}return i}(l,a,o),h=null,l=null,u+=1}if(h){let t=h._safeNAF(e);i[u]=t.points,n[u]=getNAF(l,t.width,o),u+=1}let a=this.jpoint();for(let e=o-1;e>=0;e--){e!==o-1&&(a=a.dbl());for(let t=0;t<u;t++){let r=n[t][e];r>0?a=a.add(i[t][r-1>>1]):r<0&&(a=a.sub(i[t][-r-1>>1]))}}return a}_endoWnafMulAdd(e,t){throw Error("Not implemented.")}_scale(e,t){switch(assert(e instanceof Curve),assert(e.p.eq(this.p)),e.type){case"short":return this._scaleShort(e,t);case"mont":return this._scaleMont(e,t);case"edwards":return this._scaleEdwards(e,t);default:throw Error("Not implemented.")}}_scaleShort(e,t){throw Error("Not implemented.")}_scaleMont(e,t){throw Error("Not implemented.")}_scaleEdwards(e,t){throw Error("Not implemented.")}isElliptic(){throw Error("Not implemented.")}jinv(){throw Error("Not implemented.")}isComplete(){return!1}precompute(e){return assert(!this.g.isInfinity(),"Must have base point."),assert(!this.n.isZero(),"Must have order."),this.g.precompute(this.n.bitLength(),e),this}scalar(e,t,r){let f=new s(e,t,r);return(assert(!f.red),this.n.isZero())?f:f.imod(this.n)}field(e,t,r){let f=s.cast(e,t,r);return f.red?f.forceRed(this.red):f.toRed(this.red)}point(e,t){throw Error("Not implemented.")}jpoint(e,t,r){throw Error("Not implemented.")}xpoint(e,t){throw Error("Not implemented.")}cpoint(e,t,r,f){if(assert(e instanceof s),assert(t instanceof s),assert(r instanceof s),assert(f instanceof s),t.isZero()||f.isZero())return this.point();let i=t.redMul(f).redInvert(),n=e.redMul(f).redMul(i),d=r.redMul(t).redMul(i);return this.point(n,d)}solveX2(e){throw Error("Not implemented.")}solveX(e){return this.solveX2(e).redSqrt()}solveY2(e){throw Error("Not implemented.")}solveY(e){return this.solveY2(e).redSqrt()}validate(e){throw Error("Not implemented.")}pointFromX(e,t){throw Error("Not implemented.")}pointFromY(e,t){throw Error("Not implemented.")}isIsomorphic(e){throw Error("Not implemented.")}isIsogenous(e){throw Error("Not implemented.")}pointFromShort(e){throw Error("Not implemented.")}pointFromMont(e,t){throw Error("Not implemented.")}pointFromEdwards(e){throw Error("Not implemented.")}pointFromUniform(e){throw Error("Not implemented.")}pointToUniform(e){throw Error("Not implemented.")}pointFromHash(e,t=!1){if(assert(f.isBuffer(e)),assert("boolean"==typeof t),e.length!==2*this.fieldSize)throw Error("Invalid hash size.");let r=e.slice(0,this.fieldSize),i=e.slice(this.fieldSize),s=this.decodeUniform(r),n=this.decodeUniform(i),d=this.pointFromUniform(s),o=this.pointFromUniform(n),h=d.add(o);return t?h.mulH():h}pointToHash(e,t,r){assert(e instanceof this.Point),assert(t>>>0===t);let i=t%this.torsion.length,s=e.add(this.torsion[i]);for(;;){let e;let t=this.randomField(r),i=this.pointFromUniform(t);if(i.neg().eq(i))continue;let n=s.sub(i),d=randomInt(r);try{e=this.pointToUniform(n,15&d)}catch(e){if("Invalid point."===e.message)continue;throw e}let o=this.encodeUniform(t,d>>>8),h=this.encodeUniform(e,d>>>16);return f.concat([o,h])}}randomScalar(e){let t=this.n.isZero()?this.p:this.n;return s.random(e,1,t)}randomField(e){return s.random(e,1,this.p).toRed(this.red)}randomPoint(e){let t;for(;;){let r=this.randomField(e),f=(1&randomInt(e))!=0;try{t=this.pointFromX(r,f)}catch(e){continue}return assert(t.validate()),t.mulH()}}mulAll(e,t){return this.jmulAll(e,t)}jmulAll(e,t){return(assert(Array.isArray(e)),assert(0===e.length||e[0]instanceof Point),this.endo&&e.length>0&&e[0].type===n.AFFINE)?this._endoWnafMulAdd(e,t):this._wnafMulAdd(5,e,t)}mulH(e){return assert(e instanceof s),this.imulH(e.clone())}imulH(e){assert(e instanceof s),assert(!e.red);let t=this.h.word(0);if((t&t-1)==0){let t=this.h.bitLength();return e.iushln(t-1).imod(this.n)}return e.imuln(t).imod(this.n)}normalizeAll(e){assert(Array.isArray(e));let t=e.length,r=Array(t);for(let f=0;f<t;f++){let t=e[f];if(assert(t instanceof Point),assert(t.curve===this),t.type===n.AFFINE){r[f]=this.one;continue}r[f]=t.z}let f=this.red.invertAll(r),i=Array(t);for(let r=0;r<t;r++)i[r]=e[r].scale(f[r]);return i}affinizeAll(e){return this.normalizeAll(e)}clamp(e){assert(f.isBuffer(e)),assert(e.length===this.scalarSize),assert(this.scalarSize<=this.fieldSize);let t=7&this.fieldBits||8,r=0,i=this.scalarSize-1;return"be"===this.endian&&([r,i]=[i,r]),this.scalarSize<this.fieldSize&&(t=8),e[r]&=255&-this.h.word(0),e[i]&=(1<<t)-1,e[i]|=1<<t-1,e}splitHash(e){assert(f.isBuffer(e)),assert(e.length===2*this.adjustedSize),assert(this.scalarSize<=this.adjustedSize);let t=0;"be"===this.endian&&(t=this.adjustedSize-this.scalarSize);let r=e.slice(t,t+this.scalarSize),i=e.slice(this.adjustedSize);return this.clamp(r),[r,i]}encodeField(e){return assert(e instanceof s),assert(!e.red),e.encode(this.endian,this.fieldSize)}decodeField(e){if(assert(f.isBuffer(e)),e.length!==this.fieldSize)throw Error("Invalid field element size.");return s.decode(e,this.endian)}encodeAdjusted(e){return assert(e instanceof s),assert(!e.red),e.encode(this.endian,this.adjustedSize)}decodeAdjusted(e){if(assert(f.isBuffer(e)),e.length!==this.adjustedSize)throw Error("Invalid field element size.");return s.decode(e,this.endian)}encodeScalar(e){return assert(e instanceof s),assert(!e.red),e.encode(this.endian,this.scalarSize)}decodeScalar(e){if(assert(f.isBuffer(e)),e.length!==this.scalarSize)throw Error("Invalid scalar size.");return s.decode(e,this.endian)}encodeClamped(e){return this.clamp(this.encodeScalar(e))}decodeClamped(e){if(assert(f.isBuffer(e)),e.length!==this.scalarSize)throw Error("Invalid scalar size.");let t=this.clamp(f.from(e));return s.decode(t,this.endian)}encodeUniform(e,t){assert(e instanceof s),assert(t>>>0===t);let r="le"===this.endian?this.fieldSize-1:0,f=e.fromRed().encode(this.endian,this.fieldSize);return f[r]|=t&~this.mask&255,f}decodeUniform(e){if(assert(f.isBuffer(e)),e.length!==this.fieldSize)throw Error("Invalid field size.");let t=s.decode(e,this.endian);return t.iumaskn(this.fieldBits),t.toRed(this.red)}encodePoint(e,t){return assert(e instanceof Point),e.encode(t)}decodePoint(e){throw Error("Not implemented.")}encodeX(e){throw Error("Not implemented.")}decodeX(e){throw Error("Not implemented.")}decodeEven(e){throw Error("Not implemented.")}decodeSquare(e){throw Error("Not implemented.")}toShort(){throw Error("Not implemented.")}toMont(e){throw Error("Not implemented.")}toEdwards(e){throw Error("Not implemented.")}pointToJSON(e,t){return assert(e instanceof Point),e.toJSON(t)}pointFromJSON(e){throw Error("Not implemented.")}toJSON(e){let t,r,f,i,s;return"edwards"===this.type&&(t=this.prefix?this.prefix.toString():null,r=this.context),this.n.isZero()||(f=this.n.toJSON()),this.z.isZero()||(i=this.z.fromRed(),this.z.redIsHigh()&&i.isub(this.p),i=i.toString(16)),this.endo&&(s=this.endo.toJSON()),{id:this.id,ossl:this.ossl,type:this.type,endian:this.endian,hash:this.hash,prefix:t,context:r,prime:this.prime,p:this.p.toJSON(),a:void 0,b:void 0,d:void 0,n:f,h:this.h.toString(16),s:void 0,z:i,c:void 0,g:this.g.toJSON(e),endo:s}}static fromJSON(e){return new this(e)}};let Point=class Point{constructor(e,t){assert(e instanceof Curve),assert(t>>>0===t),this.curve=e,this.type=t,this.pre=null}_init(){throw Error("Not implemented.")}_safeNAF(e){if(assert(e>>>0===e),this.pre&&this.pre.naf)return this.pre.naf;if(0===e)return null;let t=1<<e-2,r=Array(t),f=this.toJ(),i=1===t?null:f.dbl();r[0]=f;for(let e=1;e<t;e++)r[e]=r[e-1].add(i);return new NAF(e,r)}_getNAF(e){if(assert(e>>>0===e),this.pre&&this.pre.naf)return this.pre.naf;if(0===e)return null;let t=this._safeNAF(e).points,r=this.curve.affinizeAll(t);return new NAF(e,r)}_getWindows(e,t){if(assert(e>>>0===e),assert(t>>>0===t),this.pre&&this.pre.windows)return this.pre.windows;if(0===e)return null;let r=1<<e,f=(t+e-1)/e>>>0,i=Array(f*r),s=this.toJ();for(let t=0;t<f;t++){i[t*r]=this.curve.jpoint();for(let e=1;e<r;e++)i[t*r+e]=i[t*r+e-1].add(s);s=s.dblp(e)}let n=this.curve.affinizeAll(i);return new Windows(e,t,n)}_getDoubles(e,t){if(assert(e>>>0===e),assert(t>>>0===t),this.pre&&this.pre.doubles)return this.pre.doubles;if(0===e)return null;let r=Math.ceil(t/e)+1,f=Array(r),i=this.toJ(),s=0;f[s++]=i;for(let r=0;r<t;r+=e){for(let t=0;t<e;t++)i=i.dbl();f[s++]=i}assert(s===r);let n=this.curve.affinizeAll(f);return new Doubles(e,n)}_getBeta(){return null}_getBlinding(e){if(this.pre&&this.pre.blinding)return this.pre.blinding;if(!e||this.curve.n.isZero())return null;let t=this.curve.randomScalar(e),r=this.mul(t);return new Blinding(t,r)}_hasWindows(e){if(assert(e instanceof s),!this.pre||!this.pre.windows)return!1;let{width:t,bits:r}=this.pre.windows;return e.bitLength()<=((r+t-1)/t>>>0)*t}_hasDoubles(e){if(assert(e instanceof s),!this.pre||!this.pre.doubles)return!1;let{step:t,points:r}=this.pre.doubles,f=e.bitLength()+1;return r.length>=Math.ceil(f/t)+1}_getJNAF(e){return assert(e instanceof Point),assert(e.type===this.type),[this,this.add(e),this.sub(e),e]}_blind(e,t){if(assert(e instanceof s),assert(!e.red),this.pre&&this.pre.blinding){let{blind:t,unblind:r}=this.pre.blinding,f=e.sub(t);return[this,f,r]}if(!t)return[this,e,null];if(this.pre){if(this.curve.n.isZero())return[this,e,null];let r=this.curve.randomScalar(t),f=r.mul(this.curve.n),i=f.iadd(e);return[this,i,null]}let r=this.randomize(t);return[r,e,null]}clone(){throw Error("Not implemented.")}precompute(e,t){return assert(e>>>0===e),this.pre||(this.pre=new Precomp),this.pre.naf||(this.pre.naf=this._getNAF(9)),this.pre.doubles||(this.pre.doubles=this._getDoubles(4,e+1)),this.pre.beta||(this.pre.beta=this._getBeta()),this.pre.blinding||(this.pre.blinding=this._getBlinding(t)),this}validate(){return this.curve.validate(this)}normalize(){return this}scale(e){throw Error("Not implemented.")}randomize(e){let t=this.curve.randomField(e);return this.scale(t)}neg(){throw Error("Not implemented.")}add(e){throw Error("Not implemented.")}sub(e){return assert(e instanceof Point),this.add(e.neg())}dbl(){throw Error("Not implemented.")}dblp(e){assert(e>>>0===e);let t=this;for(let r=0;r<e;r++)t=t.dbl();return t}diffAddDbl(e,t){throw Error("Not implemented.")}getX(){throw Error("Not implemented.")}getY(){throw Error("Not implemented.")}eq(e){throw Error("Not implemented.")}cmp(e){throw Error("Not implemented.")}isInfinity(){throw Error("Not implemented.")}isOrder2(){throw Error("Not implemented.")}isOdd(){throw Error("Not implemented.")}isEven(){throw Error("Not implemented.")}isSquare(){throw Error("Not implemented.")}eqX(e){throw Error("Not implemented.")}eqR(e){throw Error("Not implemented.")}isSmall(){return!this.isInfinity()&&this.jmulH().isInfinity()}hasTorsion(){return!this.isInfinity()&&!this.jmul(this.curve.n).isInfinity()}order(){let{h:e,n:t}=this.curve,r=this.toJ(),f=new s(1);for(;!r.isInfinity();){if(f.iaddn(1),f.cmp(e)>0){f=t.clone();break}r=r.add(this)}return f}mul(e){return this.jmul(e)}muln(e){return this.jmuln(e)}mulBlind(e,t){return this.jmulBlind(e,t)}mulAdd(e,t,r){return this.jmulAdd(e,t,r)}mulH(){return this.jmulH()}div(e){return this.jdiv(e)}divn(e){return this.jdivn(e)}divH(){return this.jdivH()}jmul(e){return this._hasDoubles(e)?this.curve._fixedNafMul(this,e):this.curve.endo&&this.type===n.AFFINE?this.curve._endoWnafMulAdd([this],[e]):this.curve._wnafMul(5,this,e)}jmuln(e){return assert((0|e)===e),this.jmul(new s(e))}jmulBlind(e,t=null){let[r,f,i]=this._blind(e,t),s=r.jmul(f);return i?s.add(i):s}jmulAdd(e,t,r){return this.curve.endo&&this.type===n.AFFINE?this.curve._endoWnafMulAdd([this,t],[e,r]):this.curve._wnafMulAdd(5,[this,t],[e,r])}jmulH(){let e=this.curve.h.word(0);if((e&e-1)==0){let e=this.curve.h.bitLength();return this.toJ().dblp(e-1)}return this.jmul(this.curve.h)}jdiv(e){return assert(e instanceof s),assert(!e.red),this.jmul(e.invert(this.curve.n))}jdivn(e){return(assert(!this.curve.n.isZero()),0===this.curve.h.cmpn(e))?this.jdivH():this.jdiv(new s(e))}jdivH(){return this.curve.n.isZero()||0===this.curve.h.cmpn(1)?this.toJ():(null===this.curve.hi&&(this.curve.hi=this.curve.h.invert(this.curve.n)),this.jmul(this.curve.hi))}toP(){return this.normalize()}toJ(){return this}toX(){return this}key(){if(this.isInfinity())return`${this.curve.uid}:oo`;this.normalize();let e=this.getX().toString(16),t=this.getY().toString(16);return`${this.curve.uid}:${e},${t}`}encode(e){throw Error("Not implemented.")}static decode(e,t){throw Error("Not implemented.")}encodeX(){throw Error("Not implemented.")}static decodeX(e,t){throw Error("Not implemented.")}static decodeEven(e,t){throw Error("Not implemented.")}static decodeSquare(e,t){throw Error("Not implemented.")}toJSON(e){throw Error("Not implemented.")}static fromJSON(e,t){throw Error("Not implemented.")}[i](){return"<Point>"}};let ShortCurve=class ShortCurve extends Curve{constructor(e){super(ShortPoint,"short",e),this.a=s.fromJSON(e.a).toRed(this.red),this.b=s.fromJSON(e.b).toRed(this.red),this.c=s.fromJSON(e.c||"0").toRed(this.red),this.ai=this.a.isZero()?this.zero:this.a.redInvert(),this.zi=this.z.isZero()?this.zero:this.z.redInvert(),this.zeroA=this.a.isZero(),this.threeA=this.a.eq(this.three.redNeg()),this.redN=this.n.toRed(this.red),this.pmodn=this.p.clone(),this.highOrder=this.n.cmp(this.p)>=0,this.smallGap=!1,this._finalize(e)}_finalize(e){return super._finalize(e),null!=e.endo?this.endo=Endo.fromJSON(this,e.endo):this.endo=this._getEndomorphism(),this.n.isZero()||(this.pmodn=this.p.mod(this.n),this.smallGap=0>=this.p.div(this.n).cmpn(1)),this}static _isomorphism(e,t,r,f){if(assert(e instanceof s),assert(t instanceof s),assert(r instanceof s),assert(null==f||"boolean"==typeof f),assert(!e.isZero()||!t.isZero()),r.isZero())throw Error("Invalid coefficient.");if(e.isZero()){let f=r.redDiv(t),i=uncube(f);return assert(1===i.redJacobi()),[e.clone(),r.clone()]}if(t.isZero()){let f=r.redDiv(e),i=f.redSqrt();if(1!==i.redJacobi()&&i.redINeg(),1!==i.redJacobi())throw Error("Invalid `a` coefficient.");return[r.clone(),t.clone()]}let i=r.redDiv(e),n=i.redSqrt();if(null!=f?n.redIsOdd()!==f&&n.redINeg():1!==n.redJacobi()&&n.redINeg(),1!==n.redJacobi())throw Error("Invalid `a` coefficient.");let d=i.redMul(n),o=e.redMul(i),h=t.redMul(d);return assert(o.eq(r)),[o,h]}_short(e,t){return ShortCurve._isomorphism(this.a,this.b,e,t)}_mont(e,t){let[r,f]=this._findRS(t),i=f.redInvert(),s=r.redMuln(3).redMul(i);return null!=e?MontCurve._isomorphism(s,i,e):[s,i]}_edwards(e,t){let[r,f]=this._findRS(t),i=r.redMuln(3),s=f.redMuln(2),n=i.redAdd(s),d=i.redSub(s);return null!=e?EdwardsCurve._isomorphism(n,d,e):[n,d]}_findRS(e){let t;assert(null==e||"boolean"==typeof e),assert(this.h.word(0)>=4),assert(!this.n.isZero());let r=this.one.redNeg();for(;;){r.redIAdd(this.one);try{t=this.pointFromX(r.clone())}catch(e){continue}if(!(t=t.mul(this.n)).isInfinity()&&t.y.isZero())break}let f=t.x,i=f.redSqr(),s=i.redMuln(3).redIAdd(this.a).redSqrt();return null!=e&&s.redIsOdd()!==e&&s.redINeg(),[f,s]}_scale0(e,t){if(assert(this.a.isZero()===e.isZero()),assert(this.b.isZero()===t.isZero()),this.a.isZero()){let e=this.b.redDiv(this.field(t)),r=uncube(e),f=r.redSqrt(),i=r.redMul(f);return assert(i.redSqr().eq(e)),assert(!f.isZero()),[r,i]}if(this.b.isZero()){let t=this.a.redDiv(this.field(e)),r=t.redSqrt();1!==r.redJacobi()&&r.redINeg();let f=r.redSqrt(),i=r.redMul(f);return assert(i.redMul(f).eq(t)),assert(!f.isZero()),[r,i]}let r=this.a.redDiv(this.field(e)),f=this.b.redDiv(this.field(t)),i=r.redSqrt();r.redMul(i).eq(f)||i.redINeg(),assert(r.redMul(i).eq(f));let s=i.redSqrt(),n=i.redMul(s);return assert(!s.isZero()),[i,n]}_scale1(e,t){let r=this.g.x.redDiv(this.field(e)),f=this.g.y.redDiv(this.field(t)),i=r.redSqrt();return r.redMul(i).eq(f)||i.redINeg(),assert(r.redMul(i).eq(f)),assert(!i.isZero()),[r,f]}_scaleShort(e){return(assert(e instanceof ShortCurve),this.g.isInfinity()||e.g.isInfinity())?this._scale0(e.a,e.b):this._scale1(e.g.x,e.g.y)}_scaleMont(e){if(assert(e instanceof MontCurve),this.g.isInfinity()||e.g.isInfinity()){let[t,r]=e._short();return this._scale0(t,r)}let{x:t,y:r}=e.g,f=t.redAdd(e.a3).redMul(e.bi),i=r.redMul(e.bi);return this._scale1(f,i)}_scaleEdwards(e){if(assert(e instanceof EdwardsCurve),this.g.isInfinity()||e.g.isInfinity()){let[t,r]=e._short();return this._scale0(t,r)}let{x:t,y:r,z:f}=e.g,i=e.a.redMuln(5),s=e.d.redMuln(5),n=e.d.redSub(e.a),d=s.redSub(e.a),o=e.d.redSub(i),h=r.redAdd(f),l=r.redSub(f),u=d.redMul(r).redIAdd(o.redMul(f)),a=l.redMuln(12),c=n.redMul(h).redMul(f),b=l.redMul(t).redIMuln(4),p=a.redMul(b).redInvert(),m=u.redMul(b).redMul(p),S=c.redMul(a).redMul(p);return this._scale1(m,S)}_getEndomorphism(e=0){let t;if(this.n.isZero()||this.g.isInfinity()||!this.zeroA||1!==this.p.modrn(3)||1!==this.n.modrn(3))return null;let[r,f]=this._getEndoRoots(this.p),i=[r,f][1&e].toRed(this.red),[s,n]=this._getEndoRoots(this.n),d=this.point(this.g.x.redMul(i),this.g.y);this.g.mul(s).eq(d)?t=s:(assert(this.g.mul(n).eq(d)),t=n);let o=this._getEndoBasis(t),h=this._getEndoPrecomp(o);return new Endo(i,t,o,h)}_getEndoRoots(e){let t=e===this.p?this.red:s.mont(e),r=new s(2).toRed(t),f=new s(3).toRed(t),i=r.redInvert(),n=f.redNeg().redSqrt().redMul(i),d=n.redNeg(),o=n.redSub(i).fromRed(),h=d.redSub(i).fromRed();return[o,h].sort(s.cmp)}_getEndoBasis(e){let t,r;let[f,i,s,n,d,o]=this._egcdSqrt(e),h=n.neg(),l=f.sqr().iadd(i.sqr()),u=d.sqr().iadd(o.sqr());return 0>=l.cmp(u)?(t=f,r=i.neg()):(t=d,r=o.neg()),[new Vector(s,h),new Vector(t,r)]}_egcdSqrt(e){let t,r,f,i,n;assert(e instanceof s),assert(!e.red),assert(e.sign()>0),assert(this.n.sign()>0);let d=this.n.ushrn(this.n.bitLength()>>>1),o=e,h=this.n.clone(),l=new s(1),u=new s(0),a=new s(0),c=new s(1),b=0,p=0;for(;!o.isZero()&&b<2;){let e=h.quo(o),s=h.sub(e.mul(o)),m=a.sub(e.mul(l)),S=c.sub(e.mul(u));0===p&&0>s.cmp(d)&&(t=n,r=l,f=s,i=m,p=1),n=s,h=o,o=s,a=l,l=m,c=u,u=S,b+=p}assert(0!==p,"Could not find r < sqrt(n).");let m=a,S=l;return[t,r,f,i,m,S]}_getEndoPrecomp(e){let t,r;assert(Array.isArray(e)),assert(2===e.length),assert(e[0]instanceof Vector),assert(e[1]instanceof Vector);let[f,i]=e,s=f.a.mul(i.b).isub(f.b.mul(i.a)),n=s.bitLength(),d=n>=160;assert(s.eq(this.n));let o=n+Math.ceil(n/2)+1;for(d&&(o-=63&o);o>n&&(t=i.b.ushln(o).divRound(s),r=f.b.ushln(o).divRound(s),!(0>t.ucmp(s)&&0>r.ucmp(s)));)d?o-=64:o-=1;if(o<=n)throw Error("Could not calculate g1 and g2.");return[o,t,r]}_endoSplit(e){assert(e instanceof s),assert(!e.red),assert(!this.n.isZero());let[t,r]=this.endo.basis,f=r.b.mul(e).divRound(this.n),i=t.b.neg().mul(e).divRound(this.n),n=f.mul(t.a),d=i.mul(r.a),o=f.ineg().mul(t.b),h=i.mul(r.b),l=e.sub(n).isub(d),u=o.isub(h);return[l,u]}_endoBeta(e){return assert(e instanceof ShortPoint),[e,e._getBeta()]}_endoWnafMulAdd(e,t){assert(Array.isArray(e)),assert(Array.isArray(t)),assert(e.length===t.length),assert(null!=this.endo);let r=e.length,f=Array(2*r),i=Array(2*r);for(let s=0;s<r;s++){let[r,n]=this._endoBeta(e[s]),[d,o]=this._endoSplit(t[s]);f[2*s+0]=r,i[2*s+0]=d,f[2*s+1]=n,i[2*s+1]=o}return this._wnafMulAdd(5,f,i)}_sswu(e){let{b:t,z:r,ai:f,zi:i,one:s}=this,n=r.redSqr(),d=t.redNeg().redMul(f),o=t.redMul(i).redMul(f),h=e.redSqr(),l=h.redSqr(),u=n.redMul(l).redIAdd(r.redMul(h)),a=u.isZero()?u:u.redInvert(),c=a.isZero()?o:d.redMul(s.redAdd(a)),b=r.redMul(h).redMul(c),p=this.solveY2(c),m=this.solveY2(b),S=0|p.redIsSquare(),v=[c,b][1^S],M=[p,m][1^S].redSqrt();return M.redIsOdd()!==e.redIsOdd()&&M.redINeg(),this.point(v,M)}_sswui(e,t){let{a:r,b:f,z:i}=this,{x:s,y:n}=e,d=3&t,o=r.redSqr().redMul(s.redSqr()),h=r.redMul(f).redMul(s).redIMuln(2),l=f.redSqr().redMuln(3),u=r.redMul(s).redIAdd(f),a=o.redISub(h).redISub(l).redSqrt(),c=u.redSub(a).redINeg(),b=u.redAdd(a).redINeg(),p=u.redMul(i).redIMuln(2),m=f.redMul(i).redIMuln(2),S=[c,b][1&d],v=[p,m][d>>>1],M=S.redDivSqrt(v);return M.redIsOdd()!==n.redIsOdd()&&M.redINeg(),M}_svdwf(e){let t;let{c:r,z:f,zi:i,i2:s,i3:n}=this,d=this.solveY2(f),o=n.redMul(i.redSqr()),h=e.redSqr(),l=h.redSqr(),u=h.redAdd(d),a=h.redMul(u),c=a.isZero()?a:a.redInvert(),b=l.redMul(c).redMul(r),p=u.redSqr().redMul(u),m=r.redSub(f).redMul(s).redISub(b),S=b.redSub(r.redAdd(f).redMul(s)),v=f.redSub(p.redMul(c).redMul(o)),M=this.solveY2(m),I=this.solveY2(S),g=this.solveY2(v),y=1|M.redJacobi(),w=1|I.redJacobi(),N=((t=(y-1)*w%3)<0&&(t+=3),t),z=[m,S,v][N],A=[M,I,g][N];return[z,A]}_svdw(e){let[t,r]=this._svdwf(e),f=r.redSqrt();return f.redIsOdd()!==e.redIsOdd()&&f.redINeg(),this.point(t,f)}_svdwi(e,t){let{b:r,c:f,z:i,zero:s,two:n}=this,{x:d,y:o}=e,h=3&t,l=i.redSqr(),u=l.redMul(i),a=l.redSqr(),c=u.redAdd(r),b=c.redMuln(2),p=d.redSqr(),m=d.redMuln(2).redIAdd(i),S=d.redMul(l),v=f.redSub(m),M=f.redAdd(m),I=p.redMul(l).redIAdd(a).redIMuln(9),g=d.redMul(u).redIMuln(18),y=c.redMul(d.redSub(i)).redIMuln(12),w=h>=2?I.redISub(g).redIAdd(y).redSqrt():s,N=w.redMul(i),z=u.redISub(S).redIMuln(3).redISub(b),A=c.redMul(v),q=c.redMul(M),E=z.redAdd(N),_=z.redSub(N),x=[A,q,E,_][h],O=[M,v,n,n][h],P=x.redDivSqrt(O),[J]=this._svdwf(P);if(!J.eq(d))throw Error("Invalid point.");return P.redIsOdd()!==o.redIsOdd()&&P.redINeg(),P}isElliptic(){let{a:e,b:t}=this,r=e.redSqr(),f=r.redMul(e),i=t.redSqr(),s=i.redMuln(27).redIAdd(f.redMuln(4));return!s.isZero()}jinv(){let{a:e,b:t}=this,r=e.redSqr(),f=r.redMul(e),i=t.redSqr(),s=f.redMuln(4),n=s.redMuln(1728),d=i.redMuln(27).redIAdd(s);if(d.isZero())throw Error("Curve is not elliptic.");return n.redDiv(d).fromRed()}point(e,t){return new ShortPoint(this,e,t)}jpoint(e,t,r){return new JPoint(this,e,t,r)}solveX(e){if(assert(e instanceof s),!this.a.isZero())throw Error("Not implemented.");let t=e.redSqr(),r=t.redSub(this.b);return cubeRoots(r)}solveY2(e){assert(e instanceof s);let t=e.redSqr().redMul(e),r=t.redIAdd(this.b);return this.zeroA||(this.threeA?r.redIAdd(e.redMuln(-3)):r.redIAdd(this.a.redMul(e))),r}validate(e){if(assert(e instanceof ShortPoint),e.inf)return!0;let{x:t,y:r}=e,f=this.solveY2(t);return r.redSqr().eq(f)}pointFromX(e,t=null){assert(e instanceof s),assert(null==t||"boolean"==typeof t),e.red||(e=e.toRed(this.red));let r=this.solveY(e);if(null!=t){if(this.h.cmpn(1)>0&&r.isZero()&&t)throw Error("Invalid point.");r.redIsOdd()!==t&&r.redINeg()}return this.point(e,r)}pointFromY(e,t=0){assert(e instanceof s),assert(t>>>0===t),e.red||(e=e.toRed(this.red));let r=this.solveX(e);if(t>=r.length)throw Error("Invalid X coordinate index.");let f=r[t];return this.point(f,e)}isIsomorphic(e){let t,r;if(assert(e instanceof Curve),!e.p.eq(this.p))return!1;try{[t,r]=this._scale(e)}catch(e){return!1}if("short"===e.type){let f=this.field(e.a).redMul(t.redSqr()),i=this.field(e.b).redMul(r.redSqr());return this.a.eq(f)&&this.b.eq(i)}if("mont"===e.type){let{a3:r,bi:f}=e,i=this.field(r.redMul(f)).redMul(t),s=this.solveY2(i);return s.isZero()}if("edwards"===e.type){let r=this.field(e.ad6).redMul(t),f=this.solveY2(r);return f.isZero()}return!1}isIsogenous(e){return assert(e instanceof Curve),!1}pointFromShort(e){if(assert(e instanceof ShortPoint),this.isIsomorphic(e.curve)){if(e.isInfinity())return this.point();let[t,r]=this._scale(e.curve),f=this.field(e.x),i=this.field(e.y),s=f.redMul(t),n=i.redMul(r);return this.point(s,n)}throw Error("Not implemented.")}pointFromMont(e){if(assert(e instanceof MontPoint),this.isIsomorphic(e.curve)){if(e.isInfinity())return this.point();let{a3:t,bi:r}=e.curve,[f,i]=this._scale(e.curve),s=e.x.redAdd(t).redMul(r),n=e.y.redMul(r);return this.point(this.field(s).redMul(f),this.field(n).redMul(i))}throw Error("Not implemented.")}pointFromEdwards(e){if(assert(e instanceof EdwardsPoint),this.isIsomorphic(e.curve)){let{a:t,d:r,ad6:f}=e.curve,[i,s]=this._scale(e.curve);if(e.isInfinity())return this.point();if(e.x.isZero()){let e=this.field(f).redMul(i);return this.point(e,this.zero)}let{x:n,y:d,z:o}=e,h=t.redMuln(5),l=r.redMuln(5),u=r.redSub(t),a=l.redSub(t),c=r.redSub(h),b=d.redAdd(o),p=d.redSub(o),m=a.redMul(d).redIAdd(c.redMul(o)),S=p.redMuln(12),v=u.redMul(b).redMul(o),M=p.redMul(n).redIMuln(4);return this.cpoint(this.field(m).redMul(i),this.field(S),this.field(v).redMul(s),this.field(M))}throw Error("Not implemented.")}pointFromUniform(e){if(assert(e instanceof s),this.z.isZero()||this.b.isZero())throw Error("Not implemented.");if(!this.a.isZero())return this._sswu(e);if(!this.c.isZero())return this._svdw(e);throw Error("Not implemented.")}pointToUniform(e,t){if(assert(e instanceof ShortPoint),assert(t>>>0===t),this.z.isZero()||this.b.isZero())throw Error("Not implemented.");if(e.isInfinity())throw Error("Invalid point.");let r=(t>>>4&15)%this.torsion.length,f=e.add(this.torsion[r]);return wrapErrors(()=>{if(!this.a.isZero())return this._sswui(f,t);if(!this.c.isZero())return this._svdwi(f,t);throw Error("Not implemented.")})}mulAll(e,t){return super.mulAll(e,t).toP()}affinizeAll(e){let t=this.normalizeAll(e);for(let e=0;e<t.length;e++)t[e]=t[e].toP();return t}decodePoint(e){return ShortPoint.decode(this,e)}encodeX(e){return assert(e instanceof Point),e.encodeX()}decodeEven(e){return ShortPoint.decodeEven(this,e)}decodeSquare(e){return ShortPoint.decodeSquare(this,e)}toShort(e,t,r=null){let[f,i]=this._short(e,t),s=new ShortCurve({red:this.red,prime:this.prime,p:this.p,a:f,b:i,n:this.n,h:this.h});if(null!=r){let[,e]=s._scale(this);e.redIsOdd()!==r&&e.redINeg()}this.g.isInfinity()||(s.g=s.pointFromShort(this.g));for(let e=0;e<this.h.word(0);e++)s.torsion[e]=s.pointFromShort(this.torsion[e]);return s}toMont(e,t,r=null){let[f,i]=this._mont(e,t),s=new MontCurve({red:this.red,prime:this.prime,p:this.p,a:f,b:i,n:this.n,h:this.h});if(null!=r){let[,e]=this._scale(s);e.redIsOdd()!==r&&e.redINeg()}this.g.isInfinity()||(s.g=s.pointFromShort(this.g));for(let e=0;e<this.h.word(0);e++)s.torsion[e]=s.pointFromShort(this.torsion[e]);return s}toEdwards(e,t,r=null){let[f,i]=this._edwards(e,t),s=new EdwardsCurve({red:this.red,prime:this.prime,p:this.p,a:f,d:i,n:this.n,h:this.h});if(null!=r){let[,e]=this._scale(s);e.redIsOdd()!==r&&e.redINeg()}if(this.g.isInfinity()||(s.g=s.pointFromShort(this.g),s.g.normalize()),s.isComplete())for(let e=0;e<this.h.word(0);e++)s.torsion[e]=s.pointFromShort(this.torsion[e]),s.torsion[e].normalize();return s}pointFromJSON(e){return ShortPoint.fromJSON(this,e)}toJSON(e){let t=super.toJSON(e);return t.a=this.a.fromRed().toJSON(),t.b=this.b.fromRed().toJSON(),this.c.isZero()||(t.c=this.c.fromRed().toJSON()),t}};let ShortPoint=class ShortPoint extends Point{constructor(e,t,r){assert(e instanceof ShortCurve),super(e,n.AFFINE),this.x=this.curve.zero,this.y=this.curve.zero,this.inf=!0,null!=t&&this._init(t,r)}_init(e,t){assert(e instanceof s),assert(t instanceof s),this.x=e,this.y=t,this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.inf=!1}_getBeta(){if(!this.curve.endo)return null;if(this.pre&&this.pre.beta)return this.pre.beta;let e=this.x.redMul(this.curve.endo.beta),t=this.curve.point(e,this.y);return this.pre&&(t.pre=this.pre.map(e=>{let t=e.x.redMul(this.curve.endo.beta);return this.curve.point(t,e.y)}),this.pre.beta=t),t}_getJNAF(e){if(assert(e instanceof ShortPoint),this.inf||e.inf)return super._getJNAF(e);let t=[this,null,null,e];return this.y.eq(e.y)?(t[1]=this.add(e),t[2]=this.toJ().sub(e)):this.y.eq(e.y.redNeg())?(t[1]=this.toJ().add(e),t[2]=this.sub(e)):(t[1]=this.toJ().add(e),t[2]=this.toJ().sub(e)),t}clone(){return this.inf?this.curve.point():this.curve.point(this.x,this.y)}scale(e){return this.toJ().scale(e)}neg(){return this.inf?this:this.curve.point(this.x,this.y.redNeg())}add(e){if(assert(e instanceof ShortPoint),this.inf)return e;if(e.inf)return this;if(this.x.eq(e.x))return this.y.eq(e.y)?this.dbl():this.curve.point();if(this.y.eq(e.y)){let t=this.x.redNeg().redISub(e.x),r=this.y.redNeg();return this.curve.point(t,r)}let t=this.x.redSub(e.x),r=this.y.redSub(e.y),f=r.redDiv(t),i=f.redSqr().redISub(this.x).redISub(e.x),s=f.redMul(this.x.redSub(i)).redISub(this.y);return this.curve.point(i,s)}dbl(){if(this.inf)return this;if(this.y.isZero())return this.curve.point();let e=this.x.redSqr(),t=e.redIMuln(3).redIAdd(this.curve.a),r=this.y.redMuln(2),f=t.redDiv(r),i=f.redSqr().redISub(this.x).redISub(this.x),s=f.redMul(this.x.redSub(i)).redISub(this.y);return this.curve.point(i,s)}dblp(e){return this.toJ().dblp(e).toP()}getX(){if(this.inf)throw Error("Invalid point.");return this.x.fromRed()}getY(){if(this.inf)throw Error("Invalid point.");return this.y.fromRed()}eq(e){return assert(e instanceof ShortPoint),this===e||(this.inf?e.inf:!e.inf&&this.x.eq(e.x)&&this.y.eq(e.y))}cmp(e){return(assert(e instanceof ShortPoint),this.inf&&!e.inf)?-1:!this.inf&&e.inf?1:this.inf&&e.inf?0:this.order().cmp(e.order())||this.getX().cmp(e.getX())||this.getY().cmp(e.getY())}isInfinity(){return this.inf}isOrder2(){return!this.inf&&this.y.isZero()}isOdd(){return!this.inf&&this.y.redIsOdd()}isEven(){return!this.inf&&this.y.redIsEven()}isSquare(){return!this.inf&&-1!==this.y.redJacobi()}eqX(e){return assert(e instanceof s),assert(!e.red),!this.inf&&this.getX().eq(e)}eqR(e){return assert(e instanceof s),assert(!e.red),assert(!this.curve.n.isZero()),!this.inf&&this.getX().imod(this.curve.n).eq(e)}mul(e){return super.mul(e).toP()}muln(e){return super.muln(e).toP()}mulBlind(e,t){return super.mulBlind(e,t).toP()}mulAdd(e,t,r){return super.mulAdd(e,t,r).toP()}mulH(){return super.mulH().toP()}div(e){return super.div(e).toP()}divn(e){return super.divn(e).toP()}divH(){return super.divH().toP()}toP(){return this}toJ(){return this.inf?this.curve.jpoint():this.curve.jpoint(this.x,this.y,this.curve.one)}encode(e){null==e&&(e=!0),assert("boolean"==typeof e);let{fieldSize:t}=this.curve;if(this.inf)throw Error("Invalid point.");if(e){let e=f.alloc(1+t),r=this.curve.encodeField(this.getX());return e[0]=2|this.y.redIsOdd(),r.copy(e,1),e}let r=f.alloc(1+2*t),i=this.curve.encodeField(this.getX()),s=this.curve.encodeField(this.getY());return r[0]=4,i.copy(r,1),s.copy(r,1+t),r}static decode(e,t){assert(e instanceof ShortCurve),assert(f.isBuffer(t));let r=e.fieldSize;if(t.length<1+r)throw Error("Not a point.");let i=t[0];switch(i){case 2:case 3:{if(t.length!==1+r)throw Error("Invalid point size for compressed.");let f=e.decodeField(t.slice(1,1+r));if(f.cmp(e.p)>=0)throw Error("Invalid point.");let s=e.pointFromX(f,3===i);return assert(!s.isInfinity()),s}case 4:case 6:case 7:{if(t.length!==1+2*r)throw Error("Invalid point size for uncompressed.");let f=e.decodeField(t.slice(1,1+r)),s=e.decodeField(t.slice(1+r,1+2*r));if(f.cmp(e.p)>=0||s.cmp(e.p)>=0)throw Error("Invalid point.");if(4!==i&&i!==(6|s.isOdd()))throw Error("Invalid hybrid encoding.");let n=e.point(f,s);if(!n.validate())throw Error("Invalid point.");return assert(!n.isInfinity()),n}default:throw Error("Unknown point format.")}}encodeX(){return this.curve.encodeField(this.getX())}static decodeEven(e,t){assert(e instanceof ShortCurve);let r=e.decodeField(t);if(r.cmp(e.p)>=0)throw Error("Invalid point.");return e.pointFromX(r,!1)}static decodeSquare(e,t){assert(e instanceof ShortCurve);let r=e.decodeField(t);if(r.cmp(e.p)>=0)throw Error("Invalid point.");return e.pointFromX(r)}toJSON(e){if(this.inf)return[];let t=this.getX().toJSON(),r=this.getY().toJSON();return!0===e&&this.pre?[t,r,this.pre.toJSON()]:[t,r]}toPretty(){if(this.inf)return[];let e=2*this.curve.fieldSize,t=toPretty(this.getX(),e),r=toPretty(this.getY(),e);return[t,r]}static fromJSON(e,t){if(assert(e instanceof ShortCurve),assert(Array.isArray(t)),assert(0===t.length||2===t.length||3===t.length),0===t.length)return e.point();let r=s.fromJSON(t[0]),f=s.fromJSON(t[1]),i=e.point(r,f);return t.length>2&&null!=t[2]&&(i.pre=Precomp.fromJSON(i,t[2])),i}[i](){return this.inf?"<ShortPoint: Infinity>":"<ShortPoint: x="+this.x.fromRed().toString(16,2)+" y="+this.y.fromRed().toString(16,2)+">"}};let JPoint=class JPoint extends Point{constructor(e,t,r,f){assert(e instanceof ShortCurve),super(e,n.JACOBIAN),this.x=this.curve.one,this.y=this.curve.one,this.z=this.curve.zero,this.zOne=!1,null!=t&&this._init(t,r,f)}_init(e,t,r){assert(e instanceof s),assert(t instanceof s),assert(null==r||r instanceof s),this.x=e,this.y=t,this.z=r||this.curve.one,this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)),this.zOne=this.z.eq(this.curve.one)}clone(){return this.curve.jpoint(this.x,this.y,this.z)}validate(){let{a:e,b:t}=this.curve;if(this.isInfinity())return!0;if(this.zOne)return this.curve.validate(this.toP());let r=this.y.redSqr(),f=this.x.redSqr().redMul(this.x),i=this.z.redSqr(),s=i.redSqr(),n=s.redMul(i),d=f.redIAdd(t.redMul(n));return this.curve.zeroA||(this.curve.threeA?d.redIAdd(s.redIMuln(-3).redMul(this.x)):d.redIAdd(e.redMul(s).redMul(this.x))),r.eq(d)}normalize(){if(this.zOne||this.isInfinity())return this;let e=this.z.redInvert(),t=e.redSqr();return this.x=this.x.redMul(t),this.y=this.y.redMul(t).redMul(e),this.z=this.curve.one,this.zOne=!0,this}scale(e){if(assert(e instanceof s),this.isInfinity())return this.curve.jpoint();let t=e.redSqr(),r=this.x.redMul(t),f=this.y.redMul(t).redMul(e),i=this.z.redMul(e);return this.curve.jpoint(r,f,i)}neg(){return this.curve.jpoint(this.x,this.y.redNeg(),this.z)}add(e){return(assert(e instanceof Point),e.type===n.AFFINE)?this._mixedAdd(e):this._add(e)}_add(e){return(assert(e instanceof JPoint),this.isInfinity())?e:e.isInfinity()?this:this.zOne?e._addJA(this):e.zOne?this._addJA(e):this._addJJ(e)}_mixedAdd(e){return(assert(e instanceof ShortPoint),this.isInfinity())?e.toJ():e.isInfinity()?this:this._addJA(e)}_addJJ(e){let t=this.z.redSqr(),r=e.z.redSqr(),f=this.x.redMul(r),i=e.x.redMul(t),s=this.y.redMul(e.z).redMul(r),n=e.y.redMul(this.z).redMul(t),d=i.redISub(f),o=n.redISub(s);if(d.isZero())return o.isZero()?this.dbl():this.curve.jpoint();let h=d.redSqr(),l=d.redMul(h),u=f.redMul(h),a=o.redSqr().redISub(l).redISub(u).redISub(u),c=o.redMul(u.redISub(a)).redISub(s.redMul(l)),b=this.z.redMul(e.z).redMul(d);return this.curve.jpoint(a,c,b)}_addJA(e){let t=this.z.redSqr(),r=e.x.redMul(t),f=e.y.redMul(this.z).redMul(t),i=r.redISub(this.x),s=f.redISub(this.y).redIMuln(2);if(i.isZero())return s.isZero()?this.dbl():this.curve.jpoint();let n=i.redMuln(2).redSqr(),d=i.redMul(n),o=this.x.redMul(n),h=s.redSqr().redISub(d).redISub(o).redISub(o),l=s.redMul(o.redISub(h)).redISub(this.y.redMul(d).redIMuln(2)),u=this.z.redMul(i).redIMuln(2);return this.curve.jpoint(h,l,u)}dbl(){return this.isInfinity()?this:this.y.isZero()?this.curve.jpoint():this.curve.zeroA?this._dbl0():this.curve.threeA?this._dbl3():this._dblJ()}_dblJ(){let e=this.x.redSqr(),t=this.y.redSqr(),r=this.z.redSqr(),f=this.x.redMul(t).redIMuln(4),i=e.redIMuln(3).redIAdd(this.curve.a.redMul(r.redSqr())),s=i.redSqr().redISub(f).redISub(f),n=i.redMul(f.redISub(s)).redISub(t.redSqr().redIMuln(8)),d=this.y.redMul(this.z).redIMuln(2);return this.curve.jpoint(s,n,d)}_dbl0(){let e=this.x.redSqr(),t=this.y.redSqr(),r=t.redSqr(),f=t.redIAdd(this.x).redSqr(),i=f.redISub(e).redISub(r).redIMuln(2),s=e.redIMuln(3),n=s.redSqr(),d=n.redISub(i).redISub(i),o=s.redMul(i.redISub(d)).redISub(r.redIMuln(8)),h=this.y.redMul(this.z).redIMuln(2);return this.curve.jpoint(d,o,h)}_dbl3(){let e=this.z.redSqr(),t=this.y.redSqr(),r=this.x.redMul(t),f=this.x.redSub(e),i=this.x.redAdd(e),s=f.redMul(i).redIMuln(3),n=r.redIMuln(4),d=n.redMuln(2),o=t.redSqr().redIMuln(8),h=s.redSqr().redISub(d),l=this.y.redAdd(this.z).redSqr().redISub(t).redISub(e),u=s.redMul(n.redISub(h)).redISub(o);return this.curve.jpoint(h,u,l)}getX(){if(this.isInfinity())throw Error("Invalid point.");return this.normalize(),this.x.fromRed()}getY(){if(this.isInfinity())throw Error("Invalid point.");return this.normalize(),this.y.fromRed()}eq(e){if(assert(e instanceof JPoint),this===e)return!0;if(this.isInfinity())return e.isInfinity();if(e.isInfinity())return!1;if(this.z.eq(e.z))return this.x.eq(e.x)&&this.y.eq(e.y);let t=this.z.redSqr(),r=e.z.redSqr(),f=this.x.redMul(r),i=e.x.redMul(t);if(!f.eq(i))return!1;let s=t.redMul(this.z),n=r.redMul(e.z),d=this.y.redMul(n),o=e.y.redMul(s);return d.eq(o)}cmp(e){assert(e instanceof JPoint);let t=this.isInfinity(),r=e.isInfinity();return t&&!r?-1:!t&&r?1:t&&r?0:this.order().cmp(e.order())||this.getX().cmp(e.getX())||this.getY().cmp(e.getY())}isInfinity(){return this.z.isZero()}isOrder2(){return!this.isInfinity()&&this.y.isZero()}isOdd(){return!this.isInfinity()&&(this.normalize(),this.y.redIsOdd())}isEven(){return!this.isInfinity()&&(this.normalize(),this.y.redIsEven())}isSquare(){return!this.isInfinity()&&-1!==this.y.redMul(this.z).redJacobi()}eqX(e){if(assert(e instanceof s),assert(!e.red),this.isInfinity())return!1;let t=this.z.redSqr(),r=e.toRed(this.curve.red).redMul(t);return this.x.eq(r)}eqR(e){if(assert(e instanceof s),assert(!e.red),!this.curve.smallGap)return this.toP().eqR(e);if(this.isInfinity()||e.cmp(this.curve.p)>=0)return!1;let t=this.z.redSqr(),r=e.toRed(this.curve.red).redMul(t);if(this.x.eq(r))return!0;if(this.curve.highOrder||e.cmp(this.curve.pmodn)>=0)return!1;let f=this.curve.redN.redMul(t);return r.redIAdd(f),this.x.eq(r)}toP(){return this.isInfinity()?this.curve.point():(this.normalize(),this.curve.point(this.x,this.y))}toJ(){return this}encode(e){return this.toP().encode(e)}static decode(e,t){return ShortPoint.decode(e,t).toJ()}encodeX(){return this.toP().encodeX()}static decodeEven(e,t){return ShortPoint.decodeEven(e,t).toJ()}static decodeSquare(e,t){return ShortPoint.decodeSquare(e,t).toJ()}toJSON(e){return this.toP().toJSON(e)}toPretty(){return this.toP().toPretty()}static fromJSON(e,t){return ShortPoint.fromJSON(e,t).toJ()}[i](){return this.isInfinity()?"<JPoint: Infinity>":"<JPoint: x="+this.x.fromRed().toString(16,2)+" y="+this.y.fromRed().toString(16,2)+" z="+this.z.fromRed().toString(16,2)+">"}};let MontCurve=class MontCurve extends Curve{constructor(e){super(MontPoint,"mont",e),this.a=s.fromJSON(e.a).toRed(this.red),this.b=s.fromJSON(e.b).toRed(this.red),this.bi=this.b.redInvert(),this.a2=this.a.redAdd(this.two),this.a24=this.a2.redMul(this.i4),this.a3=this.a.redMul(this.i3),this.a0=this.a.redMul(this.bi),this.b0=this.bi.redSqr(),this._finalize(e)}static _isomorphism(e,t,r){assert(e instanceof s),assert(t instanceof s),assert(r instanceof s);let f=e.clone(),i=r.clone(),n=t.redDiv(r);if(1!==n.redJacobi())throw Error("Invalid `b` coefficient.");return[f,i]}_short(e,t){let{a:r,b:f,three:i}=this,s=r.redSqr(),n=s.redMul(r),d=f.redSqr(),o=d.redMul(f),h=i.redSub(s),l=d.redMuln(3),u=n.redMuln(2).redISub(r.redMuln(9)),a=o.redMuln(27),c=h.redDiv(l),b=u.redDiv(a);return null!=e?ShortCurve._isomorphism(c,b,e,t):[c,b]}_mont(e){return MontCurve._isomorphism(this.a,this.b,e)}_edwards(e,t=!1){assert("boolean"==typeof t);let{two:r,bi:f}=this,i=this.a.redAdd(r).redMul(f),s=this.a.redSub(r).redMul(f);return(t&&i.swap(s),null!=e)?EdwardsCurve._isomorphism(i,s,e):[i,s]}_scaleShort(e){assert(e instanceof ShortCurve);let[t,r]=e._scale(this);return[this.field(t.redInvert()),this.field(r.redInvert())]}_scaleMont(e){return(assert(e instanceof MontCurve),this.g.isInfinity()||e.g.isInfinity())?this.field(e.b).redDivSqrt(this.b):this.g.y.redDiv(this.field(e.g.y))}_scaleEdwards(e,t){assert(e instanceof EdwardsCurve);let r=e._scale(this,t);return this.field(r)}_solveY0(e){assert(e instanceof s);let t=this.a0,r=this.b0,f=e.redSqr(),i=f.redMul(e),n=i.redIAdd(t.redMul(f)).redIAdd(r.redMul(e));return n}_elligator2(e){let t=this.a0.redNeg(),r=this.one.redAdd(this.z.redMul(e.redSqr()));r.isZero()&&r.inject(this.one);let f=t.redMul(r.redInvert()),i=f.redNeg().redISub(this.a0),s=this._solveY0(f),n=this._solveY0(i),d=0|s.redIsSquare(),o=[f,i][1^d],h=[s,n][1^d].redSqrt();h.redIsOdd()!==e.redIsOdd()&&h.redINeg();let l=this.b.redMul(o),u=this.b.redMul(h);return this.point(l,u)}_invert2(e,t){let{x:r,y:f}=e,i=1&t,s=r.redMul(this.bi),n=f.redMul(this.bi),d=s.redAdd(this.a0),o=[d,s][i].redINeg(),h=[s,d][i].redMul(this.z),l=o.redDivSqrt(h);return l.redIsOdd()!==n.redIsOdd()&&l.redINeg(),l}isElliptic(){let e=this.a.redSqr(),t=this.b.redMul(e.redSub(this.four));return!t.isZero()}jinv(){let{a:e,three:t,four:r}=this,f=e.redSqr(),i=f.redSub(t),s=i.redPown(3).redIMuln(256),n=f.redSub(r);if(n.isZero())throw Error("Curve is not elliptic.");return s.redDiv(n).fromRed()}point(e,t){return new MontPoint(this,e,t)}jpoint(e,t,r){return assert(null==e&&null==t&&null==r),this.point()}xpoint(e,t){return new XPoint(this,e,t)}solveY2(e){assert(e instanceof s);let t=e.redSqr(),r=t.redMul(e),f=r.redIAdd(this.a.redMul(t)).redIAdd(e),i=f.redMul(this.bi);return i}validate(e){if(assert(e instanceof MontPoint),e.isInfinity())return!0;let{x:t,y:r}=e,f=this.solveY2(t);return r.redSqr().eq(f)}pointFromX(e,t=null){assert(e instanceof s),assert(null==t||"boolean"==typeof t),e.red||(e=e.toRed(this.red));let r=this.solveY(e);if(null!=t){if(r.isZero()&&t)throw Error("Invalid point.");r.redIsOdd()!==t&&r.redINeg()}return this.point(e,r)}isIsomorphic(e,t){if(assert(e instanceof Curve),!e.p.eq(this.p))return!1;if("mont"===e.type){let t=this.field(e.a),r=this.field(e.b);if(!this.a.eq(t)||this.b.isZero())return!1;let f=r.redDiv(this.b);return 1===f.redJacobi()}return e.isIsomorphic(this,t)}isIsogenous(e){return assert(e instanceof Curve),"mont"!==e.type&&e.isIsogenous(this)}pointFromShort(e){if(assert(e instanceof ShortPoint),this.isIsomorphic(e.curve)){if(e.isInfinity())return this.point();let{a3:t,b:r}=this,[f,i]=this._scale(e.curve),s=this.field(e.x).redMul(f),n=this.field(e.y).redMul(i),d=r.redMul(s).redISub(t),o=r.redMul(n);return this.point(d,o)}throw Error("Not implemented.")}pointFromMont(e){if(assert(e instanceof MontPoint),this.isIsomorphic(e.curve)){if(e.isInfinity())return this.point();let t=this._scale(e.curve),r=this.field(e.x),f=this.field(e.y),i=t.redMul(f);return this.point(r,i)}throw Error("Not implemented.")}pointFromEdwards(e){assert(e instanceof EdwardsPoint),assert(e.curve.p.eq(this.p));let t=this.field(e.x),r=this.field(e.y),f=this.field(e.z);if(this.isIsogenous(e.curve)){if(e.isInfinity())return this.point();if(e.x.isZero())return this.point(this.zero,this.zero);let i=f.redSqr().redIMuln(2),s=r.redSqr(),n=t.redSqr(),d=i.redISub(n).redISub(s).redMul(r),o=n.redMul(t);return this.cpoint(s,n,d,o)}if(this.isIsomorphic(e.curve,!0)){if(e.isInfinity())return this.point();if(e.x.isZero())return this.point(this.zero,this.zero);let i=this._scale(e.curve,!0),s=r.redAdd(f),n=r.redSub(f),d=i.redMul(f).redMul(s),o=t.redMul(n);return this.cpoint(s,n,d,o)}if(this.isIsomorphic(e.curve,!1)){if(e.isInfinity())return this.point();if(e.x.isZero())return this.point(this.zero,this.zero);let i=this._scale(e.curve,!1),s=f.redAdd(r),n=f.redSub(r),d=i.redMul(f).redMul(s),o=t.redMul(n);return this.cpoint(s,n,d,o)}throw Error("Not implemented.")}pointFromUniform(e){if(assert(e instanceof s),this.z.isZero()||this.a.isZero())throw Error("Not implemented.");return this._elligator2(e)}pointToUniform(e,t){if(assert(e instanceof MontPoint),assert(t>>>0===t),this.z.isZero()||this.a.isZero())throw Error("Not implemented.");if(e.isInfinity())throw Error("Invalid point.");let r=(t>>>4&15)%this.torsion.length,f=e.add(this.torsion[r]);return wrapErrors(()=>this._invert2(f,t))}decodePoint(e,t){return MontPoint.decode(this,e,t)}encodeX(e){return assert(e instanceof XPoint),e.encode()}decodeX(e){return XPoint.decode(this,e)}toShort(e,t,r=null){let[f,i]=this._short(e,t),s=new ShortCurve({red:this.red,prime:this.prime,p:this.p,a:f,b:i,n:this.n,h:this.h});if(null!=r){let[,e]=s._scale(this);e.redIsOdd()!==r&&e.redINeg()}this.g.isInfinity()||(s.g=s.pointFromMont(this.g));for(let e=0;e<this.h.word(0);e++)s.torsion[e]=s.pointFromMont(this.torsion[e]);return s}toMont(e,t=null){let[r,f]=this._mont(e),i=new MontCurve({red:this.red,prime:this.prime,p:this.p,a:r,b:f,n:this.n,h:this.h,z:this.z});if(null!=t){let e=i._scale(this);e.redIsOdd()!==t&&e.redINeg()}this.g.isInfinity()||(i.g=i.pointFromMont(this.g));for(let e=0;e<this.h.word(0);e++)i.torsion[e]=i.pointFromMont(this.torsion[e]);return i}toEdwards(e,t,r=null){let[f,i]=this._edwards(e,t),s=new EdwardsCurve({red:this.red,prime:this.prime,p:this.p,a:f,d:i,n:this.n,h:this.h,z:this.z});if(null!=r){let e=s._scale(this,t);e.redIsOdd()!==r&&e.redINeg()}if(this.g.isInfinity()||(s.g=s.pointFromMont(this.g),s.g.normalize()),s.isComplete())for(let e=0;e<this.h.word(0);e++)s.torsion[e]=s.pointFromMont(this.torsion[e]),s.torsion[e].normalize();return s}pointFromJSON(e){return MontPoint.fromJSON(this,e)}toJSON(e){let t=super.toJSON(e);return t.a=this.a.fromRed().toJSON(),t.b=this.b.fromRed().toJSON(),t}};let MontPoint=class MontPoint extends Point{constructor(e,t,r){assert(e instanceof MontCurve),super(e,n.AFFINE),this.x=this.curve.zero,this.y=this.curve.zero,this.inf=!0,null!=t&&this._init(t,r)}_init(e,t){assert(e instanceof s),assert(t instanceof s),this.x=e,this.y=t,this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.inf=!1}clone(){return this.inf?this.curve.point():this.curve.point(this.x,this.y)}scale(e){return this.clone()}randomize(e){return this.clone()}neg(){return this.inf?this:this.curve.point(this.x,this.y.redNeg())}add(e){if(assert(e instanceof MontPoint),this.inf)return e;if(e.inf)return this;if(this.x.eq(e.x))return this.y.eq(e.y)?this.dbl():this.curve.point();let t=e.x.redSub(this.x),r=e.y.redSub(this.y),f=r.redDiv(t),i=this.curve.b.redMul(f.redSqr()),s=i.redISub(this.curve.a).redISub(this.x).redISub(e.x),n=f.redMul(this.x.redSub(s)).redISub(this.y);return this.curve.point(s,n)}dbl(){if(this.inf)return this;if(this.y.isZero())return this.curve.point();let e=this.x.redSqr().redIMuln(3),t=this.curve.a.redMul(this.x).redIMuln(2),r=e.redIAdd(t).redIAdd(this.curve.one),f=this.curve.b.redMul(this.y).redIMuln(2),i=r.redDiv(f),s=this.curve.b.redMul(i.redSqr()),n=s.redISub(this.curve.a).redISub(this.x).redISub(this.x),d=i.redMul(this.x.redSub(n)).redISub(this.y);return this.curve.point(n,d)}getX(){if(this.inf)throw Error("Invalid point.");return this.x.fromRed()}getY(){if(this.inf)throw Error("Invalid point.");return this.y.fromRed()}eq(e){return assert(e instanceof MontPoint),this===e||(this.inf?e.inf:!e.inf&&this.x.eq(e.x)&&this.y.eq(e.y))}cmp(e){return(assert(e instanceof MontPoint),this.inf&&!e.inf)?-1:!this.inf&&e.inf?1:this.inf&&e.inf?0:this.order().cmp(e.order())||this.getX().cmp(e.getX())||this.getY().cmp(e.getY())}isInfinity(){return this.inf}isOrder2(){return!this.inf&&this.y.isZero()}isOdd(){return!this.inf&&this.y.redIsOdd()}isEven(){return!this.inf&&this.y.redIsEven()}toP(){return this}toJ(){return this}toX(){return this.inf?this.curve.xpoint():this.curve.xpoint(this.x,this.curve.one)}encode(){return this.toX().encode()}static decode(e,t,r){return assert(e instanceof MontCurve),e.decodeX(t).toP(r)}toJSON(e){if(this.inf)return[];let t=this.getX().toJSON(),r=this.getY().toJSON();return[t,r]}toPretty(){if(this.inf)return[];let e=2*this.curve.fieldSize,t=toPretty(this.getX(),e),r=toPretty(this.getY(),e);return[t,r]}static fromJSON(e,t){if(assert(e instanceof MontCurve),assert(Array.isArray(t)),assert(0===t.length||2===t.length||3===t.length),0===t.length)return e.point();let r=s.fromJSON(t[0]),f=s.fromJSON(t[1]);return e.point(r,f)}[i](){return this.inf?"<MontPoint: Infinity>":"<MontPoint: x="+this.x.fromRed().toString(16,2)+" y="+this.y.fromRed().toString(16,2)+">"}};let XPoint=class XPoint extends Point{constructor(e,t,r){assert(e instanceof MontCurve),super(e,n.PROJECTIVE),this.x=this.curve.one,this.z=this.curve.zero,null!=t&&this._init(t,r)}_init(e,t){assert(e instanceof s),assert(null==t||t instanceof s),this.x=e,this.z=t||this.curve.one,this.x.red||(this.x=this.x.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red))}clone(){return this.curve.xpoint(this.x,this.z)}precompute(e,t){return this}validate(){if(this.isInfinity())return!0;let{x:e,z:t}=this,r=e.redSqr(),f=r.redMul(e),i=t.redSqr(),s=this.curve.a.redMul(r).redMul(t),n=f.redIAdd(s).redIAdd(e.redMul(i)),d=n.redMul(this.curve.bi);return -1!==d.redMul(t).redJacobi()}normalize(){return this.isInfinity()||this.z.eq(this.curve.one)||(this.x=this.x.redDiv(this.z),this.z=this.curve.one),this}scale(e){if(assert(e instanceof s),this.isInfinity())return this.curve.xpoint();let t=this.x.redMul(e),r=this.z.redMul(e);return this.curve.xpoint(t,r)}neg(){return this}dbl(){let e=this.x.redAdd(this.z),t=e.redSqr(),r=this.x.redSub(this.z),f=r.redSqr(),i=t.redSub(f),s=t.redMul(f),n=i.redMul(f.redIAdd(this.curve.a24.redMul(i)));return this.curve.xpoint(s,n)}diffAddDbl(e,t){assert(e instanceof XPoint),assert(t instanceof XPoint);let r=e.x.redAdd(e.z),f=r.redSqr(),i=e.x.redSub(e.z),s=i.redSqr(),n=f.redSub(s),d=t.x.redAdd(t.z),o=t.x.redSub(t.z),h=o.redMul(r),l=d.redMul(i),u=this.z.redMul(h.redAdd(l).redSqr()),a=this.x.redMul(h.redISub(l).redSqr()),c=f.redMul(s),b=n.redMul(s.redIAdd(this.curve.a24.redMul(n)));return[this.curve.xpoint(c,b),this.curve.xpoint(u,a)]}getX(){if(this.isInfinity())throw Error("Invalid point.");return this.normalize(),this.x.fromRed()}getY(e){return this.toP(e).getY()}eq(e){if(assert(e instanceof XPoint),this===e)return!0;if(this.isInfinity())return e.isInfinity();if(e.isInfinity())return!1;if(this.z.eq(e.z))return this.x.eq(e.x);let t=this.x.redMul(e.z),r=e.x.redMul(this.z);return t.eq(r)}cmp(e){assert(e instanceof XPoint);let t=this.isInfinity(),r=e.isInfinity();return t&&!r?-1:!t&&r?1:t&&r?0:this.order().cmp(e.order())||this.getX().cmp(e.getX())}isInfinity(){return this.z.isZero()}isOrder2(){return!this.isInfinity()&&this.x.isZero()}isOdd(){return!1}isEven(){return!1}hasTorsion(){return!this.isInfinity()&&(!!this.x.isZero()||super.hasTorsion())}order(){try{return this.toP().order()}catch(e){return new s(1)}}jmul(e){assert(e instanceof s),assert(!e.red);let t=e.bitLength(),r=this.curve.xpoint(),f=this;for(let i=t-1;i>=0;i--){let t=e.bit(i);0===t?[r,f]=this.diffAddDbl(r,f):[f,r]=this.diffAddDbl(f,r)}return r}jmulBlind(e,t){return t?this.randomize(t).jmul(e):this.jmul(e)}jmulAdd(e,t,r){throw Error("Not implemented.")}toP(e=null){return(assert(null==e||"boolean"==typeof e),this.isInfinity())?this.curve.point():(this.normalize(),this.curve.pointFromX(this.x,e))}toJ(){return this}toX(){return this}key(){if(this.isInfinity())return`${this.curve.uid}:oo`;this.normalize();let e=this.getX().toString(16);return`${this.curve.uid}:${e}`}encode(){return this.curve.encodeField(this.getX())}static decode(e,t){assert(e instanceof MontCurve);let r=e.decodeField(t);r.iumaskn(e.fieldBits);let f=e.xpoint(r,e.one);return assert(!f.isInfinity()),f}toJSON(e){return this.toP().toJSON(e)}toPretty(){return this.toP().toPretty()}static fromJSON(e,t){return MontPoint.fromJSON(e,t).toX()}[i](){return this.isInfinity()?"<XPoint: Infinity>":"<XPoint: x="+this.x.fromRed().toString(16,2)+" z="+this.z.fromRed().toString(16,2)+">"}};let EdwardsCurve=class EdwardsCurve extends Curve{constructor(e){super(EdwardsPoint,"edwards",e),this.a=s.fromJSON(e.a).toRed(this.red),this.d=s.fromJSON(e.d).toRed(this.red),this.s=s.fromJSON(e.s||"0").toRed(this.red),this.si=this.s.isZero()?this.zero:this.s.redInvert(),this.k=this.d.redMuln(2),this.smi=-this.d.redNeg().word(0),this.ad6=this.a.redAdd(this.d).redMul(this.i6),this.twisted=!this.a.eq(this.one),this.oneA=this.a.eq(this.one),this.mOneA=this.a.eq(this.one.redNeg()),this.smallD=null!=this.prime&&1===this.d.redNeg().length,this.alt=null,this._finalize(e)}static _isomorphism(e,t,r){assert(e instanceof s),assert(t instanceof s),assert(r instanceof s);let f=r.clone(),i=r.redMul(t).redDiv(e),n=e.redDiv(r);if(1!==n.redJacobi())throw Error("Invalid `a` coefficient.");return[f,i]}_short(e,t){let{a:r,d:f}=this,i=r.redSqr(),s=i.redMul(r),n=f.redSqr(),d=n.redMul(f),o=r.redMul(f).redIMuln(14),h=i.redMul(f),l=r.redMul(n),u=h.redIAdd(l).redIMuln(33),a=i.redAdd(o).redIAdd(n).redDivn(-48),c=u.redISub(s).redISub(d).redDivn(864);return null!=e?ShortCurve._isomorphism(a,c,e,t):[a,c]}_mont(e,t=!1){let r,f;assert("boolean"==typeof t),t?(r=this.d.redAdd(this.a),f=this.d.redSub(this.a)):(r=this.a.redAdd(this.d),f=this.a.redSub(this.d));let i=f.redInvert(),s=r.redMuln(2).redMul(i),n=i.redMuln(4);return null!=e?MontCurve._isomorphism(s,n,e):[s,n]}_edwards(e){return EdwardsCurve._isomorphism(this.a,this.d,e)}_scaleShort(e){assert(e instanceof ShortCurve);let[t,r]=e._scale(this);return[this.field(t.redInvert()),this.field(r.redInvert())]}_scaleMont(e,t=!1){if(assert(e instanceof MontCurve),assert("boolean"==typeof t),this.g.isInfinity()||e.g.isInfinity()){let[r]=e._edwards(null,t);return this.field(r).redDivSqrt(this.a)}let r=e.g.x.redDiv(e.g.y);return this.g.x.redDiv(this.field(r))}_scaleEdwards(e){return(assert(e instanceof EdwardsCurve),this.g.isInfinity()||e.g.isInfinity())?this.field(e.a).redDivSqrt(this.a):this.g.x.redDiv(this.field(e.g.x))}_mulA(e){return(assert(e instanceof s),this.oneA)?e.clone():this.mOneA?e.redNeg():this.a.redMul(e)}_mulD(e){return(assert(e instanceof s),this.smallD)?e.redMuln(this.smi):this.d.redMul(e)}_elligator1(e){let{s:t,si:r,i2:f,one:i,two:s}=this,n=r.redSqr().redIMuln(2),d=t.redSqr().redMul(f),o=d.redSqr(),h=n.redAdd(d),l=h.redSqr().redISub(s),u=n.redSub(i),a=i.redSub(e),c=i.redAdd(e),b=c.isZero()?c:a.redDiv(c),p=b.redSqr(),m=p.redMul(b),S=m.redMul(p),v=S.redAdd(l.redMul(m)).redIAdd(b),M=this.field(v.redJacobi()),I=this.field(p.redAdd(o).redJacobi()),g=M.redMul(I),y=M.redMul(b),w=M.redMul(v).redSqrt().redMul(g),N=i.redAdd(y),z=h.redMul(y),A=N.redSqr(),q=u.redMul(t).redMul(y).redMul(N),E=b.isZero()?this.one:w,_=z.redSub(A),x=z.redAdd(A);return this.cpoint(q,E,_,x)}_invert1(e,t){let{s:r,si:f,i2:i,one:s}=this,{x:n,y:d,z:o}=e,h=f.redSqr().redIMuln(2),l=r.redSqr().redMul(i),u=l.redSqr(),a=h.redAdd(l),c=h.redSub(s),b=d.redSub(o),p=d.redAdd(o).redIMuln(2),m=p.isZero()?p:b.redDiv(p),S=s.redAdd(m.redMul(a)),v=S.redSqr().redISub(s),M=v.redSqrt(),I=M.redSub(S),g=s.redAdd(I),y=c.redMul(r).redMul(I).redMul(g),w=y.redMul(n.redMul(o)),N=I.redSqr().redIAdd(u),z=this.field(w.redMul(N).redJacobi()),A=z.redMul(I),q=s.redSub(A),E=s.redAdd(A),_=E.isZero()?E:q.redDiv(E);return _.redIsOdd()!==!!(1&t)&&_.redINeg(),_}_alt(){return this.alt||(this.alt=this.toMont()),this.alt}isElliptic(){let e=this.a.redMul(this.d),t=this.a.redSub(this.d);return!e.redMul(t).isZero()}jinv(){let{a:e,d:t}=this,r=e.redMul(t),f=e.redSub(t).redPown(4),i=e.redSqr(),s=t.redSqr(),n=i.redAdd(r.redMuln(14)).redIAdd(s),d=n.redPown(3).redIMuln(16),o=r.redMul(f);if(o.isZero())throw Error("Curve is not elliptic.");return d.redDiv(o).fromRed()}isComplete(){return 1===this.a.redJacobi()&&-1===this.d.redJacobi()}point(e,t,r,f){return new EdwardsPoint(this,e,t,r,f)}jpoint(e,t,r){return assert(null==e&&null==t&&null==r),this.point()}cpoint(e,t,r,f){assert(e instanceof s),assert(t instanceof s),assert(r instanceof s),assert(f instanceof s);let i=e.redMul(f),n=r.redMul(t),d=t.redMul(f),o=e.redMul(r);return this.point(i,n,d,o)}solveX2(e){assert(e instanceof s);let t=e.redSqr(),r=this._mulD(t).redISub(this.a),f=t.redISub(this.one),i=f.redDiv(r);return i}solveX(e){let t=e.redSqr(),r=this._mulD(t).redISub(this.a),f=t.redISub(this.one);return f.redDivSqrt(r)}solveY2(e){assert(e instanceof s);let t=e.redSqr(),r=this._mulA(t).redISub(this.one),f=this._mulD(t).redISub(this.one),i=r.redDiv(f);return i}solveY(e){let t=e.redSqr(),r=this._mulA(t).redISub(this.one),f=this._mulD(t).redISub(this.one);return r.redDivSqrt(f)}validate(e){if(assert(e instanceof EdwardsPoint),e.zOne){let t=e.x.redSqr(),r=e.y.redSqr(),f=this._mulD(t).redMul(r),i=this._mulA(t).redIAdd(r),s=this.one.redAdd(f),n=e.t,d=e.x.redMul(e.y);return i.eq(s)&&n.eq(d)}let t=e.x.redSqr(),r=e.y.redSqr(),f=e.z.redSqr(),i=f.redSqr(),s=this._mulD(t).redMul(r),n=this._mulA(t).redIAdd(r).redMul(f),d=i.redIAdd(s),o=e.t.redMul(e.z),h=e.x.redMul(e.y);return n.eq(d)&&o.eq(h)}pointFromX(e,t=null){assert(e instanceof s),assert(null==t||"boolean"==typeof t),e.red||(e=e.toRed(this.red));let r=this.solveY(e);if(null!=t){if(r.isZero()&&t)throw Error("Invalid point.");r.redIsOdd()!==t&&r.redINeg()}return this.point(e,r)}pointFromY(e,t=null){assert(e instanceof s),assert(null==t||"boolean"==typeof t),e.red||(e=e.toRed(this.red));let r=this.solveX(e);if(null!=t){if(r.isZero()&&t)throw Error("Invalid point.");r.redIsOdd()!==t&&r.redINeg()}return this.point(r,e)}isIsomorphic(e,t=!1){if(assert(e instanceof Curve),assert("boolean"==typeof t),!e.p.eq(this.p))return!1;if("short"===e.type)return e.isIsomorphic(this);if("mont"===e.type){let r,f;let i=this.field(e.a);return t?(r=this.d.redAdd(this.a),f=this.d.redSub(this.a)):(r=this.a.redAdd(this.d),f=this.a.redSub(this.d)),i.redMul(f).eq(r.redIMuln(2))}if("edwards"===e.type){let t=this.field(e.a),r=this.field(e.d);return this.a.redMul(r).eq(t.redMul(this.d))}return!1}isIsogenous(e){if(assert(e instanceof Curve),!e.p.eq(this.p))return!1;if("mont"===e.type){if(!this.a.eq(this.one))return!1;let t=this.field(e.a),r=this.field(e.b),f=this.two.redSub(this.d.redMuln(4));return t.eq(f)&&r.eq(this.one)}if("edwards"===e.type){let t=this.field(e.a),r=this.field(e.d);return t.eq(this.a.redNeg())&&r.eq(this.d.redSub(this.a))}return!1}pointFromShort(e){if(assert(e instanceof ShortPoint),this.isIsomorphic(e.curve)){if(e.isInfinity())return this.point();if(e.y.isZero())return this.point(this.zero,this.one.redNeg());let{a:t,d:r}=this,[f,i]=this._scale(e.curve),s=t.redMuln(5),n=r.redMuln(5),d=this.field(e.x).redMul(f),o=this.field(e.y).redMul(i),h=d.redMuln(6),l=d.redMuln(12),u=h.redSub(t).redISub(r),a=o.redMuln(6),c=l.redSub(s).redIAdd(r),b=l.redAdd(t).redISub(n);return this.cpoint(u,a,c,b)}throw Error("Not implemented.")}pointFromMont(e){assert(e instanceof MontPoint),assert(e.curve.p.eq(this.p));let t=this.field(e.x),r=this.field(e.y);if(this.isIsogenous(e.curve)){if(e.isInfinity()||e.x.isZero())return this.point();let f=t.redSqr(),i=f.redMul(t),s=i.redMul(t),n=s.redMul(t),d=r.redSqr(),o=r.redMuln(4),h=f.redSub(this.one),l=f.redMuln(2),u=d.redMuln(4),a=i.redIMuln(2),c=t.redMul(d).redIMuln(4),b=f.redMul(d).redIMuln(2),p=d.redIMuln(2),m=o.redMul(h),S=s.redISub(l).redIAdd(u).redIAdd(this.one),v=n.redSub(a).redISub(c).redIAdd(t).redINeg(),M=n.redISub(b).redISub(a).redISub(p).redIAdd(t);return this.cpoint(m,S,v,M).divn(4)}if(this.isIsomorphic(e.curve,!0)){if(e.isInfinity())return this.point();if(e.x.isZero())return this.point(this.zero,this.one.redNeg());let f=this._scale(e.curve,!0),i=f.redMul(t),s=t.redAdd(this.one),n=t.redSub(this.one);return this.cpoint(i,r,s,n)}if(this.isIsomorphic(e.curve,!1)){if(e.isInfinity())return this.point();if(e.x.isZero())return this.point(this.zero,this.one.redNeg());let f=this._scale(e.curve,!1),i=f.redMul(t),s=t.redSub(this.one),n=t.redAdd(this.one);return this.cpoint(i,r,s,n)}throw Error("Not implemented.")}pointFromEdwards(e){assert(e instanceof EdwardsPoint),assert(e.curve.p.eq(this.p));let t=this.field(e.curve.a),r=this.field(e.x),f=this.field(e.y),i=this.field(e.z),s=this.field(e.t);if(this.isIsogenous(e.curve)){let e=r.redMul(f),s=r.redSqr(),n=f.redSqr(),d=i.redSqr(),o=t.redMul(s),h=e.redIMuln(2),l=n.redSub(o),u=n.redAdd(o),a=d.redIMuln(2).redISub(u),c=this.cpoint(h,l,u,a);return this.twisted?c:c.divn(4)}if(this.isIsomorphic(e.curve)){let t=this._scale(e.curve),n=t.redMul(r),d=t.redMul(s);return this.point(n,f,i,d)}throw Error("Not implemented.")}pointFromUniform(e,t=null){assert(e instanceof s),assert(e.red===this.red),assert(null==t||t instanceof MontCurve),t||(t=this._alt());let r=t.field(e),f=t.pointFromUniform(r);return this.pointFromMont(f)}pointToUniform(e,t,r=null){assert(e instanceof EdwardsPoint),assert(t>>>0===t),assert(null==r||r instanceof MontCurve),r||(r=this._alt());let f=(t>>4&15)%this.torsion.length,i=e.add(this.torsion[f]),s=r.pointFromEdwards(i),n=r.pointToUniform(s,15&t);return this.field(n)}pointFromHash(e,t,r=null){assert(null==r||r instanceof MontCurve),r||(r=this._alt());let f=r.pointFromHash(e,t);return this.pointFromMont(f)}pointToHash(e,t,r,f=null){assert(e instanceof EdwardsPoint),assert(t>>>0===t),assert(null==f||f instanceof MontCurve),f||(f=this._alt());let i=t%this.torsion.length,s=e.add(this.torsion[i]),n=f.pointFromEdwards(s);return f.pointToHash(n,0,r)}decodePoint(e){return EdwardsPoint.decode(this,e)}toShort(e,t,r=null){let[f,i]=this._short(e,t),s=new ShortCurve({red:this.red,prime:this.prime,p:this.p,a:f,b:i,n:this.n,h:this.h});if(null!=r){let[,e]=s._scale(this);e.redIsOdd()!==r&&e.redINeg()}this.g.isInfinity()||(s.g=s.pointFromEdwards(this.g));for(let e=0;e<this.h.word(0);e++)s.torsion[e]=s.pointFromEdwards(this.torsion[e]);return s}toMont(e,t,r=null){let[f,i]=this._mont(e,t),s=new MontCurve({red:this.red,prime:this.prime,p:this.p,a:f,b:i,n:this.n,h:this.h,z:this.z});if(null!=r){let e=this._scale(s,t);e.redIsOdd()!==r&&e.redINeg()}this.g.isInfinity()||(s.g=s.pointFromEdwards(this.g));for(let e=0;e<this.h.word(0);e++)s.torsion[e]=s.pointFromEdwards(this.torsion[e]);return s}toEdwards(e,t=null){let[r,f]=this._edwards(e),i=new EdwardsCurve({red:this.red,prime:this.prime,p:this.p,a:r,d:f,n:this.n,h:this.h,z:this.z});if(null!=t){let e=i._scale(this);e.redIsOdd()!==t&&e.redINeg()}if(this.g.isInfinity()||(i.g=i.pointFromEdwards(this.g),i.g.normalize()),i.isComplete())for(let e=0;e<this.h.word(0);e++)i.torsion[e]=i.pointFromEdwards(this.torsion[e]),i.torsion[e].normalize();return i}pointFromJSON(e){return EdwardsPoint.fromJSON(this,e)}toJSON(e){let t=super.toJSON(e);return t.a=this.a.fromRed().toJSON(),t.d=this.d.fromRed().toJSON(),this.s.isZero()||(t.s=this.s.fromRed().toJSON()),t}};let EdwardsPoint=class EdwardsPoint extends Point{constructor(e,t,r,f,i){assert(e instanceof EdwardsCurve),super(e,n.EXTENDED),this.x=this.curve.zero,this.y=this.curve.one,this.z=this.curve.one,this.t=this.curve.zero,this.zOne=!0,null!=t&&this._init(t,r,f,i)}_init(e,t,r,f){assert(e instanceof s),assert(t instanceof s),assert(null==r||r instanceof s),assert(null==f||f instanceof s),this.x=e,this.y=t,this.z=r||this.curve.one,this.t=f||null,this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)),this.t&&!this.t.red&&(this.t=this.t.toRed(this.curve.red)),this.zOne=this.z.eq(this.curve.one),this._check(),this.t||(this.t=this.x.redMul(this.y),this.zOne||(this.t=this.t.redDiv(this.z)))}_check(){if(this.z.isZero())throw Error("Invalid point.")}clone(){return this.curve.point(this.x,this.y,this.z,this.t)}normalize(){if(this.zOne)return this;let e=this.z.redInvert();return this.x=this.x.redMul(e),this.y=this.y.redMul(e),this.t=this.t.redMul(e),this.z=this.curve.one,this.zOne=!0,this}scale(e){assert(e instanceof s);let t=this.x.redMul(e),r=this.y.redMul(e),f=this.z.redMul(e),i=this.t.redMul(e);return this.curve.point(t,r,f,i)}neg(){let e=this.x.redNeg(),t=this.y,r=this.z,f=this.t.redNeg();return this.curve.point(e,t,r,f)}add(e){return(assert(e instanceof EdwardsPoint),this.isInfinity())?e:e.isInfinity()?this:this.zOne?e._add(this):this._add(e)}_add(e){return this.curve.mOneA?this._addM1(e):this._addA(e)}_addM1(e){let t=this.y.redSub(this.x).redMul(e.y.redSub(e.x)),r=this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)),f=this.t.redMul(this.curve.k).redMul(e.t),i=e.zOne?this.z.redAdd(this.z):this.z.redMul(e.z).redIMuln(2),s=r.redSub(t),n=i.redSub(f),d=i.redIAdd(f),o=r.redIAdd(t),h=s.redMul(n),l=d.redMul(o),u=s.redMul(o),a=n.redMul(d);return this.curve.point(h,l,a,u)}_addA(e){let t=this.x.redMul(e.x),r=this.y.redMul(e.y),f=this.curve._mulD(this.t).redMul(e.t),i=e.zOne?this.z.clone():this.z.redMul(e.z),s=this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)),n=s.redISub(t).redISub(r),d=i.redSub(f),o=i.redIAdd(f),h=r.redISub(this.curve._mulA(t)),l=n.redMul(d),u=o.redMul(h),a=n.redMul(h),c=d.redMul(o);return this.curve.point(l,u,c,a)}dbl(){return this.isInfinity()?this:this._dbl()}_dbl(){let e=this.x.redSqr(),t=this.y.redSqr(),r=this.zOne?this.curve.two:this.z.redSqr().redIMuln(2),f=this.curve._mulA(e),i=this.x.redAdd(this.y).redSqr().redISub(e).redISub(t),s=f.redAdd(t),n=s.redSub(r),d=f.redISub(t),o=i.redMul(n),h=s.redMul(d),l=i.redMul(d),u=n.redMul(s);return this.curve.point(o,h,u,l)}getX(){return this.normalize(),this.x.fromRed()}getY(){return this.normalize(),this.y.fromRed()}eq(e){if(assert(e instanceof EdwardsPoint),assert(!this.z.isZero()),assert(!e.z.isZero()),this===e)return!0;if(this.z.eq(e.z))return this.x.eq(e.x)&&this.y.eq(e.y);let t=this.x.redMul(e.z),r=e.x.redMul(this.z);if(!t.eq(r))return!1;let f=this.y.redMul(e.z),i=e.y.redMul(this.z);return f.eq(i)}cmp(e){return assert(e instanceof EdwardsPoint),this.order().cmp(e.order())||this.getY().cmp(e.getY())||this.getX().cmp(e.getX())}isInfinity(){return assert(!this.z.isZero()),!!this.x.isZero()&&this.y.eq(this.z)}isOrder2(){return!this.isInfinity()&&this.x.isZero()}isOdd(){return this.normalize(),this.x.redIsOdd()}isEven(){return this.normalize(),this.x.redIsEven()}toP(){return this.normalize()}toJ(){return this}encode(){let e=this.getY();return e.setn(this.curve.signBit,this.x.redIsOdd()),this.curve.encodeAdjusted(e)}static decode(e,t){assert(e instanceof EdwardsCurve);let r=e.decodeAdjusted(t),f=0!==r.testn(e.signBit);if(r.setn(e.signBit,0),r.cmp(e.p)>=0)throw Error("Invalid point.");return e.pointFromY(r,f)}toJSON(e){if(this.isInfinity())return[];let t=this.getX().toJSON(),r=this.getY().toJSON();return!0===e&&this.pre?[t,r,this.pre.toJSON()]:[t,r]}toPretty(){let e=2*this.curve.fieldSize,t=toPretty(this.getX(),e),r=toPretty(this.getY(),e);return[t,r]}static fromJSON(e,t){if(assert(e instanceof EdwardsCurve),assert(Array.isArray(t)),assert(0===t.length||2===t.length||3===t.length),0===t.length)return e.point();let r=s.fromJSON(t[0]),f=s.fromJSON(t[1]),i=e.point(r,f);return t.length>2&&null!=t[2]&&(i.pre=Precomp.fromJSON(i,t[2])),i}[i](){return this.isInfinity()?"<EdwardsPoint: Infinity>":"<EdwardsPoint: x="+this.x.fromRed().toString(16,2)+" y="+this.y.fromRed().toString(16,2)+" z="+this.z.fromRed().toString(16,2)+">"}};let Precomp=class Precomp{constructor(){this.naf=null,this.windows=null,this.doubles=null,this.blinding=null,this.beta=null}map(e){assert("function"==typeof e);let t=new this.constructor;return this.naf&&(t.naf=this.naf.map(e)),this.doubles&&(t.doubles=this.doubles.map(e)),t}toJSON(){return{naf:this.naf?this.naf.toJSON():null,windows:this.windows?this.windows.toJSON():null,doubles:this.doubles?this.doubles.toJSON():null,blinding:this.blinding?this.blinding.toJSON():void 0}}fromJSON(e,t){return assert(e instanceof Point),assert(t&&"object"==typeof t),null!=t.naf&&(this.naf=NAF.fromJSON(e,t.naf)),null!=t.windows&&(this.windows=Windows.fromJSON(e,t.windows)),null!=t.doubles&&(this.doubles=Doubles.fromJSON(e,t.doubles)),null!=t.blinding&&(this.blinding=Blinding.fromJSON(e,t.blinding)),this}static fromJSON(e,t){return new this().fromJSON(e,t)}};let NAF=class NAF{constructor(e,t){this.width=e,this.points=t}map(e){assert("function"==typeof e);let{width:t}=this,r=[];for(let t of this.points)r.push(e(t));return new this.constructor(t,r)}toJSON(){return{width:this.width,points:this.points.slice(1).map(e=>e.toJSON())}}static fromJSON(e,t){assert(e instanceof Point),assert(t&&"object"==typeof t),assert(t.width>>>0===t.width),assert(Array.isArray(t.points));let{curve:r}=e,{width:f}=t,i=[e];for(let e of t.points)i.push(r.pointFromJSON(e));return new this(f,i)}};let Windows=class Windows{constructor(e,t,r){this.width=e,this.bits=t,this.points=r}toJSON(){return{width:this.width,bits:this.bits,points:this.points.slice(1).map(e=>e.toJSON())}}static fromJSON(e,t){assert(e instanceof Point),assert(t&&"object"==typeof t),assert(t.width>>>0===t.width),assert(t.bits>>>0===t.bits),assert(Array.isArray(t.points));let{curve:r}=e,{width:f,bits:i}=t,s=[e];for(let e of t.points)s.push(r.pointFromJSON(e));return new this(f,i,s)}};let Doubles=class Doubles{constructor(e,t){this.step=e,this.points=t}map(e){assert("function"==typeof e);let{step:t}=this,r=[];for(let t of this.points)r.push(e(t));return new this.constructor(t,r)}toJSON(){return{step:this.step,points:this.points.slice(1).map(e=>e.toJSON())}}static fromJSON(e,t){assert(e instanceof Point),assert(t&&"object"==typeof t),assert(t.step>>>0===t.step),assert(Array.isArray(t.points));let{curve:r}=e,{step:f}=t,i=[e];for(let e of t.points)i.push(r.pointFromJSON(e));return new this(f,i)}};let Blinding=class Blinding{constructor(e,t){this.blind=e,this.unblind=t}toJSON(){return{blind:this.blind.toJSON(),unblind:this.unblind.toJSON()}}static fromJSON(e,t){assert(e instanceof Point),assert(t&&"object"==typeof t);let{curve:r}=e,f=s.fromJSON(t.blind),i=r.pointFromJSON(t.unblind);return new this(f,i)}};let Endo=class Endo{constructor(e,t,r,f){this.beta=e,this.lambda=t,this.basis=r,this.pre=f}toJSON(){return{beta:this.beta.fromRed().toJSON(),lambda:this.lambda.toJSON(),basis:[this.basis[0].toJSON(),this.basis[1].toJSON()],pre:[this.pre[0],this.pre[1].toJSON(),this.pre[2].toJSON()]}}static fromJSON(e,t){assert(e instanceof Curve),assert(t&&"object"==typeof t),assert(Array.isArray(t.basis)),assert(Array.isArray(t.pre)),assert(2===t.basis.length),assert(3===t.pre.length),assert(t.pre[0]>>>0===t.pre[0]);let r=s.fromJSON(t.beta).toRed(e.red),f=s.fromJSON(t.lambda),i=[Vector.fromJSON(t.basis[0]),Vector.fromJSON(t.basis[1])],n=[t.pre[0],s.fromJSON(t.pre[1]),s.fromJSON(t.pre[2])];return new this(r,f,i,n)}};let Vector=class Vector{constructor(e,t){this.a=e,this.b=t}toJSON(){return{a:this.a.toJSON(),b:this.b.toJSON()}}static fromJSON(e){assert(e&&"object"==typeof e);let t=s.fromJSON(e.a),r=s.fromJSON(e.b);return new this(t,r)}};let h={__proto__:null,P192:class extends ShortCurve{constructor(e){super({id:"P192",ossl:"prime192v1",type:"short",endian:"be",hash:"SHA256",prime:"p192",p:["ffffffff ffffffff ffffffff fffffffe","ffffffff ffffffff"],a:["ffffffff ffffffff ffffffff fffffffe","ffffffff fffffffc"],b:["64210519 e59c80e7 0fa7e9ab 72243049","feb8deec c146b9b1"],n:["ffffffff ffffffff ffffffff 99def836","146bc9b1 b4d22831"],h:"1",z:"-5",g:[["188da80e b03090f6 7cbf20eb 43a18800","f4ff0afd 82ff1012"],["07192b95 ffc8da78 631011ed 6b24cdd5","73f977a1 1e794811"],e]})}},P224:class extends ShortCurve{constructor(e){super({id:"P224",ossl:"secp224r1",type:"short",endian:"be",hash:"SHA256",prime:"p224",p:["ffffffff ffffffff ffffffff ffffffff","00000000 00000000 00000001"],a:["ffffffff ffffffff ffffffff fffffffe","ffffffff ffffffff fffffffe"],b:["b4050a85 0c04b3ab f5413256 5044b0b7","d7bfd8ba 270b3943 2355ffb4"],n:["ffffffff ffffffff ffffffff ffff16a2","e0b8f03e 13dd2945 5c5c2a3d"],h:"1",z:"1f",g:[["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3","56c21122 343280d6 115c1d21"],["bd376388 b5f723fb 4c22dfe6 cd4375a0","5a074764 44d58199 85007e34"],e]})}},P256:class extends ShortCurve{constructor(e){super({id:"P256",ossl:"prime256v1",type:"short",endian:"be",hash:"SHA256",prime:null,p:["ffffffff 00000001 00000000 00000000","00000000 ffffffff ffffffff ffffffff"],a:["ffffffff 00000001 00000000 00000000","00000000 ffffffff ffffffff fffffffc"],b:["5ac635d8 aa3a93e7 b3ebbd55 769886bc","651d06b0 cc53b0f6 3bce3c3e 27d2604b"],n:["ffffffff 00000000 ffffffff ffffffff","bce6faad a7179e84 f3b9cac2 fc632551"],h:"1",z:"-a",g:[["6b17d1f2 e12c4247 f8bce6e5 63a440f2","77037d81 2deb33a0 f4a13945 d898c296"],["4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16","2bce3357 6b315ece cbb64068 37bf51f5"],e]})}},P384:class extends ShortCurve{constructor(e){super({id:"P384",ossl:"secp384r1",type:"short",endian:"be",hash:"SHA384",prime:null,p:["ffffffff ffffffff ffffffff ffffffff","ffffffff ffffffff ffffffff fffffffe","ffffffff 00000000 00000000 ffffffff"],a:["ffffffff ffffffff ffffffff ffffffff","ffffffff ffffffff ffffffff fffffffe","ffffffff 00000000 00000000 fffffffc"],b:["b3312fa7 e23ee7e4 988e056b e3f82d19","181d9c6e fe814112 0314088f 5013875a","c656398d 8a2ed19d 2a85c8ed d3ec2aef"],n:["ffffffff ffffffff ffffffff ffffffff","ffffffff ffffffff c7634d81 f4372ddf","581a0db2 48b0a77a ecec196a ccc52973"],h:"1",z:"-c",g:[["aa87ca22 be8b0537 8eb1c71e f320ad74","6e1d3b62 8ba79b98 59f741e0 82542a38","5502f25d bf55296c 3a545e38 72760ab7"],["3617de4a 96262c6f 5d9e98bf 9292dc29","f8f41dbd 289a147c e9da3113 b5f0b8c0","0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"],e]})}},P521:class extends ShortCurve{constructor(e){super({id:"P521",ossl:"secp521r1",type:"short",endian:"be",hash:"SHA512",prime:"p521",p:["000001ff ffffffff ffffffff ffffffff","ffffffff ffffffff ffffffff ffffffff","ffffffff ffffffff ffffffff ffffffff","ffffffff ffffffff ffffffff ffffffff","ffffffff"],a:["000001ff ffffffff ffffffff ffffffff","ffffffff ffffffff ffffffff ffffffff","ffffffff ffffffff ffffffff ffffffff","ffffffff ffffffff ffffffff ffffffff","fffffffc"],b:["00000051 953eb961 8e1c9a1f 929a21a0","b68540ee a2da725b 99b315f3 b8b48991","8ef109e1 56193951 ec7e937b 1652c0bd","3bb1bf07 3573df88 3d2c34f1 ef451fd4","6b503f00"],n:["000001ff ffffffff ffffffff ffffffff","ffffffff ffffffff ffffffff ffffffff","fffffffa 51868783 bf2f966b 7fcc0148","f709a5d0 3bb5c9b8 899c47ae bb6fb71e","91386409"],h:"1",z:"-4",g:[["000000c6 858e06b7 0404e9cd 9e3ecb66","2395b442 9c648139 053fb521 f828af60","6b4d3dba a14b5e77 efe75928 fe1dc127","a2ffa8de 3348b3c1 856a429b f97e7e31","c2e5bd66"],["00000118 39296a78 9a3bc004 5c8a5fb4","2c7d1bd9 98f54449 579b4468 17afbd17","273e662c 97ee7299 5ef42640 c550b901","3fad0761 353c7086 a272c240 88be9476","9fd16650"],e]})}},SECP256K1:class extends ShortCurve{constructor(e){super({id:"SECP256K1",ossl:"secp256k1",type:"short",endian:"be",hash:"SHA256",prime:"k256",p:["ffffffff ffffffff ffffffff ffffffff","ffffffff ffffffff fffffffe fffffc2f"],a:"0",b:"7",n:["ffffffff ffffffff ffffffff fffffffe","baaedce6 af48a03b bfd25e8c d0364141"],h:"1",z:"1",c:["0a2d2ba9 3507f1df 233770c2 a797962c","c61f6d15 da14ecd4 7d8d27ae 1cd5f852"],g:[["79be667e f9dcbbac 55a06295 ce870b07","029bfcdb 2dce28d9 59f2815b 16f81798"],["483ada77 26a3c465 5da4fbfc 0e1108a8","fd17b448 a6855419 9c47d08f fb10d4b8"],e],endo:{beta:["7ae96a2b 657c0710 6e64479e ac3434e9","9cf04975 12f58995 c1396c28 719501ee"],lambda:["5363ad4c c05c30e0 a5261c02 8812645a","122e22ea 20816678 df02967c 1b23bd72"],basis:[{a:"3086d221a7d46bcde86c90e49284eb15",b:"-e4437ed6010e88286f547fa90abfe4c3"},{a:"114ca50f7a8e2f3f657c1108d9d44cfd8",b:"3086d221a7d46bcde86c90e49284eb15"}],pre:[384,["3086d221 a7d46bcd e86c90e4 9284eb15","3daa8a14 71e8ca7f e893209a 45dbb031"],["-","e4437ed6 010e8828 6f547fa9 0abfe4c4","221208ac 9df506c6 1571b4ae 8ac47f71"]]}})}},BRAINPOOLP256:class extends ShortCurve{constructor(e){super({id:"BRAINPOOLP256",ossl:"brainpoolP256r1",type:"short",endian:"be",hash:"SHA256",prime:null,p:["a9fb57db a1eea9bc 3e660a90 9d838d72","6e3bf623 d5262028 2013481d 1f6e5377"],a:["7d5a0975 fc2c3057 eef67530 417affe7","fb8055c1 26dc5c6c e94a4b44 f330b5d9"],b:["26dc5c6c e94a4b44 f330b5d9 bbd77cbf","95841629 5cf7e1ce 6bccdc18 ff8c07b6"],n:["a9fb57db a1eea9bc 3e660a90 9d838d71","8c397aa3 b561a6f7 901e0e82 974856a7"],h:"1",z:"-2",g:[["8bd2aeb9 cb7e57cb 2c4b482f fc81b7af","b9de27e1 e3bd23c2 3a4453bd 9ace3262"],["547ef835 c3dac4fd 97f8461a 14611dc9","c2774513 2ded8e54 5c1d54c7 2f046997"],e]})}},BRAINPOOLP384:class extends ShortCurve{constructor(e){super({id:"BRAINPOOLP384",ossl:"brainpoolP384r1",type:"short",endian:"be",hash:"SHA384",prime:null,p:["8cb91e82 a3386d28 0f5d6f7e 50e641df","152f7109 ed5456b4 12b1da19 7fb71123","acd3a729 901d1a71 87470013 3107ec53"],a:["7bc382c6 3d8c150c 3c72080a ce05afa0","c2bea28e 4fb22787 139165ef ba91f90f","8aa5814a 503ad4eb 04a8c7dd 22ce2826"],b:["04a8c7dd 22ce2826 8b39b554 16f0447c","2fb77de1 07dcd2a6 2e880ea5 3eeb62d5","7cb43902 95dbc994 3ab78696 fa504c11"],n:["8cb91e82 a3386d28 0f5d6f7e 50e641df","152f7109 ed5456b3 1f166e6c ac0425a7","cf3ab6af 6b7fc310 3b883202 e9046565"],h:"1",z:"-5",g:[["1d1c64f0 68cf45ff a2a63a81 b7c13f6b","8847a3e7 7ef14fe3 db7fcafe 0cbd10e8","e826e034 36d646aa ef87b2e2 47d4af1e"],["8abe1d75 20f9c2a4 5cb1eb8e 95cfd552","62b70b29 feec5864 e19c054f f9912928","0e464621 77918111 42820341 263c5315"],e]})}},BRAINPOOLP512:class extends ShortCurve{constructor(e){super({id:"BRAINPOOLP512",ossl:"brainpoolP512r1",type:"short",endian:"be",hash:"SHA512",prime:null,p:["aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07","cb308db3 b3c9d20e d6639cca 70330871","7d4d9b00 9bc66842 aecda12a e6a380e6","2881ff2f 2d82c685 28aa6056 583a48f3"],a:["7830a331 8b603b89 e2327145 ac234cc5","94cbdd8d 3df91610 a83441ca ea9863bc","2ded5d5a a8253aa1 0a2ef1c9 8b9ac8b5","7f1117a7 2bf2c7b9 e7c1ac4d 77fc94ca"],b:["3df91610 a83441ca ea9863bc 2ded5d5a","a8253aa1 0a2ef1c9 8b9ac8b5 7f1117a7","2bf2c7b9 e7c1ac4d 77fc94ca dc083e67","984050b7 5ebae5dd 2809bd63 8016f723"],n:["aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07","cb308db3 b3c9d20e d6639cca 70330870","553e5c41 4ca92619 41866119 7fac1047","1db1d381 085ddadd b5879682 9ca90069"],h:"1",z:"7",g:[["81aee4bd d82ed964 5a21322e 9c4c6a93","85ed9f70 b5d916c1 b43b62ee f4d0098e","ff3b1f78 e2d0d48d 50d1687b 93b97d5f","7c6d5047 406a5e68 8b352209 bcb9f822"],["7dde385d 566332ec c0eabfa9 cf7822fd","f209f700 24a57b1a a000c55b 881f8111","b2dcde49 4a5f485e 5bca4bd8 8a2763ae","d1ca2b2f a8f05406 78cd1e0f 3ad80892"],e]})}},X25519:class extends MontCurve{constructor(){super({id:"X25519",ossl:"X25519",type:"mont",endian:"le",hash:"SHA512",prime:"p25519",p:["7fffffff ffffffff ffffffff ffffffff","ffffffff ffffffff ffffffff ffffffed"],a:"76d06",b:"1",n:["10000000 00000000 00000000 00000000","14def9de a2f79cd6 5812631a 5cf5d3ed"],h:"8",z:"2",g:[["00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000009"],["5f51e65e 475f794b 1fe122d3 88b72eb3","6dc2b281 92839e4d d6163a5d 81312c14"]],torsion:[[],[["00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000"],["00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000"]],[["00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000001"],["6be4f497 f9a9c2af c21fa77a d7f4a6ef","635a11c7 284a9363 e9a248ef 9c884415"]],[["00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000001"],["141b0b68 06563d50 3de05885 280b5910","9ca5ee38 d7b56c9c 165db710 6377bbd8"]],[["57119fd0 dd4e22d8 868e1c58 c45c4404","5bef839c 55b1d0b1 248c50a3 bc959c5f"],["68c59389 3d458e64 31c6ca00 45fb5015","20a44346 8eaa68dd 0f103842 048065b7"]],[["57119fd0 dd4e22d8 868e1c58 c45c4404","5bef839c 55b1d0b1 248c50a3 bc959c5f"],["173a6c76 c2ba719b ce3935ff ba04afea","df5bbcb9 71559722 f0efc7bd fb7f9a36"]],[["00b8495f 16056286 fdb1329c eb8d09da","6ac49ff1 fae35616 aeb8413b 7c7aebe0"],["3931c129 569e83a5 29482c14 e628b457","933bfc29 ed801b4d 68871483 92507b1a"]],[["00b8495f 16056286 fdb1329c eb8d09da","6ac49ff1 fae35616 aeb8413b 7c7aebe0"],["46ce3ed6 a9617c5a d6b7d3eb 19d74ba8","6cc403d6 127fe4b2 9778eb7c 6daf84d3"]]]})}},X448:class extends MontCurve{constructor(){super({id:"X448",ossl:"X448",type:"mont",endian:"le",hash:"SHAKE256",prime:"p448",p:["ffffffff ffffffff ffffffff ffffffff","ffffffff ffffffff fffffffe ffffffff","ffffffff ffffffff ffffffff ffffffff","ffffffff ffffffff"],a:"262a6",b:"1",n:["3fffffff ffffffff ffffffff ffffffff","ffffffff ffffffff ffffffff 7cca23e9","c44edb49 aed63690 216cc272 8dc58f55","2378c292 ab5844f3"],h:"4",z:"-1",g:[["00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000005"],["7d235d12 95f5b1f6 6c98ab6e 58326fce","cbae5d34 f55545d0 60f75dc2 8df3f6ed","b8027e23 46430d21 1312c4b1 50677af7","6fd7223d 457b5b1a"]],torsion:[[],[["00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000000"],["00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000000"]],[["ffffffff ffffffff ffffffff ffffffff","ffffffff ffffffff fffffffe ffffffff","ffffffff ffffffff ffffffff ffffffff","ffffffff fffffffe"],["ba4d3a08 29b6112f 8812e51b a0bb2abe","bc1cb08e b48e5569 36ba50fd d2e7d68a","f8cb3216 0522425b 3f990812 abbe635a","d37a21e1 7551b193"]],[["ffffffff ffffffff ffffffff ffffffff","ffffffff ffffffff fffffffe ffffffff","ffffffff ffffffff ffffffff ffffffff","ffffffff fffffffe"],["45b2c5f7 d649eed0 77ed1ae4 5f44d541","43e34f71 4b71aa96 c945af01 2d182975","0734cde9 faddbda4 c066f7ed 54419ca5","2c85de1e 8aae4e6c"]]]})}},MONT448:class extends MontCurve{constructor(){super({id:"MONT448",ossl:null,type:"mont",endian:"le",hash:"SHAKE256",prime:"p448",p:["ffffffff ffffffff ffffffff ffffffff","ffffffff ffffffff fffffffe ffffffff","ffffffff ffffffff ffffffff ffffffff","ffffffff ffffffff"],a:["b2cf97d2 d43459a9 31ed36b1 fc4e3cb5","5d93f8d2 22746997 60ccffc6 49961ed6","c5b05fca c24864ed 6fb59697 931b78da","84ddecd8 ca2b5cfb"],b:"1",n:["3fffffff ffffffff ffffffff ffffffff","ffffffff ffffffff ffffffff 7cca23e9","c44edb49 aed63690 216cc272 8dc58f55","2378c292 ab5844f3"],h:"4",z:"-1",g:[["ac0d24cc c6c75cb0 eb71f81e 7a6edf51","48e88aee 009a2a24 e795687e c28e125a","3e6730a6 0d46367b aa7fe99d 152128dc","41321bc7 7817f059"],["5a4437f6 80c0d0db 9b061276 d5d0ffcc","e786ff33 b6a53d30 98746425 82e66f09","4433dae7 7244a6e2 6b11e905 7228f483","556c41a5 913f55fe"]],torsion:[[],[["00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000000"],["00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000000"]],[["ffffffff ffffffff ffffffff ffffffff","ffffffff ffffffff fffffffe ffffffff","ffffffff ffffffff ffffffff ffffffff","ffffffff fffffffe"],["bec92fd0 6da2acf2 b4e261e8 7cef0d34","22e75c18 3c589857 b71924e5 73c2f9ce","e18da5f2 466e2f39 3c2eedf0 f105a60a","b40c717d 4f1e1fd7"]],[["ffffffff ffffffff ffffffff ffffffff","ffffffff ffffffff fffffffe ffffffff","ffffffff ffffffff ffffffff ffffffff","ffffffff fffffffe"],["4136d02f 925d530d 4b1d9e17 8310f2cb","dd18a3e7 c3a767a8 48e6db19 8c3d0631","1e725a0d b991d0c6 c3d1120f 0efa59f5","4bf38e82 b0e1e028"]]]})}},ED25519:class extends EdwardsCurve{constructor(e){super({id:"ED25519",ossl:"ED25519",type:"edwards",endian:"le",hash:"SHA512",prefix:"SigEd25519 no Ed25519 collisions",context:!1,prime:"p25519",p:["7fffffff ffffffff ffffffff ffffffff","ffffffff ffffffff ffffffff ffffffed"],a:"-1",d:["52036cee 2b6ffe73 8cc74079 7779e898","00700a4d 4141d8ab 75eb4dca 135978a3"],n:["10000000 00000000 00000000 00000000","14def9de a2f79cd6 5812631a 5cf5d3ed"],h:"8",z:"2",g:[["216936d3 cd6e53fe c0a4e231 fdd6dc5c","692cc760 9525a7b2 c9562d60 8f25d51a"],["66666666 66666666 66666666 66666666","66666666 66666666 66666666 66666658"],e],torsion:[[["00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000"],["00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000001"]],[["00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000"],["7fffffff ffffffff ffffffff ffffffff","ffffffff ffffffff ffffffff ffffffec"]],[["2b832480 4fc1df0b 2b4d0099 3dfbd7a7","2f431806 ad2fe478 c4ee1b27 4a0ea0b0"],["00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000"]],[["547cdb7f b03e20f4 d4b2ff66 c2042858","d0bce7f9 52d01b87 3b11e4d8 b5f15f3d"],["00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000"]],[["1fd5b9a0 06394a28 e9339932 38de4abb","5c193c70 13e5e238 dea14646 c545d14a"],["05fc536d 880238b1 3933c6d3 05acdfd5","f098eff2 89f4c345 b027b2c2 8f95e826"]],[["602a465f f9c6b5d7 16cc66cd c721b544","a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3"],["05fc536d 880238b1 3933c6d3 05acdfd5","f098eff2 89f4c345 b027b2c2 8f95e826"]],[["1fd5b9a0 06394a28 e9339932 38de4abb","5c193c70 13e5e238 dea14646 c545d14a"],["7a03ac92 77fdc74e c6cc392c fa53202a","0f67100d 760b3cba 4fd84d3d 706a17c7"]],[["602a465f f9c6b5d7 16cc66cd c721b544","a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3"],["7a03ac92 77fdc74e c6cc392c fa53202a","0f67100d 760b3cba 4fd84d3d 706a17c7"]]]})}},ISO448:class extends EdwardsCurve{constructor(e){super({id:"ISO448",ossl:null,type:"edwards",endian:"le",hash:"SHAKE256",prefix:"SigEd448",context:!0,prime:"p448",p:["ffffffff ffffffff ffffffff ffffffff","ffffffff ffffffff fffffffe ffffffff","ffffffff ffffffff ffffffff ffffffff","ffffffff ffffffff"],a:"1",d:["d78b4bdc 7f0daf19 f24f38c2 9373a2cc","ad461572 42a50f37 809b1da3 412a12e7","9ccc9c81 264cfe9a d0809970 58fb61c4","243cc32d baa156b9"],n:["3fffffff ffffffff ffffffff ffffffff","ffffffff ffffffff ffffffff 7cca23e9","c44edb49 aed63690 216cc272 8dc58f55","2378c292 ab5844f3"],h:"4",z:"-1",g:[["79a70b2b 70400553 ae7c9df4 16c792c6","1128751a c9296924 0c25a07d 728bdc93","e21f7787 ed697224 9de732f3 8496cd11","69871309 3e9c04fc"],["7fffffff ffffffff ffffffff ffffffff","ffffffff ffffffff ffffffff 80000000","00000000 00000000 00000000 00000000","00000000 00000001"],e],torsion:[[["00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000000"],["00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000001"]],[["00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000000"],["ffffffff ffffffff ffffffff ffffffff","ffffffff ffffffff fffffffe ffffffff","ffffffff ffffffff ffffffff ffffffff","ffffffff fffffffe"]],[["00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000001"],["00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000000"]],[["ffffffff ffffffff ffffffff ffffffff","ffffffff ffffffff fffffffe ffffffff","ffffffff ffffffff ffffffff ffffffff","ffffffff fffffffe"],["00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000000"]]]})}},ED448:class extends EdwardsCurve{constructor(e){super({id:"ED448",ossl:"ED448",type:"edwards",endian:"le",hash:"SHAKE256",prefix:"SigEd448",context:!0,prime:"p448",p:["ffffffff ffffffff ffffffff ffffffff","ffffffff ffffffff fffffffe ffffffff","ffffffff ffffffff ffffffff ffffffff","ffffffff ffffffff"],a:"1",d:["ffffffff ffffffff ffffffff ffffffff","ffffffff ffffffff fffffffe ffffffff","ffffffff ffffffff ffffffff ffffffff","ffffffff ffff6756"],n:["3fffffff ffffffff ffffffff ffffffff","ffffffff ffffffff ffffffff 7cca23e9","c44edb49 aed63690 216cc272 8dc58f55","2378c292 ab5844f3"],h:"4",z:"-1",g:[["4f1970c6 6bed0ded 221d15a6 22bf36da","9e146570 470f1767 ea6de324 a3d3a464","12ae1af7 2ab66511 433b80e1 8b00938e","2626a82b c70cc05e"],["693f4671 6eb6bc24 88762037 56c9c762","4bea7373 6ca39840 87789c1e 05a0c2d7","3ad3ff1c e67c39c4 fdbd132c 4ed7c8ad","9808795b f230fa14"],e],torsion:[[["00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000000"],["00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000001"]],[["00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000000"],["ffffffff ffffffff ffffffff ffffffff","ffffffff ffffffff fffffffe ffffffff","ffffffff ffffffff ffffffff ffffffff","ffffffff fffffffe"]],[["00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000001"],["00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000000"]],[["ffffffff ffffffff ffffffff ffffffff","ffffffff ffffffff fffffffe ffffffff","ffffffff ffffffff ffffffff ffffffff","ffffffff fffffffe"],["00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000000 00000000 00000000","00000000 00000000"]]]})}}},l={__proto__:null,P192:null,P224:null,P256:null,P384:null,P521:null,SECP256K1:null,BRAINPOOLP256:null,BRAINPOOLP384:null,BRAINPOOLP512:null,X25519:null,X448:null,MONT448:null,ED25519:null,ISO448:null,ED448:null};function getNAF(e,t,r){let f;assert(e instanceof s),assert(!e.red),assert(t>>>0===t),assert(r>>>0===r);let i=Array(r),n=e.bitLength()+1,d=1|e.sign();assert(n<=r);for(let e=0;e<r;e++)i[e]=0;let o=0,h=0;for(;o<n;){if(e.bit(o)===h){o+=1;continue}h=(f=e.bits(o,t)+h)>>t-1&1,f-=h<<t,i[o]=d*f,o+=t}return assert(0===h),i}function assert(e,t){if(!e){let e=Error(t||"Assertion failed");throw Error.captureStackTrace&&Error.captureStackTrace(e,assert),e}}function wrapErrors(e){assert("function"==typeof e);try{return e()}catch(e){if("X is not a square mod P."===e.message||"Not invertible."===e.message)throw Error("Invalid point.");throw e}}function cubeRoots(e){let t=function(e){assert(e instanceof s),assert(e.red);let t=e.red.m;if(0>=t.cmpn(3))return e.clone();if(2===t.modrn(3)){let r=t.ushln(1).isubn(1).idivn(3);return e.redPow(r)}let r=t.modrn(9);if(4===r){let r=t.ushln(1).iaddn(1).idivn(9),f=e.redPow(r),i=f.redSqr().redMul(f);if(!i.eq(e))throw Error("X is not a cube mod P.");return f}if(7===r){let r=t.addn(2).idivn(9),f=e.redPow(r),i=f.redSqr().redMul(f);if(!i.eq(e))throw Error("X is not a cube mod P.");return f}throw Error("Not implemented.")}(e);if(1===e.red.m.modrn(3)){let r=new s(2).toRed(e.red),f=new s(3).toRed(e.red),i=r.redInvert(),n=f.redNeg().redSqrt().redMul(i),d=n.redNeg(),o=n.redSub(i),h=d.redSub(i),l=t.redMul(o),u=t.redMul(h);return[t,l,u]}return[t]}function uncube(e){for(let t of cubeRoots(e))if(t.redJacobi()>=0)return t;throw Error("X^(1/3) is not a square mod P.")}function randomInt(e){return s.randomBits(e,32).toNumber()}function memoize(e,t){let r=new WeakMap;return function(f,i){let s=1&i,n=r.get(f);if(n&&null!==n[s])return n[s];let d=e.call(t,f,i);return r.has(f)||r.set(f,[null,null]),r.get(f)[s]=d,d}}function toPretty(e,t){assert(e instanceof s),assert(t>>>0===t),7&t&&(t+=8-(7&t));let r=e.toString(16,t),f=[],i=[];assert((7&r.length)==0);for(let e=0;e<r.length;e+=8)f.push(r.slice(e,e+8));for(let e=0;e<f.length;e+=4)i.push(f.slice(e,e+4).join(" "));return i}t.Curve=Curve,t.Point=Point,t.ShortCurve=ShortCurve,t.ShortPoint=ShortPoint,t.JPoint=JPoint,t.MontCurve=MontCurve,t.MontPoint=MontPoint,t.XPoint=XPoint,t.EdwardsCurve=EdwardsCurve,t.EdwardsPoint=EdwardsPoint,t.curves=h,t.curve=function(e,...t){assert("string"==typeof e);let r=e.toUpperCase(),f=l[r];if(!f){let i=h[r];if(!i)throw Error(`Curve not found: "${e}".`);f=new i(...t),l[r]=f}return f},t.register=function(e,t){assert("string"==typeof e),assert("function"==typeof t);let r=e.toUpperCase();if(h[r])throw Error(`Curve already registered: "${e}".`);h[r]=t,l[r]=null}}}]);
//# sourceMappingURL=2b38c15a.29779d56c0a8cd8e.js.map