{"version":3,"file":"static/chunks/093d6630.6af573af580ed8cf.js","mappings":"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","sources":["webpack://_N_E/./node_modules/@confio/ics23/build/generated/codecimpl.js","webpack://_N_E/<anon>"],"sourcesContent":["/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\");\n\n// Common aliases\nvar $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n$root.ics23 = (function() {\n\n    /**\n     * Namespace ics23.\n     * @exports ics23\n     * @namespace\n     */\n    var ics23 = {};\n\n    /**\n     * HashOp enum.\n     * @name ics23.HashOp\n     * @enum {string}\n     * @property {number} NO_HASH=0 NO_HASH value\n     * @property {number} SHA256=1 SHA256 value\n     * @property {number} SHA512=2 SHA512 value\n     * @property {number} KECCAK=3 KECCAK value\n     * @property {number} RIPEMD160=4 RIPEMD160 value\n     * @property {number} BITCOIN=5 BITCOIN value\n     * @property {number} SHA512_256=6 SHA512_256 value\n     */\n    ics23.HashOp = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"NO_HASH\"] = 0;\n        values[valuesById[1] = \"SHA256\"] = 1;\n        values[valuesById[2] = \"SHA512\"] = 2;\n        values[valuesById[3] = \"KECCAK\"] = 3;\n        values[valuesById[4] = \"RIPEMD160\"] = 4;\n        values[valuesById[5] = \"BITCOIN\"] = 5;\n        values[valuesById[6] = \"SHA512_256\"] = 6;\n        return values;\n    })();\n\n    /**\n     * LengthOp defines how to process the key and value of the LeafOp\n     * to include length information. After encoding the length with the given\n     * algorithm, the length will be prepended to the key and value bytes.\n     * (Each one with it's own encoded length)\n     * @name ics23.LengthOp\n     * @enum {string}\n     * @property {number} NO_PREFIX=0 NO_PREFIX value\n     * @property {number} VAR_PROTO=1 VAR_PROTO value\n     * @property {number} VAR_RLP=2 VAR_RLP value\n     * @property {number} FIXED32_BIG=3 FIXED32_BIG value\n     * @property {number} FIXED32_LITTLE=4 FIXED32_LITTLE value\n     * @property {number} FIXED64_BIG=5 FIXED64_BIG value\n     * @property {number} FIXED64_LITTLE=6 FIXED64_LITTLE value\n     * @property {number} REQUIRE_32_BYTES=7 REQUIRE_32_BYTES value\n     * @property {number} REQUIRE_64_BYTES=8 REQUIRE_64_BYTES value\n     */\n    ics23.LengthOp = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"NO_PREFIX\"] = 0;\n        values[valuesById[1] = \"VAR_PROTO\"] = 1;\n        values[valuesById[2] = \"VAR_RLP\"] = 2;\n        values[valuesById[3] = \"FIXED32_BIG\"] = 3;\n        values[valuesById[4] = \"FIXED32_LITTLE\"] = 4;\n        values[valuesById[5] = \"FIXED64_BIG\"] = 5;\n        values[valuesById[6] = \"FIXED64_LITTLE\"] = 6;\n        values[valuesById[7] = \"REQUIRE_32_BYTES\"] = 7;\n        values[valuesById[8] = \"REQUIRE_64_BYTES\"] = 8;\n        return values;\n    })();\n\n    ics23.ExistenceProof = (function() {\n\n        /**\n         * Properties of an ExistenceProof.\n         * @memberof ics23\n         * @interface IExistenceProof\n         * @property {Uint8Array|null} [key] ExistenceProof key\n         * @property {Uint8Array|null} [value] ExistenceProof value\n         * @property {ics23.ILeafOp|null} [leaf] ExistenceProof leaf\n         * @property {Array.<ics23.IInnerOp>|null} [path] ExistenceProof path\n         */\n\n        /**\n         * Constructs a new ExistenceProof.\n         * @memberof ics23\n         * @classdesc ExistenceProof takes a key and a value and a set of steps to perform on it.\n         * The result of peforming all these steps will provide a \"root hash\", which can\n         * be compared to the value in a header.\n         * \n         * Since it is computationally infeasible to produce a hash collission for any of the used\n         * cryptographic hash functions, if someone can provide a series of operations to transform\n         * a given key and value into a root hash that matches some trusted root, these key and values\n         * must be in the referenced merkle tree.\n         * \n         * The only possible issue is maliablity in LeafOp, such as providing extra prefix data,\n         * which should be controlled by a spec. Eg. with lengthOp as NONE,\n         * prefix = FOO, key = BAR, value = CHOICE\n         * and\n         * prefix = F, key = OOBAR, value = CHOICE\n         * would produce the same value.\n         * \n         * With LengthOp this is tricker but not impossible. Which is why the \"leafPrefixEqual\" field\n         * in the ProofSpec is valuable to prevent this mutability. And why all trees should\n         * length-prefix the data before hashing it.\n         * @implements IExistenceProof\n         * @constructor\n         * @param {ics23.IExistenceProof=} [properties] Properties to set\n         */\n        function ExistenceProof(properties) {\n            this.path = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ExistenceProof key.\n         * @member {Uint8Array} key\n         * @memberof ics23.ExistenceProof\n         * @instance\n         */\n        ExistenceProof.prototype.key = $util.newBuffer([]);\n\n        /**\n         * ExistenceProof value.\n         * @member {Uint8Array} value\n         * @memberof ics23.ExistenceProof\n         * @instance\n         */\n        ExistenceProof.prototype.value = $util.newBuffer([]);\n\n        /**\n         * ExistenceProof leaf.\n         * @member {ics23.ILeafOp|null|undefined} leaf\n         * @memberof ics23.ExistenceProof\n         * @instance\n         */\n        ExistenceProof.prototype.leaf = null;\n\n        /**\n         * ExistenceProof path.\n         * @member {Array.<ics23.IInnerOp>} path\n         * @memberof ics23.ExistenceProof\n         * @instance\n         */\n        ExistenceProof.prototype.path = $util.emptyArray;\n\n        /**\n         * Creates a new ExistenceProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {ics23.IExistenceProof=} [properties] Properties to set\n         * @returns {ics23.ExistenceProof} ExistenceProof instance\n         */\n        ExistenceProof.create = function create(properties) {\n            return new ExistenceProof(properties);\n        };\n\n        /**\n         * Encodes the specified ExistenceProof message. Does not implicitly {@link ics23.ExistenceProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {ics23.IExistenceProof} message ExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ExistenceProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\"))\n                $root.ics23.LeafOp.encode(message.leaf, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            if (message.path != null && message.path.length)\n                for (var i = 0; i < message.path.length; ++i)\n                    $root.ics23.InnerOp.encode(message.path[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified ExistenceProof message, length delimited. Does not implicitly {@link ics23.ExistenceProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {ics23.IExistenceProof} message ExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes an ExistenceProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.ExistenceProof} ExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ExistenceProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.ExistenceProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                case 2:\n                    message.value = reader.bytes();\n                    break;\n                case 3:\n                    message.leaf = $root.ics23.LeafOp.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    if (!(message.path && message.path.length))\n                        message.path = [];\n                    message.path.push($root.ics23.InnerOp.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes an ExistenceProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.ExistenceProof} ExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies an ExistenceProof message.\n         * @function verify\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        ExistenceProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key)))\n                    return \"key: buffer expected\";\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                if (!(message.value && typeof message.value.length === \"number\" || $util.isString(message.value)))\n                    return \"value: buffer expected\";\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\")) {\n                var error = $root.ics23.LeafOp.verify(message.leaf);\n                if (error)\n                    return \"leaf.\" + error;\n            }\n            if (message.path != null && message.hasOwnProperty(\"path\")) {\n                if (!Array.isArray(message.path))\n                    return \"path: array expected\";\n                for (var i = 0; i < message.path.length; ++i) {\n                    var error = $root.ics23.InnerOp.verify(message.path[i]);\n                    if (error)\n                        return \"path.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates an ExistenceProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.ExistenceProof} ExistenceProof\n         */\n        ExistenceProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.ExistenceProof)\n                return object;\n            var message = new $root.ics23.ExistenceProof();\n            if (object.key != null)\n                if (typeof object.key === \"string\")\n                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);\n                else if (object.key.length)\n                    message.key = object.key;\n            if (object.value != null)\n                if (typeof object.value === \"string\")\n                    $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);\n                else if (object.value.length)\n                    message.value = object.value;\n            if (object.leaf != null) {\n                if (typeof object.leaf !== \"object\")\n                    throw TypeError(\".ics23.ExistenceProof.leaf: object expected\");\n                message.leaf = $root.ics23.LeafOp.fromObject(object.leaf);\n            }\n            if (object.path) {\n                if (!Array.isArray(object.path))\n                    throw TypeError(\".ics23.ExistenceProof.path: array expected\");\n                message.path = [];\n                for (var i = 0; i < object.path.length; ++i) {\n                    if (typeof object.path[i] !== \"object\")\n                        throw TypeError(\".ics23.ExistenceProof.path: object expected\");\n                    message.path[i] = $root.ics23.InnerOp.fromObject(object.path[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from an ExistenceProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {ics23.ExistenceProof} message ExistenceProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        ExistenceProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.path = [];\n            if (options.defaults) {\n                if (options.bytes === String)\n                    object.key = \"\";\n                else {\n                    object.key = [];\n                    if (options.bytes !== Array)\n                        object.key = $util.newBuffer(object.key);\n                }\n                if (options.bytes === String)\n                    object.value = \"\";\n                else {\n                    object.value = [];\n                    if (options.bytes !== Array)\n                        object.value = $util.newBuffer(object.value);\n                }\n                object.leaf = null;\n            }\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\"))\n                object.leaf = $root.ics23.LeafOp.toObject(message.leaf, options);\n            if (message.path && message.path.length) {\n                object.path = [];\n                for (var j = 0; j < message.path.length; ++j)\n                    object.path[j] = $root.ics23.InnerOp.toObject(message.path[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this ExistenceProof to JSON.\n         * @function toJSON\n         * @memberof ics23.ExistenceProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        ExistenceProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ExistenceProof;\n    })();\n\n    ics23.NonExistenceProof = (function() {\n\n        /**\n         * Properties of a NonExistenceProof.\n         * @memberof ics23\n         * @interface INonExistenceProof\n         * @property {Uint8Array|null} [key] NonExistenceProof key\n         * @property {ics23.IExistenceProof|null} [left] NonExistenceProof left\n         * @property {ics23.IExistenceProof|null} [right] NonExistenceProof right\n         */\n\n        /**\n         * Constructs a new NonExistenceProof.\n         * @memberof ics23\n         * @classdesc Represents a NonExistenceProof.\n         * @implements INonExistenceProof\n         * @constructor\n         * @param {ics23.INonExistenceProof=} [properties] Properties to set\n         */\n        function NonExistenceProof(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * NonExistenceProof key.\n         * @member {Uint8Array} key\n         * @memberof ics23.NonExistenceProof\n         * @instance\n         */\n        NonExistenceProof.prototype.key = $util.newBuffer([]);\n\n        /**\n         * NonExistenceProof left.\n         * @member {ics23.IExistenceProof|null|undefined} left\n         * @memberof ics23.NonExistenceProof\n         * @instance\n         */\n        NonExistenceProof.prototype.left = null;\n\n        /**\n         * NonExistenceProof right.\n         * @member {ics23.IExistenceProof|null|undefined} right\n         * @memberof ics23.NonExistenceProof\n         * @instance\n         */\n        NonExistenceProof.prototype.right = null;\n\n        /**\n         * Creates a new NonExistenceProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {ics23.INonExistenceProof=} [properties] Properties to set\n         * @returns {ics23.NonExistenceProof} NonExistenceProof instance\n         */\n        NonExistenceProof.create = function create(properties) {\n            return new NonExistenceProof(properties);\n        };\n\n        /**\n         * Encodes the specified NonExistenceProof message. Does not implicitly {@link ics23.NonExistenceProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {ics23.INonExistenceProof} message NonExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        NonExistenceProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);\n            if (message.left != null && message.hasOwnProperty(\"left\"))\n                $root.ics23.ExistenceProof.encode(message.left, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.right != null && message.hasOwnProperty(\"right\"))\n                $root.ics23.ExistenceProof.encode(message.right, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified NonExistenceProof message, length delimited. Does not implicitly {@link ics23.NonExistenceProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {ics23.INonExistenceProof} message NonExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        NonExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a NonExistenceProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.NonExistenceProof} NonExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        NonExistenceProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.NonExistenceProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                case 2:\n                    message.left = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.right = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a NonExistenceProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.NonExistenceProof} NonExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        NonExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a NonExistenceProof message.\n         * @function verify\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        NonExistenceProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key)))\n                    return \"key: buffer expected\";\n            if (message.left != null && message.hasOwnProperty(\"left\")) {\n                var error = $root.ics23.ExistenceProof.verify(message.left);\n                if (error)\n                    return \"left.\" + error;\n            }\n            if (message.right != null && message.hasOwnProperty(\"right\")) {\n                var error = $root.ics23.ExistenceProof.verify(message.right);\n                if (error)\n                    return \"right.\" + error;\n            }\n            return null;\n        };\n\n        /**\n         * Creates a NonExistenceProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.NonExistenceProof} NonExistenceProof\n         */\n        NonExistenceProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.NonExistenceProof)\n                return object;\n            var message = new $root.ics23.NonExistenceProof();\n            if (object.key != null)\n                if (typeof object.key === \"string\")\n                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);\n                else if (object.key.length)\n                    message.key = object.key;\n            if (object.left != null) {\n                if (typeof object.left !== \"object\")\n                    throw TypeError(\".ics23.NonExistenceProof.left: object expected\");\n                message.left = $root.ics23.ExistenceProof.fromObject(object.left);\n            }\n            if (object.right != null) {\n                if (typeof object.right !== \"object\")\n                    throw TypeError(\".ics23.NonExistenceProof.right: object expected\");\n                message.right = $root.ics23.ExistenceProof.fromObject(object.right);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a NonExistenceProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {ics23.NonExistenceProof} message NonExistenceProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        NonExistenceProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                if (options.bytes === String)\n                    object.key = \"\";\n                else {\n                    object.key = [];\n                    if (options.bytes !== Array)\n                        object.key = $util.newBuffer(object.key);\n                }\n                object.left = null;\n                object.right = null;\n            }\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n            if (message.left != null && message.hasOwnProperty(\"left\"))\n                object.left = $root.ics23.ExistenceProof.toObject(message.left, options);\n            if (message.right != null && message.hasOwnProperty(\"right\"))\n                object.right = $root.ics23.ExistenceProof.toObject(message.right, options);\n            return object;\n        };\n\n        /**\n         * Converts this NonExistenceProof to JSON.\n         * @function toJSON\n         * @memberof ics23.NonExistenceProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        NonExistenceProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return NonExistenceProof;\n    })();\n\n    ics23.CommitmentProof = (function() {\n\n        /**\n         * Properties of a CommitmentProof.\n         * @memberof ics23\n         * @interface ICommitmentProof\n         * @property {ics23.IExistenceProof|null} [exist] CommitmentProof exist\n         * @property {ics23.INonExistenceProof|null} [nonexist] CommitmentProof nonexist\n         * @property {ics23.IBatchProof|null} [batch] CommitmentProof batch\n         * @property {ics23.ICompressedBatchProof|null} [compressed] CommitmentProof compressed\n         */\n\n        /**\n         * Constructs a new CommitmentProof.\n         * @memberof ics23\n         * @classdesc Represents a CommitmentProof.\n         * @implements ICommitmentProof\n         * @constructor\n         * @param {ics23.ICommitmentProof=} [properties] Properties to set\n         */\n        function CommitmentProof(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CommitmentProof exist.\n         * @member {ics23.IExistenceProof|null|undefined} exist\n         * @memberof ics23.CommitmentProof\n         * @instance\n         */\n        CommitmentProof.prototype.exist = null;\n\n        /**\n         * CommitmentProof nonexist.\n         * @member {ics23.INonExistenceProof|null|undefined} nonexist\n         * @memberof ics23.CommitmentProof\n         * @instance\n         */\n        CommitmentProof.prototype.nonexist = null;\n\n        /**\n         * CommitmentProof batch.\n         * @member {ics23.IBatchProof|null|undefined} batch\n         * @memberof ics23.CommitmentProof\n         * @instance\n         */\n        CommitmentProof.prototype.batch = null;\n\n        /**\n         * CommitmentProof compressed.\n         * @member {ics23.ICompressedBatchProof|null|undefined} compressed\n         * @memberof ics23.CommitmentProof\n         * @instance\n         */\n        CommitmentProof.prototype.compressed = null;\n\n        // OneOf field names bound to virtual getters and setters\n        var $oneOfFields;\n\n        /**\n         * CommitmentProof proof.\n         * @member {\"exist\"|\"nonexist\"|\"batch\"|\"compressed\"|undefined} proof\n         * @memberof ics23.CommitmentProof\n         * @instance\n         */\n        Object.defineProperty(CommitmentProof.prototype, \"proof\", {\n            get: $util.oneOfGetter($oneOfFields = [\"exist\", \"nonexist\", \"batch\", \"compressed\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Creates a new CommitmentProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {ics23.ICommitmentProof=} [properties] Properties to set\n         * @returns {ics23.CommitmentProof} CommitmentProof instance\n         */\n        CommitmentProof.create = function create(properties) {\n            return new CommitmentProof(properties);\n        };\n\n        /**\n         * Encodes the specified CommitmentProof message. Does not implicitly {@link ics23.CommitmentProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {ics23.ICommitmentProof} message CommitmentProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CommitmentProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.exist != null && message.hasOwnProperty(\"exist\"))\n                $root.ics23.ExistenceProof.encode(message.exist, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\"))\n                $root.ics23.NonExistenceProof.encode(message.nonexist, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.batch != null && message.hasOwnProperty(\"batch\"))\n                $root.ics23.BatchProof.encode(message.batch, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            if (message.compressed != null && message.hasOwnProperty(\"compressed\"))\n                $root.ics23.CompressedBatchProof.encode(message.compressed, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CommitmentProof message, length delimited. Does not implicitly {@link ics23.CommitmentProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {ics23.ICommitmentProof} message CommitmentProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CommitmentProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CommitmentProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.CommitmentProof} CommitmentProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CommitmentProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.CommitmentProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.exist = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.nonexist = $root.ics23.NonExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.batch = $root.ics23.BatchProof.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.compressed = $root.ics23.CompressedBatchProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CommitmentProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.CommitmentProof} CommitmentProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CommitmentProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CommitmentProof message.\n         * @function verify\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CommitmentProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            var properties = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.ExistenceProof.verify(message.exist);\n                    if (error)\n                        return \"exist.\" + error;\n                }\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                if (properties.proof === 1)\n                    return \"proof: multiple values\";\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.NonExistenceProof.verify(message.nonexist);\n                    if (error)\n                        return \"nonexist.\" + error;\n                }\n            }\n            if (message.batch != null && message.hasOwnProperty(\"batch\")) {\n                if (properties.proof === 1)\n                    return \"proof: multiple values\";\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.BatchProof.verify(message.batch);\n                    if (error)\n                        return \"batch.\" + error;\n                }\n            }\n            if (message.compressed != null && message.hasOwnProperty(\"compressed\")) {\n                if (properties.proof === 1)\n                    return \"proof: multiple values\";\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.CompressedBatchProof.verify(message.compressed);\n                    if (error)\n                        return \"compressed.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a CommitmentProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.CommitmentProof} CommitmentProof\n         */\n        CommitmentProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.CommitmentProof)\n                return object;\n            var message = new $root.ics23.CommitmentProof();\n            if (object.exist != null) {\n                if (typeof object.exist !== \"object\")\n                    throw TypeError(\".ics23.CommitmentProof.exist: object expected\");\n                message.exist = $root.ics23.ExistenceProof.fromObject(object.exist);\n            }\n            if (object.nonexist != null) {\n                if (typeof object.nonexist !== \"object\")\n                    throw TypeError(\".ics23.CommitmentProof.nonexist: object expected\");\n                message.nonexist = $root.ics23.NonExistenceProof.fromObject(object.nonexist);\n            }\n            if (object.batch != null) {\n                if (typeof object.batch !== \"object\")\n                    throw TypeError(\".ics23.CommitmentProof.batch: object expected\");\n                message.batch = $root.ics23.BatchProof.fromObject(object.batch);\n            }\n            if (object.compressed != null) {\n                if (typeof object.compressed !== \"object\")\n                    throw TypeError(\".ics23.CommitmentProof.compressed: object expected\");\n                message.compressed = $root.ics23.CompressedBatchProof.fromObject(object.compressed);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a CommitmentProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {ics23.CommitmentProof} message CommitmentProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CommitmentProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                object.exist = $root.ics23.ExistenceProof.toObject(message.exist, options);\n                if (options.oneofs)\n                    object.proof = \"exist\";\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                object.nonexist = $root.ics23.NonExistenceProof.toObject(message.nonexist, options);\n                if (options.oneofs)\n                    object.proof = \"nonexist\";\n            }\n            if (message.batch != null && message.hasOwnProperty(\"batch\")) {\n                object.batch = $root.ics23.BatchProof.toObject(message.batch, options);\n                if (options.oneofs)\n                    object.proof = \"batch\";\n            }\n            if (message.compressed != null && message.hasOwnProperty(\"compressed\")) {\n                object.compressed = $root.ics23.CompressedBatchProof.toObject(message.compressed, options);\n                if (options.oneofs)\n                    object.proof = \"compressed\";\n            }\n            return object;\n        };\n\n        /**\n         * Converts this CommitmentProof to JSON.\n         * @function toJSON\n         * @memberof ics23.CommitmentProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CommitmentProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CommitmentProof;\n    })();\n\n    ics23.LeafOp = (function() {\n\n        /**\n         * Properties of a LeafOp.\n         * @memberof ics23\n         * @interface ILeafOp\n         * @property {ics23.HashOp|null} [hash] LeafOp hash\n         * @property {ics23.HashOp|null} [prehashKey] LeafOp prehashKey\n         * @property {ics23.HashOp|null} [prehashValue] LeafOp prehashValue\n         * @property {ics23.LengthOp|null} [length] LeafOp length\n         * @property {Uint8Array|null} [prefix] LeafOp prefix\n         */\n\n        /**\n         * Constructs a new LeafOp.\n         * @memberof ics23\n         * @classdesc LeafOp represents the raw key-value data we wish to prove, and\n         * must be flexible to represent the internal transformation from\n         * the original key-value pairs into the basis hash, for many existing\n         * merkle trees.\n         * \n         * key and value are passed in. So that the signature of this operation is:\n         * leafOp(key, value) -> output\n         * \n         * To process this, first prehash the keys and values if needed (ANY means no hash in this case):\n         * hkey = prehashKey(key)\n         * hvalue = prehashValue(value)\n         * \n         * Then combine the bytes, and hash it\n         * output = hash(prefix || length(hkey) || hkey || length(hvalue) || hvalue)\n         * @implements ILeafOp\n         * @constructor\n         * @param {ics23.ILeafOp=} [properties] Properties to set\n         */\n        function LeafOp(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * LeafOp hash.\n         * @member {ics23.HashOp} hash\n         * @memberof ics23.LeafOp\n         * @instance\n         */\n        LeafOp.prototype.hash = 0;\n\n        /**\n         * LeafOp prehashKey.\n         * @member {ics23.HashOp} prehashKey\n         * @memberof ics23.LeafOp\n         * @instance\n         */\n        LeafOp.prototype.prehashKey = 0;\n\n        /**\n         * LeafOp prehashValue.\n         * @member {ics23.HashOp} prehashValue\n         * @memberof ics23.LeafOp\n         * @instance\n         */\n        LeafOp.prototype.prehashValue = 0;\n\n        /**\n         * LeafOp length.\n         * @member {ics23.LengthOp} length\n         * @memberof ics23.LeafOp\n         * @instance\n         */\n        LeafOp.prototype.length = 0;\n\n        /**\n         * LeafOp prefix.\n         * @member {Uint8Array} prefix\n         * @memberof ics23.LeafOp\n         * @instance\n         */\n        LeafOp.prototype.prefix = $util.newBuffer([]);\n\n        /**\n         * Creates a new LeafOp instance using the specified properties.\n         * @function create\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {ics23.ILeafOp=} [properties] Properties to set\n         * @returns {ics23.LeafOp} LeafOp instance\n         */\n        LeafOp.create = function create(properties) {\n            return new LeafOp(properties);\n        };\n\n        /**\n         * Encodes the specified LeafOp message. Does not implicitly {@link ics23.LeafOp.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {ics23.ILeafOp} message LeafOp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        LeafOp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hash);\n            if (message.prehashKey != null && message.hasOwnProperty(\"prehashKey\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.prehashKey);\n            if (message.prehashValue != null && message.hasOwnProperty(\"prehashValue\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.prehashValue);\n            if (message.length != null && message.hasOwnProperty(\"length\"))\n                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.length);\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.prefix);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified LeafOp message, length delimited. Does not implicitly {@link ics23.LeafOp.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {ics23.ILeafOp} message LeafOp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        LeafOp.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a LeafOp message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.LeafOp} LeafOp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        LeafOp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.LeafOp();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.hash = reader.int32();\n                    break;\n                case 2:\n                    message.prehashKey = reader.int32();\n                    break;\n                case 3:\n                    message.prehashValue = reader.int32();\n                    break;\n                case 4:\n                    message.length = reader.int32();\n                    break;\n                case 5:\n                    message.prefix = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a LeafOp message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.LeafOp} LeafOp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        LeafOp.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a LeafOp message.\n         * @function verify\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        LeafOp.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                switch (message.hash) {\n                default:\n                    return \"hash: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                    break;\n                }\n            if (message.prehashKey != null && message.hasOwnProperty(\"prehashKey\"))\n                switch (message.prehashKey) {\n                default:\n                    return \"prehashKey: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                    break;\n                }\n            if (message.prehashValue != null && message.hasOwnProperty(\"prehashValue\"))\n                switch (message.prehashValue) {\n                default:\n                    return \"prehashValue: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                    break;\n                }\n            if (message.length != null && message.hasOwnProperty(\"length\"))\n                switch (message.length) {\n                default:\n                    return \"length: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                case 7:\n                case 8:\n                    break;\n                }\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                if (!(message.prefix && typeof message.prefix.length === \"number\" || $util.isString(message.prefix)))\n                    return \"prefix: buffer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a LeafOp message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.LeafOp} LeafOp\n         */\n        LeafOp.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.LeafOp)\n                return object;\n            var message = new $root.ics23.LeafOp();\n            switch (object.hash) {\n            case \"NO_HASH\":\n            case 0:\n                message.hash = 0;\n                break;\n            case \"SHA256\":\n            case 1:\n                message.hash = 1;\n                break;\n            case \"SHA512\":\n            case 2:\n                message.hash = 2;\n                break;\n            case \"KECCAK\":\n            case 3:\n                message.hash = 3;\n                break;\n            case \"RIPEMD160\":\n            case 4:\n                message.hash = 4;\n                break;\n            case \"BITCOIN\":\n            case 5:\n                message.hash = 5;\n                break;\n            case \"SHA512_256\":\n            case 6:\n                message.hash = 6;\n                break;\n            }\n            switch (object.prehashKey) {\n            case \"NO_HASH\":\n            case 0:\n                message.prehashKey = 0;\n                break;\n            case \"SHA256\":\n            case 1:\n                message.prehashKey = 1;\n                break;\n            case \"SHA512\":\n            case 2:\n                message.prehashKey = 2;\n                break;\n            case \"KECCAK\":\n            case 3:\n                message.prehashKey = 3;\n                break;\n            case \"RIPEMD160\":\n            case 4:\n                message.prehashKey = 4;\n                break;\n            case \"BITCOIN\":\n            case 5:\n                message.prehashKey = 5;\n                break;\n            case \"SHA512_256\":\n            case 6:\n                message.prehashKey = 6;\n                break;\n            }\n            switch (object.prehashValue) {\n            case \"NO_HASH\":\n            case 0:\n                message.prehashValue = 0;\n                break;\n            case \"SHA256\":\n            case 1:\n                message.prehashValue = 1;\n                break;\n            case \"SHA512\":\n            case 2:\n                message.prehashValue = 2;\n                break;\n            case \"KECCAK\":\n            case 3:\n                message.prehashValue = 3;\n                break;\n            case \"RIPEMD160\":\n            case 4:\n                message.prehashValue = 4;\n                break;\n            case \"BITCOIN\":\n            case 5:\n                message.prehashValue = 5;\n                break;\n            case \"SHA512_256\":\n            case 6:\n                message.prehashValue = 6;\n                break;\n            }\n            switch (object.length) {\n            case \"NO_PREFIX\":\n            case 0:\n                message.length = 0;\n                break;\n            case \"VAR_PROTO\":\n            case 1:\n                message.length = 1;\n                break;\n            case \"VAR_RLP\":\n            case 2:\n                message.length = 2;\n                break;\n            case \"FIXED32_BIG\":\n            case 3:\n                message.length = 3;\n                break;\n            case \"FIXED32_LITTLE\":\n            case 4:\n                message.length = 4;\n                break;\n            case \"FIXED64_BIG\":\n            case 5:\n                message.length = 5;\n                break;\n            case \"FIXED64_LITTLE\":\n            case 6:\n                message.length = 6;\n                break;\n            case \"REQUIRE_32_BYTES\":\n            case 7:\n                message.length = 7;\n                break;\n            case \"REQUIRE_64_BYTES\":\n            case 8:\n                message.length = 8;\n                break;\n            }\n            if (object.prefix != null)\n                if (typeof object.prefix === \"string\")\n                    $util.base64.decode(object.prefix, message.prefix = $util.newBuffer($util.base64.length(object.prefix)), 0);\n                else if (object.prefix.length)\n                    message.prefix = object.prefix;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a LeafOp message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {ics23.LeafOp} message LeafOp\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        LeafOp.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.hash = options.enums === String ? \"NO_HASH\" : 0;\n                object.prehashKey = options.enums === String ? \"NO_HASH\" : 0;\n                object.prehashValue = options.enums === String ? \"NO_HASH\" : 0;\n                object.length = options.enums === String ? \"NO_PREFIX\" : 0;\n                if (options.bytes === String)\n                    object.prefix = \"\";\n                else {\n                    object.prefix = [];\n                    if (options.bytes !== Array)\n                        object.prefix = $util.newBuffer(object.prefix);\n                }\n            }\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;\n            if (message.prehashKey != null && message.hasOwnProperty(\"prehashKey\"))\n                object.prehashKey = options.enums === String ? $root.ics23.HashOp[message.prehashKey] : message.prehashKey;\n            if (message.prehashValue != null && message.hasOwnProperty(\"prehashValue\"))\n                object.prehashValue = options.enums === String ? $root.ics23.HashOp[message.prehashValue] : message.prehashValue;\n            if (message.length != null && message.hasOwnProperty(\"length\"))\n                object.length = options.enums === String ? $root.ics23.LengthOp[message.length] : message.length;\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                object.prefix = options.bytes === String ? $util.base64.encode(message.prefix, 0, message.prefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.prefix) : message.prefix;\n            return object;\n        };\n\n        /**\n         * Converts this LeafOp to JSON.\n         * @function toJSON\n         * @memberof ics23.LeafOp\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        LeafOp.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return LeafOp;\n    })();\n\n    ics23.InnerOp = (function() {\n\n        /**\n         * Properties of an InnerOp.\n         * @memberof ics23\n         * @interface IInnerOp\n         * @property {ics23.HashOp|null} [hash] InnerOp hash\n         * @property {Uint8Array|null} [prefix] InnerOp prefix\n         * @property {Uint8Array|null} [suffix] InnerOp suffix\n         */\n\n        /**\n         * Constructs a new InnerOp.\n         * @memberof ics23\n         * @classdesc InnerOp represents a merkle-proof step that is not a leaf.\n         * It represents concatenating two children and hashing them to provide the next result.\n         * \n         * The result of the previous step is passed in, so the signature of this op is:\n         * innerOp(child) -> output\n         * \n         * The result of applying InnerOp should be:\n         * output = op.hash(op.prefix || child || op.suffix)\n         * \n         * where the || operator is concatenation of binary data,\n         * and child is the result of hashing all the tree below this step.\n         * \n         * Any special data, like prepending child with the length, or prepending the entire operation with\n         * some value to differentiate from leaf nodes, should be included in prefix and suffix.\n         * If either of prefix or suffix is empty, we just treat it as an empty string\n         * @implements IInnerOp\n         * @constructor\n         * @param {ics23.IInnerOp=} [properties] Properties to set\n         */\n        function InnerOp(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * InnerOp hash.\n         * @member {ics23.HashOp} hash\n         * @memberof ics23.InnerOp\n         * @instance\n         */\n        InnerOp.prototype.hash = 0;\n\n        /**\n         * InnerOp prefix.\n         * @member {Uint8Array} prefix\n         * @memberof ics23.InnerOp\n         * @instance\n         */\n        InnerOp.prototype.prefix = $util.newBuffer([]);\n\n        /**\n         * InnerOp suffix.\n         * @member {Uint8Array} suffix\n         * @memberof ics23.InnerOp\n         * @instance\n         */\n        InnerOp.prototype.suffix = $util.newBuffer([]);\n\n        /**\n         * Creates a new InnerOp instance using the specified properties.\n         * @function create\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {ics23.IInnerOp=} [properties] Properties to set\n         * @returns {ics23.InnerOp} InnerOp instance\n         */\n        InnerOp.create = function create(properties) {\n            return new InnerOp(properties);\n        };\n\n        /**\n         * Encodes the specified InnerOp message. Does not implicitly {@link ics23.InnerOp.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {ics23.IInnerOp} message InnerOp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        InnerOp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hash);\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.prefix);\n            if (message.suffix != null && message.hasOwnProperty(\"suffix\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.suffix);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified InnerOp message, length delimited. Does not implicitly {@link ics23.InnerOp.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {ics23.IInnerOp} message InnerOp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        InnerOp.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes an InnerOp message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.InnerOp} InnerOp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        InnerOp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.InnerOp();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.hash = reader.int32();\n                    break;\n                case 2:\n                    message.prefix = reader.bytes();\n                    break;\n                case 3:\n                    message.suffix = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes an InnerOp message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.InnerOp} InnerOp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        InnerOp.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies an InnerOp message.\n         * @function verify\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        InnerOp.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                switch (message.hash) {\n                default:\n                    return \"hash: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                    break;\n                }\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                if (!(message.prefix && typeof message.prefix.length === \"number\" || $util.isString(message.prefix)))\n                    return \"prefix: buffer expected\";\n            if (message.suffix != null && message.hasOwnProperty(\"suffix\"))\n                if (!(message.suffix && typeof message.suffix.length === \"number\" || $util.isString(message.suffix)))\n                    return \"suffix: buffer expected\";\n            return null;\n        };\n\n        /**\n         * Creates an InnerOp message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.InnerOp} InnerOp\n         */\n        InnerOp.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.InnerOp)\n                return object;\n            var message = new $root.ics23.InnerOp();\n            switch (object.hash) {\n            case \"NO_HASH\":\n            case 0:\n                message.hash = 0;\n                break;\n            case \"SHA256\":\n            case 1:\n                message.hash = 1;\n                break;\n            case \"SHA512\":\n            case 2:\n                message.hash = 2;\n                break;\n            case \"KECCAK\":\n            case 3:\n                message.hash = 3;\n                break;\n            case \"RIPEMD160\":\n            case 4:\n                message.hash = 4;\n                break;\n            case \"BITCOIN\":\n            case 5:\n                message.hash = 5;\n                break;\n            case \"SHA512_256\":\n            case 6:\n                message.hash = 6;\n                break;\n            }\n            if (object.prefix != null)\n                if (typeof object.prefix === \"string\")\n                    $util.base64.decode(object.prefix, message.prefix = $util.newBuffer($util.base64.length(object.prefix)), 0);\n                else if (object.prefix.length)\n                    message.prefix = object.prefix;\n            if (object.suffix != null)\n                if (typeof object.suffix === \"string\")\n                    $util.base64.decode(object.suffix, message.suffix = $util.newBuffer($util.base64.length(object.suffix)), 0);\n                else if (object.suffix.length)\n                    message.suffix = object.suffix;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from an InnerOp message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {ics23.InnerOp} message InnerOp\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        InnerOp.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.hash = options.enums === String ? \"NO_HASH\" : 0;\n                if (options.bytes === String)\n                    object.prefix = \"\";\n                else {\n                    object.prefix = [];\n                    if (options.bytes !== Array)\n                        object.prefix = $util.newBuffer(object.prefix);\n                }\n                if (options.bytes === String)\n                    object.suffix = \"\";\n                else {\n                    object.suffix = [];\n                    if (options.bytes !== Array)\n                        object.suffix = $util.newBuffer(object.suffix);\n                }\n            }\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                object.prefix = options.bytes === String ? $util.base64.encode(message.prefix, 0, message.prefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.prefix) : message.prefix;\n            if (message.suffix != null && message.hasOwnProperty(\"suffix\"))\n                object.suffix = options.bytes === String ? $util.base64.encode(message.suffix, 0, message.suffix.length) : options.bytes === Array ? Array.prototype.slice.call(message.suffix) : message.suffix;\n            return object;\n        };\n\n        /**\n         * Converts this InnerOp to JSON.\n         * @function toJSON\n         * @memberof ics23.InnerOp\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        InnerOp.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return InnerOp;\n    })();\n\n    ics23.ProofSpec = (function() {\n\n        /**\n         * Properties of a ProofSpec.\n         * @memberof ics23\n         * @interface IProofSpec\n         * @property {ics23.ILeafOp|null} [leafSpec] ProofSpec leafSpec\n         * @property {ics23.IInnerSpec|null} [innerSpec] ProofSpec innerSpec\n         * @property {number|null} [maxDepth] ProofSpec maxDepth\n         * @property {number|null} [minDepth] ProofSpec minDepth\n         */\n\n        /**\n         * Constructs a new ProofSpec.\n         * @memberof ics23\n         * @classdesc ProofSpec defines what the expected parameters are for a given proof type.\n         * This can be stored in the client and used to validate any incoming proofs.\n         * \n         * verify(ProofSpec, Proof) -> Proof | Error\n         * \n         * As demonstrated in tests, if we don't fix the algorithm used to calculate the\n         * LeafHash for a given tree, there are many possible key-value pairs that can\n         * generate a given hash (by interpretting the preimage differently).\n         * We need this for proper security, requires client knows a priori what\n         * tree format server uses. But not in code, rather a configuration object.\n         * @implements IProofSpec\n         * @constructor\n         * @param {ics23.IProofSpec=} [properties] Properties to set\n         */\n        function ProofSpec(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ProofSpec leafSpec.\n         * @member {ics23.ILeafOp|null|undefined} leafSpec\n         * @memberof ics23.ProofSpec\n         * @instance\n         */\n        ProofSpec.prototype.leafSpec = null;\n\n        /**\n         * ProofSpec innerSpec.\n         * @member {ics23.IInnerSpec|null|undefined} innerSpec\n         * @memberof ics23.ProofSpec\n         * @instance\n         */\n        ProofSpec.prototype.innerSpec = null;\n\n        /**\n         * ProofSpec maxDepth.\n         * @member {number} maxDepth\n         * @memberof ics23.ProofSpec\n         * @instance\n         */\n        ProofSpec.prototype.maxDepth = 0;\n\n        /**\n         * ProofSpec minDepth.\n         * @member {number} minDepth\n         * @memberof ics23.ProofSpec\n         * @instance\n         */\n        ProofSpec.prototype.minDepth = 0;\n\n        /**\n         * Creates a new ProofSpec instance using the specified properties.\n         * @function create\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {ics23.IProofSpec=} [properties] Properties to set\n         * @returns {ics23.ProofSpec} ProofSpec instance\n         */\n        ProofSpec.create = function create(properties) {\n            return new ProofSpec(properties);\n        };\n\n        /**\n         * Encodes the specified ProofSpec message. Does not implicitly {@link ics23.ProofSpec.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {ics23.IProofSpec} message ProofSpec message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ProofSpec.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.leafSpec != null && message.hasOwnProperty(\"leafSpec\"))\n                $root.ics23.LeafOp.encode(message.leafSpec, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.innerSpec != null && message.hasOwnProperty(\"innerSpec\"))\n                $root.ics23.InnerSpec.encode(message.innerSpec, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.maxDepth != null && message.hasOwnProperty(\"maxDepth\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.maxDepth);\n            if (message.minDepth != null && message.hasOwnProperty(\"minDepth\"))\n                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.minDepth);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified ProofSpec message, length delimited. Does not implicitly {@link ics23.ProofSpec.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {ics23.IProofSpec} message ProofSpec message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ProofSpec.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a ProofSpec message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.ProofSpec} ProofSpec\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ProofSpec.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.ProofSpec();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.leafSpec = $root.ics23.LeafOp.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.innerSpec = $root.ics23.InnerSpec.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.maxDepth = reader.int32();\n                    break;\n                case 4:\n                    message.minDepth = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a ProofSpec message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.ProofSpec} ProofSpec\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ProofSpec.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a ProofSpec message.\n         * @function verify\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        ProofSpec.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.leafSpec != null && message.hasOwnProperty(\"leafSpec\")) {\n                var error = $root.ics23.LeafOp.verify(message.leafSpec);\n                if (error)\n                    return \"leafSpec.\" + error;\n            }\n            if (message.innerSpec != null && message.hasOwnProperty(\"innerSpec\")) {\n                var error = $root.ics23.InnerSpec.verify(message.innerSpec);\n                if (error)\n                    return \"innerSpec.\" + error;\n            }\n            if (message.maxDepth != null && message.hasOwnProperty(\"maxDepth\"))\n                if (!$util.isInteger(message.maxDepth))\n                    return \"maxDepth: integer expected\";\n            if (message.minDepth != null && message.hasOwnProperty(\"minDepth\"))\n                if (!$util.isInteger(message.minDepth))\n                    return \"minDepth: integer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a ProofSpec message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.ProofSpec} ProofSpec\n         */\n        ProofSpec.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.ProofSpec)\n                return object;\n            var message = new $root.ics23.ProofSpec();\n            if (object.leafSpec != null) {\n                if (typeof object.leafSpec !== \"object\")\n                    throw TypeError(\".ics23.ProofSpec.leafSpec: object expected\");\n                message.leafSpec = $root.ics23.LeafOp.fromObject(object.leafSpec);\n            }\n            if (object.innerSpec != null) {\n                if (typeof object.innerSpec !== \"object\")\n                    throw TypeError(\".ics23.ProofSpec.innerSpec: object expected\");\n                message.innerSpec = $root.ics23.InnerSpec.fromObject(object.innerSpec);\n            }\n            if (object.maxDepth != null)\n                message.maxDepth = object.maxDepth | 0;\n            if (object.minDepth != null)\n                message.minDepth = object.minDepth | 0;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a ProofSpec message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {ics23.ProofSpec} message ProofSpec\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        ProofSpec.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.leafSpec = null;\n                object.innerSpec = null;\n                object.maxDepth = 0;\n                object.minDepth = 0;\n            }\n            if (message.leafSpec != null && message.hasOwnProperty(\"leafSpec\"))\n                object.leafSpec = $root.ics23.LeafOp.toObject(message.leafSpec, options);\n            if (message.innerSpec != null && message.hasOwnProperty(\"innerSpec\"))\n                object.innerSpec = $root.ics23.InnerSpec.toObject(message.innerSpec, options);\n            if (message.maxDepth != null && message.hasOwnProperty(\"maxDepth\"))\n                object.maxDepth = message.maxDepth;\n            if (message.minDepth != null && message.hasOwnProperty(\"minDepth\"))\n                object.minDepth = message.minDepth;\n            return object;\n        };\n\n        /**\n         * Converts this ProofSpec to JSON.\n         * @function toJSON\n         * @memberof ics23.ProofSpec\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        ProofSpec.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ProofSpec;\n    })();\n\n    ics23.InnerSpec = (function() {\n\n        /**\n         * Properties of an InnerSpec.\n         * @memberof ics23\n         * @interface IInnerSpec\n         * @property {Array.<number>|null} [childOrder] InnerSpec childOrder\n         * @property {number|null} [childSize] InnerSpec childSize\n         * @property {number|null} [minPrefixLength] InnerSpec minPrefixLength\n         * @property {number|null} [maxPrefixLength] InnerSpec maxPrefixLength\n         * @property {Uint8Array|null} [emptyChild] InnerSpec emptyChild\n         * @property {ics23.HashOp|null} [hash] InnerSpec hash\n         */\n\n        /**\n         * Constructs a new InnerSpec.\n         * @memberof ics23\n         * @classdesc Represents an InnerSpec.\n         * @implements IInnerSpec\n         * @constructor\n         * @param {ics23.IInnerSpec=} [properties] Properties to set\n         */\n        function InnerSpec(properties) {\n            this.childOrder = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * InnerSpec childOrder.\n         * @member {Array.<number>} childOrder\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.childOrder = $util.emptyArray;\n\n        /**\n         * InnerSpec childSize.\n         * @member {number} childSize\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.childSize = 0;\n\n        /**\n         * InnerSpec minPrefixLength.\n         * @member {number} minPrefixLength\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.minPrefixLength = 0;\n\n        /**\n         * InnerSpec maxPrefixLength.\n         * @member {number} maxPrefixLength\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.maxPrefixLength = 0;\n\n        /**\n         * InnerSpec emptyChild.\n         * @member {Uint8Array} emptyChild\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.emptyChild = $util.newBuffer([]);\n\n        /**\n         * InnerSpec hash.\n         * @member {ics23.HashOp} hash\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.hash = 0;\n\n        /**\n         * Creates a new InnerSpec instance using the specified properties.\n         * @function create\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {ics23.IInnerSpec=} [properties] Properties to set\n         * @returns {ics23.InnerSpec} InnerSpec instance\n         */\n        InnerSpec.create = function create(properties) {\n            return new InnerSpec(properties);\n        };\n\n        /**\n         * Encodes the specified InnerSpec message. Does not implicitly {@link ics23.InnerSpec.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {ics23.IInnerSpec} message InnerSpec message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        InnerSpec.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.childOrder != null && message.childOrder.length) {\n                writer.uint32(/* id 1, wireType 2 =*/10).fork();\n                for (var i = 0; i < message.childOrder.length; ++i)\n                    writer.int32(message.childOrder[i]);\n                writer.ldelim();\n            }\n            if (message.childSize != null && message.hasOwnProperty(\"childSize\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.childSize);\n            if (message.minPrefixLength != null && message.hasOwnProperty(\"minPrefixLength\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.minPrefixLength);\n            if (message.maxPrefixLength != null && message.hasOwnProperty(\"maxPrefixLength\"))\n                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.maxPrefixLength);\n            if (message.emptyChild != null && message.hasOwnProperty(\"emptyChild\"))\n                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.emptyChild);\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.hash);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified InnerSpec message, length delimited. Does not implicitly {@link ics23.InnerSpec.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {ics23.IInnerSpec} message InnerSpec message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        InnerSpec.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes an InnerSpec message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.InnerSpec} InnerSpec\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        InnerSpec.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.InnerSpec();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.childOrder && message.childOrder.length))\n                        message.childOrder = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.childOrder.push(reader.int32());\n                    } else\n                        message.childOrder.push(reader.int32());\n                    break;\n                case 2:\n                    message.childSize = reader.int32();\n                    break;\n                case 3:\n                    message.minPrefixLength = reader.int32();\n                    break;\n                case 4:\n                    message.maxPrefixLength = reader.int32();\n                    break;\n                case 5:\n                    message.emptyChild = reader.bytes();\n                    break;\n                case 6:\n                    message.hash = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes an InnerSpec message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.InnerSpec} InnerSpec\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        InnerSpec.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies an InnerSpec message.\n         * @function verify\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        InnerSpec.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.childOrder != null && message.hasOwnProperty(\"childOrder\")) {\n                if (!Array.isArray(message.childOrder))\n                    return \"childOrder: array expected\";\n                for (var i = 0; i < message.childOrder.length; ++i)\n                    if (!$util.isInteger(message.childOrder[i]))\n                        return \"childOrder: integer[] expected\";\n            }\n            if (message.childSize != null && message.hasOwnProperty(\"childSize\"))\n                if (!$util.isInteger(message.childSize))\n                    return \"childSize: integer expected\";\n            if (message.minPrefixLength != null && message.hasOwnProperty(\"minPrefixLength\"))\n                if (!$util.isInteger(message.minPrefixLength))\n                    return \"minPrefixLength: integer expected\";\n            if (message.maxPrefixLength != null && message.hasOwnProperty(\"maxPrefixLength\"))\n                if (!$util.isInteger(message.maxPrefixLength))\n                    return \"maxPrefixLength: integer expected\";\n            if (message.emptyChild != null && message.hasOwnProperty(\"emptyChild\"))\n                if (!(message.emptyChild && typeof message.emptyChild.length === \"number\" || $util.isString(message.emptyChild)))\n                    return \"emptyChild: buffer expected\";\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                switch (message.hash) {\n                default:\n                    return \"hash: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                    break;\n                }\n            return null;\n        };\n\n        /**\n         * Creates an InnerSpec message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.InnerSpec} InnerSpec\n         */\n        InnerSpec.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.InnerSpec)\n                return object;\n            var message = new $root.ics23.InnerSpec();\n            if (object.childOrder) {\n                if (!Array.isArray(object.childOrder))\n                    throw TypeError(\".ics23.InnerSpec.childOrder: array expected\");\n                message.childOrder = [];\n                for (var i = 0; i < object.childOrder.length; ++i)\n                    message.childOrder[i] = object.childOrder[i] | 0;\n            }\n            if (object.childSize != null)\n                message.childSize = object.childSize | 0;\n            if (object.minPrefixLength != null)\n                message.minPrefixLength = object.minPrefixLength | 0;\n            if (object.maxPrefixLength != null)\n                message.maxPrefixLength = object.maxPrefixLength | 0;\n            if (object.emptyChild != null)\n                if (typeof object.emptyChild === \"string\")\n                    $util.base64.decode(object.emptyChild, message.emptyChild = $util.newBuffer($util.base64.length(object.emptyChild)), 0);\n                else if (object.emptyChild.length)\n                    message.emptyChild = object.emptyChild;\n            switch (object.hash) {\n            case \"NO_HASH\":\n            case 0:\n                message.hash = 0;\n                break;\n            case \"SHA256\":\n            case 1:\n                message.hash = 1;\n                break;\n            case \"SHA512\":\n            case 2:\n                message.hash = 2;\n                break;\n            case \"KECCAK\":\n            case 3:\n                message.hash = 3;\n                break;\n            case \"RIPEMD160\":\n            case 4:\n                message.hash = 4;\n                break;\n            case \"BITCOIN\":\n            case 5:\n                message.hash = 5;\n                break;\n            case \"SHA512_256\":\n            case 6:\n                message.hash = 6;\n                break;\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from an InnerSpec message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {ics23.InnerSpec} message InnerSpec\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        InnerSpec.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.childOrder = [];\n            if (options.defaults) {\n                object.childSize = 0;\n                object.minPrefixLength = 0;\n                object.maxPrefixLength = 0;\n                if (options.bytes === String)\n                    object.emptyChild = \"\";\n                else {\n                    object.emptyChild = [];\n                    if (options.bytes !== Array)\n                        object.emptyChild = $util.newBuffer(object.emptyChild);\n                }\n                object.hash = options.enums === String ? \"NO_HASH\" : 0;\n            }\n            if (message.childOrder && message.childOrder.length) {\n                object.childOrder = [];\n                for (var j = 0; j < message.childOrder.length; ++j)\n                    object.childOrder[j] = message.childOrder[j];\n            }\n            if (message.childSize != null && message.hasOwnProperty(\"childSize\"))\n                object.childSize = message.childSize;\n            if (message.minPrefixLength != null && message.hasOwnProperty(\"minPrefixLength\"))\n                object.minPrefixLength = message.minPrefixLength;\n            if (message.maxPrefixLength != null && message.hasOwnProperty(\"maxPrefixLength\"))\n                object.maxPrefixLength = message.maxPrefixLength;\n            if (message.emptyChild != null && message.hasOwnProperty(\"emptyChild\"))\n                object.emptyChild = options.bytes === String ? $util.base64.encode(message.emptyChild, 0, message.emptyChild.length) : options.bytes === Array ? Array.prototype.slice.call(message.emptyChild) : message.emptyChild;\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;\n            return object;\n        };\n\n        /**\n         * Converts this InnerSpec to JSON.\n         * @function toJSON\n         * @memberof ics23.InnerSpec\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        InnerSpec.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return InnerSpec;\n    })();\n\n    ics23.BatchProof = (function() {\n\n        /**\n         * Properties of a BatchProof.\n         * @memberof ics23\n         * @interface IBatchProof\n         * @property {Array.<ics23.IBatchEntry>|null} [entries] BatchProof entries\n         */\n\n        /**\n         * Constructs a new BatchProof.\n         * @memberof ics23\n         * @classdesc Represents a BatchProof.\n         * @implements IBatchProof\n         * @constructor\n         * @param {ics23.IBatchProof=} [properties] Properties to set\n         */\n        function BatchProof(properties) {\n            this.entries = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * BatchProof entries.\n         * @member {Array.<ics23.IBatchEntry>} entries\n         * @memberof ics23.BatchProof\n         * @instance\n         */\n        BatchProof.prototype.entries = $util.emptyArray;\n\n        /**\n         * Creates a new BatchProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {ics23.IBatchProof=} [properties] Properties to set\n         * @returns {ics23.BatchProof} BatchProof instance\n         */\n        BatchProof.create = function create(properties) {\n            return new BatchProof(properties);\n        };\n\n        /**\n         * Encodes the specified BatchProof message. Does not implicitly {@link ics23.BatchProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {ics23.IBatchProof} message BatchProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BatchProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.entries != null && message.entries.length)\n                for (var i = 0; i < message.entries.length; ++i)\n                    $root.ics23.BatchEntry.encode(message.entries[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified BatchProof message, length delimited. Does not implicitly {@link ics23.BatchProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {ics23.IBatchProof} message BatchProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BatchProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a BatchProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.BatchProof} BatchProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BatchProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.BatchProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.entries && message.entries.length))\n                        message.entries = [];\n                    message.entries.push($root.ics23.BatchEntry.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a BatchProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.BatchProof} BatchProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BatchProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a BatchProof message.\n         * @function verify\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        BatchProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.entries != null && message.hasOwnProperty(\"entries\")) {\n                if (!Array.isArray(message.entries))\n                    return \"entries: array expected\";\n                for (var i = 0; i < message.entries.length; ++i) {\n                    var error = $root.ics23.BatchEntry.verify(message.entries[i]);\n                    if (error)\n                        return \"entries.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a BatchProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.BatchProof} BatchProof\n         */\n        BatchProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.BatchProof)\n                return object;\n            var message = new $root.ics23.BatchProof();\n            if (object.entries) {\n                if (!Array.isArray(object.entries))\n                    throw TypeError(\".ics23.BatchProof.entries: array expected\");\n                message.entries = [];\n                for (var i = 0; i < object.entries.length; ++i) {\n                    if (typeof object.entries[i] !== \"object\")\n                        throw TypeError(\".ics23.BatchProof.entries: object expected\");\n                    message.entries[i] = $root.ics23.BatchEntry.fromObject(object.entries[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a BatchProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {ics23.BatchProof} message BatchProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        BatchProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.entries = [];\n            if (message.entries && message.entries.length) {\n                object.entries = [];\n                for (var j = 0; j < message.entries.length; ++j)\n                    object.entries[j] = $root.ics23.BatchEntry.toObject(message.entries[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this BatchProof to JSON.\n         * @function toJSON\n         * @memberof ics23.BatchProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        BatchProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return BatchProof;\n    })();\n\n    ics23.BatchEntry = (function() {\n\n        /**\n         * Properties of a BatchEntry.\n         * @memberof ics23\n         * @interface IBatchEntry\n         * @property {ics23.IExistenceProof|null} [exist] BatchEntry exist\n         * @property {ics23.INonExistenceProof|null} [nonexist] BatchEntry nonexist\n         */\n\n        /**\n         * Constructs a new BatchEntry.\n         * @memberof ics23\n         * @classdesc Represents a BatchEntry.\n         * @implements IBatchEntry\n         * @constructor\n         * @param {ics23.IBatchEntry=} [properties] Properties to set\n         */\n        function BatchEntry(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * BatchEntry exist.\n         * @member {ics23.IExistenceProof|null|undefined} exist\n         * @memberof ics23.BatchEntry\n         * @instance\n         */\n        BatchEntry.prototype.exist = null;\n\n        /**\n         * BatchEntry nonexist.\n         * @member {ics23.INonExistenceProof|null|undefined} nonexist\n         * @memberof ics23.BatchEntry\n         * @instance\n         */\n        BatchEntry.prototype.nonexist = null;\n\n        // OneOf field names bound to virtual getters and setters\n        var $oneOfFields;\n\n        /**\n         * BatchEntry proof.\n         * @member {\"exist\"|\"nonexist\"|undefined} proof\n         * @memberof ics23.BatchEntry\n         * @instance\n         */\n        Object.defineProperty(BatchEntry.prototype, \"proof\", {\n            get: $util.oneOfGetter($oneOfFields = [\"exist\", \"nonexist\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Creates a new BatchEntry instance using the specified properties.\n         * @function create\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {ics23.IBatchEntry=} [properties] Properties to set\n         * @returns {ics23.BatchEntry} BatchEntry instance\n         */\n        BatchEntry.create = function create(properties) {\n            return new BatchEntry(properties);\n        };\n\n        /**\n         * Encodes the specified BatchEntry message. Does not implicitly {@link ics23.BatchEntry.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {ics23.IBatchEntry} message BatchEntry message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BatchEntry.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.exist != null && message.hasOwnProperty(\"exist\"))\n                $root.ics23.ExistenceProof.encode(message.exist, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\"))\n                $root.ics23.NonExistenceProof.encode(message.nonexist, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified BatchEntry message, length delimited. Does not implicitly {@link ics23.BatchEntry.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {ics23.IBatchEntry} message BatchEntry message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BatchEntry.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a BatchEntry message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.BatchEntry} BatchEntry\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BatchEntry.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.BatchEntry();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.exist = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.nonexist = $root.ics23.NonExistenceProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a BatchEntry message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.BatchEntry} BatchEntry\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BatchEntry.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a BatchEntry message.\n         * @function verify\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        BatchEntry.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            var properties = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.ExistenceProof.verify(message.exist);\n                    if (error)\n                        return \"exist.\" + error;\n                }\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                if (properties.proof === 1)\n                    return \"proof: multiple values\";\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.NonExistenceProof.verify(message.nonexist);\n                    if (error)\n                        return \"nonexist.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a BatchEntry message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.BatchEntry} BatchEntry\n         */\n        BatchEntry.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.BatchEntry)\n                return object;\n            var message = new $root.ics23.BatchEntry();\n            if (object.exist != null) {\n                if (typeof object.exist !== \"object\")\n                    throw TypeError(\".ics23.BatchEntry.exist: object expected\");\n                message.exist = $root.ics23.ExistenceProof.fromObject(object.exist);\n            }\n            if (object.nonexist != null) {\n                if (typeof object.nonexist !== \"object\")\n                    throw TypeError(\".ics23.BatchEntry.nonexist: object expected\");\n                message.nonexist = $root.ics23.NonExistenceProof.fromObject(object.nonexist);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a BatchEntry message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {ics23.BatchEntry} message BatchEntry\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        BatchEntry.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                object.exist = $root.ics23.ExistenceProof.toObject(message.exist, options);\n                if (options.oneofs)\n                    object.proof = \"exist\";\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                object.nonexist = $root.ics23.NonExistenceProof.toObject(message.nonexist, options);\n                if (options.oneofs)\n                    object.proof = \"nonexist\";\n            }\n            return object;\n        };\n\n        /**\n         * Converts this BatchEntry to JSON.\n         * @function toJSON\n         * @memberof ics23.BatchEntry\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        BatchEntry.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return BatchEntry;\n    })();\n\n    ics23.CompressedBatchProof = (function() {\n\n        /**\n         * Properties of a CompressedBatchProof.\n         * @memberof ics23\n         * @interface ICompressedBatchProof\n         * @property {Array.<ics23.ICompressedBatchEntry>|null} [entries] CompressedBatchProof entries\n         * @property {Array.<ics23.IInnerOp>|null} [lookupInners] CompressedBatchProof lookupInners\n         */\n\n        /**\n         * Constructs a new CompressedBatchProof.\n         * @memberof ics23\n         * @classdesc Represents a CompressedBatchProof.\n         * @implements ICompressedBatchProof\n         * @constructor\n         * @param {ics23.ICompressedBatchProof=} [properties] Properties to set\n         */\n        function CompressedBatchProof(properties) {\n            this.entries = [];\n            this.lookupInners = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CompressedBatchProof entries.\n         * @member {Array.<ics23.ICompressedBatchEntry>} entries\n         * @memberof ics23.CompressedBatchProof\n         * @instance\n         */\n        CompressedBatchProof.prototype.entries = $util.emptyArray;\n\n        /**\n         * CompressedBatchProof lookupInners.\n         * @member {Array.<ics23.IInnerOp>} lookupInners\n         * @memberof ics23.CompressedBatchProof\n         * @instance\n         */\n        CompressedBatchProof.prototype.lookupInners = $util.emptyArray;\n\n        /**\n         * Creates a new CompressedBatchProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {ics23.ICompressedBatchProof=} [properties] Properties to set\n         * @returns {ics23.CompressedBatchProof} CompressedBatchProof instance\n         */\n        CompressedBatchProof.create = function create(properties) {\n            return new CompressedBatchProof(properties);\n        };\n\n        /**\n         * Encodes the specified CompressedBatchProof message. Does not implicitly {@link ics23.CompressedBatchProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {ics23.ICompressedBatchProof} message CompressedBatchProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedBatchProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.entries != null && message.entries.length)\n                for (var i = 0; i < message.entries.length; ++i)\n                    $root.ics23.CompressedBatchEntry.encode(message.entries[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.lookupInners != null && message.lookupInners.length)\n                for (var i = 0; i < message.lookupInners.length; ++i)\n                    $root.ics23.InnerOp.encode(message.lookupInners[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CompressedBatchProof message, length delimited. Does not implicitly {@link ics23.CompressedBatchProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {ics23.ICompressedBatchProof} message CompressedBatchProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedBatchProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CompressedBatchProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.CompressedBatchProof} CompressedBatchProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedBatchProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.CompressedBatchProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.entries && message.entries.length))\n                        message.entries = [];\n                    message.entries.push($root.ics23.CompressedBatchEntry.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    if (!(message.lookupInners && message.lookupInners.length))\n                        message.lookupInners = [];\n                    message.lookupInners.push($root.ics23.InnerOp.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CompressedBatchProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.CompressedBatchProof} CompressedBatchProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedBatchProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CompressedBatchProof message.\n         * @function verify\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CompressedBatchProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.entries != null && message.hasOwnProperty(\"entries\")) {\n                if (!Array.isArray(message.entries))\n                    return \"entries: array expected\";\n                for (var i = 0; i < message.entries.length; ++i) {\n                    var error = $root.ics23.CompressedBatchEntry.verify(message.entries[i]);\n                    if (error)\n                        return \"entries.\" + error;\n                }\n            }\n            if (message.lookupInners != null && message.hasOwnProperty(\"lookupInners\")) {\n                if (!Array.isArray(message.lookupInners))\n                    return \"lookupInners: array expected\";\n                for (var i = 0; i < message.lookupInners.length; ++i) {\n                    var error = $root.ics23.InnerOp.verify(message.lookupInners[i]);\n                    if (error)\n                        return \"lookupInners.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a CompressedBatchProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.CompressedBatchProof} CompressedBatchProof\n         */\n        CompressedBatchProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.CompressedBatchProof)\n                return object;\n            var message = new $root.ics23.CompressedBatchProof();\n            if (object.entries) {\n                if (!Array.isArray(object.entries))\n                    throw TypeError(\".ics23.CompressedBatchProof.entries: array expected\");\n                message.entries = [];\n                for (var i = 0; i < object.entries.length; ++i) {\n                    if (typeof object.entries[i] !== \"object\")\n                        throw TypeError(\".ics23.CompressedBatchProof.entries: object expected\");\n                    message.entries[i] = $root.ics23.CompressedBatchEntry.fromObject(object.entries[i]);\n                }\n            }\n            if (object.lookupInners) {\n                if (!Array.isArray(object.lookupInners))\n                    throw TypeError(\".ics23.CompressedBatchProof.lookupInners: array expected\");\n                message.lookupInners = [];\n                for (var i = 0; i < object.lookupInners.length; ++i) {\n                    if (typeof object.lookupInners[i] !== \"object\")\n                        throw TypeError(\".ics23.CompressedBatchProof.lookupInners: object expected\");\n                    message.lookupInners[i] = $root.ics23.InnerOp.fromObject(object.lookupInners[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a CompressedBatchProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {ics23.CompressedBatchProof} message CompressedBatchProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CompressedBatchProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults) {\n                object.entries = [];\n                object.lookupInners = [];\n            }\n            if (message.entries && message.entries.length) {\n                object.entries = [];\n                for (var j = 0; j < message.entries.length; ++j)\n                    object.entries[j] = $root.ics23.CompressedBatchEntry.toObject(message.entries[j], options);\n            }\n            if (message.lookupInners && message.lookupInners.length) {\n                object.lookupInners = [];\n                for (var j = 0; j < message.lookupInners.length; ++j)\n                    object.lookupInners[j] = $root.ics23.InnerOp.toObject(message.lookupInners[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this CompressedBatchProof to JSON.\n         * @function toJSON\n         * @memberof ics23.CompressedBatchProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CompressedBatchProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CompressedBatchProof;\n    })();\n\n    ics23.CompressedBatchEntry = (function() {\n\n        /**\n         * Properties of a CompressedBatchEntry.\n         * @memberof ics23\n         * @interface ICompressedBatchEntry\n         * @property {ics23.ICompressedExistenceProof|null} [exist] CompressedBatchEntry exist\n         * @property {ics23.ICompressedNonExistenceProof|null} [nonexist] CompressedBatchEntry nonexist\n         */\n\n        /**\n         * Constructs a new CompressedBatchEntry.\n         * @memberof ics23\n         * @classdesc Represents a CompressedBatchEntry.\n         * @implements ICompressedBatchEntry\n         * @constructor\n         * @param {ics23.ICompressedBatchEntry=} [properties] Properties to set\n         */\n        function CompressedBatchEntry(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CompressedBatchEntry exist.\n         * @member {ics23.ICompressedExistenceProof|null|undefined} exist\n         * @memberof ics23.CompressedBatchEntry\n         * @instance\n         */\n        CompressedBatchEntry.prototype.exist = null;\n\n        /**\n         * CompressedBatchEntry nonexist.\n         * @member {ics23.ICompressedNonExistenceProof|null|undefined} nonexist\n         * @memberof ics23.CompressedBatchEntry\n         * @instance\n         */\n        CompressedBatchEntry.prototype.nonexist = null;\n\n        // OneOf field names bound to virtual getters and setters\n        var $oneOfFields;\n\n        /**\n         * CompressedBatchEntry proof.\n         * @member {\"exist\"|\"nonexist\"|undefined} proof\n         * @memberof ics23.CompressedBatchEntry\n         * @instance\n         */\n        Object.defineProperty(CompressedBatchEntry.prototype, \"proof\", {\n            get: $util.oneOfGetter($oneOfFields = [\"exist\", \"nonexist\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Creates a new CompressedBatchEntry instance using the specified properties.\n         * @function create\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {ics23.ICompressedBatchEntry=} [properties] Properties to set\n         * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry instance\n         */\n        CompressedBatchEntry.create = function create(properties) {\n            return new CompressedBatchEntry(properties);\n        };\n\n        /**\n         * Encodes the specified CompressedBatchEntry message. Does not implicitly {@link ics23.CompressedBatchEntry.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {ics23.ICompressedBatchEntry} message CompressedBatchEntry message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedBatchEntry.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.exist != null && message.hasOwnProperty(\"exist\"))\n                $root.ics23.CompressedExistenceProof.encode(message.exist, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\"))\n                $root.ics23.CompressedNonExistenceProof.encode(message.nonexist, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CompressedBatchEntry message, length delimited. Does not implicitly {@link ics23.CompressedBatchEntry.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {ics23.ICompressedBatchEntry} message CompressedBatchEntry message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedBatchEntry.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CompressedBatchEntry message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedBatchEntry.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.CompressedBatchEntry();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.exist = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.nonexist = $root.ics23.CompressedNonExistenceProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CompressedBatchEntry message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedBatchEntry.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CompressedBatchEntry message.\n         * @function verify\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CompressedBatchEntry.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            var properties = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.CompressedExistenceProof.verify(message.exist);\n                    if (error)\n                        return \"exist.\" + error;\n                }\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                if (properties.proof === 1)\n                    return \"proof: multiple values\";\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.CompressedNonExistenceProof.verify(message.nonexist);\n                    if (error)\n                        return \"nonexist.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a CompressedBatchEntry message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry\n         */\n        CompressedBatchEntry.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.CompressedBatchEntry)\n                return object;\n            var message = new $root.ics23.CompressedBatchEntry();\n            if (object.exist != null) {\n                if (typeof object.exist !== \"object\")\n                    throw TypeError(\".ics23.CompressedBatchEntry.exist: object expected\");\n                message.exist = $root.ics23.CompressedExistenceProof.fromObject(object.exist);\n            }\n            if (object.nonexist != null) {\n                if (typeof object.nonexist !== \"object\")\n                    throw TypeError(\".ics23.CompressedBatchEntry.nonexist: object expected\");\n                message.nonexist = $root.ics23.CompressedNonExistenceProof.fromObject(object.nonexist);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a CompressedBatchEntry message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {ics23.CompressedBatchEntry} message CompressedBatchEntry\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CompressedBatchEntry.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                object.exist = $root.ics23.CompressedExistenceProof.toObject(message.exist, options);\n                if (options.oneofs)\n                    object.proof = \"exist\";\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                object.nonexist = $root.ics23.CompressedNonExistenceProof.toObject(message.nonexist, options);\n                if (options.oneofs)\n                    object.proof = \"nonexist\";\n            }\n            return object;\n        };\n\n        /**\n         * Converts this CompressedBatchEntry to JSON.\n         * @function toJSON\n         * @memberof ics23.CompressedBatchEntry\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CompressedBatchEntry.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CompressedBatchEntry;\n    })();\n\n    ics23.CompressedExistenceProof = (function() {\n\n        /**\n         * Properties of a CompressedExistenceProof.\n         * @memberof ics23\n         * @interface ICompressedExistenceProof\n         * @property {Uint8Array|null} [key] CompressedExistenceProof key\n         * @property {Uint8Array|null} [value] CompressedExistenceProof value\n         * @property {ics23.ILeafOp|null} [leaf] CompressedExistenceProof leaf\n         * @property {Array.<number>|null} [path] CompressedExistenceProof path\n         */\n\n        /**\n         * Constructs a new CompressedExistenceProof.\n         * @memberof ics23\n         * @classdesc Represents a CompressedExistenceProof.\n         * @implements ICompressedExistenceProof\n         * @constructor\n         * @param {ics23.ICompressedExistenceProof=} [properties] Properties to set\n         */\n        function CompressedExistenceProof(properties) {\n            this.path = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CompressedExistenceProof key.\n         * @member {Uint8Array} key\n         * @memberof ics23.CompressedExistenceProof\n         * @instance\n         */\n        CompressedExistenceProof.prototype.key = $util.newBuffer([]);\n\n        /**\n         * CompressedExistenceProof value.\n         * @member {Uint8Array} value\n         * @memberof ics23.CompressedExistenceProof\n         * @instance\n         */\n        CompressedExistenceProof.prototype.value = $util.newBuffer([]);\n\n        /**\n         * CompressedExistenceProof leaf.\n         * @member {ics23.ILeafOp|null|undefined} leaf\n         * @memberof ics23.CompressedExistenceProof\n         * @instance\n         */\n        CompressedExistenceProof.prototype.leaf = null;\n\n        /**\n         * CompressedExistenceProof path.\n         * @member {Array.<number>} path\n         * @memberof ics23.CompressedExistenceProof\n         * @instance\n         */\n        CompressedExistenceProof.prototype.path = $util.emptyArray;\n\n        /**\n         * Creates a new CompressedExistenceProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {ics23.ICompressedExistenceProof=} [properties] Properties to set\n         * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof instance\n         */\n        CompressedExistenceProof.create = function create(properties) {\n            return new CompressedExistenceProof(properties);\n        };\n\n        /**\n         * Encodes the specified CompressedExistenceProof message. Does not implicitly {@link ics23.CompressedExistenceProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {ics23.ICompressedExistenceProof} message CompressedExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedExistenceProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\"))\n                $root.ics23.LeafOp.encode(message.leaf, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            if (message.path != null && message.path.length) {\n                writer.uint32(/* id 4, wireType 2 =*/34).fork();\n                for (var i = 0; i < message.path.length; ++i)\n                    writer.int32(message.path[i]);\n                writer.ldelim();\n            }\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CompressedExistenceProof message, length delimited. Does not implicitly {@link ics23.CompressedExistenceProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {ics23.ICompressedExistenceProof} message CompressedExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CompressedExistenceProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedExistenceProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.CompressedExistenceProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                case 2:\n                    message.value = reader.bytes();\n                    break;\n                case 3:\n                    message.leaf = $root.ics23.LeafOp.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    if (!(message.path && message.path.length))\n                        message.path = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.path.push(reader.int32());\n                    } else\n                        message.path.push(reader.int32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CompressedExistenceProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CompressedExistenceProof message.\n         * @function verify\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CompressedExistenceProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key)))\n                    return \"key: buffer expected\";\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                if (!(message.value && typeof message.value.length === \"number\" || $util.isString(message.value)))\n                    return \"value: buffer expected\";\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\")) {\n                var error = $root.ics23.LeafOp.verify(message.leaf);\n                if (error)\n                    return \"leaf.\" + error;\n            }\n            if (message.path != null && message.hasOwnProperty(\"path\")) {\n                if (!Array.isArray(message.path))\n                    return \"path: array expected\";\n                for (var i = 0; i < message.path.length; ++i)\n                    if (!$util.isInteger(message.path[i]))\n                        return \"path: integer[] expected\";\n            }\n            return null;\n        };\n\n        /**\n         * Creates a CompressedExistenceProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof\n         */\n        CompressedExistenceProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.CompressedExistenceProof)\n                return object;\n            var message = new $root.ics23.CompressedExistenceProof();\n            if (object.key != null)\n                if (typeof object.key === \"string\")\n                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);\n                else if (object.key.length)\n                    message.key = object.key;\n            if (object.value != null)\n                if (typeof object.value === \"string\")\n                    $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);\n                else if (object.value.length)\n                    message.value = object.value;\n            if (object.leaf != null) {\n                if (typeof object.leaf !== \"object\")\n                    throw TypeError(\".ics23.CompressedExistenceProof.leaf: object expected\");\n                message.leaf = $root.ics23.LeafOp.fromObject(object.leaf);\n            }\n            if (object.path) {\n                if (!Array.isArray(object.path))\n                    throw TypeError(\".ics23.CompressedExistenceProof.path: array expected\");\n                message.path = [];\n                for (var i = 0; i < object.path.length; ++i)\n                    message.path[i] = object.path[i] | 0;\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a CompressedExistenceProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {ics23.CompressedExistenceProof} message CompressedExistenceProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CompressedExistenceProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.path = [];\n            if (options.defaults) {\n                if (options.bytes === String)\n                    object.key = \"\";\n                else {\n                    object.key = [];\n                    if (options.bytes !== Array)\n                        object.key = $util.newBuffer(object.key);\n                }\n                if (options.bytes === String)\n                    object.value = \"\";\n                else {\n                    object.value = [];\n                    if (options.bytes !== Array)\n                        object.value = $util.newBuffer(object.value);\n                }\n                object.leaf = null;\n            }\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\"))\n                object.leaf = $root.ics23.LeafOp.toObject(message.leaf, options);\n            if (message.path && message.path.length) {\n                object.path = [];\n                for (var j = 0; j < message.path.length; ++j)\n                    object.path[j] = message.path[j];\n            }\n            return object;\n        };\n\n        /**\n         * Converts this CompressedExistenceProof to JSON.\n         * @function toJSON\n         * @memberof ics23.CompressedExistenceProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CompressedExistenceProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CompressedExistenceProof;\n    })();\n\n    ics23.CompressedNonExistenceProof = (function() {\n\n        /**\n         * Properties of a CompressedNonExistenceProof.\n         * @memberof ics23\n         * @interface ICompressedNonExistenceProof\n         * @property {Uint8Array|null} [key] CompressedNonExistenceProof key\n         * @property {ics23.ICompressedExistenceProof|null} [left] CompressedNonExistenceProof left\n         * @property {ics23.ICompressedExistenceProof|null} [right] CompressedNonExistenceProof right\n         */\n\n        /**\n         * Constructs a new CompressedNonExistenceProof.\n         * @memberof ics23\n         * @classdesc Represents a CompressedNonExistenceProof.\n         * @implements ICompressedNonExistenceProof\n         * @constructor\n         * @param {ics23.ICompressedNonExistenceProof=} [properties] Properties to set\n         */\n        function CompressedNonExistenceProof(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CompressedNonExistenceProof key.\n         * @member {Uint8Array} key\n         * @memberof ics23.CompressedNonExistenceProof\n         * @instance\n         */\n        CompressedNonExistenceProof.prototype.key = $util.newBuffer([]);\n\n        /**\n         * CompressedNonExistenceProof left.\n         * @member {ics23.ICompressedExistenceProof|null|undefined} left\n         * @memberof ics23.CompressedNonExistenceProof\n         * @instance\n         */\n        CompressedNonExistenceProof.prototype.left = null;\n\n        /**\n         * CompressedNonExistenceProof right.\n         * @member {ics23.ICompressedExistenceProof|null|undefined} right\n         * @memberof ics23.CompressedNonExistenceProof\n         * @instance\n         */\n        CompressedNonExistenceProof.prototype.right = null;\n\n        /**\n         * Creates a new CompressedNonExistenceProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {ics23.ICompressedNonExistenceProof=} [properties] Properties to set\n         * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof instance\n         */\n        CompressedNonExistenceProof.create = function create(properties) {\n            return new CompressedNonExistenceProof(properties);\n        };\n\n        /**\n         * Encodes the specified CompressedNonExistenceProof message. Does not implicitly {@link ics23.CompressedNonExistenceProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {ics23.ICompressedNonExistenceProof} message CompressedNonExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedNonExistenceProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);\n            if (message.left != null && message.hasOwnProperty(\"left\"))\n                $root.ics23.CompressedExistenceProof.encode(message.left, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.right != null && message.hasOwnProperty(\"right\"))\n                $root.ics23.CompressedExistenceProof.encode(message.right, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CompressedNonExistenceProof message, length delimited. Does not implicitly {@link ics23.CompressedNonExistenceProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {ics23.ICompressedNonExistenceProof} message CompressedNonExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedNonExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CompressedNonExistenceProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedNonExistenceProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.CompressedNonExistenceProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                case 2:\n                    message.left = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.right = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CompressedNonExistenceProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedNonExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CompressedNonExistenceProof message.\n         * @function verify\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CompressedNonExistenceProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key)))\n                    return \"key: buffer expected\";\n            if (message.left != null && message.hasOwnProperty(\"left\")) {\n                var error = $root.ics23.CompressedExistenceProof.verify(message.left);\n                if (error)\n                    return \"left.\" + error;\n            }\n            if (message.right != null && message.hasOwnProperty(\"right\")) {\n                var error = $root.ics23.CompressedExistenceProof.verify(message.right);\n                if (error)\n                    return \"right.\" + error;\n            }\n            return null;\n        };\n\n        /**\n         * Creates a CompressedNonExistenceProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof\n         */\n        CompressedNonExistenceProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.CompressedNonExistenceProof)\n                return object;\n            var message = new $root.ics23.CompressedNonExistenceProof();\n            if (object.key != null)\n                if (typeof object.key === \"string\")\n                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);\n                else if (object.key.length)\n                    message.key = object.key;\n            if (object.left != null) {\n                if (typeof object.left !== \"object\")\n                    throw TypeError(\".ics23.CompressedNonExistenceProof.left: object expected\");\n                message.left = $root.ics23.CompressedExistenceProof.fromObject(object.left);\n            }\n            if (object.right != null) {\n                if (typeof object.right !== \"object\")\n                    throw TypeError(\".ics23.CompressedNonExistenceProof.right: object expected\");\n                message.right = $root.ics23.CompressedExistenceProof.fromObject(object.right);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a CompressedNonExistenceProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {ics23.CompressedNonExistenceProof} message CompressedNonExistenceProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CompressedNonExistenceProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                if (options.bytes === String)\n                    object.key = \"\";\n                else {\n                    object.key = [];\n                    if (options.bytes !== Array)\n                        object.key = $util.newBuffer(object.key);\n                }\n                object.left = null;\n                object.right = null;\n            }\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n            if (message.left != null && message.hasOwnProperty(\"left\"))\n                object.left = $root.ics23.CompressedExistenceProof.toObject(message.left, options);\n            if (message.right != null && message.hasOwnProperty(\"right\"))\n                object.right = $root.ics23.CompressedExistenceProof.toObject(message.right, options);\n            return object;\n        };\n\n        /**\n         * Converts this CompressedNonExistenceProof to JSON.\n         * @function toJSON\n         * @memberof ics23.CompressedNonExistenceProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CompressedNonExistenceProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CompressedNonExistenceProof;\n    })();\n\n    return ics23;\n})();\n\nmodule.exports = $root;\n"],"names":["ics23","valuesById","values","$protobuf","__webpack_require__","$Reader","Reader","$Writer","Writer","$util","util","$root","roots","HashOp","Object","create","LengthOp","ExistenceProof","properties","path","keys","i","length","prototype","key","newBuffer","value","leaf","emptyArray","encode","message","writer","hasOwnProperty","uint32","bytes","LeafOp","fork","ldelim","InnerOp","encodeDelimited","decode","reader","end","undefined","len","pos","tag","push","skipType","decodeDelimited","verify","isString","error","Array","isArray","fromObject","object","base64","TypeError","toObject","options","arrays","defaults","String","slice","call","j","toJSON","constructor","toJSONOptions","NonExistenceProof","left","right","CommitmentProof","$oneOfFields","exist","nonexist","batch","compressed","defineProperty","get","oneOfGetter","set","oneOfSetter","BatchProof","CompressedBatchProof","proof","oneofs","hash","prehashKey","prehashValue","prefix","int32","enums","suffix","ProofSpec","leafSpec","innerSpec","maxDepth","minDepth","InnerSpec","isInteger","childOrder","childSize","minPrefixLength","maxPrefixLength","emptyChild","end2","entries","BatchEntry","lookupInners","CompressedBatchEntry","CompressedExistenceProof","CompressedNonExistenceProof","module","exports"],"sourceRoot":""}