{"version":3,"file":"static/chunks/4013.7543fce24da77c65.js","mappings":"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","sources":["webpack://_N_E/./node_modules/@noble/hashes/esm/hmac.js","webpack://_N_E/./node_modules/@noble/hashes/esm/ripemd160.js","webpack://_N_E/./node_modules/@noble/curves/esm/abstract/weierstrass.js","webpack://_N_E/./node_modules/@noble/curves/esm/_shortw_utils.js","webpack://_N_E/./node_modules/@noble/curves/esm/secp256k1.js","webpack://_N_E/./node_modules/@scure/bip32/lib/esm/index.js","webpack://_N_E/<anon>"],"sourcesContent":["/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\nimport { abytes, aexists, ahash } from './_assert.js';\nimport { Hash, toBytes } from './utils.js';\nexport class HMAC extends Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        ahash(hash);\n        const key = toBytes(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        aexists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        abytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nexport const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map","/**\n * RIPEMD-160 legacy hash function.\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n * @module\n */\nimport { HashMD } from './_md.js';\nimport { rotl, wrapConstructor } from './utils.js';\nconst Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);\nconst Id = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((_, i) => i));\nconst Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);\nlet idxL = [Id];\nlet idxR = [Pi];\nfor (let i = 0; i < 4; i++)\n    for (let j of [idxL, idxR])\n        j.push(j[i].map((k) => Rho[k]));\nconst shifts = /* @__PURE__ */ [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => new Uint8Array(i));\nconst shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst Kl = /* @__PURE__ */ new Uint32Array([\n    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr = /* @__PURE__ */ new Uint32Array([\n    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// It's called f() in spec.\nfunction f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    else if (group === 1)\n        return (x & y) | (~x & z);\n    else if (group === 2)\n        return (x | ~y) ^ z;\n    else if (group === 3)\n        return (x & z) | (y & ~z);\n    else\n        return x ^ (y | ~z);\n}\n// Temporary buffer, not used to store anything between runs\nconst R_BUF = /* @__PURE__ */ new Uint32Array(16);\nexport class RIPEMD160 extends HashMD {\n    constructor() {\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            R_BUF[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = (rotl(al + f(group, bl, cl, dl) + R_BUF[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = (rotl(ar + f(rGroup, br, cr, dr) + R_BUF[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        R_BUF.fill(0);\n    }\n    destroy() {\n        this.destroyed = true;\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\n/** RIPEMD-160 - a legacy hash function from 1990s. */\nexport const ripemd160 = /* @__PURE__ */ wrapConstructor(() => new RIPEMD160());\n//# sourceMappingURL=ripemd160.js.map","/**\n * Short Weierstrass curve methods. The formula is: y² = x³ + ax + b.\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { pippenger, validateBasic, wNAF, } from './curve.js';\nimport { Field, getMinHashLength, invert, mapHashToField, mod, validateField, } from './modular.js';\nimport * as ut from './utils.js';\nimport { abool, ensureBytes, memoized } from './utils.js';\nfunction validateSigVerOpts(opts) {\n    if (opts.lowS !== undefined)\n        abool('lowS', opts.lowS);\n    if (opts.prehash !== undefined)\n        abool('prehash', opts.prehash);\n}\nfunction validatePointOpts(curve) {\n    const opts = validateBasic(curve);\n    ut.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('invalid endomorphism, can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('invalid endomorphism, expected beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;\nexport class DERErr extends Error {\n    constructor(m = '') {\n        super(m);\n    }\n}\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nexport const DER = {\n    // asn.1 DER encoding utils\n    Err: DERErr,\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n        encode: (tag, data) => {\n            const { Err: E } = DER;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length & 1)\n                throw new E('tlv.encode: unpadded data');\n            const dataLen = data.length / 2;\n            const len = ut.numberToHexUnpadded(dataLen);\n            if ((len.length / 2) & 128)\n                throw new E('tlv.encode: long form length too big');\n            // length of length with long form flag\n            const lenLen = dataLen > 127 ? ut.numberToHexUnpadded((len.length / 2) | 128) : '';\n            const t = ut.numberToHexUnpadded(tag);\n            return t + lenLen + len + data;\n        },\n        // v - value, l - left bytes (unparsed)\n        decode(tag, data) {\n            const { Err: E } = DER;\n            let pos = 0;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length < 2 || data[pos++] !== tag)\n                throw new E('tlv.decode: wrong tlv');\n            const first = data[pos++];\n            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n            let length = 0;\n            if (!isLong)\n                length = first;\n            else {\n                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n                const lenLen = first & 127;\n                if (!lenLen)\n                    throw new E('tlv.decode(long): indefinite length not supported');\n                if (lenLen > 4)\n                    throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n                const lengthBytes = data.subarray(pos, pos + lenLen);\n                if (lengthBytes.length !== lenLen)\n                    throw new E('tlv.decode: length bytes not complete');\n                if (lengthBytes[0] === 0)\n                    throw new E('tlv.decode(long): zero leftmost byte');\n                for (const b of lengthBytes)\n                    length = (length << 8) | b;\n                pos += lenLen;\n                if (length < 128)\n                    throw new E('tlv.decode(long): not minimal encoding');\n            }\n            const v = data.subarray(pos, pos + length);\n            if (v.length !== length)\n                throw new E('tlv.decode: wrong value length');\n            return { v, l: data.subarray(pos + length) };\n        },\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n        encode(num) {\n            const { Err: E } = DER;\n            if (num < _0n)\n                throw new E('integer: negative integers are not allowed');\n            let hex = ut.numberToHexUnpadded(num);\n            // Pad with zero byte if negative flag is present\n            if (Number.parseInt(hex[0], 16) & 0b1000)\n                hex = '00' + hex;\n            if (hex.length & 1)\n                throw new E('unexpected DER parsing assertion: unpadded hex');\n            return hex;\n        },\n        decode(data) {\n            const { Err: E } = DER;\n            if (data[0] & 128)\n                throw new E('invalid signature integer: negative');\n            if (data[0] === 0x00 && !(data[1] & 128))\n                throw new E('invalid signature integer: unnecessary leading zero');\n            return b2n(data);\n        },\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E, _int: int, _tlv: tlv } = DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        ut.abytes(data);\n        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n        if (seqLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n        if (sLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        return { r: int.decode(rBytes), s: int.decode(sBytes) };\n    },\n    hexFromSig(sig) {\n        const { _tlv: tlv, _int: int } = DER;\n        const rs = tlv.encode(0x02, int.encode(sig.r));\n        const ss = tlv.encode(0x02, int.encode(sig.s));\n        const seq = rs + ss;\n        return tlv.encode(0x30, seq);\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nexport function weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const Fn = Field(CURVE.n, CURVE.nBitLength);\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y² = x³ + ax + b: Short weierstrass curve formula\n     * @returns y²\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return ut.inRange(num, _1n, CURVE.n);\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (ut.isBytes(key))\n                key = ut.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('invalid private key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : ut.bytesToNumberBE(ensureBytes('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error('invalid private key, expected hex or ' + nByteLength + ' bytes, got ' + typeof key);\n        }\n        if (wrapPrivateKey)\n            num = mod(num, N); // disabled by default, enabled for BLS\n        ut.aInRange('private key', num, _1n, N); // num in range [1..N-1]\n        return num;\n    }\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (x, y, z) ∋ (x=x/z, y=y/z)\n    const toAffineMemo = memoized((p, iz) => {\n        const { px: x, py: y, pz: z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(z, Fp.ONE))\n            return { x, y };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null)\n            iz = is0 ? Fp.ONE : Fp.inv(z);\n        const ax = Fp.mul(x, iz);\n        const ay = Fp.mul(y, iz);\n        const zz = Fp.mul(z, iz);\n        if (is0)\n            return { x: Fp.ZERO, y: Fp.ZERO };\n        if (!Fp.eql(zz, Fp.ONE))\n            throw new Error('invZ was invalid');\n        return { x: ax, y: ay };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = memoized((p) => {\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is invalid representation of ZERO.\n            if (CURVE.allowInfinityPoint && !Fp.is0(p.py))\n                return;\n            throw new Error('bad point: ZERO');\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x, y } = p.toAffine();\n        // Check if x, y are valid field elements\n        if (!Fp.isValid(x) || !Fp.isValid(y))\n            throw new Error('bad point: x or y not FE');\n        const left = Fp.sqr(y); // y²\n        const right = weierstrassEquation(x); // x³ + ax + b\n        if (!Fp.eql(left, right))\n            throw new Error('bad point: equation left != right');\n        if (!p.isTorsionFree())\n            throw new Error('bad point: not in prime-order subgroup');\n        return true;\n    });\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n            Object.freeze(this);\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // Multiscalar Multiplication\n        static msm(points, scalars) {\n            return pippenger(Point, Fn, points, scalars);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            wnaf.setWindowSize(this, windowSize);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, n, Point.normalizeZ);\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(sc) {\n            const { endo, n: N } = CURVE;\n            ut.aInRange('scalar', sc, _0n, N);\n            const I = Point.ZERO;\n            if (sc === _0n)\n                return I;\n            if (this.is0() || sc === _1n)\n                return this;\n            // Case a: no endomorphism. Case b: has precomputes.\n            if (!endo || wnaf.hasPrecomputes(this))\n                return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);\n            // Case c: endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            const { endo, n: N } = CURVE;\n            ut.aInRange('scalar', scalar, _1n, N);\n            let point, fake; // Fake point is used to const-time mult\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ∋ (x=x/z, y=y/z)\n        toAffine(iz) {\n            return toAffineMemo(this, iz);\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            abool('isCompressed', isCompressed);\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            abool('isCompressed', isCompressed);\n            return ut.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = validateBasic(curve);\n    ut.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\n/**\n * Creates short weierstrass curve and ECDSA signature methods for it.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, b, p, n, Gx, Gy\n * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })\n */\nexport function weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function modN(a) {\n        return mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = ut.concatBytes;\n            abool('isCompressed', isCompressed);\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = ut.bytesToNumberBE(tail);\n                if (!ut.inRange(x, _1n, Fp.ORDER))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n                }\n                catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n                    throw new Error('Point is not on curve' + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                const cl = compressedLen;\n                const ul = uncompressedLen;\n                throw new Error('invalid Point, expected length of ' + cl + ', or uncompressed ' + ul + ', got ' + len);\n            }\n        },\n    });\n    const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = ensureBytes('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig(ensureBytes('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            ut.aInRange('r', this.r, _1n, CURVE_ORDER); // r in [1..N]\n            ut.aInRange('s', this.s, _1n, CURVE_ORDER); // s in [1..N]\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return ut.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return ut.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = getMinHashLength(CURVE.n);\n            return mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = ut.isBytes(item);\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // Our custom check \"just in case\"\n            if (bytes.length > 8192)\n                throw new Error('input is too large');\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = ut.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        ut.aInRange('num < 2^' + CURVE.nBitLength, num, _0n, ORDER_MASK);\n        // works with order, can have different size than numToField!\n        return ut.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,\n    // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = ensureBytes('msgHash', msgHash);\n        validateSigVerOpts(opts);\n        if (prehash)\n            msgHash = ensureBytes('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\n        }\n        const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G × k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1⋅G - U2⋅P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = ensureBytes('msgHash', msgHash);\n        publicKey = ensureBytes('publicKey', publicKey);\n        const { lowS, prehash, format } = opts;\n        // Verify opts, deduce signature format\n        validateSigVerOpts(opts);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        if (format !== undefined && format !== 'compact' && format !== 'der')\n            throw new Error('format must be compact or der');\n        const isHex = typeof sg === 'string' || ut.isBytes(sg);\n        const isObj = !isHex &&\n            !format &&\n            typeof sg === 'object' &&\n            sg !== null &&\n            typeof sg.r === 'bigint' &&\n            typeof sg.s === 'bigint';\n        if (!isHex && !isObj)\n            throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');\n        let _sig = undefined;\n        let P;\n        try {\n            if (isObj)\n                _sig = new Signature(sg.r, sg.s);\n            if (isHex) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    if (format !== 'compact')\n                        _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                }\n                if (!_sig && format !== 'der')\n                    _sig = Signature.fromCompact(sg);\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            return false;\n        }\n        if (!_sig)\n            return false;\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU(Fp, opts) {\n    validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map","/**\n * Utilities for short weierstrass curves, combined with noble-hashes.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { hmac } from '@noble/hashes/hmac';\nimport { concatBytes, randomBytes } from '@noble/hashes/utils';\nimport { weierstrass } from './abstract/weierstrass.js';\n/** connects noble-curves to noble-hashes */\nexport function getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => hmac(hash, key, concatBytes(...msgs)),\n        randomBytes,\n    };\n}\nexport function createCurve(curveDef, defHash) {\n    const create = (hash) => weierstrass({ ...curveDef, ...getHash(hash) });\n    return { ...create(defHash), create };\n}\n//# sourceMappingURL=_shortw_utils.js.map","/**\n * NIST secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\n *\n * Seems to be rigid (not backdoored)\n * [as per discussion](https://bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975).\n *\n * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n * [See explanation](https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066).\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha256';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { createCurve } from './_shortw_utils.js';\nimport { createHasher, isogenyMap } from './abstract/hash-to-curve.js';\nimport { Field, mod, pow2 } from './abstract/modular.js';\nimport { aInRange, bytesToNumberBE, concatBytes, ensureBytes, inRange, numberToBytesBE, } from './abstract/utils.js';\nimport { mapToCurveSimpleSWU } from './abstract/weierstrass.js';\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = (pow2(b3, _3n, P) * b3) % P;\n    const b9 = (pow2(b6, _3n, P) * b3) % P;\n    const b11 = (pow2(b9, _2n, P) * b2) % P;\n    const b22 = (pow2(b11, _11n, P) * b11) % P;\n    const b44 = (pow2(b22, _22n, P) * b22) % P;\n    const b88 = (pow2(b44, _44n, P) * b44) % P;\n    const b176 = (pow2(b88, _88n, P) * b88) % P;\n    const b220 = (pow2(b176, _44n, P) * b44) % P;\n    const b223 = (pow2(b220, _3n, P) * b3) % P;\n    const t1 = (pow2(b223, _23n, P) * b22) % P;\n    const t2 = (pow2(t1, _6n, P) * b2) % P;\n    const root = pow2(t2, _2n, P);\n    if (!Fpk1.eql(Fpk1.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fpk1 = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\n/**\n * secp256k1 short weierstrass curve and ECDSA signatures over it.\n *\n * @example\n * import { secp256k1 } from '@noble/curves/secp256k1';\n *\n * const priv = secp256k1.utils.randomPrivateKey();\n * const pub = secp256k1.getPublicKey(priv);\n * const msg = new Uint8Array(32).fill(1); // message hash (not message) in ecdsa\n * const sig = secp256k1.sign(msg, priv); // `{prehash: true}` option is available\n * const isValid = secp256k1.verify(sig, msg, pub) === true;\n */\nexport const secp256k1 = createCurve({\n    a: BigInt(0), // equation params: a, b\n    b: BigInt(7),\n    Fp: Fpk1, // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n\n    n: secp256k1N, // Curve order, total count of valid points in the field\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1), // Cofactor\n    lowS: true, // Allow only low-S signatures by default in sign() and verify()\n    endo: {\n        // Endomorphism, see above\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = mod(k - c1 * a1 - c2 * a2, n);\n            let k2 = mod(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = concatBytes(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return sha256(concatBytes(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => numberToBytesBE(n, 32);\nconst modP = (x) => mod(x, secp256k1P);\nconst modN = (x) => mod(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    aInRange('x', x, _1n, secp256k1P); // Fail if x ≥ p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\nconst num = bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN(num(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = randomBytes(32)) {\n    const m = ensureBytes('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = ensureBytes('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN(num(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = ensureBytes('signature', signature, 64);\n    const m = ensureBytes('message', message);\n    const pub = ensureBytes('publicKey', publicKey, 32);\n    try {\n        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\n        if (!inRange(r, _1n, secp256k1P))\n            return false;\n        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\n        if (!inRange(s, _1n, secp256k1N))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\n    }\n    catch (error) {\n        return false;\n    }\n}\n/**\n * Schnorr signatures over secp256k1.\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n * @example\n * import { schnorr } from '@noble/curves/secp256k1';\n * const priv = schnorr.utils.randomPrivateKey();\n * const pub = schnorr.getPublicKey(priv);\n * const msg = new TextEncoder().encode('hello');\n * const sig = schnorr.sign(msg, priv);\n * const isValid = schnorr.verify(sig, msg, pub);\n */\nexport const schnorr = /* @__PURE__ */ (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE,\n        bytesToNumberBE,\n        taggedHash,\n        mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => isogenyMap(Fpk1, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => mapToCurveSimpleSWU(Fpk1, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fpk1.create(BigInt('-11')),\n}))();\nconst htf = /* @__PURE__ */ (() => createHasher(secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fpk1.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha256,\n}))();\n/** secp256k1 hash-to-curve from [RFC 9380](https://www.rfc-editor.org/rfc/rfc9380). */\nexport const hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\n/** secp256k1 encode-to-curve from [RFC 9380](https://www.rfc-editor.org/rfc/rfc9380). */\nexport const encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map","/**\n * @module BIP32 hierarchical deterministic (HD) wallets over secp256k1.\n * @example\n * ```js\n * import { HDKey } from \"@scure/bip32\";\n * const hdkey1 = HDKey.fromMasterSeed(seed);\n * const hdkey2 = HDKey.fromExtendedKey(base58key);\n * const hdkey3 = HDKey.fromJSON({ xpriv: string });\n *\n * // props\n * [hdkey1.depth, hdkey1.index, hdkey1.chainCode];\n * console.log(hdkey2.privateKey, hdkey2.publicKey);\n * console.log(hdkey3.derive(\"m/0/2147483647'/1\"));\n * const sig = hdkey3.sign(hash);\n * hdkey3.verify(hash, sig);\n * ```\n */\n/*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\nimport { hmac } from '@noble/hashes/hmac';\nimport { ripemd160 } from '@noble/hashes/ripemd160';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { sha512 } from '@noble/hashes/sha512';\nimport { abytes } from '@noble/hashes/_assert';\nimport { bytesToHex, concatBytes, createView, hexToBytes, utf8ToBytes } from '@noble/hashes/utils';\nimport { secp256k1 as secp } from '@noble/curves/secp256k1';\nimport { mod } from '@noble/curves/abstract/modular';\nimport { createBase58check } from '@scure/base';\nconst Point = secp.ProjectivePoint;\nconst base58check = createBase58check(sha256);\nfunction bytesToNumber(bytes) {\n    abytes(bytes);\n    const h = bytes.length === 0 ? '0' : bytesToHex(bytes);\n    return BigInt('0x' + h);\n}\nfunction numberToBytes(num) {\n    if (typeof num !== 'bigint')\n        throw new Error('bigint expected');\n    return hexToBytes(num.toString(16).padStart(64, '0'));\n}\nconst MASTER_SECRET = utf8ToBytes('Bitcoin seed');\n// Bitcoin hardcoded by default\nconst BITCOIN_VERSIONS = { private: 0x0488ade4, public: 0x0488b21e };\nexport const HARDENED_OFFSET = 0x80000000;\nconst hash160 = (data) => ripemd160(sha256(data));\nconst fromU32 = (data) => createView(data).getUint32(0, false);\nconst toU32 = (n) => {\n    if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {\n        throw new Error('invalid number, should be from 0 to 2**32-1, got ' + n);\n    }\n    const buf = new Uint8Array(4);\n    createView(buf).setUint32(0, n, false);\n    return buf;\n};\nexport class HDKey {\n    get fingerprint() {\n        if (!this.pubHash) {\n            throw new Error('No publicKey set!');\n        }\n        return fromU32(this.pubHash);\n    }\n    get identifier() {\n        return this.pubHash;\n    }\n    get pubKeyHash() {\n        return this.pubHash;\n    }\n    get privateKey() {\n        return this.privKeyBytes || null;\n    }\n    get publicKey() {\n        return this.pubKey || null;\n    }\n    get privateExtendedKey() {\n        const priv = this.privateKey;\n        if (!priv) {\n            throw new Error('No private key');\n        }\n        return base58check.encode(this.serialize(this.versions.private, concatBytes(new Uint8Array([0]), priv)));\n    }\n    get publicExtendedKey() {\n        if (!this.pubKey) {\n            throw new Error('No public key');\n        }\n        return base58check.encode(this.serialize(this.versions.public, this.pubKey));\n    }\n    static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {\n        abytes(seed);\n        if (8 * seed.length < 128 || 8 * seed.length > 512) {\n            throw new Error('HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got ' +\n                seed.length);\n        }\n        const I = hmac(sha512, MASTER_SECRET, seed);\n        return new HDKey({\n            versions,\n            chainCode: I.slice(32),\n            privateKey: I.slice(0, 32),\n        });\n    }\n    static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {\n        // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n        const keyBuffer = base58check.decode(base58key);\n        const keyView = createView(keyBuffer);\n        const version = keyView.getUint32(0, false);\n        const opt = {\n            versions,\n            depth: keyBuffer[4],\n            parentFingerprint: keyView.getUint32(5, false),\n            index: keyView.getUint32(9, false),\n            chainCode: keyBuffer.slice(13, 45),\n        };\n        const key = keyBuffer.slice(45);\n        const isPriv = key[0] === 0;\n        if (version !== versions[isPriv ? 'private' : 'public']) {\n            throw new Error('Version mismatch');\n        }\n        if (isPriv) {\n            return new HDKey({ ...opt, privateKey: key.slice(1) });\n        }\n        else {\n            return new HDKey({ ...opt, publicKey: key });\n        }\n    }\n    static fromJSON(json) {\n        return HDKey.fromExtendedKey(json.xpriv);\n    }\n    constructor(opt) {\n        this.depth = 0;\n        this.index = 0;\n        this.chainCode = null;\n        this.parentFingerprint = 0;\n        if (!opt || typeof opt !== 'object') {\n            throw new Error('HDKey.constructor must not be called directly');\n        }\n        this.versions = opt.versions || BITCOIN_VERSIONS;\n        this.depth = opt.depth || 0;\n        this.chainCode = opt.chainCode || null;\n        this.index = opt.index || 0;\n        this.parentFingerprint = opt.parentFingerprint || 0;\n        if (!this.depth) {\n            if (this.parentFingerprint || this.index) {\n                throw new Error('HDKey: zero depth with non-zero index/parent fingerprint');\n            }\n        }\n        if (opt.publicKey && opt.privateKey) {\n            throw new Error('HDKey: publicKey and privateKey at same time.');\n        }\n        if (opt.privateKey) {\n            if (!secp.utils.isValidPrivateKey(opt.privateKey)) {\n                throw new Error('Invalid private key');\n            }\n            this.privKey =\n                typeof opt.privateKey === 'bigint' ? opt.privateKey : bytesToNumber(opt.privateKey);\n            this.privKeyBytes = numberToBytes(this.privKey);\n            this.pubKey = secp.getPublicKey(opt.privateKey, true);\n        }\n        else if (opt.publicKey) {\n            this.pubKey = Point.fromHex(opt.publicKey).toRawBytes(true); // force compressed point\n        }\n        else {\n            throw new Error('HDKey: no public or private key provided');\n        }\n        this.pubHash = hash160(this.pubKey);\n    }\n    derive(path) {\n        if (!/^[mM]'?/.test(path)) {\n            throw new Error('Path must start with \"m\" or \"M\"');\n        }\n        if (/^[mM]'?$/.test(path)) {\n            return this;\n        }\n        const parts = path.replace(/^[mM]'?\\//, '').split('/');\n        // tslint:disable-next-line\n        let child = this;\n        for (const c of parts) {\n            const m = /^(\\d+)('?)$/.exec(c);\n            const m1 = m && m[1];\n            if (!m || m.length !== 3 || typeof m1 !== 'string')\n                throw new Error('invalid child index: ' + c);\n            let idx = +m1;\n            if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) {\n                throw new Error('Invalid index');\n            }\n            // hardened key\n            if (m[2] === \"'\") {\n                idx += HARDENED_OFFSET;\n            }\n            child = child.deriveChild(idx);\n        }\n        return child;\n    }\n    deriveChild(index) {\n        if (!this.pubKey || !this.chainCode) {\n            throw new Error('No publicKey or chainCode set');\n        }\n        let data = toU32(index);\n        if (index >= HARDENED_OFFSET) {\n            // Hardened\n            const priv = this.privateKey;\n            if (!priv) {\n                throw new Error('Could not derive hardened child key');\n            }\n            // Hardened child: 0x00 || ser256(kpar) || ser32(index)\n            data = concatBytes(new Uint8Array([0]), priv, data);\n        }\n        else {\n            // Normal child: serP(point(kpar)) || ser32(index)\n            data = concatBytes(this.pubKey, data);\n        }\n        const I = hmac(sha512, this.chainCode, data);\n        const childTweak = bytesToNumber(I.slice(0, 32));\n        const chainCode = I.slice(32);\n        if (!secp.utils.isValidPrivateKey(childTweak)) {\n            throw new Error('Tweak bigger than curve order');\n        }\n        const opt = {\n            versions: this.versions,\n            chainCode,\n            depth: this.depth + 1,\n            parentFingerprint: this.fingerprint,\n            index,\n        };\n        try {\n            // Private parent key -> private child key\n            if (this.privateKey) {\n                const added = mod(this.privKey + childTweak, secp.CURVE.n);\n                if (!secp.utils.isValidPrivateKey(added)) {\n                    throw new Error('The tweak was out of range or the resulted private key is invalid');\n                }\n                opt.privateKey = added;\n            }\n            else {\n                const added = Point.fromHex(this.pubKey).add(Point.fromPrivateKey(childTweak));\n                // Cryptographically impossible: hmac-sha512 preimage would need to be found\n                if (added.equals(Point.ZERO)) {\n                    throw new Error('The tweak was equal to negative P, which made the result key invalid');\n                }\n                opt.publicKey = added.toRawBytes(true);\n            }\n            return new HDKey(opt);\n        }\n        catch (err) {\n            return this.deriveChild(index + 1);\n        }\n    }\n    sign(hash) {\n        if (!this.privateKey) {\n            throw new Error('No privateKey set!');\n        }\n        abytes(hash, 32);\n        return secp.sign(hash, this.privKey).toCompactRawBytes();\n    }\n    verify(hash, signature) {\n        abytes(hash, 32);\n        abytes(signature, 64);\n        if (!this.publicKey) {\n            throw new Error('No publicKey set!');\n        }\n        let sig;\n        try {\n            sig = secp.Signature.fromCompact(signature);\n        }\n        catch (error) {\n            return false;\n        }\n        return secp.verify(sig, hash, this.publicKey);\n    }\n    wipePrivateData() {\n        this.privKey = undefined;\n        if (this.privKeyBytes) {\n            this.privKeyBytes.fill(0);\n            this.privKeyBytes = undefined;\n        }\n        return this;\n    }\n    toJSON() {\n        return {\n            xpriv: this.privateExtendedKey,\n            xpub: this.publicExtendedKey,\n        };\n    }\n    serialize(version, key) {\n        if (!this.chainCode) {\n            throw new Error('No chainCode set');\n        }\n        abytes(key, 33);\n        // version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n        return concatBytes(toU32(version), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);\n    }\n}\n//# sourceMappingURL=index.js.map"],"names":["HMAC","_utils_js__WEBPACK_IMPORTED_MODULE_0__","kb","constructor","hash","_key","finished","destroyed","_assert_js__WEBPACK_IMPORTED_MODULE_1__","z3","key","O0","iHash","create","update","blockLen","outputLen","pad","Uint8Array","set","length","digest","i","oHash","fill","buf","$h","digestInto","out","gk","destroy","_cloneInto","to","Object","getPrototypeOf","hmac","message","Rho","Id","map","_","Pi","idxL","idxR","j","push","k","shifts","shiftsL","idx","shiftsR","Kl","Uint32Array","Kr","f","group","x","y","z","R_BUF","RIPEMD160","_md","VR","h0","h1","h2","h3","h4","get","process","view","offset","getUint32","al","ar","bl","br","cl","cr","dl","dr","el","er","rGroup","hbl","hbr","rl","rr","sl","sr","tl","utils","XG","tr","roundClean","buffer","ripemd160","hE","validateSigVerOpts","opts","undefined","lowS","abstract_utils","uw","prehash","bytesToNumberBE","b2n","hexToBytes","h2b","DER","Err","Error","m","_tlv","encode","tag","data","E","dataLen","len","uz","lenLen","t","decode","pos","first","isLong","lengthBytes","subarray","b","v","l","_int","num","_0n","hex","Number","parseInt","toSig","int","tlv","seqBytes","seqLeftBytes","rBytes","rLeftBytes","sBytes","sLeftBytes","r","s","hexFromSig","sig","rs","ss","BigInt","_1n","_3n","secp256k1P","secp256k1N","secp256k1_1n","secp256k1_2n","divNearest","a","Fpk1","modular","gN","sqrt","_6n","_11n","_22n","_23n","_44n","_88n","b2","b3","b6","oA","b9","b11","b22","b44","b88","b176","b220","b223","t1","t2","root","eql","sqr","secp256k1","createCurve","curveDef","defHash","weierstrass","CURVE","validateOpts","curve","abstract_curve","Kd","FF","randomBytes","bits2int","bits2int_modN","freeze","Fp","n","CURVE_ORDER","compressedLen","BYTES","uncompressedLen","modN","wQ","invN","U_","ProjectivePoint","Point","normPrivateKeyToScalar","weierstrassEquation","isWithinCurveOrder","weierstrassPoints","validatePointOpts","allowedPrivateKeyLengths","wrapPrivateKey","isTorsionFree","clearCofactor","allowInfinityPoint","fromBytes","toBytes","endo","ZERO","beta","splitScalar","Fn","nBitLength","_c","point","_isCompressed","toAffine","eV","from","tail","bytes","x2","x3","mul","add","Gy","Gx","lengths","nByteLength","N","_t","ci","includes","padStart","ql","error","Fy","assertPrjPoint","other","toAffineMemo","H9","p","iz","px","py","pz","ONE","is0","inv","ax","ay","zz","assertValidMemo","isValid","left","right","fromAffine","normalizeZ","points","toInv","invertBatch","fromHex","P","assertValidity","fromPrivateKey","privateKey","BASE","multiply","msm","scalars","D1","_setWindowSize","windowSize","wnaf","setWindowSize","hasEvenY","isOdd","equals","X1","Y1","Z1","X2","Y2","Z2","U1","U2","negate","neg","double","X3","Y3","Z3","t0","t3","sub","t4","t5","subtract","wNAF","wNAFCached","multiplyUnsafe","sc","I","hasPrecomputes","wNAFCachedUnsafe","k1neg","k1","k2neg","k2","k1p","k2p","d","scalar","fake","f1p","f2p","constTimeNegate","multiplyAndAddUnsafe","Q","G","sum","h","cofactor","toRawBytes","isCompressed","toHex","_bits","Mx","Math","ceil","cat","head","ORDER","y2","sqrtError","suffix","isYOdd","numToNByteStr","tL","isBiggerThanHalfOrder","number","HALF","slcNum","slice","Signature","recovery","fromCompact","fromDER","addRecoveryBit","recoverPublicKey","msgHash","rec","radj","prefix","R","ir","u1","u2","hasHighS","normalizeS","toDERRawBytes","toDERHex","toCompactRawBytes","toCompactHex","isProbPub","item","arr","str","delta","ORDER_MASK","dQ","int2octets","defaultSigOpts","defaultVerOpts","getPublicKey","getSharedSecret","privateA","publicB","sign","privKey","seed","k2sig","prepSig","some","extraEntropy","ent","h1int","seedArgs","e","kBytes","ik","q","normS","drbg","n$","C","verify","signature","publicKey","_sig","format","isHex","isObj","sg","derError","is","isValidPrivateKey","randomPrivateKey","PS","Us","precompute","msgs","O6","a1","b1","a2","POW_2_128","c1","c2","esm_sha256","JQ","esm_Point","base58check","esm","Xd","bytesToNumber","_assert","MASTER_SECRET","iY","BITCOIN_VERSIONS","private","public","hash160","fromU32","GL","toU32","isSafeInteger","setUint32","HDKey","fingerprint","pubHash","identifier","pubKeyHash","privKeyBytes","pubKey","privateExtendedKey","priv","serialize","versions","publicExtendedKey","fromMasterSeed","sha512","o","chainCode","fromExtendedKey","base58key","keyBuffer","keyView","version","opt","depth","parentFingerprint","index","isPriv","fromJSON","json","xpriv","numberToBytes","nr","toString","derive","path","test","parts","replace","split","child","c","exec","m1","deriveChild","childTweak","added","err","wipePrivateData","toJSON","xpub"],"sourceRoot":""}